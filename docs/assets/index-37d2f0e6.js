var L8 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports)
var Dve = L8((Wd) => {
  ;(function () {
    const t = document.createElement('link').relList
    if (t && t.supports && t.supports('modulepreload')) return
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
    new MutationObserver((i) => {
      for (const o of i)
        if (o.type === 'childList')
          for (const a of o.addedNodes)
            a.tagName === 'LINK' && a.rel === 'modulepreload' && r(a)
    }).observe(document, { childList: !0, subtree: !0 })
    function n(i) {
      const o = {}
      return (
        i.integrity && (o.integrity = i.integrity),
        i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === 'use-credentials'
          ? (o.credentials = 'include')
          : i.crossOrigin === 'anonymous'
          ? (o.credentials = 'omit')
          : (o.credentials = 'same-origin'),
        o
      )
    }
    function r(i) {
      if (i.ep) return
      i.ep = !0
      const o = n(i)
      fetch(i.href, o)
    }
  })()
  function l_(e, t) {
    const n = Object.create(null),
      r = e.split(',')
    for (let i = 0; i < r.length; i++) n[r[i]] = !0
    return t ? (i) => !!n[i.toLowerCase()] : (i) => !!n[i]
  }
  const zn = {},
    Au = [],
    Oo = () => {},
    I8 = () => !1,
    R8 = /^on[^a-z]/,
    Pv = (e) => R8.test(e),
    u_ = (e) => e.startsWith('onUpdate:'),
    rr = Object.assign,
    c_ = (e, t) => {
      const n = e.indexOf(t)
      n > -1 && e.splice(n, 1)
    },
    D8 = Object.prototype.hasOwnProperty,
    yn = (e, t) => D8.call(e, t),
    Yt = Array.isArray,
    $u = (e) => Tv(e) === '[object Map]',
    bT = (e) => Tv(e) === '[object Set]',
    en = (e) => typeof e == 'function',
    Xn = (e) => typeof e == 'string',
    d_ = (e) => typeof e == 'symbol',
    Bn = (e) => e !== null && typeof e == 'object',
    _T = (e) => Bn(e) && en(e.then) && en(e.catch),
    ST = Object.prototype.toString,
    Tv = (e) => ST.call(e),
    N8 = (e) => Tv(e).slice(8, -1),
    CT = (e) => Tv(e) === '[object Object]',
    f_ = (e) =>
      Xn(e) && e !== 'NaN' && e[0] !== '-' && '' + parseInt(e, 10) === e,
    Wh = l_(
      ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
    ),
    kv = (e) => {
      const t = Object.create(null)
      return (n) => t[n] || (t[n] = e(n))
    },
    B8 = /-(\w)/g,
    na = kv((e) => e.replace(B8, (t, n) => (n ? n.toUpperCase() : ''))),
    F8 = /\B([A-Z])/g,
    kl = kv((e) => e.replace(F8, '-$1').toLowerCase()),
    Av = kv((e) => e.charAt(0).toUpperCase() + e.slice(1)),
    kg = kv((e) => (e ? `on${Av(e)}` : '')),
    Md = (e, t) => !Object.is(e, t),
    Ag = (e, t) => {
      for (let n = 0; n < e.length; n++) e[n](t)
    },
    Yp = (e, t, n) => {
      Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: n,
      })
    },
    z8 = (e) => {
      const t = parseFloat(e)
      return isNaN(t) ? e : t
    },
    V8 = (e) => {
      const t = Xn(e) ? Number(e) : NaN
      return isNaN(t) ? e : t
    }
  let Kw
  const rb = () =>
    Kw ||
    (Kw =
      typeof globalThis < 'u'
        ? globalThis
        : typeof self < 'u'
        ? self
        : typeof window < 'u'
        ? window
        : typeof global < 'u'
        ? global
        : {})
  function at(e) {
    if (Yt(e)) {
      const t = {}
      for (let n = 0; n < e.length; n++) {
        const r = e[n],
          i = Xn(r) ? j8(r) : at(r)
        if (i) for (const o in i) t[o] = i[o]
      }
      return t
    } else {
      if (Xn(e)) return e
      if (Bn(e)) return e
    }
  }
  const U8 = /;(?![^(]*\))/g,
    H8 = /:([^]+)/,
    W8 = /\/\*[^]*?\*\//g
  function j8(e) {
    const t = {}
    return (
      e
        .replace(W8, '')
        .split(U8)
        .forEach((n) => {
          if (n) {
            const r = n.split(H8)
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
          }
        }),
      t
    )
  }
  function H(e) {
    let t = ''
    if (Xn(e)) t = e
    else if (Yt(e))
      for (let n = 0; n < e.length; n++) {
        const r = H(e[n])
        r && (t += r + ' ')
      }
    else if (Bn(e)) for (const n in e) e[n] && (t += n + ' ')
    return t.trim()
  }
  function En(e) {
    if (!e) return null
    let { class: t, style: n } = e
    return t && !Xn(t) && (e.class = H(t)), n && (e.style = at(n)), e
  }
  const G8 =
      'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
    K8 = l_(G8)
  function wT(e) {
    return !!e || e === ''
  }
  const mt = (e) =>
      Xn(e)
        ? e
        : e == null
        ? ''
        : Yt(e) || (Bn(e) && (e.toString === ST || !en(e.toString)))
        ? JSON.stringify(e, xT, 2)
        : String(e),
    xT = (e, t) =>
      t && t.__v_isRef
        ? xT(e, t.value)
        : $u(t)
        ? {
            [`Map(${t.size})`]: [...t.entries()].reduce(
              (n, [r, i]) => ((n[`${r} =>`] = i), n),
              {}
            ),
          }
        : bT(t)
        ? { [`Set(${t.size})`]: [...t.values()] }
        : Bn(t) && !Yt(t) && !CT(t)
        ? String(t)
        : t
  let wo
  class q8 {
    constructor(t = !1) {
      ;(this.detached = t),
        (this._active = !0),
        (this.effects = []),
        (this.cleanups = []),
        (this.parent = wo),
        !t &&
          wo &&
          (this.index = (wo.scopes || (wo.scopes = [])).push(this) - 1)
    }
    get active() {
      return this._active
    }
    run(t) {
      if (this._active) {
        const n = wo
        try {
          return (wo = this), t()
        } finally {
          wo = n
        }
      }
    }
    on() {
      wo = this
    }
    off() {
      wo = this.parent
    }
    stop(t) {
      if (this._active) {
        let n, r
        for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop()
        for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]()
        if (this.scopes)
          for (n = 0, r = this.scopes.length; n < r; n++)
            this.scopes[n].stop(!0)
        if (!this.detached && this.parent && !t) {
          const i = this.parent.scopes.pop()
          i &&
            i !== this &&
            ((this.parent.scopes[this.index] = i), (i.index = this.index))
        }
        ;(this.parent = void 0), (this._active = !1)
      }
    }
  }
  function X8(e, t = wo) {
    t && t.active && t.effects.push(e)
  }
  function Y8() {
    return wo
  }
  const h_ = (e) => {
      const t = new Set(e)
      return (t.w = 0), (t.n = 0), t
    },
    MT = (e) => (e.w & Ps) > 0,
    ET = (e) => (e.n & Ps) > 0,
    Z8 = ({ deps: e }) => {
      if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= Ps
    },
    J8 = (e) => {
      const { deps: t } = e
      if (t.length) {
        let n = 0
        for (let r = 0; r < t.length; r++) {
          const i = t[r]
          MT(i) && !ET(i) ? i.delete(e) : (t[n++] = i),
            (i.w &= ~Ps),
            (i.n &= ~Ps)
        }
        t.length = n
      }
    },
    Zp = new WeakMap()
  let Yc = 0,
    Ps = 1
  const ib = 30
  let Po
  const fl = Symbol(''),
    ob = Symbol('')
  class p_ {
    constructor(t, n = null, r) {
      ;(this.fn = t),
        (this.scheduler = n),
        (this.active = !0),
        (this.deps = []),
        (this.parent = void 0),
        X8(this, r)
    }
    run() {
      if (!this.active) return this.fn()
      let t = Po,
        n = ws
      for (; t; ) {
        if (t === this) return
        t = t.parent
      }
      try {
        return (
          (this.parent = Po),
          (Po = this),
          (ws = !0),
          (Ps = 1 << ++Yc),
          Yc <= ib ? Z8(this) : qw(this),
          this.fn()
        )
      } finally {
        Yc <= ib && J8(this),
          (Ps = 1 << --Yc),
          (Po = this.parent),
          (ws = n),
          (this.parent = void 0),
          this.deferStop && this.stop()
      }
    }
    stop() {
      Po === this
        ? (this.deferStop = !0)
        : this.active &&
          (qw(this), this.onStop && this.onStop(), (this.active = !1))
    }
  }
  function qw(e) {
    const { deps: t } = e
    if (t.length) {
      for (let n = 0; n < t.length; n++) t[n].delete(e)
      t.length = 0
    }
  }
  let ws = !0
  const PT = []
  function tc() {
    PT.push(ws), (ws = !1)
  }
  function nc() {
    const e = PT.pop()
    ws = e === void 0 ? !0 : e
  }
  function Pi(e, t, n) {
    if (ws && Po) {
      let r = Zp.get(e)
      r || Zp.set(e, (r = new Map()))
      let i = r.get(n)
      i || r.set(n, (i = h_())), TT(i)
    }
  }
  function TT(e, t) {
    let n = !1
    Yc <= ib ? ET(e) || ((e.n |= Ps), (n = !MT(e))) : (n = !e.has(Po)),
      n && (e.add(Po), Po.deps.push(e))
  }
  function Va(e, t, n, r, i, o) {
    const a = Zp.get(e)
    if (!a) return
    let s = []
    if (t === 'clear') s = [...a.values()]
    else if (n === 'length' && Yt(e)) {
      const l = Number(r)
      a.forEach((c, d) => {
        ;(d === 'length' || d >= l) && s.push(c)
      })
    } else
      switch ((n !== void 0 && s.push(a.get(n)), t)) {
        case 'add':
          Yt(e)
            ? f_(n) && s.push(a.get('length'))
            : (s.push(a.get(fl)), $u(e) && s.push(a.get(ob)))
          break
        case 'delete':
          Yt(e) || (s.push(a.get(fl)), $u(e) && s.push(a.get(ob)))
          break
        case 'set':
          $u(e) && s.push(a.get(fl))
          break
      }
    if (s.length === 1) s[0] && ab(s[0])
    else {
      const l = []
      for (const c of s) c && l.push(...c)
      ab(h_(l))
    }
  }
  function ab(e, t) {
    const n = Yt(e) ? e : [...e]
    for (const r of n) r.computed && Xw(r)
    for (const r of n) r.computed || Xw(r)
  }
  function Xw(e, t) {
    ;(e !== Po || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
  }
  function Q8(e, t) {
    var n
    return (n = Zp.get(e)) == null ? void 0 : n.get(t)
  }
  const eD = l_('__proto__,__v_isRef,__isVue'),
    kT = new Set(
      Object.getOwnPropertyNames(Symbol)
        .filter((e) => e !== 'arguments' && e !== 'caller')
        .map((e) => Symbol[e])
        .filter(d_)
    ),
    tD = v_(),
    nD = v_(!1, !0),
    rD = v_(!0),
    Yw = iD()
  function iD() {
    const e = {}
    return (
      ['includes', 'indexOf', 'lastIndexOf'].forEach((t) => {
        e[t] = function (...n) {
          const r = gn(this)
          for (let o = 0, a = this.length; o < a; o++) Pi(r, 'get', o + '')
          const i = r[t](...n)
          return i === -1 || i === !1 ? r[t](...n.map(gn)) : i
        }
      }),
      ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((t) => {
        e[t] = function (...n) {
          tc()
          const r = gn(this)[t].apply(this, n)
          return nc(), r
        }
      }),
      e
    )
  }
  function oD(e) {
    const t = gn(this)
    return Pi(t, 'has', e), t.hasOwnProperty(e)
  }
  function v_(e = !1, t = !1) {
    return function (r, i, o) {
      if (i === '__v_isReactive') return !e
      if (i === '__v_isReadonly') return e
      if (i === '__v_isShallow') return t
      if (i === '__v_raw' && o === (e ? (t ? SD : IT) : t ? LT : OT).get(r))
        return r
      const a = Yt(r)
      if (!e) {
        if (a && yn(Yw, i)) return Reflect.get(Yw, i, o)
        if (i === 'hasOwnProperty') return oD
      }
      const s = Reflect.get(r, i, o)
      return (d_(i) ? kT.has(i) : eD(i)) || (e || Pi(r, 'get', i), t)
        ? s
        : lr(s)
        ? a && f_(i)
          ? s
          : s.value
        : Bn(s)
        ? e
          ? y_(s)
          : Je(s)
        : s
    }
  }
  const aD = AT(),
    sD = AT(!0)
  function AT(e = !1) {
    return function (n, r, i, o) {
      let a = n[r]
      if (Hu(a) && lr(a) && !lr(i)) return !1
      if (
        !e &&
        (!Jp(i) && !Hu(i) && ((a = gn(a)), (i = gn(i))),
        !Yt(n) && lr(a) && !lr(i))
      )
        return (a.value = i), !0
      const s = Yt(n) && f_(r) ? Number(r) < n.length : yn(n, r),
        l = Reflect.set(n, r, i, o)
      return (
        n === gn(o) &&
          (s ? Md(i, a) && Va(n, 'set', r, i) : Va(n, 'add', r, i)),
        l
      )
    }
  }
  function lD(e, t) {
    const n = yn(e, t)
    e[t]
    const r = Reflect.deleteProperty(e, t)
    return r && n && Va(e, 'delete', t, void 0), r
  }
  function uD(e, t) {
    const n = Reflect.has(e, t)
    return (!d_(t) || !kT.has(t)) && Pi(e, 'has', t), n
  }
  function cD(e) {
    return Pi(e, 'iterate', Yt(e) ? 'length' : fl), Reflect.ownKeys(e)
  }
  const $T = { get: tD, set: aD, deleteProperty: lD, has: uD, ownKeys: cD },
    dD = {
      get: rD,
      set(e, t) {
        return !0
      },
      deleteProperty(e, t) {
        return !0
      },
    },
    fD = rr({}, $T, { get: nD, set: sD }),
    m_ = (e) => e,
    $v = (e) => Reflect.getPrototypeOf(e)
  function eh(e, t, n = !1, r = !1) {
    e = e.__v_raw
    const i = gn(e),
      o = gn(t)
    n || (t !== o && Pi(i, 'get', t), Pi(i, 'get', o))
    const { has: a } = $v(i),
      s = r ? m_ : n ? __ : Ed
    if (a.call(i, t)) return s(e.get(t))
    if (a.call(i, o)) return s(e.get(o))
    e !== i && e.get(t)
  }
  function th(e, t = !1) {
    const n = this.__v_raw,
      r = gn(n),
      i = gn(e)
    return (
      t || (e !== i && Pi(r, 'has', e), Pi(r, 'has', i)),
      e === i ? n.has(e) : n.has(e) || n.has(i)
    )
  }
  function nh(e, t = !1) {
    return (
      (e = e.__v_raw), !t && Pi(gn(e), 'iterate', fl), Reflect.get(e, 'size', e)
    )
  }
  function Zw(e) {
    e = gn(e)
    const t = gn(this)
    return $v(t).has.call(t, e) || (t.add(e), Va(t, 'add', e, e)), this
  }
  function Jw(e, t) {
    t = gn(t)
    const n = gn(this),
      { has: r, get: i } = $v(n)
    let o = r.call(n, e)
    o || ((e = gn(e)), (o = r.call(n, e)))
    const a = i.call(n, e)
    return (
      n.set(e, t), o ? Md(t, a) && Va(n, 'set', e, t) : Va(n, 'add', e, t), this
    )
  }
  function Qw(e) {
    const t = gn(this),
      { has: n, get: r } = $v(t)
    let i = n.call(t, e)
    i || ((e = gn(e)), (i = n.call(t, e))), r && r.call(t, e)
    const o = t.delete(e)
    return i && Va(t, 'delete', e, void 0), o
  }
  function e2() {
    const e = gn(this),
      t = e.size !== 0,
      n = e.clear()
    return t && Va(e, 'clear', void 0, void 0), n
  }
  function rh(e, t) {
    return function (r, i) {
      const o = this,
        a = o.__v_raw,
        s = gn(a),
        l = t ? m_ : e ? __ : Ed
      return (
        !e && Pi(s, 'iterate', fl),
        a.forEach((c, d) => r.call(i, l(c), l(d), o))
      )
    }
  }
  function ih(e, t, n) {
    return function (...r) {
      const i = this.__v_raw,
        o = gn(i),
        a = $u(o),
        s = e === 'entries' || (e === Symbol.iterator && a),
        l = e === 'keys' && a,
        c = i[e](...r),
        d = n ? m_ : t ? __ : Ed
      return (
        !t && Pi(o, 'iterate', l ? ob : fl),
        {
          next() {
            const { value: h, done: p } = c.next()
            return p
              ? { value: h, done: p }
              : { value: s ? [d(h[0]), d(h[1])] : d(h), done: p }
          },
          [Symbol.iterator]() {
            return this
          },
        }
      )
    }
  }
  function ss(e) {
    return function (...t) {
      return e === 'delete' ? !1 : this
    }
  }
  function hD() {
    const e = {
        get(o) {
          return eh(this, o)
        },
        get size() {
          return nh(this)
        },
        has: th,
        add: Zw,
        set: Jw,
        delete: Qw,
        clear: e2,
        forEach: rh(!1, !1),
      },
      t = {
        get(o) {
          return eh(this, o, !1, !0)
        },
        get size() {
          return nh(this)
        },
        has: th,
        add: Zw,
        set: Jw,
        delete: Qw,
        clear: e2,
        forEach: rh(!1, !0),
      },
      n = {
        get(o) {
          return eh(this, o, !0)
        },
        get size() {
          return nh(this, !0)
        },
        has(o) {
          return th.call(this, o, !0)
        },
        add: ss('add'),
        set: ss('set'),
        delete: ss('delete'),
        clear: ss('clear'),
        forEach: rh(!0, !1),
      },
      r = {
        get(o) {
          return eh(this, o, !0, !0)
        },
        get size() {
          return nh(this, !0)
        },
        has(o) {
          return th.call(this, o, !0)
        },
        add: ss('add'),
        set: ss('set'),
        delete: ss('delete'),
        clear: ss('clear'),
        forEach: rh(!0, !0),
      }
    return (
      ['keys', 'values', 'entries', Symbol.iterator].forEach((o) => {
        ;(e[o] = ih(o, !1, !1)),
          (n[o] = ih(o, !0, !1)),
          (t[o] = ih(o, !1, !0)),
          (r[o] = ih(o, !0, !0))
      }),
      [e, n, t, r]
    )
  }
  const [pD, vD, mD, gD] = hD()
  function g_(e, t) {
    const n = t ? (e ? gD : mD) : e ? vD : pD
    return (r, i, o) =>
      i === '__v_isReactive'
        ? !e
        : i === '__v_isReadonly'
        ? e
        : i === '__v_raw'
        ? r
        : Reflect.get(yn(n, i) && i in r ? n : r, i, o)
  }
  const yD = { get: g_(!1, !1) },
    bD = { get: g_(!1, !0) },
    _D = { get: g_(!0, !1) },
    OT = new WeakMap(),
    LT = new WeakMap(),
    IT = new WeakMap(),
    SD = new WeakMap()
  function CD(e) {
    switch (e) {
      case 'Object':
      case 'Array':
        return 1
      case 'Map':
      case 'Set':
      case 'WeakMap':
      case 'WeakSet':
        return 2
      default:
        return 0
    }
  }
  function wD(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : CD(N8(e))
  }
  function Je(e) {
    return Hu(e) ? e : b_(e, !1, $T, yD, OT)
  }
  function xD(e) {
    return b_(e, !1, fD, bD, LT)
  }
  function y_(e) {
    return b_(e, !0, dD, _D, IT)
  }
  function b_(e, t, n, r, i) {
    if (!Bn(e) || (e.__v_raw && !(t && e.__v_isReactive))) return e
    const o = i.get(e)
    if (o) return o
    const a = wD(e)
    if (a === 0) return e
    const s = new Proxy(e, a === 2 ? r : n)
    return i.set(e, s), s
  }
  function Ou(e) {
    return Hu(e) ? Ou(e.__v_raw) : !!(e && e.__v_isReactive)
  }
  function Hu(e) {
    return !!(e && e.__v_isReadonly)
  }
  function Jp(e) {
    return !!(e && e.__v_isShallow)
  }
  function RT(e) {
    return Ou(e) || Hu(e)
  }
  function gn(e) {
    const t = e && e.__v_raw
    return t ? gn(t) : e
  }
  function DT(e) {
    return Yp(e, '__v_skip', !0), e
  }
  const Ed = (e) => (Bn(e) ? Je(e) : e),
    __ = (e) => (Bn(e) ? y_(e) : e)
  function NT(e) {
    ws && Po && ((e = gn(e)), TT(e.dep || (e.dep = h_())))
  }
  function BT(e, t) {
    e = gn(e)
    const n = e.dep
    n && ab(n)
  }
  function lr(e) {
    return !!(e && e.__v_isRef === !0)
  }
  function J(e) {
    return FT(e, !1)
  }
  function xo(e) {
    return FT(e, !0)
  }
  function FT(e, t) {
    return lr(e) ? e : new MD(e, t)
  }
  class MD {
    constructor(t, n) {
      ;(this.__v_isShallow = n),
        (this.dep = void 0),
        (this.__v_isRef = !0),
        (this._rawValue = n ? t : gn(t)),
        (this._value = n ? t : Ed(t))
    }
    get value() {
      return NT(this), this._value
    }
    set value(t) {
      const n = this.__v_isShallow || Jp(t) || Hu(t)
      ;(t = n ? t : gn(t)),
        Md(t, this._rawValue) &&
          ((this._rawValue = t), (this._value = n ? t : Ed(t)), BT(this))
    }
  }
  function zT(e) {
    return lr(e) ? e.value : e
  }
  const ED = {
    get: (e, t, n) => zT(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
      const i = e[t]
      return lr(i) && !lr(n) ? ((i.value = n), !0) : Reflect.set(e, t, n, r)
    },
  }
  function VT(e) {
    return Ou(e) ? e : new Proxy(e, ED)
  }
  function tt(e) {
    const t = Yt(e) ? new Array(e.length) : {}
    for (const n in e) t[n] = UT(e, n)
    return t
  }
  class PD {
    constructor(t, n, r) {
      ;(this._object = t),
        (this._key = n),
        (this._defaultValue = r),
        (this.__v_isRef = !0)
    }
    get value() {
      const t = this._object[this._key]
      return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
      this._object[this._key] = t
    }
    get dep() {
      return Q8(gn(this._object), this._key)
    }
  }
  class TD {
    constructor(t) {
      ;(this._getter = t), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
    }
    get value() {
      return this._getter()
    }
  }
  function Vi(e, t, n) {
    return lr(e)
      ? e
      : en(e)
      ? new TD(e)
      : Bn(e) && arguments.length > 1
      ? UT(e, t, n)
      : J(e)
  }
  function UT(e, t, n) {
    const r = e[t]
    return lr(r) ? r : new PD(e, t, n)
  }
  class kD {
    constructor(t, n, r, i) {
      ;(this._setter = n),
        (this.dep = void 0),
        (this.__v_isRef = !0),
        (this.__v_isReadonly = !1),
        (this._dirty = !0),
        (this.effect = new p_(t, () => {
          this._dirty || ((this._dirty = !0), BT(this))
        })),
        (this.effect.computed = this),
        (this.effect.active = this._cacheable = !i),
        (this.__v_isReadonly = r)
    }
    get value() {
      const t = gn(this)
      return (
        NT(t),
        (t._dirty || !t._cacheable) &&
          ((t._dirty = !1), (t._value = t.effect.run())),
        t._value
      )
    }
    set value(t) {
      this._setter(t)
    }
  }
  function AD(e, t, n = !1) {
    let r, i
    const o = en(e)
    return (
      o ? ((r = e), (i = Oo)) : ((r = e.get), (i = e.set)),
      new kD(r, i, o || !i, n)
    )
  }
  function xs(e, t, n, r) {
    let i
    try {
      i = r ? e(...r) : e()
    } catch (o) {
      Ov(o, t, n)
    }
    return i
  }
  function no(e, t, n, r) {
    if (en(e)) {
      const o = xs(e, t, n, r)
      return (
        o &&
          _T(o) &&
          o.catch((a) => {
            Ov(a, t, n)
          }),
        o
      )
    }
    const i = []
    for (let o = 0; o < e.length; o++) i.push(no(e[o], t, n, r))
    return i
  }
  function Ov(e, t, n, r = !0) {
    const i = t ? t.vnode : null
    if (t) {
      let o = t.parent
      const a = t.proxy,
        s = n
      for (; o; ) {
        const c = o.ec
        if (c) {
          for (let d = 0; d < c.length; d++) if (c[d](e, a, s) === !1) return
        }
        o = o.parent
      }
      const l = t.appContext.config.errorHandler
      if (l) {
        xs(l, null, 10, [e, a, s])
        return
      }
    }
    $D(e, n, i, r)
  }
  function $D(e, t, n, r = !0) {
    console.error(e)
  }
  let Pd = !1,
    sb = !1
  const qr = []
  let Xo = 0
  const Lu = []
  let Aa = null,
    ol = 0
  const HT = Promise.resolve()
  let S_ = null
  function hn(e) {
    const t = S_ || HT
    return e ? t.then(this ? e.bind(this) : e) : t
  }
  function OD(e) {
    let t = Xo + 1,
      n = qr.length
    for (; t < n; ) {
      const r = (t + n) >>> 1
      Td(qr[r]) < e ? (t = r + 1) : (n = r)
    }
    return t
  }
  function C_(e) {
    ;(!qr.length || !qr.includes(e, Pd && e.allowRecurse ? Xo + 1 : Xo)) &&
      (e.id == null ? qr.push(e) : qr.splice(OD(e.id), 0, e), WT())
  }
  function WT() {
    !Pd && !sb && ((sb = !0), (S_ = HT.then(GT)))
  }
  function LD(e) {
    const t = qr.indexOf(e)
    t > Xo && qr.splice(t, 1)
  }
  function ID(e) {
    Yt(e)
      ? Lu.push(...e)
      : (!Aa || !Aa.includes(e, e.allowRecurse ? ol + 1 : ol)) && Lu.push(e),
      WT()
  }
  function t2(e, t = Pd ? Xo + 1 : 0) {
    for (; t < qr.length; t++) {
      const n = qr[t]
      n && n.pre && (qr.splice(t, 1), t--, n())
    }
  }
  function jT(e) {
    if (Lu.length) {
      const t = [...new Set(Lu)]
      if (((Lu.length = 0), Aa)) {
        Aa.push(...t)
        return
      }
      for (
        Aa = t, Aa.sort((n, r) => Td(n) - Td(r)), ol = 0;
        ol < Aa.length;
        ol++
      )
        Aa[ol]()
      ;(Aa = null), (ol = 0)
    }
  }
  const Td = (e) => (e.id == null ? 1 / 0 : e.id),
    RD = (e, t) => {
      const n = Td(e) - Td(t)
      if (n === 0) {
        if (e.pre && !t.pre) return -1
        if (t.pre && !e.pre) return 1
      }
      return n
    }
  function GT(e) {
    ;(sb = !1), (Pd = !0), qr.sort(RD)
    const t = Oo
    try {
      for (Xo = 0; Xo < qr.length; Xo++) {
        const n = qr[Xo]
        n && n.active !== !1 && xs(n, null, 14)
      }
    } finally {
      ;(Xo = 0),
        (qr.length = 0),
        jT(),
        (Pd = !1),
        (S_ = null),
        (qr.length || Lu.length) && GT()
    }
  }
  function DD(e, t, ...n) {
    if (e.isUnmounted) return
    const r = e.vnode.props || zn
    let i = n
    const o = t.startsWith('update:'),
      a = o && t.slice(7)
    if (a && a in r) {
      const d = `${a === 'modelValue' ? 'model' : a}Modifiers`,
        { number: h, trim: p } = r[d] || zn
      p && (i = n.map((v) => (Xn(v) ? v.trim() : v))), h && (i = n.map(z8))
    }
    let s,
      l = r[(s = kg(t))] || r[(s = kg(na(t)))]
    !l && o && (l = r[(s = kg(kl(t)))]), l && no(l, e, 6, i)
    const c = r[s + 'Once']
    if (c) {
      if (!e.emitted) e.emitted = {}
      else if (e.emitted[s]) return
      ;(e.emitted[s] = !0), no(c, e, 6, i)
    }
  }
  function KT(e, t, n = !1) {
    const r = t.emitsCache,
      i = r.get(e)
    if (i !== void 0) return i
    const o = e.emits
    let a = {},
      s = !1
    if (!en(e)) {
      const l = (c) => {
        const d = KT(c, t, !0)
        d && ((s = !0), rr(a, d))
      }
      !n && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !o && !s
      ? (Bn(e) && r.set(e, null), null)
      : (Yt(o) ? o.forEach((l) => (a[l] = null)) : rr(a, o),
        Bn(e) && r.set(e, a),
        a)
  }
  function Lv(e, t) {
    return !e || !Pv(t)
      ? !1
      : ((t = t.slice(2).replace(/Once$/, '')),
        yn(e, t[0].toLowerCase() + t.slice(1)) || yn(e, kl(t)) || yn(e, t))
  }
  let Dr = null,
    qT = null
  function Qp(e) {
    const t = Dr
    return (Dr = e), (qT = (e && e.type.__scopeId) || null), t
  }
  function ze(e, t = Dr, n) {
    if (!t || e._n) return e
    const r = (...i) => {
      r._d && p2(-1)
      const o = Qp(t)
      let a
      try {
        a = e(...i)
      } finally {
        Qp(o), r._d && p2(1)
      }
      return a
    }
    return (r._n = !0), (r._c = !0), (r._d = !0), r
  }
  function $g(e) {
    const {
      type: t,
      vnode: n,
      proxy: r,
      withProxy: i,
      props: o,
      propsOptions: [a],
      slots: s,
      attrs: l,
      emit: c,
      render: d,
      renderCache: h,
      data: p,
      setupState: v,
      ctx: g,
      inheritAttrs: _,
    } = e
    let b, y
    const M = Qp(e)
    try {
      if (n.shapeFlag & 4) {
        const w = i || r
        ;(b = qo(d.call(w, w, h, o, v, p, g))), (y = l)
      } else {
        const w = t
        ;(b = qo(
          w.length > 1 ? w(o, { attrs: l, slots: s, emit: c }) : w(o, null)
        )),
          (y = t.props ? l : ND(l))
      }
    } catch (w) {
      ;(ad.length = 0), Ov(w, e, 1), (b = m(Fi))
    }
    let x = b
    if (y && _ !== !1) {
      const w = Object.keys(y),
        { shapeFlag: E } = x
      w.length && E & 7 && (a && w.some(u_) && (y = BD(y, a)), (x = Ti(x, y)))
    }
    return (
      n.dirs &&
        ((x = Ti(x)), (x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs)),
      n.transition && (x.transition = n.transition),
      (b = x),
      Qp(M),
      b
    )
  }
  const ND = (e) => {
      let t
      for (const n in e)
        (n === 'class' || n === 'style' || Pv(n)) && ((t || (t = {}))[n] = e[n])
      return t
    },
    BD = (e, t) => {
      const n = {}
      for (const r in e) (!u_(r) || !(r.slice(9) in t)) && (n[r] = e[r])
      return n
    }
  function FD(e, t, n) {
    const { props: r, children: i, component: o } = e,
      { props: a, children: s, patchFlag: l } = t,
      c = o.emitsOptions
    if (t.dirs || t.transition) return !0
    if (n && l >= 0) {
      if (l & 1024) return !0
      if (l & 16) return r ? n2(r, a, c) : !!a
      if (l & 8) {
        const d = t.dynamicProps
        for (let h = 0; h < d.length; h++) {
          const p = d[h]
          if (a[p] !== r[p] && !Lv(c, p)) return !0
        }
      }
    } else
      return (i || s) && (!s || !s.$stable)
        ? !0
        : r === a
        ? !1
        : r
        ? a
          ? n2(r, a, c)
          : !0
        : !!a
    return !1
  }
  function n2(e, t, n) {
    const r = Object.keys(t)
    if (r.length !== Object.keys(e).length) return !0
    for (let i = 0; i < r.length; i++) {
      const o = r[i]
      if (t[o] !== e[o] && !Lv(n, o)) return !0
    }
    return !1
  }
  function zD({ vnode: e, parent: t }, n) {
    for (; t && t.subTree === e; ) ((e = t.vnode).el = n), (t = t.parent)
  }
  const VD = (e) => e.__isSuspense
  function UD(e, t) {
    t && t.pendingBranch
      ? Yt(e)
        ? t.effects.push(...e)
        : t.effects.push(e)
      : ID(e)
  }
  function pr(e, t) {
    return w_(e, null, t)
  }
  const oh = {}
  function pt(e, t, n) {
    return w_(e, t, n)
  }
  function w_(
    e,
    t,
    { immediate: n, deep: r, flush: i, onTrack: o, onTrigger: a } = zn
  ) {
    var s
    const l = Y8() === ((s = Cr) == null ? void 0 : s.scope) ? Cr : null
    let c,
      d = !1,
      h = !1
    if (
      (lr(e)
        ? ((c = () => e.value), (d = Jp(e)))
        : Ou(e)
        ? ((c = () => e), (r = !0))
        : Yt(e)
        ? ((h = !0),
          (d = e.some((w) => Ou(w) || Jp(w))),
          (c = () =>
            e.map((w) => {
              if (lr(w)) return w.value
              if (Ou(w)) return ul(w)
              if (en(w)) return xs(w, l, 2)
            })))
        : en(e)
        ? t
          ? (c = () => xs(e, l, 2))
          : (c = () => {
              if (!(l && l.isUnmounted)) return p && p(), no(e, l, 3, [v])
            })
        : (c = Oo),
      t && r)
    ) {
      const w = c
      c = () => ul(w())
    }
    let p,
      v = (w) => {
        p = M.onStop = () => {
          xs(w, l, 4)
        }
      },
      g
    if (Od)
      if (
        ((v = Oo),
        t ? n && no(t, l, 3, [c(), h ? [] : void 0, v]) : c(),
        i === 'sync')
      ) {
        const w = ON()
        g = w.__watcherHandles || (w.__watcherHandles = [])
      } else return Oo
    let _ = h ? new Array(e.length).fill(oh) : oh
    const b = () => {
      if (M.active)
        if (t) {
          const w = M.run()
          ;(r || d || (h ? w.some((E, P) => Md(E, _[P])) : Md(w, _))) &&
            (p && p(),
            no(t, l, 3, [w, _ === oh ? void 0 : h && _[0] === oh ? [] : _, v]),
            (_ = w))
        } else M.run()
    }
    b.allowRecurse = !!t
    let y
    i === 'sync'
      ? (y = b)
      : i === 'post'
      ? (y = () => bi(b, l && l.suspense))
      : ((b.pre = !0), l && (b.id = l.uid), (y = () => C_(b)))
    const M = new p_(c, y)
    t
      ? n
        ? b()
        : (_ = M.run())
      : i === 'post'
      ? bi(M.run.bind(M), l && l.suspense)
      : M.run()
    const x = () => {
      M.stop(), l && l.scope && c_(l.scope.effects, M)
    }
    return g && g.push(x), x
  }
  function HD(e, t, n) {
    const r = this.proxy,
      i = Xn(e) ? (e.includes('.') ? XT(r, e) : () => r[e]) : e.bind(r, r)
    let o
    en(t) ? (o = t) : ((o = t.handler), (n = t))
    const a = Cr
    Wu(this)
    const s = w_(i, o.bind(r), n)
    return a ? Wu(a) : hl(), s
  }
  function XT(e, t) {
    const n = t.split('.')
    return () => {
      let r = e
      for (let i = 0; i < n.length && r; i++) r = r[n[i]]
      return r
    }
  }
  function ul(e, t) {
    if (!Bn(e) || e.__v_skip || ((t = t || new Set()), t.has(e))) return e
    if ((t.add(e), lr(e))) ul(e.value, t)
    else if (Yt(e)) for (let n = 0; n < e.length; n++) ul(e[n], t)
    else if (bT(e) || $u(e))
      e.forEach((n) => {
        ul(n, t)
      })
    else if (CT(e)) for (const n in e) ul(e[n], t)
    return e
  }
  function ro(e, t) {
    const n = Dr
    if (n === null) return e
    const r = Fv(n) || n.proxy,
      i = e.dirs || (e.dirs = [])
    for (let o = 0; o < t.length; o++) {
      let [a, s, l, c = zn] = t[o]
      a &&
        (en(a) && (a = { mounted: a, updated: a }),
        a.deep && ul(s),
        i.push({
          dir: a,
          instance: r,
          value: s,
          oldValue: void 0,
          arg: l,
          modifiers: c,
        }))
    }
    return e
  }
  function Ks(e, t, n, r) {
    const i = e.dirs,
      o = t && t.dirs
    for (let a = 0; a < i.length; a++) {
      const s = i[a]
      o && (s.oldValue = o[a].value)
      let l = s.dir[r]
      l && (tc(), no(l, n, 8, [e.el, s, e, t]), nc())
    }
  }
  function YT() {
    const e = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: new Map(),
    }
    return (
      Wt(() => {
        e.isMounted = !0
      }),
      Pr(() => {
        e.isUnmounting = !0
      }),
      e
    )
  }
  const Ji = [Function, Array],
    ZT = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: Ji,
      onEnter: Ji,
      onAfterEnter: Ji,
      onEnterCancelled: Ji,
      onBeforeLeave: Ji,
      onLeave: Ji,
      onAfterLeave: Ji,
      onLeaveCancelled: Ji,
      onBeforeAppear: Ji,
      onAppear: Ji,
      onAfterAppear: Ji,
      onAppearCancelled: Ji,
    },
    WD = {
      name: 'BaseTransition',
      props: ZT,
      setup(e, { slots: t }) {
        const n = Jr(),
          r = YT()
        let i
        return () => {
          const o = t.default && x_(t.default(), !0)
          if (!o || !o.length) return
          let a = o[0]
          if (o.length > 1) {
            for (const _ of o)
              if (_.type !== Fi) {
                a = _
                break
              }
          }
          const s = gn(e),
            { mode: l } = s
          if (r.isLeaving) return Og(a)
          const c = r2(a)
          if (!c) return Og(a)
          const d = kd(c, s, r, n)
          Ad(c, d)
          const h = n.subTree,
            p = h && r2(h)
          let v = !1
          const { getTransitionKey: g } = c.type
          if (g) {
            const _ = g()
            i === void 0 ? (i = _) : _ !== i && ((i = _), (v = !0))
          }
          if (p && p.type !== Fi && (!al(c, p) || v)) {
            const _ = kd(p, s, r, n)
            if ((Ad(p, _), l === 'out-in'))
              return (
                (r.isLeaving = !0),
                (_.afterLeave = () => {
                  ;(r.isLeaving = !1), n.update.active !== !1 && n.update()
                }),
                Og(a)
              )
            l === 'in-out' &&
              c.type !== Fi &&
              (_.delayLeave = (b, y, M) => {
                const x = JT(r, p)
                ;(x[String(p.key)] = p),
                  (b._leaveCb = () => {
                    y(), (b._leaveCb = void 0), delete d.delayedLeave
                  }),
                  (d.delayedLeave = M)
              })
          }
          return a
        }
      },
    },
    jD = WD
  function JT(e, t) {
    const { leavingVNodes: n } = e
    let r = n.get(t.type)
    return r || ((r = Object.create(null)), n.set(t.type, r)), r
  }
  function kd(e, t, n, r) {
    const {
        appear: i,
        mode: o,
        persisted: a = !1,
        onBeforeEnter: s,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: d,
        onBeforeLeave: h,
        onLeave: p,
        onAfterLeave: v,
        onLeaveCancelled: g,
        onBeforeAppear: _,
        onAppear: b,
        onAfterAppear: y,
        onAppearCancelled: M,
      } = t,
      x = String(e.key),
      w = JT(n, e),
      E = (F, T) => {
        F && no(F, r, 9, T)
      },
      P = (F, T) => {
        const k = T[1]
        E(F, T),
          Yt(F) ? F.every((R) => R.length <= 1) && k() : F.length <= 1 && k()
      },
      A = {
        mode: o,
        persisted: a,
        beforeEnter(F) {
          let T = s
          if (!n.isMounted)
            if (i) T = _ || s
            else return
          F._leaveCb && F._leaveCb(!0)
          const k = w[x]
          k && al(e, k) && k.el._leaveCb && k.el._leaveCb(), E(T, [F])
        },
        enter(F) {
          let T = l,
            k = c,
            R = d
          if (!n.isMounted)
            if (i) (T = b || l), (k = y || c), (R = M || d)
            else return
          let j = !1
          const N = (F._enterCb = (I) => {
            j ||
              ((j = !0),
              I ? E(R, [F]) : E(k, [F]),
              A.delayedLeave && A.delayedLeave(),
              (F._enterCb = void 0))
          })
          T ? P(T, [F, N]) : N()
        },
        leave(F, T) {
          const k = String(e.key)
          if ((F._enterCb && F._enterCb(!0), n.isUnmounting)) return T()
          E(h, [F])
          let R = !1
          const j = (F._leaveCb = (N) => {
            R ||
              ((R = !0),
              T(),
              N ? E(g, [F]) : E(v, [F]),
              (F._leaveCb = void 0),
              w[k] === e && delete w[k])
          })
          ;(w[k] = e), p ? P(p, [F, j]) : j()
        },
        clone(F) {
          return kd(F, t, n, r)
        },
      }
    return A
  }
  function Og(e) {
    if (Iv(e)) return (e = Ti(e)), (e.children = null), e
  }
  function r2(e) {
    return Iv(e) ? (e.children ? e.children[0] : void 0) : e
  }
  function Ad(e, t) {
    e.shapeFlag & 6 && e.component
      ? Ad(e.component.subTree, t)
      : e.shapeFlag & 128
      ? ((e.ssContent.transition = t.clone(e.ssContent)),
        (e.ssFallback.transition = t.clone(e.ssFallback)))
      : (e.transition = t)
  }
  function x_(e, t = !1, n) {
    let r = [],
      i = 0
    for (let o = 0; o < e.length; o++) {
      let a = e[o]
      const s =
        n == null ? a.key : String(n) + String(a.key != null ? a.key : o)
      a.type === yt
        ? (a.patchFlag & 128 && i++, (r = r.concat(x_(a.children, t, s))))
        : (t || a.type !== Fi) && r.push(s != null ? Ti(a, { key: s }) : a)
    }
    if (i > 1) for (let o = 0; o < r.length; o++) r[o].patchFlag = -2
    return r
  }
  function ce(e, t) {
    return en(e) ? (() => rr({ name: e.name }, t, { setup: e }))() : e
  }
  const rd = (e) => !!e.type.__asyncLoader,
    Iv = (e) => e.type.__isKeepAlive
  function GD(e, t) {
    e4(e, 'a', t)
  }
  function QT(e, t) {
    e4(e, 'da', t)
  }
  function e4(e, t, n = Cr) {
    const r =
      e.__wdc ||
      (e.__wdc = () => {
        let i = n
        for (; i; ) {
          if (i.isDeactivated) return
          i = i.parent
        }
        return e()
      })
    if ((Rv(t, r, n), n)) {
      let i = n.parent
      for (; i && i.parent; )
        Iv(i.parent.vnode) && KD(r, t, n, i), (i = i.parent)
    }
  }
  function KD(e, t, n, r) {
    const i = Rv(t, e, r, !0)
    wr(() => {
      c_(r[t], i)
    }, n)
  }
  function Rv(e, t, n = Cr, r = !1) {
    if (n) {
      const i = n[e] || (n[e] = []),
        o =
          t.__weh ||
          (t.__weh = (...a) => {
            if (n.isUnmounted) return
            tc(), Wu(n)
            const s = no(t, n, e, a)
            return hl(), nc(), s
          })
      return r ? i.unshift(o) : i.push(o), o
    }
  }
  const Ha =
      (e) =>
      (t, n = Cr) =>
        (!Od || e === 'sp') && Rv(e, (...r) => t(...r), n),
    qD = Ha('bm'),
    Wt = Ha('m'),
    XD = Ha('bu'),
    Zr = Ha('u'),
    Pr = Ha('bum'),
    wr = Ha('um'),
    YD = Ha('sp'),
    ZD = Ha('rtg'),
    JD = Ha('rtc')
  function QD(e, t = Cr) {
    Rv('ec', e, t)
  }
  const M_ = 'components'
  function ge(e, t) {
    return n4(M_, e, !0, t) || e
  }
  const t4 = Symbol.for('v-ndc')
  function xi(e) {
    return Xn(e) ? n4(M_, e, !1) || e : e || t4
  }
  function n4(e, t, n = !0, r = !1) {
    const i = Dr || Cr
    if (i) {
      const o = i.type
      if (e === M_) {
        const s = kN(o, !1)
        if (s && (s === t || s === na(t) || s === Av(na(t)))) return o
      }
      const a = i2(i[e] || o[e], t) || i2(i.appContext[e], t)
      return !a && r ? o : a
    }
  }
  function i2(e, t) {
    return e && (e[t] || e[na(t)] || e[Av(na(t))])
  }
  function Yn(e, t, n, r) {
    let i
    const o = n && n[r]
    if (Yt(e) || Xn(e)) {
      i = new Array(e.length)
      for (let a = 0, s = e.length; a < s; a++)
        i[a] = t(e[a], a, void 0, o && o[a])
    } else if (typeof e == 'number') {
      i = new Array(e)
      for (let a = 0; a < e; a++) i[a] = t(a + 1, a, void 0, o && o[a])
    } else if (Bn(e))
      if (e[Symbol.iterator])
        i = Array.from(e, (a, s) => t(a, s, void 0, o && o[s]))
      else {
        const a = Object.keys(e)
        i = new Array(a.length)
        for (let s = 0, l = a.length; s < l; s++) {
          const c = a[s]
          i[s] = t(e[c], c, s, o && o[s])
        }
      }
    else i = []
    return n && (n[r] = i), i
  }
  function Nn(e, t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n]
      if (Yt(r)) for (let i = 0; i < r.length; i++) e[r[i].name] = r[i].fn
      else
        r &&
          (e[r.name] = r.key
            ? (...i) => {
                const o = r.fn(...i)
                return o && (o.key = r.key), o
              }
            : r.fn)
    }
    return e
  }
  function ve(e, t, n = {}, r, i) {
    if (Dr.isCE || (Dr.parent && rd(Dr.parent) && Dr.parent.isCE))
      return t !== 'default' && (n.name = t), m('slot', n, r && r())
    let o = e[t]
    o && o._c && (o._d = !1), O()
    const a = o && r4(o(n)),
      s = Ee(
        yt,
        { key: n.key || (a && a.key) || `_${t}` },
        a || (r ? r() : []),
        a && e._ === 1 ? 64 : -2
      )
    return (
      !i && s.scopeId && (s.slotScopeIds = [s.scopeId + '-s']),
      o && o._c && (o._d = !0),
      s
    )
  }
  function r4(e) {
    return e.some((t) =>
      An(t) ? !(t.type === Fi || (t.type === yt && !r4(t.children))) : !0
    )
      ? e
      : null
  }
  const lb = (e) => (e ? (p4(e) ? Fv(e) || e.proxy : lb(e.parent)) : null),
    id = rr(Object.create(null), {
      $: (e) => e,
      $el: (e) => e.vnode.el,
      $data: (e) => e.data,
      $props: (e) => e.props,
      $attrs: (e) => e.attrs,
      $slots: (e) => e.slots,
      $refs: (e) => e.refs,
      $parent: (e) => lb(e.parent),
      $root: (e) => lb(e.root),
      $emit: (e) => e.emit,
      $options: (e) => E_(e),
      $forceUpdate: (e) => e.f || (e.f = () => C_(e.update)),
      $nextTick: (e) => e.n || (e.n = hn.bind(e.proxy)),
      $watch: (e) => HD.bind(e),
    }),
    Lg = (e, t) => e !== zn && !e.__isScriptSetup && yn(e, t),
    eN = {
      get({ _: e }, t) {
        const {
          ctx: n,
          setupState: r,
          data: i,
          props: o,
          accessCache: a,
          type: s,
          appContext: l,
        } = e
        let c
        if (t[0] !== '$') {
          const v = a[t]
          if (v !== void 0)
            switch (v) {
              case 1:
                return r[t]
              case 2:
                return i[t]
              case 4:
                return n[t]
              case 3:
                return o[t]
            }
          else {
            if (Lg(r, t)) return (a[t] = 1), r[t]
            if (i !== zn && yn(i, t)) return (a[t] = 2), i[t]
            if ((c = e.propsOptions[0]) && yn(c, t)) return (a[t] = 3), o[t]
            if (n !== zn && yn(n, t)) return (a[t] = 4), n[t]
            ub && (a[t] = 0)
          }
        }
        const d = id[t]
        let h, p
        if (d) return t === '$attrs' && Pi(e, 'get', t), d(e)
        if ((h = s.__cssModules) && (h = h[t])) return h
        if (n !== zn && yn(n, t)) return (a[t] = 4), n[t]
        if (((p = l.config.globalProperties), yn(p, t))) return p[t]
      },
      set({ _: e }, t, n) {
        const { data: r, setupState: i, ctx: o } = e
        return Lg(i, t)
          ? ((i[t] = n), !0)
          : r !== zn && yn(r, t)
          ? ((r[t] = n), !0)
          : yn(e.props, t) || (t[0] === '$' && t.slice(1) in e)
          ? !1
          : ((o[t] = n), !0)
      },
      has(
        {
          _: {
            data: e,
            setupState: t,
            accessCache: n,
            ctx: r,
            appContext: i,
            propsOptions: o,
          },
        },
        a
      ) {
        let s
        return (
          !!n[a] ||
          (e !== zn && yn(e, a)) ||
          Lg(t, a) ||
          ((s = o[0]) && yn(s, a)) ||
          yn(r, a) ||
          yn(id, a) ||
          yn(i.config.globalProperties, a)
        )
      },
      defineProperty(e, t, n) {
        return (
          n.get != null
            ? (e._.accessCache[t] = 0)
            : yn(n, 'value') && this.set(e, t, n.value, null),
          Reflect.defineProperty(e, t, n)
        )
      },
    }
  function o2(e) {
    return Yt(e) ? e.reduce((t, n) => ((t[n] = null), t), {}) : e
  }
  let ub = !0
  function tN(e) {
    const t = E_(e),
      n = e.proxy,
      r = e.ctx
    ;(ub = !1), t.beforeCreate && a2(t.beforeCreate, e, 'bc')
    const {
      data: i,
      computed: o,
      methods: a,
      watch: s,
      provide: l,
      inject: c,
      created: d,
      beforeMount: h,
      mounted: p,
      beforeUpdate: v,
      updated: g,
      activated: _,
      deactivated: b,
      beforeDestroy: y,
      beforeUnmount: M,
      destroyed: x,
      unmounted: w,
      render: E,
      renderTracked: P,
      renderTriggered: A,
      errorCaptured: F,
      serverPrefetch: T,
      expose: k,
      inheritAttrs: R,
      components: j,
      directives: N,
      filters: I,
    } = t
    if ((c && nN(c, r, null), a))
      for (const L in a) {
        const W = a[L]
        en(W) && (r[L] = W.bind(n))
      }
    if (i) {
      const L = i.call(n, n)
      Bn(L) && (e.data = Je(L))
    }
    if (((ub = !0), o))
      for (const L in o) {
        const W = o[L],
          Y = en(W) ? W.bind(n, n) : en(W.get) ? W.get.bind(n, n) : Oo,
          U = !en(W) && en(W.set) ? W.set.bind(n) : Oo,
          le = C({ get: Y, set: U })
        Object.defineProperty(r, L, {
          enumerable: !0,
          configurable: !0,
          get: () => le.value,
          set: (q) => (le.value = q),
        })
      }
    if (s) for (const L in s) i4(s[L], r, n, L)
    if (l) {
      const L = en(l) ? l.call(n) : l
      Reflect.ownKeys(L).forEach((W) => {
        sn(W, L[W])
      })
    }
    d && a2(d, e, 'c')
    function V(L, W) {
      Yt(W) ? W.forEach((Y) => L(Y.bind(n))) : W && L(W.bind(n))
    }
    if (
      (V(qD, h),
      V(Wt, p),
      V(XD, v),
      V(Zr, g),
      V(GD, _),
      V(QT, b),
      V(QD, F),
      V(JD, P),
      V(ZD, A),
      V(Pr, M),
      V(wr, w),
      V(YD, T),
      Yt(k))
    )
      if (k.length) {
        const L = e.exposed || (e.exposed = {})
        k.forEach((W) => {
          Object.defineProperty(L, W, {
            get: () => n[W],
            set: (Y) => (n[W] = Y),
          })
        })
      } else e.exposed || (e.exposed = {})
    E && e.render === Oo && (e.render = E),
      R != null && (e.inheritAttrs = R),
      j && (e.components = j),
      N && (e.directives = N)
  }
  function nN(e, t, n = Oo) {
    Yt(e) && (e = cb(e))
    for (const r in e) {
      const i = e[r]
      let o
      Bn(i)
        ? 'default' in i
          ? (o = zt(i.from || r, i.default, !0))
          : (o = zt(i.from || r))
        : (o = zt(i)),
        lr(o)
          ? Object.defineProperty(t, r, {
              enumerable: !0,
              configurable: !0,
              get: () => o.value,
              set: (a) => (o.value = a),
            })
          : (t[r] = o)
    }
  }
  function a2(e, t, n) {
    no(Yt(e) ? e.map((r) => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
  }
  function i4(e, t, n, r) {
    const i = r.includes('.') ? XT(n, r) : () => n[r]
    if (Xn(e)) {
      const o = t[e]
      en(o) && pt(i, o)
    } else if (en(e)) pt(i, e.bind(n))
    else if (Bn(e))
      if (Yt(e)) e.forEach((o) => i4(o, t, n, r))
      else {
        const o = en(e.handler) ? e.handler.bind(n) : t[e.handler]
        en(o) && pt(i, o, e)
      }
  }
  function E_(e) {
    const t = e.type,
      { mixins: n, extends: r } = t,
      {
        mixins: i,
        optionsCache: o,
        config: { optionMergeStrategies: a },
      } = e.appContext,
      s = o.get(t)
    let l
    return (
      s
        ? (l = s)
        : !i.length && !n && !r
        ? (l = t)
        : ((l = {}),
          i.length && i.forEach((c) => ev(l, c, a, !0)),
          ev(l, t, a)),
      Bn(t) && o.set(t, l),
      l
    )
  }
  function ev(e, t, n, r = !1) {
    const { mixins: i, extends: o } = t
    o && ev(e, o, n, !0), i && i.forEach((a) => ev(e, a, n, !0))
    for (const a in t)
      if (!(r && a === 'expose')) {
        const s = rN[a] || (n && n[a])
        e[a] = s ? s(e[a], t[a]) : t[a]
      }
    return e
  }
  const rN = {
    data: s2,
    props: l2,
    emits: l2,
    methods: Zc,
    computed: Zc,
    beforeCreate: ai,
    created: ai,
    beforeMount: ai,
    mounted: ai,
    beforeUpdate: ai,
    updated: ai,
    beforeDestroy: ai,
    beforeUnmount: ai,
    destroyed: ai,
    unmounted: ai,
    activated: ai,
    deactivated: ai,
    errorCaptured: ai,
    serverPrefetch: ai,
    components: Zc,
    directives: Zc,
    watch: oN,
    provide: s2,
    inject: iN,
  }
  function s2(e, t) {
    return t
      ? e
        ? function () {
            return rr(
              en(e) ? e.call(this, this) : e,
              en(t) ? t.call(this, this) : t
            )
          }
        : t
      : e
  }
  function iN(e, t) {
    return Zc(cb(e), cb(t))
  }
  function cb(e) {
    if (Yt(e)) {
      const t = {}
      for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
      return t
    }
    return e
  }
  function ai(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
  }
  function Zc(e, t) {
    return e ? rr(Object.create(null), e, t) : t
  }
  function l2(e, t) {
    return e
      ? Yt(e) && Yt(t)
        ? [...new Set([...e, ...t])]
        : rr(Object.create(null), o2(e), o2(t ?? {}))
      : t
  }
  function oN(e, t) {
    if (!e) return t
    if (!t) return e
    const n = rr(Object.create(null), e)
    for (const r in t) n[r] = ai(e[r], t[r])
    return n
  }
  function o4() {
    return {
      app: null,
      config: {
        isNativeTag: I8,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {},
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap(),
    }
  }
  let aN = 0
  function sN(e, t) {
    return function (r, i = null) {
      en(r) || (r = rr({}, r)), i != null && !Bn(i) && (i = null)
      const o = o4(),
        a = new Set()
      let s = !1
      const l = (o.app = {
        _uid: aN++,
        _component: r,
        _props: i,
        _container: null,
        _context: o,
        _instance: null,
        version: LN,
        get config() {
          return o.config
        },
        set config(c) {},
        use(c, ...d) {
          return (
            a.has(c) ||
              (c && en(c.install)
                ? (a.add(c), c.install(l, ...d))
                : en(c) && (a.add(c), c(l, ...d))),
            l
          )
        },
        mixin(c) {
          return o.mixins.includes(c) || o.mixins.push(c), l
        },
        component(c, d) {
          return d ? ((o.components[c] = d), l) : o.components[c]
        },
        directive(c, d) {
          return d ? ((o.directives[c] = d), l) : o.directives[c]
        },
        mount(c, d, h) {
          if (!s) {
            const p = m(r, i)
            return (
              (p.appContext = o),
              d && t ? t(p, c) : e(p, c, h),
              (s = !0),
              (l._container = c),
              (c.__vue_app__ = l),
              Fv(p.component) || p.component.proxy
            )
          }
        },
        unmount() {
          s && (e(null, l._container), delete l._container.__vue_app__)
        },
        provide(c, d) {
          return (o.provides[c] = d), l
        },
        runWithContext(c) {
          tv = l
          try {
            return c()
          } finally {
            tv = null
          }
        },
      })
      return l
    }
  }
  let tv = null
  function sn(e, t) {
    if (Cr) {
      let n = Cr.provides
      const r = Cr.parent && Cr.parent.provides
      r === n && (n = Cr.provides = Object.create(r)), (n[e] = t)
    }
  }
  function zt(e, t, n = !1) {
    const r = Cr || Dr
    if (r || tv) {
      const i = r
        ? r.parent == null
          ? r.vnode.appContext && r.vnode.appContext.provides
          : r.parent.provides
        : tv._context.provides
      if (i && e in i) return i[e]
      if (arguments.length > 1) return n && en(t) ? t.call(r && r.proxy) : t
    }
  }
  function lN(e, t, n, r = !1) {
    const i = {},
      o = {}
    Yp(o, Bv, 1), (e.propsDefaults = Object.create(null)), a4(e, t, i, o)
    for (const a in e.propsOptions[0]) a in i || (i[a] = void 0)
    n
      ? (e.props = r ? i : xD(i))
      : e.type.props
      ? (e.props = i)
      : (e.props = o),
      (e.attrs = o)
  }
  function uN(e, t, n, r) {
    const {
        props: i,
        attrs: o,
        vnode: { patchFlag: a },
      } = e,
      s = gn(i),
      [l] = e.propsOptions
    let c = !1
    if ((r || a > 0) && !(a & 16)) {
      if (a & 8) {
        const d = e.vnode.dynamicProps
        for (let h = 0; h < d.length; h++) {
          let p = d[h]
          if (Lv(e.emitsOptions, p)) continue
          const v = t[p]
          if (l)
            if (yn(o, p)) v !== o[p] && ((o[p] = v), (c = !0))
            else {
              const g = na(p)
              i[g] = db(l, s, g, v, e, !1)
            }
          else v !== o[p] && ((o[p] = v), (c = !0))
        }
      }
    } else {
      a4(e, t, i, o) && (c = !0)
      let d
      for (const h in s)
        (!t || (!yn(t, h) && ((d = kl(h)) === h || !yn(t, d)))) &&
          (l
            ? n &&
              (n[h] !== void 0 || n[d] !== void 0) &&
              (i[h] = db(l, s, h, void 0, e, !0))
            : delete i[h])
      if (o !== s)
        for (const h in o) (!t || !yn(t, h)) && (delete o[h], (c = !0))
    }
    c && Va(e, 'set', '$attrs')
  }
  function a4(e, t, n, r) {
    const [i, o] = e.propsOptions
    let a = !1,
      s
    if (t)
      for (let l in t) {
        if (Wh(l)) continue
        const c = t[l]
        let d
        i && yn(i, (d = na(l)))
          ? !o || !o.includes(d)
            ? (n[d] = c)
            : ((s || (s = {}))[d] = c)
          : Lv(e.emitsOptions, l) ||
            ((!(l in r) || c !== r[l]) && ((r[l] = c), (a = !0)))
      }
    if (o) {
      const l = gn(n),
        c = s || zn
      for (let d = 0; d < o.length; d++) {
        const h = o[d]
        n[h] = db(i, l, h, c[h], e, !yn(c, h))
      }
    }
    return a
  }
  function db(e, t, n, r, i, o) {
    const a = e[n]
    if (a != null) {
      const s = yn(a, 'default')
      if (s && r === void 0) {
        const l = a.default
        if (a.type !== Function && !a.skipFactory && en(l)) {
          const { propsDefaults: c } = i
          n in c ? (r = c[n]) : (Wu(i), (r = c[n] = l.call(null, t)), hl())
        } else r = l
      }
      a[0] &&
        (o && !s ? (r = !1) : a[1] && (r === '' || r === kl(n)) && (r = !0))
    }
    return r
  }
  function s4(e, t, n = !1) {
    const r = t.propsCache,
      i = r.get(e)
    if (i) return i
    const o = e.props,
      a = {},
      s = []
    let l = !1
    if (!en(e)) {
      const d = (h) => {
        l = !0
        const [p, v] = s4(h, t, !0)
        rr(a, p), v && s.push(...v)
      }
      !n && t.mixins.length && t.mixins.forEach(d),
        e.extends && d(e.extends),
        e.mixins && e.mixins.forEach(d)
    }
    if (!o && !l) return Bn(e) && r.set(e, Au), Au
    if (Yt(o))
      for (let d = 0; d < o.length; d++) {
        const h = na(o[d])
        u2(h) && (a[h] = zn)
      }
    else if (o)
      for (const d in o) {
        const h = na(d)
        if (u2(h)) {
          const p = o[d],
            v = (a[h] = Yt(p) || en(p) ? { type: p } : rr({}, p))
          if (v) {
            const g = f2(Boolean, v.type),
              _ = f2(String, v.type)
            ;(v[0] = g > -1),
              (v[1] = _ < 0 || g < _),
              (g > -1 || yn(v, 'default')) && s.push(h)
          }
        }
      }
    const c = [a, s]
    return Bn(e) && r.set(e, c), c
  }
  function u2(e) {
    return e[0] !== '$'
  }
  function c2(e) {
    const t = e && e.toString().match(/^\s*(function|class) (\w+)/)
    return t ? t[2] : e === null ? 'null' : ''
  }
  function d2(e, t) {
    return c2(e) === c2(t)
  }
  function f2(e, t) {
    return Yt(t) ? t.findIndex((n) => d2(n, e)) : en(t) && d2(t, e) ? 0 : -1
  }
  const l4 = (e) => e[0] === '_' || e === '$stable',
    P_ = (e) => (Yt(e) ? e.map(qo) : [qo(e)]),
    cN = (e, t, n) => {
      if (t._n) return t
      const r = ze((...i) => P_(t(...i)), n)
      return (r._c = !1), r
    },
    u4 = (e, t, n) => {
      const r = e._ctx
      for (const i in e) {
        if (l4(i)) continue
        const o = e[i]
        if (en(o)) t[i] = cN(i, o, r)
        else if (o != null) {
          const a = P_(o)
          t[i] = () => a
        }
      }
    },
    c4 = (e, t) => {
      const n = P_(t)
      e.slots.default = () => n
    },
    dN = (e, t) => {
      if (e.vnode.shapeFlag & 32) {
        const n = t._
        n ? ((e.slots = gn(t)), Yp(t, '_', n)) : u4(t, (e.slots = {}))
      } else (e.slots = {}), t && c4(e, t)
      Yp(e.slots, Bv, 1)
    },
    fN = (e, t, n) => {
      const { vnode: r, slots: i } = e
      let o = !0,
        a = zn
      if (r.shapeFlag & 32) {
        const s = t._
        s
          ? n && s === 1
            ? (o = !1)
            : (rr(i, t), !n && s === 1 && delete i._)
          : ((o = !t.$stable), u4(t, i)),
          (a = t)
      } else t && (c4(e, t), (a = { default: 1 }))
      if (o) for (const s in i) !l4(s) && !(s in a) && delete i[s]
    }
  function fb(e, t, n, r, i = !1) {
    if (Yt(e)) {
      e.forEach((p, v) => fb(p, t && (Yt(t) ? t[v] : t), n, r, i))
      return
    }
    if (rd(r) && !i) return
    const o = r.shapeFlag & 4 ? Fv(r.component) || r.component.proxy : r.el,
      a = i ? null : o,
      { i: s, r: l } = e,
      c = t && t.r,
      d = s.refs === zn ? (s.refs = {}) : s.refs,
      h = s.setupState
    if (
      (c != null &&
        c !== l &&
        (Xn(c)
          ? ((d[c] = null), yn(h, c) && (h[c] = null))
          : lr(c) && (c.value = null)),
      en(l))
    )
      xs(l, s, 12, [a, d])
    else {
      const p = Xn(l),
        v = lr(l)
      if (p || v) {
        const g = () => {
          if (e.f) {
            const _ = p ? (yn(h, l) ? h[l] : d[l]) : l.value
            i
              ? Yt(_) && c_(_, o)
              : Yt(_)
              ? _.includes(o) || _.push(o)
              : p
              ? ((d[l] = [o]), yn(h, l) && (h[l] = d[l]))
              : ((l.value = [o]), e.k && (d[e.k] = l.value))
          } else
            p
              ? ((d[l] = a), yn(h, l) && (h[l] = a))
              : v && ((l.value = a), e.k && (d[e.k] = a))
        }
        a ? ((g.id = -1), bi(g, n)) : g()
      }
    }
  }
  const bi = UD
  function hN(e) {
    return pN(e)
  }
  function pN(e, t) {
    const n = rb()
    n.__VUE__ = !0
    const {
        insert: r,
        remove: i,
        patchProp: o,
        createElement: a,
        createText: s,
        createComment: l,
        setText: c,
        setElementText: d,
        parentNode: h,
        nextSibling: p,
        setScopeId: v = Oo,
        insertStaticContent: g,
      } = e,
      _ = (
        D,
        G,
        z,
        ie = null,
        ae = null,
        re = null,
        pe = !1,
        we = null,
        $e = !!G.dynamicChildren
      ) => {
        if (D === G) return
        D && !al(D, G) && ((ie = Re(D)), q(D, ae, re, !0), (D = null)),
          G.patchFlag === -2 && (($e = !1), (G.dynamicChildren = null))
        const { type: Ae, ref: ft, shapeFlag: Q } = G
        switch (Ae) {
          case Nv:
            b(D, G, z, ie)
            break
          case Fi:
            y(D, G, z, ie)
            break
          case jh:
            D == null && M(G, z, ie, pe)
            break
          case yt:
            j(D, G, z, ie, ae, re, pe, we, $e)
            break
          default:
            Q & 1
              ? E(D, G, z, ie, ae, re, pe, we, $e)
              : Q & 6
              ? N(D, G, z, ie, ae, re, pe, we, $e)
              : (Q & 64 || Q & 128) &&
                Ae.process(D, G, z, ie, ae, re, pe, we, $e, Ve)
        }
        ft != null && ae && fb(ft, D && D.ref, re, G || D, !G)
      },
      b = (D, G, z, ie) => {
        if (D == null) r((G.el = s(G.children)), z, ie)
        else {
          const ae = (G.el = D.el)
          G.children !== D.children && c(ae, G.children)
        }
      },
      y = (D, G, z, ie) => {
        D == null ? r((G.el = l(G.children || '')), z, ie) : (G.el = D.el)
      },
      M = (D, G, z, ie) => {
        ;[D.el, D.anchor] = g(D.children, G, z, ie, D.el, D.anchor)
      },
      x = ({ el: D, anchor: G }, z, ie) => {
        let ae
        for (; D && D !== G; ) (ae = p(D)), r(D, z, ie), (D = ae)
        r(G, z, ie)
      },
      w = ({ el: D, anchor: G }) => {
        let z
        for (; D && D !== G; ) (z = p(D)), i(D), (D = z)
        i(G)
      },
      E = (D, G, z, ie, ae, re, pe, we, $e) => {
        ;(pe = pe || G.type === 'svg'),
          D == null
            ? P(G, z, ie, ae, re, pe, we, $e)
            : T(D, G, ae, re, pe, we, $e)
      },
      P = (D, G, z, ie, ae, re, pe, we) => {
        let $e, Ae
        const { type: ft, props: Q, shapeFlag: X, transition: he, dirs: de } = D
        if (
          (($e = D.el = a(D.type, re, Q && Q.is, Q)),
          X & 8
            ? d($e, D.children)
            : X & 16 &&
              F(
                D.children,
                $e,
                null,
                ie,
                ae,
                re && ft !== 'foreignObject',
                pe,
                we
              ),
          de && Ks(D, null, ie, 'created'),
          A($e, D, D.scopeId, pe, ie),
          Q)
        ) {
          for (const ne in Q)
            ne !== 'value' &&
              !Wh(ne) &&
              o($e, ne, null, Q[ne], re, D.children, ie, ae, me)
          'value' in Q && o($e, 'value', null, Q.value),
            (Ae = Q.onVnodeBeforeMount) && jo(Ae, ie, D)
        }
        de && Ks(D, null, ie, 'beforeMount')
        const xe = (!ae || (ae && !ae.pendingBranch)) && he && !he.persisted
        xe && he.beforeEnter($e),
          r($e, G, z),
          ((Ae = Q && Q.onVnodeMounted) || xe || de) &&
            bi(() => {
              Ae && jo(Ae, ie, D),
                xe && he.enter($e),
                de && Ks(D, null, ie, 'mounted')
            }, ae)
      },
      A = (D, G, z, ie, ae) => {
        if ((z && v(D, z), ie))
          for (let re = 0; re < ie.length; re++) v(D, ie[re])
        if (ae) {
          let re = ae.subTree
          if (G === re) {
            const pe = ae.vnode
            A(D, pe, pe.scopeId, pe.slotScopeIds, ae.parent)
          }
        }
      },
      F = (D, G, z, ie, ae, re, pe, we, $e = 0) => {
        for (let Ae = $e; Ae < D.length; Ae++) {
          const ft = (D[Ae] = we ? gs(D[Ae]) : qo(D[Ae]))
          _(null, ft, G, z, ie, ae, re, pe, we)
        }
      },
      T = (D, G, z, ie, ae, re, pe) => {
        const we = (G.el = D.el)
        let { patchFlag: $e, dynamicChildren: Ae, dirs: ft } = G
        $e |= D.patchFlag & 16
        const Q = D.props || zn,
          X = G.props || zn
        let he
        z && qs(z, !1),
          (he = X.onVnodeBeforeUpdate) && jo(he, z, G, D),
          ft && Ks(G, D, z, 'beforeUpdate'),
          z && qs(z, !0)
        const de = ae && G.type !== 'foreignObject'
        if (
          (Ae
            ? k(D.dynamicChildren, Ae, we, z, ie, de, re)
            : pe || W(D, G, we, null, z, ie, de, re, !1),
          $e > 0)
        ) {
          if ($e & 16) R(we, G, Q, X, z, ie, ae)
          else if (
            ($e & 2 && Q.class !== X.class && o(we, 'class', null, X.class, ae),
            $e & 4 && o(we, 'style', Q.style, X.style, ae),
            $e & 8)
          ) {
            const xe = G.dynamicProps
            for (let ne = 0; ne < xe.length; ne++) {
              const Le = xe[ne],
                et = Q[Le],
                Ne = X[Le]
              ;(Ne !== et || Le === 'value') &&
                o(we, Le, et, Ne, ae, D.children, z, ie, me)
            }
          }
          $e & 1 && D.children !== G.children && d(we, G.children)
        } else !pe && Ae == null && R(we, G, Q, X, z, ie, ae)
        ;((he = X.onVnodeUpdated) || ft) &&
          bi(() => {
            he && jo(he, z, G, D), ft && Ks(G, D, z, 'updated')
          }, ie)
      },
      k = (D, G, z, ie, ae, re, pe) => {
        for (let we = 0; we < G.length; we++) {
          const $e = D[we],
            Ae = G[we],
            ft =
              $e.el && ($e.type === yt || !al($e, Ae) || $e.shapeFlag & 70)
                ? h($e.el)
                : z
          _($e, Ae, ft, null, ie, ae, re, pe, !0)
        }
      },
      R = (D, G, z, ie, ae, re, pe) => {
        if (z !== ie) {
          if (z !== zn)
            for (const we in z)
              !Wh(we) &&
                !(we in ie) &&
                o(D, we, z[we], null, pe, G.children, ae, re, me)
          for (const we in ie) {
            if (Wh(we)) continue
            const $e = ie[we],
              Ae = z[we]
            $e !== Ae &&
              we !== 'value' &&
              o(D, we, Ae, $e, pe, G.children, ae, re, me)
          }
          'value' in ie && o(D, 'value', z.value, ie.value)
        }
      },
      j = (D, G, z, ie, ae, re, pe, we, $e) => {
        const Ae = (G.el = D ? D.el : s('')),
          ft = (G.anchor = D ? D.anchor : s(''))
        let { patchFlag: Q, dynamicChildren: X, slotScopeIds: he } = G
        he && (we = we ? we.concat(he) : he),
          D == null
            ? (r(Ae, z, ie),
              r(ft, z, ie),
              F(G.children, z, ft, ae, re, pe, we, $e))
            : Q > 0 && Q & 64 && X && D.dynamicChildren
            ? (k(D.dynamicChildren, X, z, ae, re, pe, we),
              (G.key != null || (ae && G === ae.subTree)) && T_(D, G, !0))
            : W(D, G, z, ft, ae, re, pe, we, $e)
      },
      N = (D, G, z, ie, ae, re, pe, we, $e) => {
        ;(G.slotScopeIds = we),
          D == null
            ? G.shapeFlag & 512
              ? ae.ctx.activate(G, z, ie, pe, $e)
              : I(G, z, ie, ae, re, pe, $e)
            : B(D, G, $e)
      },
      I = (D, G, z, ie, ae, re, pe) => {
        const we = (D.component = xN(D, ie, ae))
        if ((Iv(D) && (we.ctx.renderer = Ve), MN(we), we.asyncDep)) {
          if ((ae && ae.registerDep(we, V), !D.el)) {
            const $e = (we.subTree = m(Fi))
            y(null, $e, G, z)
          }
          return
        }
        V(we, D, G, z, ae, re, pe)
      },
      B = (D, G, z) => {
        const ie = (G.component = D.component)
        if (FD(D, G, z))
          if (ie.asyncDep && !ie.asyncResolved) {
            L(ie, G, z)
            return
          } else (ie.next = G), LD(ie.update), ie.update()
        else (G.el = D.el), (ie.vnode = G)
      },
      V = (D, G, z, ie, ae, re, pe) => {
        const we = () => {
            if (D.isMounted) {
              let { next: ft, bu: Q, u: X, parent: he, vnode: de } = D,
                xe = ft,
                ne
              qs(D, !1),
                ft ? ((ft.el = de.el), L(D, ft, pe)) : (ft = de),
                Q && Ag(Q),
                (ne = ft.props && ft.props.onVnodeBeforeUpdate) &&
                  jo(ne, he, ft, de),
                qs(D, !0)
              const Le = $g(D),
                et = D.subTree
              ;(D.subTree = Le),
                _(et, Le, h(et.el), Re(et), D, ae, re),
                (ft.el = Le.el),
                xe === null && zD(D, Le.el),
                X && bi(X, ae),
                (ne = ft.props && ft.props.onVnodeUpdated) &&
                  bi(() => jo(ne, he, ft, de), ae)
            } else {
              let ft
              const { el: Q, props: X } = G,
                { bm: he, m: de, parent: xe } = D,
                ne = rd(G)
              if (
                (qs(D, !1),
                he && Ag(he),
                !ne && (ft = X && X.onVnodeBeforeMount) && jo(ft, xe, G),
                qs(D, !0),
                Q && We)
              ) {
                const Le = () => {
                  ;(D.subTree = $g(D)), We(Q, D.subTree, D, ae, null)
                }
                ne
                  ? G.type.__asyncLoader().then(() => !D.isUnmounted && Le())
                  : Le()
              } else {
                const Le = (D.subTree = $g(D))
                _(null, Le, z, ie, D, ae, re), (G.el = Le.el)
              }
              if ((de && bi(de, ae), !ne && (ft = X && X.onVnodeMounted))) {
                const Le = G
                bi(() => jo(ft, xe, Le), ae)
              }
              ;(G.shapeFlag & 256 ||
                (xe && rd(xe.vnode) && xe.vnode.shapeFlag & 256)) &&
                D.a &&
                bi(D.a, ae),
                (D.isMounted = !0),
                (G = z = ie = null)
            }
          },
          $e = (D.effect = new p_(we, () => C_(Ae), D.scope)),
          Ae = (D.update = () => $e.run())
        ;(Ae.id = D.uid), qs(D, !0), Ae()
      },
      L = (D, G, z) => {
        G.component = D
        const ie = D.vnode.props
        ;(D.vnode = G),
          (D.next = null),
          uN(D, G.props, ie, z),
          fN(D, G.children, z),
          tc(),
          t2(),
          nc()
      },
      W = (D, G, z, ie, ae, re, pe, we, $e = !1) => {
        const Ae = D && D.children,
          ft = D ? D.shapeFlag : 0,
          Q = G.children,
          { patchFlag: X, shapeFlag: he } = G
        if (X > 0) {
          if (X & 128) {
            U(Ae, Q, z, ie, ae, re, pe, we, $e)
            return
          } else if (X & 256) {
            Y(Ae, Q, z, ie, ae, re, pe, we, $e)
            return
          }
        }
        he & 8
          ? (ft & 16 && me(Ae, ae, re), Q !== Ae && d(z, Q))
          : ft & 16
          ? he & 16
            ? U(Ae, Q, z, ie, ae, re, pe, we, $e)
            : me(Ae, ae, re, !0)
          : (ft & 8 && d(z, ''), he & 16 && F(Q, z, ie, ae, re, pe, we, $e))
      },
      Y = (D, G, z, ie, ae, re, pe, we, $e) => {
        ;(D = D || Au), (G = G || Au)
        const Ae = D.length,
          ft = G.length,
          Q = Math.min(Ae, ft)
        let X
        for (X = 0; X < Q; X++) {
          const he = (G[X] = $e ? gs(G[X]) : qo(G[X]))
          _(D[X], he, z, null, ae, re, pe, we, $e)
        }
        Ae > ft ? me(D, ae, re, !0, !1, Q) : F(G, z, ie, ae, re, pe, we, $e, Q)
      },
      U = (D, G, z, ie, ae, re, pe, we, $e) => {
        let Ae = 0
        const ft = G.length
        let Q = D.length - 1,
          X = ft - 1
        for (; Ae <= Q && Ae <= X; ) {
          const he = D[Ae],
            de = (G[Ae] = $e ? gs(G[Ae]) : qo(G[Ae]))
          if (al(he, de)) _(he, de, z, null, ae, re, pe, we, $e)
          else break
          Ae++
        }
        for (; Ae <= Q && Ae <= X; ) {
          const he = D[Q],
            de = (G[X] = $e ? gs(G[X]) : qo(G[X]))
          if (al(he, de)) _(he, de, z, null, ae, re, pe, we, $e)
          else break
          Q--, X--
        }
        if (Ae > Q) {
          if (Ae <= X) {
            const he = X + 1,
              de = he < ft ? G[he].el : ie
            for (; Ae <= X; )
              _(
                null,
                (G[Ae] = $e ? gs(G[Ae]) : qo(G[Ae])),
                z,
                de,
                ae,
                re,
                pe,
                we,
                $e
              ),
                Ae++
          }
        } else if (Ae > X) for (; Ae <= Q; ) q(D[Ae], ae, re, !0), Ae++
        else {
          const he = Ae,
            de = Ae,
            xe = new Map()
          for (Ae = de; Ae <= X; Ae++) {
            const Ge = (G[Ae] = $e ? gs(G[Ae]) : qo(G[Ae]))
            Ge.key != null && xe.set(Ge.key, Ae)
          }
          let ne,
            Le = 0
          const et = X - de + 1
          let Ne = !1,
            Et = 0
          const kt = new Array(et)
          for (Ae = 0; Ae < et; Ae++) kt[Ae] = 0
          for (Ae = he; Ae <= Q; Ae++) {
            const Ge = D[Ae]
            if (Le >= et) {
              q(Ge, ae, re, !0)
              continue
            }
            let Ye
            if (Ge.key != null) Ye = xe.get(Ge.key)
            else
              for (ne = de; ne <= X; ne++)
                if (kt[ne - de] === 0 && al(Ge, G[ne])) {
                  Ye = ne
                  break
                }
            Ye === void 0
              ? q(Ge, ae, re, !0)
              : ((kt[Ye - de] = Ae + 1),
                Ye >= Et ? (Et = Ye) : (Ne = !0),
                _(Ge, G[Ye], z, null, ae, re, pe, we, $e),
                Le++)
          }
          const je = Ne ? vN(kt) : Au
          for (ne = je.length - 1, Ae = et - 1; Ae >= 0; Ae--) {
            const Ge = de + Ae,
              Ye = G[Ge],
              lt = Ge + 1 < ft ? G[Ge + 1].el : ie
            kt[Ae] === 0
              ? _(null, Ye, z, lt, ae, re, pe, we, $e)
              : Ne && (ne < 0 || Ae !== je[ne] ? le(Ye, z, lt, 2) : ne--)
          }
        }
      },
      le = (D, G, z, ie, ae = null) => {
        const {
          el: re,
          type: pe,
          transition: we,
          children: $e,
          shapeFlag: Ae,
        } = D
        if (Ae & 6) {
          le(D.component.subTree, G, z, ie)
          return
        }
        if (Ae & 128) {
          D.suspense.move(G, z, ie)
          return
        }
        if (Ae & 64) {
          pe.move(D, G, z, Ve)
          return
        }
        if (pe === yt) {
          r(re, G, z)
          for (let Q = 0; Q < $e.length; Q++) le($e[Q], G, z, ie)
          r(D.anchor, G, z)
          return
        }
        if (pe === jh) {
          x(D, G, z)
          return
        }
        if (ie !== 2 && Ae & 1 && we)
          if (ie === 0)
            we.beforeEnter(re), r(re, G, z), bi(() => we.enter(re), ae)
          else {
            const { leave: Q, delayLeave: X, afterLeave: he } = we,
              de = () => r(re, G, z),
              xe = () => {
                Q(re, () => {
                  de(), he && he()
                })
              }
            X ? X(re, de, xe) : xe()
          }
        else r(re, G, z)
      },
      q = (D, G, z, ie = !1, ae = !1) => {
        const {
          type: re,
          props: pe,
          ref: we,
          children: $e,
          dynamicChildren: Ae,
          shapeFlag: ft,
          patchFlag: Q,
          dirs: X,
        } = D
        if ((we != null && fb(we, null, z, D, !0), ft & 256)) {
          G.ctx.deactivate(D)
          return
        }
        const he = ft & 1 && X,
          de = !rd(D)
        let xe
        if (
          (de && (xe = pe && pe.onVnodeBeforeUnmount) && jo(xe, G, D), ft & 6)
        )
          ue(D.component, z, ie)
        else {
          if (ft & 128) {
            D.suspense.unmount(z, ie)
            return
          }
          he && Ks(D, null, G, 'beforeUnmount'),
            ft & 64
              ? D.type.remove(D, G, z, ae, Ve, ie)
              : Ae && (re !== yt || (Q > 0 && Q & 64))
              ? me(Ae, G, z, !1, !0)
              : ((re === yt && Q & 384) || (!ae && ft & 16)) && me($e, G, z),
            ie && oe(D)
        }
        ;((de && (xe = pe && pe.onVnodeUnmounted)) || he) &&
          bi(() => {
            xe && jo(xe, G, D), he && Ks(D, null, G, 'unmounted')
          }, z)
      },
      oe = (D) => {
        const { type: G, el: z, anchor: ie, transition: ae } = D
        if (G === yt) {
          te(z, ie)
          return
        }
        if (G === jh) {
          w(D)
          return
        }
        const re = () => {
          i(z), ae && !ae.persisted && ae.afterLeave && ae.afterLeave()
        }
        if (D.shapeFlag & 1 && ae && !ae.persisted) {
          const { leave: pe, delayLeave: we } = ae,
            $e = () => pe(z, re)
          we ? we(D.el, re, $e) : $e()
        } else re()
      },
      te = (D, G) => {
        let z
        for (; D !== G; ) (z = p(D)), i(D), (D = z)
        i(G)
      },
      ue = (D, G, z) => {
        const { bum: ie, scope: ae, update: re, subTree: pe, um: we } = D
        ie && Ag(ie),
          ae.stop(),
          re && ((re.active = !1), q(pe, D, G, z)),
          we && bi(we, G),
          bi(() => {
            D.isUnmounted = !0
          }, G),
          G &&
            G.pendingBranch &&
            !G.isUnmounted &&
            D.asyncDep &&
            !D.asyncResolved &&
            D.suspenseId === G.pendingId &&
            (G.deps--, G.deps === 0 && G.resolve())
      },
      me = (D, G, z, ie = !1, ae = !1, re = 0) => {
        for (let pe = re; pe < D.length; pe++) q(D[pe], G, z, ie, ae)
      },
      Re = (D) =>
        D.shapeFlag & 6
          ? Re(D.component.subTree)
          : D.shapeFlag & 128
          ? D.suspense.next()
          : p(D.anchor || D.el),
      qe = (D, G, z) => {
        D == null
          ? G._vnode && q(G._vnode, null, null, !0)
          : _(G._vnode || null, D, G, null, null, null, z),
          t2(),
          jT(),
          (G._vnode = D)
      },
      Ve = {
        p: _,
        um: q,
        m: le,
        r: oe,
        mt: I,
        mc: F,
        pc: W,
        pbc: k,
        n: Re,
        o: e,
      }
    let nt, We
    return (
      t && ([nt, We] = t(Ve)),
      { render: qe, hydrate: nt, createApp: sN(qe, nt) }
    )
  }
  function qs({ effect: e, update: t }, n) {
    e.allowRecurse = t.allowRecurse = n
  }
  function T_(e, t, n = !1) {
    const r = e.children,
      i = t.children
    if (Yt(r) && Yt(i))
      for (let o = 0; o < r.length; o++) {
        const a = r[o]
        let s = i[o]
        s.shapeFlag & 1 &&
          !s.dynamicChildren &&
          ((s.patchFlag <= 0 || s.patchFlag === 32) &&
            ((s = i[o] = gs(i[o])), (s.el = a.el)),
          n || T_(a, s)),
          s.type === Nv && (s.el = a.el)
      }
  }
  function vN(e) {
    const t = e.slice(),
      n = [0]
    let r, i, o, a, s
    const l = e.length
    for (r = 0; r < l; r++) {
      const c = e[r]
      if (c !== 0) {
        if (((i = n[n.length - 1]), e[i] < c)) {
          ;(t[r] = i), n.push(r)
          continue
        }
        for (o = 0, a = n.length - 1; o < a; )
          (s = (o + a) >> 1), e[n[s]] < c ? (o = s + 1) : (a = s)
        c < e[n[o]] && (o > 0 && (t[r] = n[o - 1]), (n[o] = r))
      }
    }
    for (o = n.length, a = n[o - 1]; o-- > 0; ) (n[o] = a), (a = t[a])
    return n
  }
  const mN = (e) => e.__isTeleport,
    od = (e) => e && (e.disabled || e.disabled === ''),
    h2 = (e) => typeof SVGElement < 'u' && e instanceof SVGElement,
    hb = (e, t) => {
      const n = e && e.to
      return Xn(n) ? (t ? t(n) : null) : n
    },
    gN = {
      __isTeleport: !0,
      process(e, t, n, r, i, o, a, s, l, c) {
        const {
            mc: d,
            pc: h,
            pbc: p,
            o: { insert: v, querySelector: g, createText: _, createComment: b },
          } = c,
          y = od(t.props)
        let { shapeFlag: M, children: x, dynamicChildren: w } = t
        if (e == null) {
          const E = (t.el = _('')),
            P = (t.anchor = _(''))
          v(E, n, r), v(P, n, r)
          const A = (t.target = hb(t.props, g)),
            F = (t.targetAnchor = _(''))
          A && (v(F, A), (a = a || h2(A)))
          const T = (k, R) => {
            M & 16 && d(x, k, R, i, o, a, s, l)
          }
          y ? T(n, P) : A && T(A, F)
        } else {
          t.el = e.el
          const E = (t.anchor = e.anchor),
            P = (t.target = e.target),
            A = (t.targetAnchor = e.targetAnchor),
            F = od(e.props),
            T = F ? n : P,
            k = F ? E : A
          if (
            ((a = a || h2(P)),
            w
              ? (p(e.dynamicChildren, w, T, i, o, a, s), T_(e, t, !0))
              : l || h(e, t, T, k, i, o, a, s, !1),
            y)
          )
            F || ah(t, n, E, c, 1)
          else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
            const R = (t.target = hb(t.props, g))
            R && ah(t, R, null, c, 0)
          } else F && ah(t, P, A, c, 1)
        }
        d4(t)
      },
      remove(e, t, n, r, { um: i, o: { remove: o } }, a) {
        const {
          shapeFlag: s,
          children: l,
          anchor: c,
          targetAnchor: d,
          target: h,
          props: p,
        } = e
        if ((h && o(d), (a || !od(p)) && (o(c), s & 16)))
          for (let v = 0; v < l.length; v++) {
            const g = l[v]
            i(g, t, n, !0, !!g.dynamicChildren)
          }
      },
      move: ah,
      hydrate: yN,
    }
  function ah(e, t, n, { o: { insert: r }, m: i }, o = 2) {
    o === 0 && r(e.targetAnchor, t, n)
    const { el: a, anchor: s, shapeFlag: l, children: c, props: d } = e,
      h = o === 2
    if ((h && r(a, t, n), (!h || od(d)) && l & 16))
      for (let p = 0; p < c.length; p++) i(c[p], t, n, 2)
    h && r(s, t, n)
  }
  function yN(
    e,
    t,
    n,
    r,
    i,
    o,
    { o: { nextSibling: a, parentNode: s, querySelector: l } },
    c
  ) {
    const d = (t.target = hb(t.props, l))
    if (d) {
      const h = d._lpa || d.firstChild
      if (t.shapeFlag & 16)
        if (od(t.props))
          (t.anchor = c(a(e), t, s(e), n, r, i, o)), (t.targetAnchor = h)
        else {
          t.anchor = a(e)
          let p = h
          for (; p; )
            if (
              ((p = a(p)),
              p && p.nodeType === 8 && p.data === 'teleport anchor')
            ) {
              ;(t.targetAnchor = p),
                (d._lpa = t.targetAnchor && a(t.targetAnchor))
              break
            }
          c(h, t, d, n, r, i, o)
        }
      d4(t)
    }
    return t.anchor && a(t.anchor)
  }
  const Dv = gN
  function d4(e) {
    const t = e.ctx
    if (t && t.ut) {
      let n = e.children[0].el
      for (; n !== e.targetAnchor; )
        n.nodeType === 1 && n.setAttribute('data-v-owner', t.uid),
          (n = n.nextSibling)
      t.ut()
    }
  }
  const yt = Symbol.for('v-fgt'),
    Nv = Symbol.for('v-txt'),
    Fi = Symbol.for('v-cmt'),
    jh = Symbol.for('v-stc'),
    ad = []
  let Ao = null
  function O(e = !1) {
    ad.push((Ao = e ? null : []))
  }
  function bN() {
    ad.pop(), (Ao = ad[ad.length - 1] || null)
  }
  let $d = 1
  function p2(e) {
    $d += e
  }
  function f4(e) {
    return (
      (e.dynamicChildren = $d > 0 ? Ao || Au : null),
      bN(),
      $d > 0 && Ao && Ao.push(e),
      e
    )
  }
  function Z(e, t, n, r, i, o) {
    return f4(Se(e, t, n, r, i, o, !0))
  }
  function Ee(e, t, n, r, i) {
    return f4(m(e, t, n, r, i, !0))
  }
  function An(e) {
    return e ? e.__v_isVNode === !0 : !1
  }
  function al(e, t) {
    return e.type === t.type && e.key === t.key
  }
  const Bv = '__vInternal',
    h4 = ({ key: e }) => e ?? null,
    Gh = ({ ref: e, ref_key: t, ref_for: n }) => (
      typeof e == 'number' && (e = '' + e),
      e != null
        ? Xn(e) || lr(e) || en(e)
          ? { i: Dr, r: e, k: t, f: !!n }
          : e
        : null
    )
  function Se(
    e,
    t = null,
    n = null,
    r = 0,
    i = null,
    o = e === yt ? 0 : 1,
    a = !1,
    s = !1
  ) {
    const l = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e,
      props: t,
      key: t && h4(t),
      ref: t && Gh(t),
      scopeId: qT,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: o,
      patchFlag: r,
      dynamicProps: i,
      dynamicChildren: null,
      appContext: null,
      ctx: Dr,
    }
    return (
      s
        ? (k_(l, n), o & 128 && e.normalize(l))
        : n && (l.shapeFlag |= Xn(n) ? 8 : 16),
      $d > 0 &&
        !a &&
        Ao &&
        (l.patchFlag > 0 || o & 6) &&
        l.patchFlag !== 32 &&
        Ao.push(l),
      l
    )
  }
  const m = _N
  function _N(e, t = null, n = null, r = 0, i = null, o = !1) {
    if (((!e || e === t4) && (e = Fi), An(e))) {
      const s = Ti(e, t, !0)
      return (
        n && k_(s, n),
        $d > 0 &&
          !o &&
          Ao &&
          (s.shapeFlag & 6 ? (Ao[Ao.indexOf(e)] = s) : Ao.push(s)),
        (s.patchFlag |= -2),
        s
      )
    }
    if ((AN(e) && (e = e.__vccOpts), t)) {
      t = Rr(t)
      let { class: s, style: l } = t
      s && !Xn(s) && (t.class = H(s)),
        Bn(l) && (RT(l) && !Yt(l) && (l = rr({}, l)), (t.style = at(l)))
    }
    const a = Xn(e) ? 1 : VD(e) ? 128 : mN(e) ? 64 : Bn(e) ? 4 : en(e) ? 2 : 0
    return Se(e, t, n, r, i, a, o, !0)
  }
  function Rr(e) {
    return e ? (RT(e) || Bv in e ? rr({}, e) : e) : null
  }
  function Ti(e, t, n = !1) {
    const { props: r, ref: i, patchFlag: o, children: a } = e,
      s = t ? Fe(r || {}, t) : r
    return {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: s,
      key: s && h4(s),
      ref:
        t && t.ref
          ? n && i
            ? Yt(i)
              ? i.concat(Gh(t))
              : [i, Gh(t)]
            : Gh(t)
          : i,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: a,
      target: e.target,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== yt ? (o === -1 ? 16 : o | 16) : o,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: e.transition,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && Ti(e.ssContent),
      ssFallback: e.ssFallback && Ti(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce,
    }
  }
  function Lt(e = ' ', t = 0) {
    return m(Nv, null, e, t)
  }
  function SN(e, t) {
    const n = m(jh, null, e)
    return (n.staticCount = t), n
  }
  function Ce(e = '', t = !1) {
    return t ? (O(), Ee(Fi, null, e)) : m(Fi, null, e)
  }
  function qo(e) {
    return e == null || typeof e == 'boolean'
      ? m(Fi)
      : Yt(e)
      ? m(yt, null, e.slice())
      : typeof e == 'object'
      ? gs(e)
      : m(Nv, null, String(e))
  }
  function gs(e) {
    return (e.el === null && e.patchFlag !== -1) || e.memo ? e : Ti(e)
  }
  function k_(e, t) {
    let n = 0
    const { shapeFlag: r } = e
    if (t == null) t = null
    else if (Yt(t)) n = 16
    else if (typeof t == 'object')
      if (r & 65) {
        const i = t.default
        i && (i._c && (i._d = !1), k_(e, i()), i._c && (i._d = !0))
        return
      } else {
        n = 32
        const i = t._
        !i && !(Bv in t)
          ? (t._ctx = Dr)
          : i === 3 &&
            Dr &&
            (Dr.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
      }
    else
      en(t)
        ? ((t = { default: t, _ctx: Dr }), (n = 32))
        : ((t = String(t)), r & 64 ? ((n = 16), (t = [Lt(t)])) : (n = 8))
    ;(e.children = t), (e.shapeFlag |= n)
  }
  function Fe(...e) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const r = e[n]
      for (const i in r)
        if (i === 'class')
          t.class !== r.class && (t.class = H([t.class, r.class]))
        else if (i === 'style') t.style = at([t.style, r.style])
        else if (Pv(i)) {
          const o = t[i],
            a = r[i]
          a &&
            o !== a &&
            !(Yt(o) && o.includes(a)) &&
            (t[i] = o ? [].concat(o, a) : a)
        } else i !== '' && (t[i] = r[i])
    }
    return t
  }
  function jo(e, t, n, r = null) {
    no(e, t, 7, [n, r])
  }
  const CN = o4()
  let wN = 0
  function xN(e, t, n) {
    const r = e.type,
      i = (t ? t.appContext : e.appContext) || CN,
      o = {
        uid: wN++,
        vnode: e,
        type: r,
        parent: t,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new q8(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(i.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: s4(r, i),
        emitsOptions: KT(r, i),
        emit: null,
        emitted: null,
        propsDefaults: zn,
        inheritAttrs: r.inheritAttrs,
        ctx: zn,
        data: zn,
        props: zn,
        attrs: zn,
        slots: zn,
        refs: zn,
        setupState: zn,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null,
      }
    return (
      (o.ctx = { _: o }),
      (o.root = t ? t.root : o),
      (o.emit = DD.bind(null, o)),
      e.ce && e.ce(o),
      o
    )
  }
  let Cr = null
  const Jr = () => Cr || Dr
  let A_,
    nu,
    v2 = '__VUE_INSTANCE_SETTERS__'
  ;(nu = rb()[v2]) || (nu = rb()[v2] = []),
    nu.push((e) => (Cr = e)),
    (A_ = (e) => {
      nu.length > 1 ? nu.forEach((t) => t(e)) : nu[0](e)
    })
  const Wu = (e) => {
      A_(e), e.scope.on()
    },
    hl = () => {
      Cr && Cr.scope.off(), A_(null)
    }
  function p4(e) {
    return e.vnode.shapeFlag & 4
  }
  let Od = !1
  function MN(e, t = !1) {
    Od = t
    const { props: n, children: r } = e.vnode,
      i = p4(e)
    lN(e, n, i, t), dN(e, r)
    const o = i ? EN(e, t) : void 0
    return (Od = !1), o
  }
  function EN(e, t) {
    const n = e.type
    ;(e.accessCache = Object.create(null)), (e.proxy = DT(new Proxy(e.ctx, eN)))
    const { setup: r } = n
    if (r) {
      const i = (e.setupContext = r.length > 1 ? TN(e) : null)
      Wu(e), tc()
      const o = xs(r, e, 0, [e.props, i])
      if ((nc(), hl(), _T(o))) {
        if ((o.then(hl, hl), t))
          return o
            .then((a) => {
              m2(e, a, t)
            })
            .catch((a) => {
              Ov(a, e, 0)
            })
        e.asyncDep = o
      } else m2(e, o, t)
    } else v4(e, t)
  }
  function m2(e, t, n) {
    en(t)
      ? e.type.__ssrInlineRender
        ? (e.ssrRender = t)
        : (e.render = t)
      : Bn(t) && (e.setupState = VT(t)),
      v4(e, n)
  }
  let g2
  function v4(e, t, n) {
    const r = e.type
    if (!e.render) {
      if (!t && g2 && !r.render) {
        const i = r.template || E_(e).template
        if (i) {
          const { isCustomElement: o, compilerOptions: a } =
              e.appContext.config,
            { delimiters: s, compilerOptions: l } = r,
            c = rr(rr({ isCustomElement: o, delimiters: s }, a), l)
          r.render = g2(i, c)
        }
      }
      e.render = r.render || Oo
    }
    Wu(e), tc(), tN(e), nc(), hl()
  }
  function PN(e) {
    return (
      e.attrsProxy ||
      (e.attrsProxy = new Proxy(e.attrs, {
        get(t, n) {
          return Pi(e, 'get', '$attrs'), t[n]
        },
      }))
    )
  }
  function TN(e) {
    const t = (n) => {
      e.exposed = n || {}
    }
    return {
      get attrs() {
        return PN(e)
      },
      slots: e.slots,
      emit: e.emit,
      expose: t,
    }
  }
  function Fv(e) {
    if (e.exposed)
      return (
        e.exposeProxy ||
        (e.exposeProxy = new Proxy(VT(DT(e.exposed)), {
          get(t, n) {
            if (n in t) return t[n]
            if (n in id) return id[n](e)
          },
          has(t, n) {
            return n in t || n in id
          },
        }))
      )
  }
  function kN(e, t = !0) {
    return en(e) ? e.displayName || e.name : e.name || (t && e.__name)
  }
  function AN(e) {
    return en(e) && '__vccOpts' in e
  }
  const C = (e, t) => AD(e, t, Od)
  function _i(e, t, n) {
    const r = arguments.length
    return r === 2
      ? Bn(t) && !Yt(t)
        ? An(t)
          ? m(e, null, [t])
          : m(e, t)
        : m(e, null, t)
      : (r > 3
          ? (n = Array.prototype.slice.call(arguments, 2))
          : r === 3 && An(n) && (n = [n]),
        m(e, t, n))
  }
  const $N = Symbol.for('v-scx'),
    ON = () => zt($N),
    LN = '3.3.4',
    IN = 'http://www.w3.org/2000/svg',
    sl = typeof document < 'u' ? document : null,
    y2 = sl && sl.createElement('template'),
    RN = {
      insert: (e, t, n) => {
        t.insertBefore(e, n || null)
      },
      remove: (e) => {
        const t = e.parentNode
        t && t.removeChild(e)
      },
      createElement: (e, t, n, r) => {
        const i = t
          ? sl.createElementNS(IN, e)
          : sl.createElement(e, n ? { is: n } : void 0)
        return (
          e === 'select' &&
            r &&
            r.multiple != null &&
            i.setAttribute('multiple', r.multiple),
          i
        )
      },
      createText: (e) => sl.createTextNode(e),
      createComment: (e) => sl.createComment(e),
      setText: (e, t) => {
        e.nodeValue = t
      },
      setElementText: (e, t) => {
        e.textContent = t
      },
      parentNode: (e) => e.parentNode,
      nextSibling: (e) => e.nextSibling,
      querySelector: (e) => sl.querySelector(e),
      setScopeId(e, t) {
        e.setAttribute(t, '')
      },
      insertStaticContent(e, t, n, r, i, o) {
        const a = n ? n.previousSibling : t.lastChild
        if (i && (i === o || i.nextSibling))
          for (
            ;
            t.insertBefore(i.cloneNode(!0), n),
              !(i === o || !(i = i.nextSibling));

          );
        else {
          y2.innerHTML = r ? `<svg>${e}</svg>` : e
          const s = y2.content
          if (r) {
            const l = s.firstChild
            for (; l.firstChild; ) s.appendChild(l.firstChild)
            s.removeChild(l)
          }
          t.insertBefore(s, n)
        }
        return [
          a ? a.nextSibling : t.firstChild,
          n ? n.previousSibling : t.lastChild,
        ]
      },
    }
  function DN(e, t, n) {
    const r = e._vtc
    r && (t = (t ? [t, ...r] : [...r]).join(' ')),
      t == null
        ? e.removeAttribute('class')
        : n
        ? e.setAttribute('class', t)
        : (e.className = t)
  }
  function NN(e, t, n) {
    const r = e.style,
      i = Xn(n)
    if (n && !i) {
      if (t && !Xn(t)) for (const o in t) n[o] == null && pb(r, o, '')
      for (const o in n) pb(r, o, n[o])
    } else {
      const o = r.display
      i ? t !== n && (r.cssText = n) : t && e.removeAttribute('style'),
        '_vod' in e && (r.display = o)
    }
  }
  const b2 = /\s*!important$/
  function pb(e, t, n) {
    if (Yt(n)) n.forEach((r) => pb(e, t, r))
    else if ((n == null && (n = ''), t.startsWith('--'))) e.setProperty(t, n)
    else {
      const r = BN(e, t)
      b2.test(n)
        ? e.setProperty(kl(r), n.replace(b2, ''), 'important')
        : (e[r] = n)
    }
  }
  const _2 = ['Webkit', 'Moz', 'ms'],
    Ig = {}
  function BN(e, t) {
    const n = Ig[t]
    if (n) return n
    let r = na(t)
    if (r !== 'filter' && r in e) return (Ig[t] = r)
    r = Av(r)
    for (let i = 0; i < _2.length; i++) {
      const o = _2[i] + r
      if (o in e) return (Ig[t] = o)
    }
    return t
  }
  const S2 = 'http://www.w3.org/1999/xlink'
  function FN(e, t, n, r, i) {
    if (r && t.startsWith('xlink:'))
      n == null
        ? e.removeAttributeNS(S2, t.slice(6, t.length))
        : e.setAttributeNS(S2, t, n)
    else {
      const o = K8(t)
      n == null || (o && !wT(n))
        ? e.removeAttribute(t)
        : e.setAttribute(t, o ? '' : n)
    }
  }
  function zN(e, t, n, r, i, o, a) {
    if (t === 'innerHTML' || t === 'textContent') {
      r && a(r, i, o), (e[t] = n ?? '')
      return
    }
    const s = e.tagName
    if (t === 'value' && s !== 'PROGRESS' && !s.includes('-')) {
      e._value = n
      const c = s === 'OPTION' ? e.getAttribute('value') : e.value,
        d = n ?? ''
      c !== d && (e.value = d), n == null && e.removeAttribute(t)
      return
    }
    let l = !1
    if (n === '' || n == null) {
      const c = typeof e[t]
      c === 'boolean'
        ? (n = wT(n))
        : n == null && c === 'string'
        ? ((n = ''), (l = !0))
        : c === 'number' && ((n = 0), (l = !0))
    }
    try {
      e[t] = n
    } catch {}
    l && e.removeAttribute(t)
  }
  function VN(e, t, n, r) {
    e.addEventListener(t, n, r)
  }
  function UN(e, t, n, r) {
    e.removeEventListener(t, n, r)
  }
  function HN(e, t, n, r, i = null) {
    const o = e._vei || (e._vei = {}),
      a = o[t]
    if (r && a) a.value = r
    else {
      const [s, l] = WN(t)
      if (r) {
        const c = (o[t] = KN(r, i))
        VN(e, s, c, l)
      } else a && (UN(e, s, a, l), (o[t] = void 0))
    }
  }
  const C2 = /(?:Once|Passive|Capture)$/
  function WN(e) {
    let t
    if (C2.test(e)) {
      t = {}
      let r
      for (; (r = e.match(C2)); )
        (e = e.slice(0, e.length - r[0].length)), (t[r[0].toLowerCase()] = !0)
    }
    return [e[2] === ':' ? e.slice(3) : kl(e.slice(2)), t]
  }
  let Rg = 0
  const jN = Promise.resolve(),
    GN = () => Rg || (jN.then(() => (Rg = 0)), (Rg = Date.now()))
  function KN(e, t) {
    const n = (r) => {
      if (!r._vts) r._vts = Date.now()
      else if (r._vts <= n.attached) return
      no(qN(r, n.value), t, 5, [r])
    }
    return (n.value = e), (n.attached = GN()), n
  }
  function qN(e, t) {
    if (Yt(t)) {
      const n = e.stopImmediatePropagation
      return (
        (e.stopImmediatePropagation = () => {
          n.call(e), (e._stopped = !0)
        }),
        t.map((r) => (i) => !i._stopped && r && r(i))
      )
    } else return t
  }
  const w2 = /^on[a-z]/,
    XN = (e, t, n, r, i = !1, o, a, s, l) => {
      t === 'class'
        ? DN(e, r, i)
        : t === 'style'
        ? NN(e, n, r)
        : Pv(t)
        ? u_(t) || HN(e, t, n, r, a)
        : (
            t[0] === '.'
              ? ((t = t.slice(1)), !0)
              : t[0] === '^'
              ? ((t = t.slice(1)), !1)
              : YN(e, t, r, i)
          )
        ? zN(e, t, r, o, a, s, l)
        : (t === 'true-value'
            ? (e._trueValue = r)
            : t === 'false-value' && (e._falseValue = r),
          FN(e, t, r, i))
    }
  function YN(e, t, n, r) {
    return r
      ? !!(
          t === 'innerHTML' ||
          t === 'textContent' ||
          (t in e && w2.test(t) && en(n))
        )
      : t === 'spellcheck' ||
        t === 'draggable' ||
        t === 'translate' ||
        t === 'form' ||
        (t === 'list' && e.tagName === 'INPUT') ||
        (t === 'type' && e.tagName === 'TEXTAREA') ||
        (w2.test(t) && Xn(n))
      ? !1
      : t in e
  }
  const ls = 'transition',
    Vc = 'animation',
    Fr = (e, { slots: t }) => _i(jD, g4(e), t)
  Fr.displayName = 'Transition'
  const m4 = {
      name: String,
      type: String,
      css: { type: Boolean, default: !0 },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String,
    },
    ZN = (Fr.props = rr({}, ZT, m4)),
    Xs = (e, t = []) => {
      Yt(e) ? e.forEach((n) => n(...t)) : e && e(...t)
    },
    x2 = (e) => (e ? (Yt(e) ? e.some((t) => t.length > 1) : e.length > 1) : !1)
  function g4(e) {
    const t = {}
    for (const j in e) j in m4 || (t[j] = e[j])
    if (e.css === !1) return t
    const {
        name: n = 'v',
        type: r,
        duration: i,
        enterFromClass: o = `${n}-enter-from`,
        enterActiveClass: a = `${n}-enter-active`,
        enterToClass: s = `${n}-enter-to`,
        appearFromClass: l = o,
        appearActiveClass: c = a,
        appearToClass: d = s,
        leaveFromClass: h = `${n}-leave-from`,
        leaveActiveClass: p = `${n}-leave-active`,
        leaveToClass: v = `${n}-leave-to`,
      } = e,
      g = JN(i),
      _ = g && g[0],
      b = g && g[1],
      {
        onBeforeEnter: y,
        onEnter: M,
        onEnterCancelled: x,
        onLeave: w,
        onLeaveCancelled: E,
        onBeforeAppear: P = y,
        onAppear: A = M,
        onAppearCancelled: F = x,
      } = t,
      T = (j, N, I) => {
        vs(j, N ? d : s), vs(j, N ? c : a), I && I()
      },
      k = (j, N) => {
        ;(j._isLeaving = !1), vs(j, h), vs(j, v), vs(j, p), N && N()
      },
      R = (j) => (N, I) => {
        const B = j ? A : M,
          V = () => T(N, j, I)
        Xs(B, [N, V]),
          M2(() => {
            vs(N, j ? l : o), Ta(N, j ? d : s), x2(B) || E2(N, r, _, V)
          })
      }
    return rr(t, {
      onBeforeEnter(j) {
        Xs(y, [j]), Ta(j, o), Ta(j, a)
      },
      onBeforeAppear(j) {
        Xs(P, [j]), Ta(j, l), Ta(j, c)
      },
      onEnter: R(!1),
      onAppear: R(!0),
      onLeave(j, N) {
        j._isLeaving = !0
        const I = () => k(j, N)
        Ta(j, h),
          b4(),
          Ta(j, p),
          M2(() => {
            j._isLeaving && (vs(j, h), Ta(j, v), x2(w) || E2(j, r, b, I))
          }),
          Xs(w, [j, I])
      },
      onEnterCancelled(j) {
        T(j, !1), Xs(x, [j])
      },
      onAppearCancelled(j) {
        T(j, !0), Xs(F, [j])
      },
      onLeaveCancelled(j) {
        k(j), Xs(E, [j])
      },
    })
  }
  function JN(e) {
    if (e == null) return null
    if (Bn(e)) return [Dg(e.enter), Dg(e.leave)]
    {
      const t = Dg(e)
      return [t, t]
    }
  }
  function Dg(e) {
    return V8(e)
  }
  function Ta(e, t) {
    t.split(/\s+/).forEach((n) => n && e.classList.add(n)),
      (e._vtc || (e._vtc = new Set())).add(t)
  }
  function vs(e, t) {
    t.split(/\s+/).forEach((r) => r && e.classList.remove(r))
    const { _vtc: n } = e
    n && (n.delete(t), n.size || (e._vtc = void 0))
  }
  function M2(e) {
    requestAnimationFrame(() => {
      requestAnimationFrame(e)
    })
  }
  let QN = 0
  function E2(e, t, n, r) {
    const i = (e._endId = ++QN),
      o = () => {
        i === e._endId && r()
      }
    if (n) return setTimeout(o, n)
    const { type: a, timeout: s, propCount: l } = y4(e, t)
    if (!a) return r()
    const c = a + 'end'
    let d = 0
    const h = () => {
        e.removeEventListener(c, p), o()
      },
      p = (v) => {
        v.target === e && ++d >= l && h()
      }
    setTimeout(() => {
      d < l && h()
    }, s + 1),
      e.addEventListener(c, p)
  }
  function y4(e, t) {
    const n = window.getComputedStyle(e),
      r = (g) => (n[g] || '').split(', '),
      i = r(`${ls}Delay`),
      o = r(`${ls}Duration`),
      a = P2(i, o),
      s = r(`${Vc}Delay`),
      l = r(`${Vc}Duration`),
      c = P2(s, l)
    let d = null,
      h = 0,
      p = 0
    t === ls
      ? a > 0 && ((d = ls), (h = a), (p = o.length))
      : t === Vc
      ? c > 0 && ((d = Vc), (h = c), (p = l.length))
      : ((h = Math.max(a, c)),
        (d = h > 0 ? (a > c ? ls : Vc) : null),
        (p = d ? (d === ls ? o.length : l.length) : 0))
    const v =
      d === ls && /\b(transform|all)(,|$)/.test(r(`${ls}Property`).toString())
    return { type: d, timeout: h, propCount: p, hasTransform: v }
  }
  function P2(e, t) {
    for (; e.length < t.length; ) e = e.concat(e)
    return Math.max(...t.map((n, r) => T2(n) + T2(e[r])))
  }
  function T2(e) {
    return Number(e.slice(0, -1).replace(',', '.')) * 1e3
  }
  function b4() {
    return document.body.offsetHeight
  }
  const _4 = new WeakMap(),
    S4 = new WeakMap(),
    C4 = {
      name: 'TransitionGroup',
      props: rr({}, ZN, { tag: String, moveClass: String }),
      setup(e, { slots: t }) {
        const n = Jr(),
          r = YT()
        let i, o
        return (
          Zr(() => {
            if (!i.length) return
            const a = e.moveClass || `${e.name || 'v'}-move`
            if (!iB(i[0].el, n.vnode.el, a)) return
            i.forEach(tB), i.forEach(nB)
            const s = i.filter(rB)
            b4(),
              s.forEach((l) => {
                const c = l.el,
                  d = c.style
                Ta(c, a),
                  (d.transform = d.webkitTransform = d.transitionDuration = '')
                const h = (c._moveCb = (p) => {
                  ;(p && p.target !== c) ||
                    ((!p || /transform$/.test(p.propertyName)) &&
                      (c.removeEventListener('transitionend', h),
                      (c._moveCb = null),
                      vs(c, a)))
                })
                c.addEventListener('transitionend', h)
              })
          }),
          () => {
            const a = gn(e),
              s = g4(a)
            let l = a.tag || yt
            ;(i = o), (o = t.default ? x_(t.default()) : [])
            for (let c = 0; c < o.length; c++) {
              const d = o[c]
              d.key != null && Ad(d, kd(d, s, r, n))
            }
            if (i)
              for (let c = 0; c < i.length; c++) {
                const d = i[c]
                Ad(d, kd(d, s, r, n)), _4.set(d, d.el.getBoundingClientRect())
              }
            return m(l, null, o)
          }
        )
      },
    },
    eB = (e) => delete e.mode
  C4.props
  const jd = C4
  function tB(e) {
    const t = e.el
    t._moveCb && t._moveCb(), t._enterCb && t._enterCb()
  }
  function nB(e) {
    S4.set(e, e.el.getBoundingClientRect())
  }
  function rB(e) {
    const t = _4.get(e),
      n = S4.get(e),
      r = t.left - n.left,
      i = t.top - n.top
    if (r || i) {
      const o = e.el.style
      return (
        (o.transform = o.webkitTransform = `translate(${r}px,${i}px)`),
        (o.transitionDuration = '0s'),
        e
      )
    }
  }
  function iB(e, t, n) {
    const r = e.cloneNode()
    e._vtc &&
      e._vtc.forEach((a) => {
        a.split(/\s+/).forEach((s) => s && r.classList.remove(s))
      }),
      n.split(/\s+/).forEach((a) => a && r.classList.add(a)),
      (r.style.display = 'none')
    const i = t.nodeType === 1 ? t : t.parentNode
    i.appendChild(r)
    const { hasTransform: o } = y4(r)
    return i.removeChild(r), o
  }
  const oB = ['ctrl', 'shift', 'alt', 'meta'],
    aB = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => 'button' in e && e.button !== 0,
      middle: (e) => 'button' in e && e.button !== 1,
      right: (e) => 'button' in e && e.button !== 2,
      exact: (e, t) => oB.some((n) => e[`${n}Key`] && !t.includes(n)),
    },
    io =
      (e, t) =>
      (n, ...r) => {
        for (let i = 0; i < t.length; i++) {
          const o = aB[t[i]]
          if (o && o(n, t)) return
        }
        return e(n, ...r)
      },
    sB = {
      esc: 'escape',
      space: ' ',
      up: 'arrow-up',
      left: 'arrow-left',
      right: 'arrow-right',
      down: 'arrow-down',
      delete: 'backspace',
    },
    xu = (e, t) => (n) => {
      if (!('key' in n)) return
      const r = kl(n.key)
      if (t.some((i) => i === r || sB[i] === r)) return e(n)
    },
    oo = {
      beforeMount(e, { value: t }, { transition: n }) {
        ;(e._vod = e.style.display === 'none' ? '' : e.style.display),
          n && t ? n.beforeEnter(e) : Uc(e, t)
      },
      mounted(e, { value: t }, { transition: n }) {
        n && t && n.enter(e)
      },
      updated(e, { value: t, oldValue: n }, { transition: r }) {
        !t != !n &&
          (r
            ? t
              ? (r.beforeEnter(e), Uc(e, !0), r.enter(e))
              : r.leave(e, () => {
                  Uc(e, !1)
                })
            : Uc(e, t))
      },
      beforeUnmount(e, { value: t }) {
        Uc(e, t)
      },
    }
  function Uc(e, t) {
    e.style.display = t ? e._vod : 'none'
  }
  const lB = rr({ patchProp: XN }, RN)
  let k2
  function w4() {
    return k2 || (k2 = hN(lB))
  }
  const Ua = (...e) => {
      w4().render(...e)
    },
    $_ = (...e) => {
      const t = w4().createApp(...e),
        { mount: n } = t
      return (
        (t.mount = (r) => {
          const i = uB(r)
          if (!i) return
          const o = t._component
          !en(o) && !o.render && !o.template && (o.template = i.innerHTML),
            (i.innerHTML = '')
          const a = n(i, !1, i instanceof SVGElement)
          return (
            i instanceof Element &&
              (i.removeAttribute('v-cloak'), i.setAttribute('data-v-app', '')),
            a
          )
        }),
        t
      )
    }
  function uB(e) {
    return Xn(e) ? document.querySelector(e) : e
  }
  const Al = Object.prototype.toString
  function Ft(e) {
    return Al.call(e) === '[object Array]'
  }
  function fi(e) {
    return Al.call(e) === '[object Null]'
  }
  function Ui(e) {
    return Al.call(e) === '[object Boolean]'
  }
  function Ht(e) {
    return Al.call(e) === '[object Object]'
  }
  const xl = (e) => Al.call(e) === '[object Promise]'
  function ir(e) {
    return Al.call(e) === '[object String]'
  }
  function it(e) {
    return Al.call(e) === '[object Number]' && e === e
  }
  function Mt(e) {
    return e === void 0
  }
  function xt(e) {
    return typeof e == 'function'
  }
  function cB(e) {
    return Ht(e) && Object.keys(e).length === 0
  }
  function Kh(e) {
    return e === window
  }
  const x4 = (e) => (e == null ? void 0 : e.$) !== void 0,
    dB = (e) => /\[Q]Q/.test(e)
  function ao(e) {
    return (
      Ht(e) &&
      '$y' in e &&
      '$M' in e &&
      '$D' in e &&
      '$d' in e &&
      '$H' in e &&
      '$m' in e &&
      '$s' in e
    )
  }
  const di = Symbol('ArcoConfigProvider'),
    sh = {
      formatYear: 'YYYY ',
      formatMonth: 'YYYY  MM ',
      today: '',
      view: { month: '', year: '', week: '', day: '' },
      month: {
        long: {
          January: '',
          February: '',
          March: '',
          April: '',
          May: '',
          June: '',
          July: '',
          August: '',
          September: '',
          October: '',
          November: '',
          December: '',
        },
        short: {
          January: '',
          February: '',
          March: '',
          April: '',
          May: '',
          June: '',
          July: '',
          August: '',
          September: '',
          October: '',
          November: '',
          December: '',
        },
      },
      week: {
        long: {
          self: '',
          monday: '',
          tuesday: '',
          wednesday: '',
          thursday: '',
          friday: '',
          saturday: '',
          sunday: '',
        },
        short: {
          self: '',
          monday: '',
          tuesday: '',
          wednesday: '',
          thursday: '',
          friday: '',
          saturday: '',
          sunday: '',
        },
      },
    },
    fB = {
      locale: 'zh-CN',
      empty: { description: '' },
      drawer: { okText: '', cancelText: '' },
      popconfirm: { okText: '', cancelText: '' },
      modal: { okText: '', cancelText: '' },
      pagination: {
        goto: '',
        page: '',
        countPerPage: '/',
        total: ' {0} ',
      },
      table: { okText: '', resetText: '' },
      upload: {
        start: '',
        cancel: '',
        delete: '',
        retry: '',
        buttonText: '',
        preview: '',
        drag: '',
        dragHover: '',
        error: '',
      },
      calendar: sh,
      datePicker: {
        view: sh.view,
        month: sh.month,
        week: sh.week,
        placeholder: {
          date: '',
          week: '',
          month: '',
          year: '',
          quarter: '',
          time: '',
        },
        rangePlaceholder: {
          date: ['', ''],
          week: ['', ''],
          month: ['', ''],
          year: ['', ''],
          quarter: ['', ''],
          time: ['', ''],
        },
        selectTime: '',
        today: '',
        now: '',
        ok: '',
      },
      image: { loading: '' },
      imagePreview: {
        fullScreen: '',
        rotateRight: '',
        rotateLeft: '',
        zoomIn: '',
        zoomOut: '',
        originalSize: '',
      },
      typography: {
        copied: '',
        copy: '',
        expand: '',
        collapse: '',
        edit: '',
      },
      form: {
        validateMessages: {
          required: '#{field} ',
          type: {
            string: '#{field} ',
            number: '#{field} ',
            boolean: '#{field} ',
            array: '#{field} ',
            object: '#{field} ',
            url: '#{field}  url ',
            email: '#{field} ',
            ip: '#{field}  IP ',
          },
          number: {
            min: '`#{value}`  `#{min}`',
            max: '`#{value}`  `#{max}`',
            equal: '`#{value}`  `#{equal}`',
            range: '`#{value}`  `#{min} ~ #{max}` ',
            positive: '`#{value}` ',
            negative: '`#{value}` ',
          },
          array: {
            length: '`#{field}`  #{length}',
            minLength: '`#{field}`  #{minLength}',
            maxLength: '`#{field}`  #{maxLength}',
            includes: '#{field}  #{includes}',
            deepEqual: '#{field}  #{deepEqual}',
            empty: '`#{field}` ',
          },
          string: {
            minLength: ' #{minLength}',
            maxLength: ' #{maxLength}',
            length: ' #{length}',
            match: '`#{value}`  #{pattern}',
            uppercase: '`#{value}` ',
            lowercase: '`#{value}` ',
          },
          object: {
            deepEqual: '`#{field}` ',
            hasKeys: '`#{field}` ',
            empty: '`#{field}` ',
          },
          boolean: { true: ' `true`', false: ' `false`' },
        },
      },
    },
    O_ = J('zh-CN'),
    nv = Je({ 'zh-CN': fB }),
    hB = (e, t) => {
      for (const n of Object.keys(e))
        (!nv[n] || (t != null && t.overwrite)) && (nv[n] = e[n])
    },
    pB = (e) => {
      if (!nv[e]) {
        console.warn(`use ${e} failed! Please add ${e} first`)
        return
      }
      O_.value = e
    },
    vB = () => O_.value,
    Vn = () => {
      const e = zt(di, void 0),
        t = C(() => {
          var i
          return (i = e == null ? void 0 : e.locale) != null ? i : nv[O_.value]
        }),
        n = C(() => t.value.locale)
      return {
        i18nMessage: t,
        locale: n,
        t: (i, ...o) => {
          const a = i.split('.')
          let s = t.value
          for (const l of a) {
            if (!s[l]) return i
            s = s[l]
          }
          return ir(s) && o.length > 0
            ? s.replace(/{(\d+)}/g, (l, c) => {
                var d
                return (d = o[c]) != null ? d : l
              })
            : s
        },
      }
    }
  var mB = Object.defineProperty,
    gB = Object.defineProperties,
    yB = Object.getOwnPropertyDescriptors,
    A2 = Object.getOwnPropertySymbols,
    bB = Object.prototype.hasOwnProperty,
    _B = Object.prototype.propertyIsEnumerable,
    $2 = (e, t, n) =>
      t in e
        ? mB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    SB = (e, t) => {
      for (var n in t || (t = {})) bB.call(t, n) && $2(e, n, t[n])
      if (A2) for (var n of A2(t)) _B.call(t, n) && $2(e, n, t[n])
      return e
    },
    CB = (e, t) => gB(e, yB(t))
  const wB = 'A',
    xB = 'arco',
    vb = '$arco',
    It = (e) => {
      var t
      return (t = e == null ? void 0 : e.componentPrefix) != null ? t : wB
    },
    Rt = (e, t) => {
      var n
      t &&
        t.classPrefix &&
        (e.config.globalProperties[vb] = CB(
          SB({}, (n = e.config.globalProperties[vb]) != null ? n : {}),
          { classPrefix: t.classPrefix }
        ))
    },
    ye = (e) => {
      var t, n, r
      const i = Jr(),
        o = zt(di, void 0),
        a =
          (r =
            (n = o == null ? void 0 : o.prefixCls) != null
              ? n
              : (t =
                  i == null
                    ? void 0
                    : i.appContext.config.globalProperties[vb]) == null
              ? void 0
              : t.classPrefix) != null
            ? r
            : xB
      return e ? `${a}-${e}` : a
    }
  var M4 = (function () {
      if (typeof Map < 'u') return Map
      function e(t, n) {
        var r = -1
        return (
          t.some(function (i, o) {
            return i[0] === n ? ((r = o), !0) : !1
          }),
          r
        )
      }
      return (function () {
        function t() {
          this.__entries__ = []
        }
        return (
          Object.defineProperty(t.prototype, 'size', {
            get: function () {
              return this.__entries__.length
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.get = function (n) {
            var r = e(this.__entries__, n),
              i = this.__entries__[r]
            return i && i[1]
          }),
          (t.prototype.set = function (n, r) {
            var i = e(this.__entries__, n)
            ~i ? (this.__entries__[i][1] = r) : this.__entries__.push([n, r])
          }),
          (t.prototype.delete = function (n) {
            var r = this.__entries__,
              i = e(r, n)
            ~i && r.splice(i, 1)
          }),
          (t.prototype.has = function (n) {
            return !!~e(this.__entries__, n)
          }),
          (t.prototype.clear = function () {
            this.__entries__.splice(0)
          }),
          (t.prototype.forEach = function (n, r) {
            r === void 0 && (r = null)
            for (var i = 0, o = this.__entries__; i < o.length; i++) {
              var a = o[i]
              n.call(r, a[1], a[0])
            }
          }),
          t
        )
      })()
    })(),
    mb =
      typeof window < 'u' &&
      typeof document < 'u' &&
      window.document === document,
    rv = (function () {
      return typeof global < 'u' && global.Math === Math
        ? global
        : typeof self < 'u' && self.Math === Math
        ? self
        : typeof window < 'u' && window.Math === Math
        ? window
        : Function('return this')()
    })(),
    MB = (function () {
      return typeof requestAnimationFrame == 'function'
        ? requestAnimationFrame.bind(rv)
        : function (e) {
            return setTimeout(function () {
              return e(Date.now())
            }, 1e3 / 60)
          }
    })(),
    EB = 2
  function PB(e, t) {
    var n = !1,
      r = !1,
      i = 0
    function o() {
      n && ((n = !1), e()), r && s()
    }
    function a() {
      MB(o)
    }
    function s() {
      var l = Date.now()
      if (n) {
        if (l - i < EB) return
        r = !0
      } else (n = !0), (r = !1), setTimeout(a, t)
      i = l
    }
    return s
  }
  var TB = 20,
    kB = [
      'top',
      'right',
      'bottom',
      'left',
      'width',
      'height',
      'size',
      'weight',
    ],
    AB = typeof MutationObserver < 'u',
    $B = (function () {
      function e() {
        ;(this.connected_ = !1),
          (this.mutationEventsAdded_ = !1),
          (this.mutationsObserver_ = null),
          (this.observers_ = []),
          (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
          (this.refresh = PB(this.refresh.bind(this), TB))
      }
      return (
        (e.prototype.addObserver = function (t) {
          ~this.observers_.indexOf(t) || this.observers_.push(t),
            this.connected_ || this.connect_()
        }),
        (e.prototype.removeObserver = function (t) {
          var n = this.observers_,
            r = n.indexOf(t)
          ~r && n.splice(r, 1),
            !n.length && this.connected_ && this.disconnect_()
        }),
        (e.prototype.refresh = function () {
          var t = this.updateObservers_()
          t && this.refresh()
        }),
        (e.prototype.updateObservers_ = function () {
          var t = this.observers_.filter(function (n) {
            return n.gatherActive(), n.hasActive()
          })
          return (
            t.forEach(function (n) {
              return n.broadcastActive()
            }),
            t.length > 0
          )
        }),
        (e.prototype.connect_ = function () {
          !mb ||
            this.connected_ ||
            (document.addEventListener('transitionend', this.onTransitionEnd_),
            window.addEventListener('resize', this.refresh),
            AB
              ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
                this.mutationsObserver_.observe(document, {
                  attributes: !0,
                  childList: !0,
                  characterData: !0,
                  subtree: !0,
                }))
              : (document.addEventListener('DOMSubtreeModified', this.refresh),
                (this.mutationEventsAdded_ = !0)),
            (this.connected_ = !0))
        }),
        (e.prototype.disconnect_ = function () {
          !mb ||
            !this.connected_ ||
            (document.removeEventListener(
              'transitionend',
              this.onTransitionEnd_
            ),
            window.removeEventListener('resize', this.refresh),
            this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
            this.mutationEventsAdded_ &&
              document.removeEventListener('DOMSubtreeModified', this.refresh),
            (this.mutationsObserver_ = null),
            (this.mutationEventsAdded_ = !1),
            (this.connected_ = !1))
        }),
        (e.prototype.onTransitionEnd_ = function (t) {
          var n = t.propertyName,
            r = n === void 0 ? '' : n,
            i = kB.some(function (o) {
              return !!~r.indexOf(o)
            })
          i && this.refresh()
        }),
        (e.getInstance = function () {
          return this.instance_ || (this.instance_ = new e()), this.instance_
        }),
        (e.instance_ = null),
        e
      )
    })(),
    E4 = function (e, t) {
      for (var n = 0, r = Object.keys(t); n < r.length; n++) {
        var i = r[n]
        Object.defineProperty(e, i, {
          value: t[i],
          enumerable: !1,
          writable: !1,
          configurable: !0,
        })
      }
      return e
    },
    ju = function (e) {
      var t = e && e.ownerDocument && e.ownerDocument.defaultView
      return t || rv
    },
    P4 = zv(0, 0, 0, 0)
  function iv(e) {
    return parseFloat(e) || 0
  }
  function O2(e) {
    for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
    return t.reduce(function (r, i) {
      var o = e['border-' + i + '-width']
      return r + iv(o)
    }, 0)
  }
  function OB(e) {
    for (
      var t = ['top', 'right', 'bottom', 'left'], n = {}, r = 0, i = t;
      r < i.length;
      r++
    ) {
      var o = i[r],
        a = e['padding-' + o]
      n[o] = iv(a)
    }
    return n
  }
  function LB(e) {
    var t = e.getBBox()
    return zv(0, 0, t.width, t.height)
  }
  function IB(e) {
    var t = e.clientWidth,
      n = e.clientHeight
    if (!t && !n) return P4
    var r = ju(e).getComputedStyle(e),
      i = OB(r),
      o = i.left + i.right,
      a = i.top + i.bottom,
      s = iv(r.width),
      l = iv(r.height)
    if (
      (r.boxSizing === 'border-box' &&
        (Math.round(s + o) !== t && (s -= O2(r, 'left', 'right') + o),
        Math.round(l + a) !== n && (l -= O2(r, 'top', 'bottom') + a)),
      !DB(e))
    ) {
      var c = Math.round(s + o) - t,
        d = Math.round(l + a) - n
      Math.abs(c) !== 1 && (s -= c), Math.abs(d) !== 1 && (l -= d)
    }
    return zv(i.left, i.top, s, l)
  }
  var RB = (function () {
    return typeof SVGGraphicsElement < 'u'
      ? function (e) {
          return e instanceof ju(e).SVGGraphicsElement
        }
      : function (e) {
          return e instanceof ju(e).SVGElement && typeof e.getBBox == 'function'
        }
  })()
  function DB(e) {
    return e === ju(e).document.documentElement
  }
  function NB(e) {
    return mb ? (RB(e) ? LB(e) : IB(e)) : P4
  }
  function BB(e) {
    var t = e.x,
      n = e.y,
      r = e.width,
      i = e.height,
      o = typeof DOMRectReadOnly < 'u' ? DOMRectReadOnly : Object,
      a = Object.create(o.prototype)
    return (
      E4(a, {
        x: t,
        y: n,
        width: r,
        height: i,
        top: n,
        right: t + r,
        bottom: i + n,
        left: t,
      }),
      a
    )
  }
  function zv(e, t, n, r) {
    return { x: e, y: t, width: n, height: r }
  }
  var FB = (function () {
      function e(t) {
        ;(this.broadcastWidth = 0),
          (this.broadcastHeight = 0),
          (this.contentRect_ = zv(0, 0, 0, 0)),
          (this.target = t)
      }
      return (
        (e.prototype.isActive = function () {
          var t = NB(this.target)
          return (
            (this.contentRect_ = t),
            t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
          )
        }),
        (e.prototype.broadcastRect = function () {
          var t = this.contentRect_
          return (
            (this.broadcastWidth = t.width),
            (this.broadcastHeight = t.height),
            t
          )
        }),
        e
      )
    })(),
    zB = (function () {
      function e(t, n) {
        var r = BB(n)
        E4(this, { target: t, contentRect: r })
      }
      return e
    })(),
    VB = (function () {
      function e(t, n, r) {
        if (
          ((this.activeObservations_ = []),
          (this.observations_ = new M4()),
          typeof t != 'function')
        )
          throw new TypeError(
            'The callback provided as parameter 1 is not a function.'
          )
        ;(this.callback_ = t), (this.controller_ = n), (this.callbackCtx_ = r)
      }
      return (
        (e.prototype.observe = function (t) {
          if (!arguments.length)
            throw new TypeError('1 argument required, but only 0 present.')
          if (!(typeof Element > 'u' || !(Element instanceof Object))) {
            if (!(t instanceof ju(t).Element))
              throw new TypeError('parameter 1 is not of type "Element".')
            var n = this.observations_
            n.has(t) ||
              (n.set(t, new FB(t)),
              this.controller_.addObserver(this),
              this.controller_.refresh())
          }
        }),
        (e.prototype.unobserve = function (t) {
          if (!arguments.length)
            throw new TypeError('1 argument required, but only 0 present.')
          if (!(typeof Element > 'u' || !(Element instanceof Object))) {
            if (!(t instanceof ju(t).Element))
              throw new TypeError('parameter 1 is not of type "Element".')
            var n = this.observations_
            n.has(t) &&
              (n.delete(t), n.size || this.controller_.removeObserver(this))
          }
        }),
        (e.prototype.disconnect = function () {
          this.clearActive(),
            this.observations_.clear(),
            this.controller_.removeObserver(this)
        }),
        (e.prototype.gatherActive = function () {
          var t = this
          this.clearActive(),
            this.observations_.forEach(function (n) {
              n.isActive() && t.activeObservations_.push(n)
            })
        }),
        (e.prototype.broadcastActive = function () {
          if (this.hasActive()) {
            var t = this.callbackCtx_,
              n = this.activeObservations_.map(function (r) {
                return new zB(r.target, r.broadcastRect())
              })
            this.callback_.call(t, n, t), this.clearActive()
          }
        }),
        (e.prototype.clearActive = function () {
          this.activeObservations_.splice(0)
        }),
        (e.prototype.hasActive = function () {
          return this.activeObservations_.length > 0
        }),
        e
      )
    })(),
    T4 = typeof WeakMap < 'u' ? new WeakMap() : new M4(),
    k4 = (function () {
      function e(t) {
        if (!(this instanceof e))
          throw new TypeError('Cannot call a class as a function.')
        if (!arguments.length)
          throw new TypeError('1 argument required, but only 0 present.')
        var n = $B.getInstance(),
          r = new VB(t, n, this)
        T4.set(this, r)
      }
      return e
    })()
  ;['observe', 'unobserve', 'disconnect'].forEach(function (e) {
    k4.prototype[e] = function () {
      var t
      return (t = T4.get(this))[e].apply(t, arguments)
    }
  })
  var Vv = (function () {
      return typeof rv.ResizeObserver < 'u' ? rv.ResizeObserver : k4
    })(),
    L2
  ;(function (e) {
    ;(e[(e.ELEMENT = 1)] = 'ELEMENT'),
      (e[(e.FUNCTIONAL_COMPONENT = 2)] = 'FUNCTIONAL_COMPONENT'),
      (e[(e.STATEFUL_COMPONENT = 4)] = 'STATEFUL_COMPONENT'),
      (e[(e.COMPONENT = 6)] = 'COMPONENT'),
      (e[(e.TEXT_CHILDREN = 8)] = 'TEXT_CHILDREN'),
      (e[(e.ARRAY_CHILDREN = 16)] = 'ARRAY_CHILDREN'),
      (e[(e.SLOTS_CHILDREN = 32)] = 'SLOTS_CHILDREN'),
      (e[(e.TELEPORT = 64)] = 'TELEPORT'),
      (e[(e.SUSPENSE = 128)] = 'SUSPENSE'),
      (e[(e.COMPONENT_SHOULD_KEEP_ALIVE = 256)] =
        'COMPONENT_SHOULD_KEEP_ALIVE'),
      (e[(e.COMPONENT_KEPT_ALIVE = 512)] = 'COMPONENT_KEPT_ALIVE')
  })(L2 || (L2 = {}))
  var I2
  ;(function (e) {
    ;(e[(e.TEXT = 1)] = 'TEXT'),
      (e[(e.CLASS = 2)] = 'CLASS'),
      (e[(e.STYLE = 4)] = 'STYLE'),
      (e[(e.PROPS = 8)] = 'PROPS'),
      (e[(e.FULL_PROPS = 16)] = 'FULL_PROPS'),
      (e[(e.HYDRATE_EVENTS = 32)] = 'HYDRATE_EVENTS'),
      (e[(e.STABLE_FRAGMENT = 64)] = 'STABLE_FRAGMENT'),
      (e[(e.KEYED_FRAGMENT = 128)] = 'KEYED_FRAGMENT'),
      (e[(e.UNKEYED_FRAGMENT = 256)] = 'UNKEYED_FRAGMENT'),
      (e[(e.NEED_PATCH = 512)] = 'NEED_PATCH'),
      (e[(e.DYNAMIC_SLOTS = 1024)] = 'DYNAMIC_SLOTS'),
      (e[(e.DEV_ROOT_FRAGMENT = 2048)] = 'DEV_ROOT_FRAGMENT'),
      (e[(e.HOISTED = -1)] = 'HOISTED'),
      (e[(e.BAIL = -2)] = 'BAIL')
  })(I2 || (I2 = {}))
  const Uv = (e) => !!(e && e.shapeFlag & 1),
    Gd = (e, t) => !!(e && e.shapeFlag & 6),
    UB = (e, t) => !!(e && e.shapeFlag & 8),
    Hv = (e, t) => !!(e && e.shapeFlag & 16),
    Wv = (e, t) => !!(e && e.shapeFlag & 32),
    Iu = (e) => {
      var t, n
      if (e)
        for (const r of e) {
          if (Uv(r) || Gd(r)) return r
          if (Hv(r, r.children)) {
            const i = Iu(r.children)
            if (i) return i
          } else if (Wv(r, r.children)) {
            const i =
              (n = (t = r.children).default) == null ? void 0 : n.call(t)
            if (i) {
              const o = Iu(i)
              if (o) return o
            }
          } else if (Ft(r)) {
            const i = Iu(r)
            if (i) return i
          }
        }
    },
    HB = (e) => {
      if (!e) return !0
      for (const t of e) if (t.children) return !1
      return !0
    },
    A4 = (e, t) => {
      if (e && e.length > 0)
        for (let n = 0; n < e.length; n++) {
          const r = e[n]
          if (Uv(r) || Gd(r)) {
            const o = xt(t) ? t(r) : t
            return (e[n] = Ti(r, o, !0)), !0
          }
          const i = L_(r)
          if (i && i.length > 0 && A4(i, t)) return !0
        }
      return !1
    },
    L_ = (e) => {
      if (Hv(e, e.children)) return e.children
      if (Ft(e)) return e
    },
    $4 = (e) => {
      var t, n
      if (Uv(e)) return e.el
      if (Gd(e)) {
        if (((t = e.el) == null ? void 0 : t.nodeType) === 1) return e.el
        if ((n = e.component) != null && n.subTree) {
          const r = $4(e.component.subTree)
          if (r) return r
        }
      } else {
        const r = L_(e)
        return O4(r)
      }
    },
    O4 = (e) => {
      if (e && e.length > 0)
        for (const t of e) {
          const n = $4(t)
          if (n) return n
        }
    },
    ea = (e, t = !1) => {
      var n, r
      const i = []
      for (const o of e ?? [])
        Uv(o) || Gd(o) || (t && UB(o, o.children))
          ? i.push(o)
          : Hv(o, o.children)
          ? i.push(...ea(o.children, t))
          : Wv(o, o.children)
          ? i.push(
              ...ea(
                (r = (n = o.children).default) == null ? void 0 : r.call(n),
                t
              )
            )
          : Ft(o) && i.push(...ea(o, t))
      return i
    }
  function WB(e) {
    function t(n) {
      const r = []
      return (
        n.forEach((i) => {
          var o, a
          An(i) && i.type === yt
            ? Wv(i, i.children)
              ? r.push(
                  ...t(
                    ((a = (o = i.children).default) == null
                      ? void 0
                      : a.call(o)) || []
                  )
                )
              : Hv(i, i.children)
              ? r.push(...t(i.children))
              : ir(i.children) && r.push(i.children)
            : r.push(i)
        }),
        r
      )
    }
    return t(e)
  }
  const ui = (e) => {
      if (e) return xt(e) ? e : () => e
    },
    L4 = (e, t) => {
      var n
      const r = []
      if (Gd(e, e.type))
        e.type.name === t
          ? e.component && r.push(e.component.uid)
          : (n = e.component) != null &&
            n.subTree &&
            r.push(...L4(e.component.subTree, t))
      else {
        const i = L_(e)
        i && r.push(...I4(i, t))
      }
      return r
    },
    I4 = (e, t) => {
      const n = []
      if (e && e.length > 0) for (const r of e) n.push(...L4(r, t))
      return n
    }
  var Ro = ce({
    name: 'ResizeObserver',
    emits: ['resize'],
    setup(e, { emit: t, slots: n }) {
      let r
      const i = J(),
        o = C(() => (x4(i.value) ? i.value.$el : i.value)),
        a = (l) => {
          l &&
            ((r = new Vv((c) => {
              const d = c[0]
              t('resize', d)
            })),
            r.observe(l))
        },
        s = () => {
          r && (r.disconnect(), (r = null))
        }
      return (
        pt(o, (l) => {
          r && s(), l && a(l)
        }),
        Wt(() => {
          o.value && a(o.value)
        }),
        wr(() => {
          s()
        }),
        () => {
          var l, c
          const d = Iu(
            (c = (l = n.default) == null ? void 0 : l.call(n)) != null ? c : []
          )
          return d ? Ti(d, { ref: i }, !0) : null
        }
      )
    },
  })
  const R4 = typeof window > 'u' ? global : window,
    D4 = R4.requestAnimationFrame,
    ov = R4.cancelAnimationFrame
  function Gu(e) {
    let t = 0
    const n = (...r) => {
      t && ov(t),
        (t = D4(() => {
          e(...r), (t = 0)
        }))
    }
    return (
      (n.cancel = () => {
        ov(t), (t = 0)
      }),
      n
    )
  }
  const Ru = () => {},
    Kd = (() => {
      try {
        return !(typeof window < 'u' && document !== void 0)
      } catch {
        return !0
      }
    })(),
    Cn = (() =>
      Kd
        ? Ru
        : (e, t, n, r = !1) => {
            e.addEventListener(t, n, r)
          })(),
    kn = (() =>
      Kd
        ? Ru
        : (e, t, n, r = !1) => {
            e.removeEventListener(t, n, r)
          })(),
    jB = (e, t) => {
      if (!e || !t) return !1
      let n = t
      for (; n; ) {
        if (n === e) return !0
        n = n.parentNode
      }
      return !1
    },
    jv = (e) => {
      const t = document.createElement('div')
      return t.setAttribute('class', `arco-overlay arco-overlay-${e}`), t
    },
    N4 = (e, t) => {
      var n
      return Kd
        ? Ru()
        : (n = (t ?? document).querySelector(e)) != null
        ? n
        : void 0
    },
    Yo = (e, t) => {
      if (ir(e)) {
        const n = e[0] === '#' ? `[id='${e.slice(1)}']` : e
        return N4(n, t)
      }
      return e
    },
    GB = (e, t) => {
      const n = e.getBoundingClientRect(),
        r = t.getBoundingClientRect()
      return {
        top: n.top - r.top,
        bottom: r.bottom - n.bottom,
        left: n.left - r.left,
        right: r.right - n.right,
        width: n.width,
        height: n.height,
      }
    },
    KB = (e) =>
      e.tagName === 'BODY'
        ? document.documentElement.scrollHeight > window.innerHeight
        : e.scrollHeight > e.offsetHeight,
    qB = (e) =>
      e.tagName === 'BODY'
        ? window.innerWidth -
          (document.documentElement.offsetWidth || document.body.offsetWidth)
        : e.offsetWidth - e.clientWidth
  var Te = (e, t) => {
      for (const [n, r] of t) e[n] = r
      return e
    },
    XB = Object.defineProperty,
    R2 = Object.getOwnPropertySymbols,
    YB = Object.prototype.hasOwnProperty,
    ZB = Object.prototype.propertyIsEnumerable,
    D2 = (e, t, n) =>
      t in e
        ? XB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    N2 = (e, t) => {
      for (var n in t || (t = {})) YB.call(t, n) && D2(e, n, t[n])
      if (R2) for (var n of R2(t)) ZB.call(t, n) && D2(e, n, t[n])
      return e
    }
  function JB(e) {
    return Kh(e)
      ? { top: 0, bottom: window.innerHeight }
      : e.getBoundingClientRect()
  }
  const QB = ce({
      name: 'Affix',
      components: { ResizeObserver: Ro },
      props: {
        offsetTop: { type: Number, default: 0 },
        offsetBottom: { type: Number },
        target: { type: [String, Object, Function] },
        targetContainer: { type: [String, Object, Function] },
      },
      emits: { change: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('affix'),
          { target: r, targetContainer: i } = tt(e),
          o = J(),
          a = J(),
          s = J(!1),
          l = J({}),
          c = J({}),
          d = C(() => ({ [n]: s.value })),
          h = Gu(() => {
            if (!o.value || !a.value) return
            const { offsetTop: p, offsetBottom: v } = e,
              g = Mt(v) ? 'top' : 'bottom',
              _ = o.value.getBoundingClientRect(),
              b = JB(a.value)
            let y = !1,
              M = {}
            const x = {
              width: `${o.value.offsetWidth}px`,
              height: `${o.value.offsetHeight}px`,
            }
            g === 'top'
              ? ((y = _.top - b.top < (p || 0)),
                (M = y
                  ? { position: 'fixed', top: `${b.top + (p || 0)}px` }
                  : {}))
              : ((y = b.bottom - _.bottom < (v || 0)),
                (M = y
                  ? {
                      position: 'fixed',
                      bottom: `${window.innerHeight - b.bottom + (v || 0)}px`,
                    }
                  : {})),
              y !== s.value && ((s.value = y), t('change', y)),
              (l.value = x),
              (c.value = N2(N2({}, M), y ? x : {}))
          })
        return (
          Wt(() => {
            pr((p) => {
              const v = (r && r.value !== window && Yo(r.value)) || window
              ;(a.value = v),
                v &&
                  (Cn(v, 'scroll', h),
                  Cn(v, 'resize', h),
                  p(() => {
                    kn(v, 'scroll', h), kn(v, 'resize', h)
                  }))
            }),
              pr((p) => {
                if (!a.value) return
                const v = (i && i.value !== window && Yo(i.value)) || window
                v &&
                  (Cn(v, 'scroll', h),
                  Cn(v, 'resize', h),
                  p(() => {
                    kn(v, 'scroll', h), kn(v, 'resize', h)
                  }))
              })
          }),
          {
            wrapperRef: o,
            isFixed: s,
            classNames: d,
            placeholderStyles: l,
            fixedStyles: c,
            updatePositionThrottle: h,
          }
        )
      },
      methods: {
        updatePosition() {
          this.updatePositionThrottle()
        },
      },
    }),
    e9 = { ref: 'wrapperRef' }
  function t9(e, t, n, r, i, o) {
    const a = ge('ResizeObserver')
    return (
      O(),
      Ee(
        a,
        { onResize: e.updatePositionThrottle },
        {
          default: ze(() => [
            Se(
              'div',
              e9,
              [
                e.isFixed
                  ? (O(),
                    Z(
                      'div',
                      { key: 0, style: at(e.placeholderStyles) },
                      null,
                      4
                    ))
                  : Ce('v-if', !0),
                Se(
                  'div',
                  { class: H(e.classNames), style: at(e.fixedStyles) },
                  [
                    m(
                      a,
                      { onResize: e.updatePositionThrottle },
                      { default: ze(() => [ve(e.$slots, 'default')]), _: 3 },
                      8,
                      ['onResize']
                    ),
                  ],
                  6
                ),
              ],
              512
            ),
          ]),
          _: 3,
        },
        8,
        ['onResize']
      )
    )
  }
  var Ng = Te(QB, [['render', t9]])
  const n9 = Object.assign(Ng, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Ng.name, Ng)
      },
    }),
    r9 = ce({
      name: 'IconHover',
      props: {
        prefix: { type: String },
        size: { type: String, default: 'medium' },
        disabled: { type: Boolean, default: !1 },
      },
      setup() {
        return { prefixCls: ye('icon-hover') }
      },
    })
  function i9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'span',
        {
          class: H([
            e.prefixCls,
            {
              [`${e.prefix}-icon-hover`]: e.prefix,
              [`${e.prefixCls}-size-${e.size}`]: e.size !== 'medium',
              [`${e.prefixCls}-disabled`]: e.disabled,
            },
          ]),
        },
        [ve(e.$slots, 'default')],
        2
      )
    )
  }
  var In = Te(r9, [['render', i9]])
  const o9 = ce({
      name: 'IconClose',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-close`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    a9 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    s9 = Se(
      'path',
      {
        d: 'M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142',
      },
      null,
      -1
    ),
    l9 = [s9]
  function u9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        l9,
        14,
        a9
      )
    )
  }
  var Bg = Te(o9, [['render', u9]])
  const zr = Object.assign(Bg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Bg.name, Bg)
      },
    }),
    c9 = ce({
      name: 'IconInfoCircleFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-info-circle-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    d9 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    f9 = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    h9 = [f9]
  function p9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        h9,
        14,
        d9
      )
    )
  }
  var Fg = Te(c9, [['render', p9]])
  const qd = Object.assign(Fg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Fg.name, Fg)
      },
    }),
    v9 = ce({
      name: 'IconCheckCircleFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-check-circle-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    m9 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    g9 = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    y9 = [g9]
  function b9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        y9,
        14,
        m9
      )
    )
  }
  var zg = Te(v9, [['render', b9]])
  const $l = Object.assign(zg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + zg.name, zg)
      },
    }),
    _9 = ce({
      name: 'IconExclamationCircleFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [
            n,
            `${n}-exclamation-circle-fill`,
            { [`${n}-spin`]: e.spin },
          ]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    S9 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    C9 = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    w9 = [C9]
  function x9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        w9,
        14,
        S9
      )
    )
  }
  var Vg = Te(_9, [['render', x9]])
  const Wa = Object.assign(Vg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Vg.name, Vg)
      },
    }),
    M9 = ce({
      name: 'IconCloseCircleFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-close-circle-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    E9 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    P9 = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    T9 = [P9]
  function k9(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        T9,
        14,
        E9
      )
    )
  }
  var Ug = Te(M9, [['render', k9]])
  const rc = Object.assign(Ug, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Ug.name, Ug)
      },
    }),
    A9 = ce({
      name: 'Alert',
      components: {
        IconHover: In,
        IconClose: zr,
        IconInfoCircleFill: qd,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
      },
      props: {
        type: { type: String, default: 'info' },
        showIcon: { type: Boolean, default: !0 },
        closable: { type: Boolean, default: !1 },
        title: String,
        banner: { type: Boolean, default: !1 },
        center: { type: Boolean, default: !1 },
      },
      emits: { close: (e) => !0, afterClose: () => !0 },
      setup(e, { slots: t, emit: n }) {
        const r = ye('alert'),
          i = J(!0),
          o = (l) => {
            ;(i.value = !1), n('close', l)
          },
          a = () => {
            n('afterClose')
          },
          s = C(() => [
            r,
            `${r}-${e.type}`,
            {
              [`${r}-with-title`]: !!(e.title || t.title),
              [`${r}-banner`]: e.banner,
              [`${r}-center`]: e.center,
            },
          ])
        return {
          prefixCls: r,
          cls: s,
          visible: i,
          handleClose: o,
          handleAfterLeave: a,
        }
      },
    })
  function $9(e, t, n, r, i, o) {
    const a = ge('icon-info-circle-fill'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill'),
      d = ge('icon-close'),
      h = ge('icon-hover')
    return (
      O(),
      Ee(
        Fr,
        { name: 'zoom-in-top', onAfterLeave: e.handleAfterLeave },
        {
          default: ze(() => [
            e.visible
              ? (O(),
                Z(
                  'div',
                  { key: 0, role: 'alert', class: H(e.cls) },
                  [
                    e.showIcon && !(e.type === 'normal' && !e.$slots.icon)
                      ? (O(),
                        Z(
                          'div',
                          { key: 0, class: H(`${e.prefixCls}-icon`) },
                          [
                            ve(e.$slots, 'icon', {}, () => [
                              e.type === 'info'
                                ? (O(), Ee(a, { key: 0 }))
                                : e.type === 'success'
                                ? (O(), Ee(s, { key: 1 }))
                                : e.type === 'warning'
                                ? (O(), Ee(l, { key: 2 }))
                                : e.type === 'error'
                                ? (O(), Ee(c, { key: 3 }))
                                : Ce('v-if', !0),
                            ]),
                          ],
                          2
                        ))
                      : Ce('v-if', !0),
                    Se(
                      'div',
                      { class: H(`${e.prefixCls}-body`) },
                      [
                        e.title || e.$slots.title
                          ? (O(),
                            Z(
                              'div',
                              { key: 0, class: H(`${e.prefixCls}-title`) },
                              [
                                ve(e.$slots, 'title', {}, () => [
                                  Lt(mt(e.title), 1),
                                ]),
                              ],
                              2
                            ))
                          : Ce('v-if', !0),
                        Se(
                          'div',
                          { class: H(`${e.prefixCls}-content`) },
                          [ve(e.$slots, 'default')],
                          2
                        ),
                      ],
                      2
                    ),
                    e.$slots.action
                      ? (O(),
                        Z(
                          'div',
                          { key: 1, class: H(`${e.prefixCls}-action`) },
                          [ve(e.$slots, 'action')],
                          2
                        ))
                      : Ce('v-if', !0),
                    e.closable
                      ? (O(),
                        Z(
                          'div',
                          {
                            key: 2,
                            tabindex: '-1',
                            role: 'button',
                            'aria-label': 'Close',
                            class: H(`${e.prefixCls}-close-btn`),
                            onClick:
                              t[0] ||
                              (t[0] = (...p) =>
                                e.handleClose && e.handleClose(...p)),
                          },
                          [
                            ve(e.$slots, 'close-element', {}, () => [
                              m(h, null, { default: ze(() => [m(d)]), _: 1 }),
                            ]),
                          ],
                          2
                        ))
                      : Ce('v-if', !0),
                  ],
                  2
                ))
              : Ce('v-if', !0),
          ]),
          _: 3,
        },
        8,
        ['onAfterLeave']
      )
    )
  }
  var Hg = Te(A9, [['render', $9]])
  const O9 = Object.assign(Hg, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + Hg.name, Hg)
    },
  })
  function B2(e) {
    return typeof e == 'object' && e != null && e.nodeType === 1
  }
  function F2(e, t) {
    return (!t || e !== 'hidden') && e !== 'visible' && e !== 'clip'
  }
  function Wg(e, t) {
    if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
      var n = getComputedStyle(e, null)
      return (
        F2(n.overflowY, t) ||
        F2(n.overflowX, t) ||
        (function (r) {
          var i = (function (o) {
            if (!o.ownerDocument || !o.ownerDocument.defaultView) return null
            try {
              return o.ownerDocument.defaultView.frameElement
            } catch {
              return null
            }
          })(r)
          return (
            !!i &&
            (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth)
          )
        })(e)
      )
    }
    return !1
  }
  function lh(e, t, n, r, i, o, a, s) {
    return (o < e && a > t) || (o > e && a < t)
      ? 0
      : (o <= e && s <= n) || (a >= t && s >= n)
      ? o - e - r
      : (a > t && s < n) || (o < e && s > n)
      ? a - t + i
      : 0
  }
  var gb = function (e, t) {
      var n = window,
        r = t.scrollMode,
        i = t.block,
        o = t.inline,
        a = t.boundary,
        s = t.skipOverflowHiddenElements,
        l =
          typeof a == 'function'
            ? a
            : function (z) {
                return z !== a
              }
      if (!B2(e)) throw new TypeError('Invalid target')
      for (
        var c,
          d,
          h = document.scrollingElement || document.documentElement,
          p = [],
          v = e;
        B2(v) && l(v);

      ) {
        if (
          (v =
            (d = (c = v).parentElement) == null
              ? c.getRootNode().host || null
              : d) === h
        ) {
          p.push(v)
          break
        }
        ;(v != null &&
          v === document.body &&
          Wg(v) &&
          !Wg(document.documentElement)) ||
          (v != null && Wg(v, s) && p.push(v))
      }
      for (
        var g = n.visualViewport ? n.visualViewport.width : innerWidth,
          _ = n.visualViewport ? n.visualViewport.height : innerHeight,
          b = window.scrollX || pageXOffset,
          y = window.scrollY || pageYOffset,
          M = e.getBoundingClientRect(),
          x = M.height,
          w = M.width,
          E = M.top,
          P = M.right,
          A = M.bottom,
          F = M.left,
          T =
            i === 'start' || i === 'nearest' ? E : i === 'end' ? A : E + x / 2,
          k = o === 'center' ? F + w / 2 : o === 'end' ? P : F,
          R = [],
          j = 0;
        j < p.length;
        j++
      ) {
        var N = p[j],
          I = N.getBoundingClientRect(),
          B = I.height,
          V = I.width,
          L = I.top,
          W = I.right,
          Y = I.bottom,
          U = I.left
        if (
          r === 'if-needed' &&
          E >= 0 &&
          F >= 0 &&
          A <= _ &&
          P <= g &&
          E >= L &&
          A <= Y &&
          F >= U &&
          P <= W
        )
          return R
        var le = getComputedStyle(N),
          q = parseInt(le.borderLeftWidth, 10),
          oe = parseInt(le.borderTopWidth, 10),
          te = parseInt(le.borderRightWidth, 10),
          ue = parseInt(le.borderBottomWidth, 10),
          me = 0,
          Re = 0,
          qe = 'offsetWidth' in N ? N.offsetWidth - N.clientWidth - q - te : 0,
          Ve =
            'offsetHeight' in N ? N.offsetHeight - N.clientHeight - oe - ue : 0,
          nt =
            'offsetWidth' in N
              ? N.offsetWidth === 0
                ? 0
                : V / N.offsetWidth
              : 0,
          We =
            'offsetHeight' in N
              ? N.offsetHeight === 0
                ? 0
                : B / N.offsetHeight
              : 0
        if (h === N)
          (me =
            i === 'start'
              ? T
              : i === 'end'
              ? T - _
              : i === 'nearest'
              ? lh(y, y + _, _, oe, ue, y + T, y + T + x, x)
              : T - _ / 2),
            (Re =
              o === 'start'
                ? k
                : o === 'center'
                ? k - g / 2
                : o === 'end'
                ? k - g
                : lh(b, b + g, g, q, te, b + k, b + k + w, w)),
            (me = Math.max(0, me + y)),
            (Re = Math.max(0, Re + b))
        else {
          ;(me =
            i === 'start'
              ? T - L - oe
              : i === 'end'
              ? T - Y + ue + Ve
              : i === 'nearest'
              ? lh(L, Y, B, oe, ue + Ve, T, T + x, x)
              : T - (L + B / 2) + Ve / 2),
            (Re =
              o === 'start'
                ? k - U - q
                : o === 'center'
                ? k - (U + V / 2) + qe / 2
                : o === 'end'
                ? k - W + te + qe
                : lh(U, W, V, q, te + qe, k, k + w, w))
          var D = N.scrollLeft,
            G = N.scrollTop
          ;(T +=
            G -
            (me = Math.max(
              0,
              Math.min(G + me / We, N.scrollHeight - B / We + Ve)
            ))),
            (k +=
              D -
              (Re = Math.max(
                0,
                Math.min(D + Re / nt, N.scrollWidth - V / nt + qe)
              )))
        }
        R.push({ el: N, top: me, left: Re })
      }
      return R
    },
    Xd = function (e) {
      return function (t) {
        return Math.pow(t, e)
      }
    },
    Yd = function (e) {
      return function (t) {
        return 1 - Math.abs(Math.pow(t - 1, e))
      }
    },
    Gv = function (e) {
      return function (t) {
        return t < 0.5 ? Xd(e)(t * 2) / 2 : Yd(e)(t * 2 - 1) / 2 + 0.5
      }
    },
    L9 = function (e) {
      return e
    },
    I9 = Xd(2),
    R9 = Yd(2),
    D9 = Gv(2),
    N9 = Xd(3),
    B9 = Yd(3),
    F9 = Gv(3),
    z9 = Xd(4),
    V9 = Yd(4),
    U9 = Gv(4),
    H9 = Xd(5),
    W9 = Yd(5),
    j9 = Gv(5),
    G9 = function (e) {
      return 1 + Math.sin((Math.PI / 2) * e - Math.PI / 2)
    },
    K9 = function (e) {
      return Math.sin((Math.PI / 2) * e)
    },
    q9 = function (e) {
      return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2
    },
    I_ = function (e) {
      var t = 7.5625,
        n = 2.75
      return e < 1 / n
        ? t * e * e
        : e < 2 / n
        ? ((e -= 1.5 / n), t * e * e + 0.75)
        : e < 2.5 / n
        ? ((e -= 2.25 / n), t * e * e + 0.9375)
        : ((e -= 2.625 / n), t * e * e + 0.984375)
    },
    B4 = function (e) {
      return 1 - I_(1 - e)
    },
    X9 = function (e) {
      return e < 0.5 ? B4(e * 2) * 0.5 : I_(e * 2 - 1) * 0.5 + 0.5
    },
    Y9 = Object.freeze({
      linear: L9,
      quadIn: I9,
      quadOut: R9,
      quadInOut: D9,
      cubicIn: N9,
      cubicOut: B9,
      cubicInOut: F9,
      quartIn: z9,
      quartOut: V9,
      quartInOut: U9,
      quintIn: H9,
      quintOut: W9,
      quintInOut: j9,
      sineIn: G9,
      sineOut: K9,
      sineInOut: q9,
      bounceOut: I_,
      bounceIn: B4,
      bounceInOut: X9,
    }),
    Ol = function (t) {
      var n = t.from,
        r = t.to,
        i = t.duration,
        o = t.delay,
        a = t.easing,
        s = t.onStart,
        l = t.onUpdate,
        c = t.onFinish
      for (var d in n) r[d] === void 0 && (r[d] = n[d])
      for (var h in r) n[h] === void 0 && (n[h] = r[h])
      ;(this.from = n),
        (this.to = r),
        (this.duration = i || 500),
        (this.delay = o || 0),
        (this.easing = a || 'linear'),
        (this.onStart = s),
        (this.onUpdate = l || function () {}),
        (this.onFinish = c),
        (this.startTime = Date.now() + this.delay),
        (this.started = !1),
        (this.finished = !1),
        (this.timer = null),
        (this.keys = {})
    }
  Ol.prototype.update = function () {
    if (
      ((this.time = Date.now()),
      !(this.time < this.startTime) && !this.finished)
    ) {
      if (this.elapsed === this.duration) {
        this.finished ||
          ((this.finished = !0), this.onFinish && this.onFinish(this.keys))
        return
      }
      ;(this.elapsed = this.time - this.startTime),
        (this.elapsed =
          this.elapsed > this.duration ? this.duration : this.elapsed)
      for (var t in this.to)
        this.keys[t] =
          this.from[t] +
          (this.to[t] - this.from[t]) *
            Y9[this.easing](this.elapsed / this.duration)
      this.started ||
        (this.onStart && this.onStart(this.keys), (this.started = !0)),
        this.onUpdate(this.keys)
    }
  }
  Ol.prototype.start = function () {
    var t = this
    this.startTime = Date.now() + this.delay
    var n = function () {
      t.update(),
        (t.timer = requestAnimationFrame(n)),
        t.finished && (cancelAnimationFrame(t.timer), (t.timer = null))
    }
    n()
  }
  Ol.prototype.stop = function () {
    cancelAnimationFrame(this.timer), (this.timer = null)
  }
  function Z9(e, t, n) {
    new Ol({
      from: { scrollTop: e.scrollTop },
      to: { scrollTop: t },
      easing: 'quartOut',
      duration: 300,
      onUpdate: (i) => {
        e.scrollTop = i.scrollTop
      },
      onFinish: () => {
        xt(n) && n()
      },
    }).start()
  }
  const F4 = Symbol('ArcoAnchor'),
    J9 = ['start', 'end', 'center', 'nearest'],
    Q9 = ce({
      name: 'Anchor',
      props: {
        boundary: {
          type: [Number, String],
          default: 'start',
          validator: (e) => it(e) || J9.includes(e),
        },
        lineLess: { type: Boolean, default: !1 },
        scrollContainer: { type: [String, Object] },
        changeHash: { type: Boolean, default: !0 },
        smooth: { type: Boolean, default: !0 },
      },
      emits: { select: (e, t) => !0, change: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('anchor'),
          r = J(),
          i = J(),
          o = Je({}),
          a = J(''),
          s = J(!1),
          l = J(),
          c = J(),
          d = (E, P) => {
            E && (o[E] = P)
          },
          h = (E) => {
            delete o[E]
          },
          p = (E, P) => {
            e.changeHash || E.preventDefault(),
              P && (v(P), _(P)),
              t('select', P, a.value)
          },
          v = (E) => {
            try {
              const P = Yo(E)
              if (!P) return
              let A,
                F = 0
              it(e.boundary)
                ? ((A = 'start'), (F = e.boundary))
                : (A = e.boundary)
              const T = gb(P, { block: A })
              if (!T.length) return
              const { el: k, top: R } = T[0],
                j = R - F
              Z9(k, j, () => {
                s.value = !1
              }),
                (s.value = !0)
            } catch (P) {
              console.error(P)
            }
          },
          g = Gu(() => {
            if (s.value) return
            const E = b()
            if (E && E.id) {
              const P = `#${E.id}`
              _(P)
            }
          }),
          _ = (E) => {
            if (!o[E] && r.value) {
              const P = Yo(`a[data-href='${E}']`, r.value)
              if (!P) return
              o[E] = P
            }
            E !== a.value &&
              ((a.value = E),
              hn(() => {
                t('change', E)
              }))
          },
          b = () => {
            if (!l.value || !c.value) return
            const E = it(e.boundary) ? e.boundary : 0,
              P = c.value.getBoundingClientRect()
            for (const A of Object.keys(o)) {
              const F = Yo(A)
              if (F) {
                const { top: T } = F.getBoundingClientRect(),
                  k = Kh(l.value) ? T - E : T - P.top - E
                if (k >= 0 && k <= P.height / 2) return F
              }
            }
          }
        pt(a, () => {
          const E = o[a.value]
          !e.lineLess &&
            E &&
            i.value &&
            (i.value.style.top = `${E.offsetTop}px`)
        })
        const y = () => {
            l.value && Cn(l.value, 'scroll', g)
          },
          M = () => {
            l.value && kn(l.value, 'scroll', g)
          },
          x = () => {
            e.scrollContainer
              ? ((l.value = Kh(e.scrollContainer)
                  ? window
                  : Yo(e.scrollContainer)),
                (c.value = Kh(e.scrollContainer)
                  ? document.documentElement
                  : Yo(e.scrollContainer)))
              : ((l.value = window), (c.value = document.documentElement))
          }
        Wt(() => {
          x()
          const E = decodeURIComponent(window.location.hash)
          E ? (v(E), _(E)) : g(), y()
        }),
          Pr(() => {
            M()
          }),
          sn(
            F4,
            Je({ currentLink: a, addLink: d, removeLink: h, handleClick: p })
          )
        const w = C(() => [n, { [`${n}-line-less`]: e.lineLess }])
        return { prefixCls: n, cls: w, anchorRef: r, lineSliderRef: i }
      },
    })
  function eF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { ref: 'anchorRef', class: H(e.cls) },
        [
          e.lineLess
            ? Ce('v-if', !0)
            : (O(),
              Z(
                'div',
                {
                  key: 0,
                  ref: 'lineSliderRef',
                  class: H(`${e.prefixCls}-line-slider`),
                },
                null,
                2
              )),
          Se(
            'ul',
            { class: H(`${e.prefixCls}-list`) },
            [ve(e.$slots, 'default')],
            2
          ),
        ],
        2
      )
    )
  }
  var jg = Te(Q9, [['render', eF]])
  const tF = ce({
      name: 'AnchorLink',
      props: { title: String, href: String },
      setup(e) {
        const t = ye('anchor'),
          n = `${t}-link`,
          r = J(),
          i = zt(F4, void 0)
        Wt(() => {
          e.href && r.value && (i == null || i.addLink(e.href, r.value))
        })
        const o = C(() => [
          `${n}-item`,
          { [`${n}-active`]: (i == null ? void 0 : i.currentLink) === e.href },
        ])
        return {
          prefixCls: t,
          linkCls: n,
          cls: o,
          linkRef: r,
          handleClick: (s) => (i == null ? void 0 : i.handleClick(s, e.href)),
        }
      },
    }),
    nF = ['href']
  function rF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'li',
        { ref: 'linkRef', class: H(e.cls) },
        [
          Se(
            'a',
            {
              class: H(e.linkCls),
              href: e.href,
              onClick:
                t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a)),
            },
            [ve(e.$slots, 'default', {}, () => [Lt(mt(e.title), 1)])],
            10,
            nF
          ),
          e.$slots.sublist
            ? (O(),
              Z(
                'ul',
                { key: 0, class: H(`${e.prefixCls}-sublist`) },
                [ve(e.$slots, 'sublist')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var qh = Te(tF, [['render', rF]])
  const iF = Object.assign(jg, {
      Link: qh,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + jg.name, jg), e.component(n + qh.name, qh)
      },
    }),
    Kv = ['info', 'success', 'warning', 'error'],
    Ts = [
      'onFocus',
      'onFocusin',
      'onFocusout',
      'onBlur',
      'onChange',
      'onBeforeinput',
      'onInput',
      'onReset',
      'onSubmit',
      'onInvalid',
      'onKeydown',
      'onKeypress',
      'onKeyup',
      'onCopy',
      'onCut',
      'onPaste',
      'onCompositionstart',
      'onCompositionupdate',
      'onCompositionend',
      'onSelect',
      'autocomplete',
      'autofocus',
      'maxlength',
      'minlength',
      'name',
      'pattern',
      'readonly',
      'required',
    ],
    oF = ce({
      name: 'IconLoading',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-loading`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    aF = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    sF = Se(
      'path',
      { d: 'M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6' },
      null,
      -1
    ),
    lF = [sF]
  function uF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        lF,
        14,
        aF
      )
    )
  }
  var Gg = Te(oF, [['render', uF]])
  const Xr = Object.assign(Gg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Gg.name, Gg)
      },
    }),
    cF = ce({
      name: 'FeedbackIcon',
      components: {
        IconLoading: Xr,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
      },
      props: { type: { type: String } },
      setup(e) {
        const t = ye('feedback-icon')
        return { cls: C(() => [t, `${t}-status-${e.type}`]) }
      },
    })
  function dF(e, t, n, r, i, o) {
    const a = ge('icon-loading'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill')
    return (
      O(),
      Z(
        'span',
        { class: H(e.cls) },
        [
          e.type === 'validating'
            ? (O(), Ee(a, { key: 0 }))
            : e.type === 'success'
            ? (O(), Ee(s, { key: 1 }))
            : e.type === 'warning'
            ? (O(), Ee(l, { key: 2 }))
            : e.type === 'error'
            ? (O(), Ee(c, { key: 3 }))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Zd = Te(cF, [['render', dF]])
  const R_ = { key: 'Enter', code: 'Enter' },
    fF = { key: 'Backspace', code: 'Backspace' }
  var hF = Object.defineProperty,
    z2 = Object.getOwnPropertySymbols,
    pF = Object.prototype.hasOwnProperty,
    vF = Object.prototype.propertyIsEnumerable,
    V2 = (e, t, n) =>
      t in e
        ? hF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    mF = (e, t) => {
      for (var n in t || (t = {})) pF.call(t, n) && V2(e, n, t[n])
      if (z2) for (var n of z2(t)) vF.call(t, n) && V2(e, n, t[n])
      return e
    }
  const xr = (e, t) => {
    const n = mF({}, e)
    for (const r of t) r in n && delete n[r]
    return n
  }
  function ra(e, t) {
    const n = {}
    return (
      t.forEach((r) => {
        const i = r
        r in e && (n[i] = e[i])
      }),
      n
    )
  }
  const yb = Symbol('ArcoFormItemContext'),
    D_ = Symbol('ArcoFormContext'),
    Rn = ({ size: e, disabled: t, error: n, uninject: r } = {}) => {
      const i = r ? {} : zt(yb, {}),
        o = C(() => {
          var d
          return (d = e == null ? void 0 : e.value) != null ? d : i.size
        }),
        a = C(() => (t == null ? void 0 : t.value) || i.disabled),
        s = C(() => (n == null ? void 0 : n.value) || i.error),
        l = Vi(i, 'feedback'),
        c = Vi(i, 'eventHandlers')
      return {
        formItemCtx: i,
        mergedSize: o,
        mergedDisabled: a,
        mergedError: s,
        feedback: l,
        eventHandlers: c,
      }
    },
    Vr = (e, { defaultValue: t = 'medium' } = {}) => {
      const n = zt(di, void 0)
      return {
        mergedSize: C(() => {
          var i, o
          return (o =
            (i = e == null ? void 0 : e.value) != null
              ? i
              : n == null
              ? void 0
              : n.size) != null
            ? o
            : t
        }),
      }
    }
  function z4(e) {
    const t = J()
    function n() {
      if (!e.value) return
      const { selectionStart: i, selectionEnd: o, value: a } = e.value
      if (i == null || o == null) return
      const s = a.slice(0, Math.max(0, i)),
        l = a.slice(Math.max(0, o))
      t.value = {
        selectionStart: i,
        selectionEnd: o,
        value: a,
        beforeTxt: s,
        afterTxt: l,
      }
    }
    function r() {
      if (!e.value || !t.value) return
      const { value: i } = e.value,
        { beforeTxt: o, afterTxt: a, selectionStart: s } = t.value
      if (!o || !a || !s) return
      let l = i.length
      if (i.endsWith(a)) l = i.length - a.length
      else if (i.startsWith(o)) l = o.length
      else {
        const c = o[s - 1],
          d = i.indexOf(c, s - 1)
        d !== -1 && (l = d + 1)
      }
      e.value.setSelectionRange(l, l)
    }
    return [n, r]
  }
  var gF = Object.defineProperty,
    U2 = Object.getOwnPropertySymbols,
    yF = Object.prototype.hasOwnProperty,
    bF = Object.prototype.propertyIsEnumerable,
    H2 = (e, t, n) =>
      t in e
        ? gF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    W2 = (e, t) => {
      for (var n in t || (t = {})) yF.call(t, n) && H2(e, n, t[n])
      if (U2) for (var n of U2(t)) bF.call(t, n) && H2(e, n, t[n])
      return e
    },
    sd = ce({
      name: 'Input',
      inheritAttrs: !1,
      props: {
        modelValue: String,
        defaultValue: { type: String, default: '' },
        size: { type: String },
        allowClear: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        readonly: { type: Boolean, default: !1 },
        error: { type: Boolean, default: !1 },
        placeholder: String,
        maxLength: { type: [Number, Object], default: 0 },
        showWordLimit: { type: Boolean, default: !1 },
        wordLength: { type: Function },
        wordSlice: { type: Function },
        inputAttrs: { type: Object },
        type: { type: String, default: 'text' },
      },
      emits: {
        'update:modelValue': (e) => !0,
        input: (e, t) => !0,
        change: (e, t) => !0,
        pressEnter: (e) => !0,
        clear: (e) => !0,
        focus: (e) => !0,
        blur: (e) => !0,
      },
      setup(e, { emit: t, slots: n, attrs: r }) {
        const { size: i, disabled: o, error: a, modelValue: s } = tt(e),
          l = ye('input'),
          c = J(),
          {
            mergedSize: d,
            mergedDisabled: h,
            mergedError: p,
            feedback: v,
            eventHandlers: g,
          } = Rn({ size: i, disabled: o, error: a }),
          { mergedSize: _ } = Vr(d),
          [b, y] = z4(c),
          M = J(e.defaultValue),
          x = C(() => {
            var G
            return (G = e.modelValue) != null ? G : M.value
          })
        pt(s, (G) => {
          ;(Mt(G) || fi(G)) && (M.value = '')
        })
        let w = x.value
        const E = J(!1),
          P = C(() => e.allowClear && !h.value && !!x.value),
          A = J(!1),
          F = J(''),
          T = (G) => {
            var z
            return xt(e.wordLength)
              ? e.wordLength(G)
              : (z = G.length) != null
              ? z
              : 0
          },
          k = C(() => T(x.value)),
          R = C(
            () =>
              p.value ||
              !!(Ht(e.maxLength) && e.maxLength.errorOnly && k.value > N.value)
          ),
          j = C(() => Ht(e.maxLength) && !!e.maxLength.errorOnly),
          N = C(() => (Ht(e.maxLength) ? e.maxLength.length : e.maxLength)),
          I = C(() => {
            const G = T('a')
            return Math.floor(N.value / G)
          }),
          B = (G) => {
            var z, ie
            N.value &&
              !j.value &&
              T(G) > N.value &&
              (G =
                (ie =
                  (z = e.wordSlice) == null ? void 0 : z.call(e, G, N.value)) !=
                null
                  ? ie
                  : G.slice(0, I.value)),
              (M.value = G),
              t('update:modelValue', G)
          },
          V = (G) => {
            c.value &&
              G.target !== c.value &&
              (G.preventDefault(), c.value.focus())
          },
          L = (G, z) => {
            var ie, ae
            G !== w &&
              ((w = G),
              t('change', G, z),
              (ae = (ie = g.value) == null ? void 0 : ie.onChange) == null ||
                ae.call(ie, z))
          },
          W = (G) => {
            var z, ie
            ;(E.value = !0),
              (w = x.value),
              t('focus', G),
              (ie = (z = g.value) == null ? void 0 : z.onFocus) == null ||
                ie.call(z, G)
          },
          Y = (G) => {
            var z, ie
            ;(E.value = !1),
              L(x.value, G),
              t('blur', G),
              (ie = (z = g.value) == null ? void 0 : z.onBlur) == null ||
                ie.call(z, G)
          },
          U = (G) => {
            var z, ie, ae
            const { value: re, selectionStart: pe, selectionEnd: we } = G.target
            if (G.type === 'compositionend') {
              if (
                ((A.value = !1),
                (F.value = ''),
                N.value &&
                  !j.value &&
                  k.value >= N.value &&
                  T(re) > N.value &&
                  pe === we)
              ) {
                le()
                return
              }
              B(re),
                t('input', re, G),
                (ie = (z = g.value) == null ? void 0 : z.onInput) == null ||
                  ie.call(z, G),
                le()
            } else
              (A.value = !0),
                (F.value = x.value + ((ae = G.data) != null ? ae : ''))
          },
          le = () => {
            b(),
              hn(() => {
                c.value &&
                  x.value !== c.value.value &&
                  ((c.value.value = x.value), y())
              })
          },
          q = (G) => {
            var z, ie
            const { value: ae } = G.target
            if (!A.value) {
              if (
                N.value &&
                !j.value &&
                k.value >= N.value &&
                T(ae) > N.value &&
                G.inputType === 'insertText'
              ) {
                le()
                return
              }
              B(ae),
                t('input', ae, G),
                (ie = (z = g.value) == null ? void 0 : z.onInput) == null ||
                  ie.call(z, G),
                le()
            }
          },
          oe = (G) => {
            B(''), L('', G), t('clear', G)
          },
          te = (G) => {
            const z = G.key || G.code
            !A.value && z === R_.key && (L(x.value, G), t('pressEnter', G))
          },
          ue = C(() => [
            `${l}-outer`,
            `${l}-outer-size-${_.value}`,
            {
              [`${l}-outer-has-suffix`]: !!n.suffix,
              [`${l}-outer-disabled`]: h.value,
            },
          ]),
          me = C(() => [
            `${l}-wrapper`,
            {
              [`${l}-error`]: R.value,
              [`${l}-disabled`]: h.value,
              [`${l}-focus`]: E.value,
            },
          ]),
          Re = C(() => [l, `${l}-size-${_.value}`]),
          qe = C(() => xr(r, Ts)),
          Ve = C(() => ra(r, Ts)),
          nt = C(() => {
            const G = W2(W2({}, Ve.value), e.inputAttrs)
            return R.value && (G['aria-invalid'] = !0), G
          }),
          We = (G) => {
            var z
            return m(
              'span',
              Fe({ class: me.value, onMousedown: V }, G ? void 0 : qe.value),
              [
                n.prefix && m('span', { class: `${l}-prefix` }, [n.prefix()]),
                m(
                  'input',
                  Fe(nt.value, {
                    ref: c,
                    class: Re.value,
                    value: x.value,
                    type: e.type,
                    placeholder: e.placeholder,
                    readonly: e.readonly,
                    disabled: h.value,
                    onInput: q,
                    onKeydown: te,
                    onFocus: W,
                    onBlur: Y,
                    onCompositionstart: U,
                    onCompositionupdate: U,
                    onCompositionend: U,
                  }),
                  null
                ),
                P.value &&
                  m(
                    In,
                    { prefix: l, class: `${l}-clear-btn`, onClick: oe },
                    { default: () => [m(zr, null, null)] }
                  ),
                (n.suffix || (!!e.maxLength && e.showWordLimit) || !!v.value) &&
                  m(
                    'span',
                    {
                      class: [
                        `${l}-suffix`,
                        { [`${l}-suffix-has-feedback`]: v.value },
                      ],
                    },
                    [
                      !!e.maxLength &&
                        e.showWordLimit &&
                        m('span', { class: `${l}-word-limit` }, [
                          k.value,
                          Lt('/'),
                          N.value,
                        ]),
                      (z = n.suffix) == null ? void 0 : z.call(n),
                      !!v.value && m(Zd, { type: v.value }, null),
                    ]
                  ),
              ]
            )
          }
        return {
          inputRef: c,
          render: () =>
            n.prepend || n.append
              ? m('span', Fe({ class: ue.value }, qe.value), [
                  n.prepend &&
                    m('span', { class: `${l}-prepend` }, [n.prepend()]),
                  We(!0),
                  n.append && m('span', { class: `${l}-append` }, [n.append()]),
                ])
              : We(),
        }
      },
      methods: {
        focus() {
          var e
          ;(e = this.inputRef) == null || e.focus()
        },
        blur() {
          var e
          ;(e = this.inputRef) == null || e.blur()
        },
      },
      render() {
        return this.render()
      },
    })
  const _F = ce({
      name: 'IconSearch',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-search`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    SF = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    CF = Se(
      'path',
      {
        d: 'M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485',
      },
      null,
      -1
    ),
    wF = [CF]
  function xF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        wF,
        14,
        SF
      )
    )
  }
  var Kg = Te(_F, [['render', xF]])
  const bb = Object.assign(Kg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Kg.name, Kg)
      },
    }),
    V4 = Symbol('ArcoButtonGroup'),
    MF = ce({
      name: 'Button',
      components: { IconLoading: Xr },
      props: {
        type: { type: String },
        shape: { type: String },
        status: { type: String },
        size: { type: String },
        long: { type: Boolean, default: !1 },
        loading: { type: Boolean, default: !1 },
        disabled: { type: Boolean },
        htmlType: { type: String, default: 'button' },
        href: String,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const { size: n, disabled: r } = tt(e),
          i = ye('btn'),
          o = zt(V4, void 0),
          a = C(() => {
            var v
            return (v = n.value) != null ? v : o == null ? void 0 : o.size
          }),
          s = C(() => !!(r.value || (o != null && o.disabled))),
          { mergedSize: l, mergedDisabled: c } = Rn({ size: a, disabled: s }),
          { mergedSize: d } = Vr(l),
          h = C(() => {
            var v, g, _, b, y, M
            return [
              i,
              `${i}-${
                (g = (v = e.type) != null ? v : o == null ? void 0 : o.type) !=
                null
                  ? g
                  : 'secondary'
              }`,
              `${i}-shape-${
                (b =
                  (_ = e.shape) != null ? _ : o == null ? void 0 : o.shape) !=
                null
                  ? b
                  : 'square'
              }`,
              `${i}-size-${d.value}`,
              `${i}-status-${
                (M =
                  (y = e.status) != null ? y : o == null ? void 0 : o.status) !=
                null
                  ? M
                  : 'normal'
              }`,
              {
                [`${i}-long`]: e.long,
                [`${i}-loading`]: e.loading,
                [`${i}-disabled`]: c.value,
                [`${i}-link`]: ir(e.href),
              },
            ]
          })
        return {
          prefixCls: i,
          cls: h,
          mergedDisabled: c,
          handleClick: (v) => {
            if (e.disabled || e.loading) {
              v.preventDefault()
              return
            }
            t('click', v)
          },
        }
      },
    }),
    EF = ['href'],
    PF = ['type', 'disabled']
  function TF(e, t, n, r, i, o) {
    const a = ge('icon-loading')
    return e.href
      ? (O(),
        Z(
          'a',
          {
            key: 0,
            class: H([
              e.cls,
              {
                [`${e.prefixCls}-only-icon`]:
                  e.$slots.icon && !e.$slots.default,
              },
            ]),
            href: e.mergedDisabled || e.loading ? void 0 : e.href,
            onClick:
              t[0] || (t[0] = (...s) => e.handleClick && e.handleClick(...s)),
          },
          [
            e.loading || e.$slots.icon
              ? (O(),
                Z(
                  'span',
                  { key: 0, class: H(`${e.prefixCls}-icon`) },
                  [
                    e.loading
                      ? (O(), Ee(a, { key: 0, spin: 'true' }))
                      : ve(e.$slots, 'icon', { key: 1 }),
                  ],
                  2
                ))
              : Ce('v-if', !0),
            ve(e.$slots, 'default'),
          ],
          10,
          EF
        ))
      : (O(),
        Z(
          'button',
          {
            key: 1,
            class: H([
              e.cls,
              {
                [`${e.prefixCls}-only-icon`]:
                  e.$slots.icon && !e.$slots.default,
              },
            ]),
            type: e.htmlType,
            disabled: e.mergedDisabled,
            onClick:
              t[1] || (t[1] = (...s) => e.handleClick && e.handleClick(...s)),
          },
          [
            e.loading || e.$slots.icon
              ? (O(),
                Z(
                  'span',
                  { key: 0, class: H(`${e.prefixCls}-icon`) },
                  [
                    e.loading
                      ? (O(), Ee(a, { key: 0, spin: !0 }))
                      : ve(e.$slots, 'icon', { key: 1 }),
                  ],
                  2
                ))
              : Ce('v-if', !0),
            ve(e.$slots, 'default'),
          ],
          10,
          PF
        ))
  }
  var qg = Te(MF, [['render', TF]])
  const kF = ce({
    name: 'ButtonGroup',
    props: {
      type: { type: String },
      status: { type: String },
      shape: { type: String },
      size: { type: String },
      disabled: { type: Boolean },
    },
    setup(e) {
      const { type: t, size: n, status: r, disabled: i, shape: o } = tt(e),
        a = ye('btn-group')
      return (
        sn(V4, Je({ type: t, size: n, shape: o, status: r, disabled: i })),
        { prefixCls: a }
      )
    },
  })
  function AF(e, t, n, r, i, o) {
    return (
      O(), Z('div', { class: H(e.prefixCls) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var ld = Te(kF, [['render', AF]])
  const Yr = Object.assign(qg, {
    Group: ld,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + qg.name, qg), e.component(n + ld.name, ld)
    },
  })
  var Xh = ce({
    name: 'InputSearch',
    props: {
      searchButton: { type: Boolean, default: !1 },
      loading: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      size: { type: String },
      buttonText: { type: String },
      buttonProps: { type: Object },
    },
    emits: { search: (e, t) => !0 },
    setup(e, { emit: t, slots: n }) {
      const { size: r } = tt(e),
        i = ye('input-search'),
        { mergedSize: o } = Vr(r),
        a = J(),
        s = (h) => {
          a.value.inputRef && t('search', a.value.inputRef.value, h)
        },
        l = () => {
          var h
          return m(yt, null, [
            e.loading
              ? m(Xr, null, null)
              : m(In, { onClick: s }, { default: () => [m(bb, null, null)] }),
            (h = n.suffix) == null ? void 0 : h.call(n),
          ])
        },
        c = () => {
          var h
          let p = {}
          return (
            e.buttonText || n['button-default'] || n['button-icon']
              ? (p = {
                  default:
                    (h = n['button-default']) != null
                      ? h
                      : e.buttonText
                      ? () => e.buttonText
                      : void 0,
                  icon: n['button-icon'],
                })
              : (p = { icon: () => m(bb, null, null) }),
            m(
              Yr,
              Fe(
                {
                  type: 'primary',
                  class: `${i}-btn`,
                  disabled: e.disabled,
                  size: o.value,
                  loading: e.loading,
                },
                e.buttonProps,
                { onClick: s }
              ),
              p
            )
          )
        }
      return {
        inputRef: a,
        render: () =>
          m(
            sd,
            { ref: a, class: i, size: o.value, disabled: e.disabled },
            {
              prepend: n.prepend,
              prefix: n.prefix,
              suffix: e.searchButton ? n.suffix : l,
              append: e.searchButton ? c : n.append,
            }
          ),
      }
    },
    methods: {
      focus() {
        var e
        ;(e = this.inputRef) == null || e.focus()
      },
      blur() {
        var e
        ;(e = this.inputRef) == null || e.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const $F = ce({
      name: 'IconEye',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-eye`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    OF = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    LF = Se(
      'path',
      {
        'clip-rule': 'evenodd',
        d: 'M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z',
      },
      null,
      -1
    ),
    IF = Se('path', { d: 'M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z' }, null, -1),
    RF = [LF, IF]
  function DF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        RF,
        14,
        OF
      )
    )
  }
  var Xg = Te($F, [['render', DF]])
  const U4 = Object.assign(Xg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Xg.name, Xg)
      },
    }),
    NF = ce({
      name: 'IconEyeInvisible',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-eye-invisible`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    BF = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    FF = Se(
      'path',
      {
        d: 'M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14',
      },
      null,
      -1
    ),
    zF = Se(
      'path',
      { d: 'M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294' },
      null,
      -1
    ),
    VF = [FF, zF]
  function UF(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        VF,
        14,
        BF
      )
    )
  }
  var Yg = Te(NF, [['render', UF]])
  const HF = Object.assign(Yg, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Yg.name, Yg)
      },
    }),
    WF = ce({
      name: 'InputPassword',
      components: {
        IconEye: U4,
        IconEyeInvisible: HF,
        AIconHover: In,
        AInput: sd,
      },
      props: { invisibleButton: { type: Boolean, default: !0 } },
      setup() {
        const e = J(),
          t = J(!0)
        return {
          inputRef: e,
          invisible: t,
          handleInvisible: () => {
            t.value = !t.value
          },
        }
      },
      methods: {
        focus() {
          var e
          ;(e = this.inputRef) == null || e.focus()
        },
        blur() {
          var e
          ;(e = this.inputRef) == null || e.blur()
        },
      },
    })
  function jF(e, t, n, r, i, o) {
    const a = ge('icon-eye'),
      s = ge('icon-eye-invisible'),
      l = ge('a-icon-hover'),
      c = ge('a-input')
    return (
      O(),
      Ee(
        c,
        { ref: 'inputRef', type: e.invisible ? 'password' : 'text' },
        Nn({ _: 2 }, [
          e.$slots.prepend
            ? { name: 'prepend', fn: ze(() => [ve(e.$slots, 'prepend')]) }
            : void 0,
          e.$slots.prefix
            ? { name: 'prefix', fn: ze(() => [ve(e.$slots, 'prefix')]) }
            : void 0,
          e.invisibleButton || e.$slots.suffix
            ? {
                name: 'suffix',
                fn: ze(() => [
                  e.invisibleButton
                    ? (O(),
                      Ee(
                        l,
                        {
                          key: 0,
                          onClick: e.handleInvisible,
                          onMousedown:
                            t[0] || (t[0] = io(() => {}, ['prevent'])),
                          onMouseup: t[1] || (t[1] = io(() => {}, ['prevent'])),
                        },
                        {
                          default: ze(() => [
                            e.invisible
                              ? (O(), Ee(s, { key: 1 }))
                              : (O(), Ee(a, { key: 0 })),
                          ]),
                          _: 1,
                        },
                        8,
                        ['onClick']
                      ))
                    : Ce('v-if', !0),
                  ve(e.$slots, 'suffix'),
                ]),
              }
            : void 0,
          e.$slots.append
            ? { name: 'append', fn: ze(() => [ve(e.$slots, 'append')]) }
            : void 0,
        ]),
        1032,
        ['type']
      )
    )
  }
  var Yh = Te(WF, [['render', jF]])
  const GF = ce({
    name: 'InputGroup',
    setup() {
      return { prefixCls: ye('input-group') }
    },
  })
  function KF(e, t, n, r, i, o) {
    return (
      O(), Z('div', { class: H(e.prefixCls) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var Zh = Te(GF, [['render', KF]])
  const ic = Object.assign(sd, {
    Search: Xh,
    Password: Yh,
    Group: Zh,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + sd.name, sd),
        e.component(n + Zh.name, Zh),
        e.component(n + Xh.name, Xh),
        e.component(n + Yh.name, Yh)
    },
  })
  var qF = Object.defineProperty,
    j2 = Object.getOwnPropertySymbols,
    XF = Object.prototype.hasOwnProperty,
    YF = Object.prototype.propertyIsEnumerable,
    G2 = (e, t, n) =>
      t in e
        ? qF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    Jc = (e, t) => {
      for (var n in t || (t = {})) XF.call(t, n) && G2(e, n, t[n])
      if (j2) for (var n of j2(t)) YF.call(t, n) && G2(e, n, t[n])
      return e
    }
  const ZF = () => {
      const { body: e } = document,
        t = document.documentElement
      let n
      try {
        n = (window.top || window.self || window).document.body
      } catch {}
      return {
        height: Math.max(
          e.scrollHeight,
          e.offsetHeight,
          t.clientHeight,
          t.scrollHeight,
          t.offsetHeight,
          (n == null ? void 0 : n.scrollHeight) || 0,
          (n == null ? void 0 : n.clientHeight) || 0
        ),
        width: Math.max(
          e.scrollWidth,
          e.offsetWidth,
          t.clientWidth,
          t.scrollWidth,
          t.offsetWidth,
          (n == null ? void 0 : n.scrollWidth) || 0,
          (n == null ? void 0 : n.clientWidth) || 0
        ),
      }
    },
    JF = () => {
      const { height: e, width: t } = ZF()
      return {
        width: Math.min(t, window.innerWidth),
        height: Math.min(e, window.innerHeight),
      }
    },
    K2 = (e, t) => {
      var n, r
      const i = e.getBoundingClientRect()
      return {
        top: i.top,
        bottom: i.bottom,
        left: i.left,
        right: i.right,
        scrollTop: i.top - t.top,
        scrollBottom: i.bottom - t.top,
        scrollLeft: i.left - t.left,
        scrollRight: i.right - t.left,
        width: (n = e.offsetWidth) != null ? n : e.clientWidth,
        height: (r = e.offsetHeight) != null ? r : e.clientHeight,
      }
    },
    QF = (e) => {
      switch (e) {
        case 'top':
        case 'tl':
        case 'tr':
          return 'top'
        case 'bottom':
        case 'bl':
        case 'br':
          return 'bottom'
        case 'left':
        case 'lt':
        case 'lb':
          return 'left'
        case 'right':
        case 'rt':
        case 'rb':
          return 'right'
        default:
          return 'top'
      }
    },
    uh = (e, t) => {
      switch (t) {
        case 'top':
          switch (e) {
            case 'bottom':
              return 'top'
            case 'bl':
              return 'tl'
            case 'br':
              return 'tr'
            default:
              return e
          }
        case 'bottom':
          switch (e) {
            case 'top':
              return 'bottom'
            case 'tl':
              return 'bl'
            case 'tr':
              return 'br'
            default:
              return e
          }
        case 'left':
          switch (e) {
            case 'right':
              return 'left'
            case 'rt':
              return 'lt'
            case 'rb':
              return 'lb'
            default:
              return e
          }
        case 'right':
          switch (e) {
            case 'left':
              return 'right'
            case 'lt':
              return 'rt'
            case 'lb':
              return 'rb'
            default:
              return e
          }
        default:
          return e
      }
    },
    e7 = (
      e,
      t,
      {
        containerRect: n,
        triggerRect: r,
        popupRect: i,
        offset: o,
        translate: a,
      }
    ) => {
      const s = QF(e),
        l = JF(),
        c = {
          top: n.top + t.top,
          bottom: l.height - (n.top + t.top + i.height),
          left: n.left + t.left,
          right: l.width - (n.left + t.left + i.width),
        }
      let d = e
      if (s === 'top' && c.top < 0)
        if (r.top > i.height) t.top = -n.top
        else {
          const h = Qc('bottom', r, i, { offset: o, translate: a })
          l.height - (n.top + h.top + i.height) > 0 &&
            ((d = uh(e, 'bottom')), (t.top = h.top))
        }
      if (s === 'bottom' && c.bottom < 0)
        if (l.height - r.bottom > i.height)
          t.top = -n.top + (l.height - i.height)
        else {
          const h = Qc('top', r, i, { offset: o, translate: a })
          n.top + h.top > 0 && ((d = uh(e, 'top')), (t.top = h.top))
        }
      if (s === 'left' && c.left < 0)
        if (r.left > i.width) t.left = -n.left
        else {
          const h = Qc('right', r, i, { offset: o, translate: a })
          l.width - (n.left + h.left + i.width) > 0 &&
            ((d = uh(e, 'right')), (t.left = h.left))
        }
      if (s === 'right' && c.right < 0)
        if (l.width - r.right > i.width) t.left = -n.left + (l.width - i.width)
        else {
          const h = Qc('left', r, i, { offset: o, translate: a })
          n.left + h.left > 0 && ((d = uh(e, 'left')), (t.left = h.left))
        }
      return (
        (s === 'top' || s === 'bottom') &&
          (c.left < 0
            ? (t.left = -n.left)
            : c.right < 0 && (t.left = -n.left + (l.width - i.width))),
        (s === 'left' || s === 'right') &&
          (c.top < 0
            ? (t.top = -n.top)
            : c.bottom < 0 && (t.top = -n.top + (l.height - i.height))),
        { popupPosition: t, position: d }
      )
    },
    Qc = (e, t, n, { offset: r = 0, translate: i = [0, 0] } = {}) => {
      var o
      const a = (o = Ft(i) ? i : i[e]) != null ? o : [0, 0]
      switch (e) {
        case 'top':
          return {
            left:
              t.scrollLeft +
              Math.round(t.width / 2) -
              Math.round(n.width / 2) +
              a[0],
            top: t.scrollTop - n.height - r + a[1],
          }
        case 'tl':
          return {
            left: t.scrollLeft + a[0],
            top: t.scrollTop - n.height - r + a[1],
          }
        case 'tr':
          return {
            left: t.scrollRight - n.width + a[0],
            top: t.scrollTop - n.height - r + a[1],
          }
        case 'bottom':
          return {
            left:
              t.scrollLeft +
              Math.round(t.width / 2) -
              Math.round(n.width / 2) +
              a[0],
            top: t.scrollBottom + r + a[1],
          }
        case 'bl':
          return { left: t.scrollLeft + a[0], top: t.scrollBottom + r + a[1] }
        case 'br':
          return {
            left: t.scrollRight - n.width + a[0],
            top: t.scrollBottom + r + a[1],
          }
        case 'left':
          return {
            left: t.scrollLeft - n.width - r + a[0],
            top:
              t.scrollTop +
              Math.round(t.height / 2) -
              Math.round(n.height / 2) +
              a[1],
          }
        case 'lt':
          return {
            left: t.scrollLeft - n.width - r + a[0],
            top: t.scrollTop + a[1],
          }
        case 'lb':
          return {
            left: t.scrollLeft - n.width - r + a[0],
            top: t.scrollBottom - n.height + a[1],
          }
        case 'right':
          return {
            left: t.scrollRight + r + a[0],
            top:
              t.scrollTop +
              Math.round(t.height / 2) -
              Math.round(n.height / 2) +
              a[1],
          }
        case 'rt':
          return { left: t.scrollRight + r + a[0], top: t.scrollTop + a[1] }
        case 'rb':
          return {
            left: t.scrollRight + r + a[0],
            top: t.scrollBottom - n.height + a[1],
          }
        default:
          return { left: 0, top: 0 }
      }
    },
    t7 = (e) => {
      let t = '0'
      ;['top', 'bottom'].includes(e)
        ? (t = '50%')
        : ['left', 'lt', 'lb', 'tr', 'br'].includes(e) && (t = '100%')
      let n = '0'
      return (
        ['left', 'right'].includes(e)
          ? (n = '50%')
          : ['top', 'tl', 'tr', 'lt', 'rt'].includes(e) && (n = '100%'),
        `${t} ${n}`
      )
    },
    n7 = (
      e,
      t,
      n,
      r,
      {
        offset: i = 0,
        translate: o = [0, 0],
        customStyle: a = {},
        autoFitPosition: s = !1,
      } = {}
    ) => {
      let l = e,
        c = Qc(e, n, r, { offset: i, translate: o })
      if (s) {
        const h = e7(e, c, {
          containerRect: t,
          popupRect: r,
          triggerRect: n,
          offset: i,
          translate: o,
        })
        ;(c = h.popupPosition), (l = h.position)
      }
      return {
        style: Jc({ left: `${c.left}px`, top: `${c.top}px` }, a),
        position: l,
      }
    },
    r7 = (e, t, n, { customStyle: r = {} }) => {
      if (['top', 'tl', 'tr', 'bottom', 'bl', 'br'].includes(e)) {
        let o = Math.abs(t.scrollLeft + t.width / 2 - n.scrollLeft)
        return (
          o > n.width - 8 &&
            (t.width > n.width ? (o = n.width / 2) : (o = n.width - 8)),
          ['top', 'tl', 'tr'].includes(e)
            ? Jc(
                {
                  left: `${o}px`,
                  bottom: '0',
                  transform: 'translate(-50%,50%) rotate(45deg)',
                },
                r
              )
            : Jc(
                {
                  left: `${o}px`,
                  top: '0',
                  transform: 'translate(-50%,-50%) rotate(45deg)',
                },
                r
              )
        )
      }
      let i = Math.abs(t.scrollTop + t.height / 2 - n.scrollTop)
      return (
        i > n.height - 8 &&
          (t.height > n.height ? (i = n.height / 2) : (i = n.height - 8)),
        ['left', 'lt', 'lb'].includes(e)
          ? Jc(
              {
                top: `${i}px`,
                right: '0',
                transform: 'translate(50%,-50%) rotate(45deg)',
              },
              r
            )
          : Jc(
              {
                top: `${i}px`,
                left: '0',
                transform: 'translate(-50%,-50%) rotate(45deg)',
              },
              r
            )
      )
    },
    i7 = (e) =>
      e.scrollHeight > e.offsetHeight || e.scrollWidth > e.offsetWidth,
    q2 = (e) => {
      var t
      const n = []
      let r = e
      for (; r && r !== document.documentElement; )
        i7(r) && n.push(r), (r = (t = r.parentElement) != null ? t : void 0)
      return n
    },
    H4 = () => {
      const e = {},
        t = J(),
        n = () => {
          const r = O4(e.value)
          r !== t.value && (t.value = r)
        }
      return Wt(() => n()), Zr(() => n()), { children: e, firstElement: t }
    }
  var ks = ce({
    name: 'ResizeObserver',
    props: { watchOnUpdated: Boolean },
    emits: ['resize'],
    setup(e, { emit: t, slots: n }) {
      const { children: r, firstElement: i } = H4()
      let o
      const a = (l) => {
          l &&
            ((o = new Vv((c) => {
              const d = c[0]
              t('resize', d)
            })),
            o.observe(l))
        },
        s = () => {
          o && (o.disconnect(), (o = null))
        }
      return (
        pt(i, (l) => {
          o && s(), l && a(l)
        }),
        Pr(() => {
          o && s()
        }),
        () => {
          var l
          return (
            (r.value = (l = n.default) == null ? void 0 : l.call(n)), r.value
          )
        }
      )
    },
  })
  function Mo(e, t) {
    const n = J(e[t])
    return (
      Zr(() => {
        const r = e[t]
        n.value !== r && (n.value = r)
      }),
      n
    )
  }
  const X2 = Symbol('ArcoTrigger'),
    o7 = 1e3,
    a7 = 5e3,
    s7 = 1
  class l7 {
    constructor() {
      ;(this.popupStack = {
        popup: new Set(),
        dialog: new Set(),
        message: new Set(),
      }),
        (this.getNextZIndex = (t) =>
          (t === 'message'
            ? Array.from(this.popupStack.message).pop() || a7
            : Array.from(this.popupStack.popup).pop() || o7) + s7),
        (this.add = (t) => {
          const n = this.getNextZIndex(t)
          return (
            this.popupStack[t].add(n),
            t === 'dialog' && this.popupStack.popup.add(n),
            n
          )
        }),
        (this.delete = (t, n) => {
          this.popupStack[n].delete(t),
            n === 'dialog' && this.popupStack.popup.delete(t)
        }),
        (this.isLastDialog = (t) =>
          this.popupStack.dialog.size > 1
            ? t === Array.from(this.popupStack.dialog).pop()
            : !0)
    }
  }
  const Zg = new l7()
  function oc(e, { visible: t, runOnMounted: n } = {}) {
    const r = J(0),
      i = () => {
        r.value = Zg.add(e)
      },
      o = () => {
        Zg.delete(r.value, e)
      },
      a = () => (e === 'dialog' ? Zg.isLastDialog(r.value) : !1)
    return (
      pt(
        () => (t == null ? void 0 : t.value),
        (s) => {
          s ? i() : o()
        },
        { immediate: !0 }
      ),
      n &&
        (Wt(() => {
          i()
        }),
        Pr(() => {
          o()
        })),
      { zIndex: y_(r), open: i, close: o, isLastDialog: a }
    )
  }
  const u7 = ({ elementRef: e, onResize: t }) => {
    let n
    return {
      createResizeObserver: () => {
        e.value &&
          ((n = new Vv((o) => {
            const a = o[0]
            xt(t) && t(a)
          })),
          n.observe(e.value))
      },
      destroyResizeObserver: () => {
        n && (n.disconnect(), (n = null))
      },
    }
  }
  var N_ = ce({
    name: 'ClientOnly',
    setup(e, { slots: t }) {
      const n = J(!1)
      return (
        Wt(() => (n.value = !0)),
        () => {
          var r
          return n.value ? ((r = t.default) == null ? void 0 : r.call(t)) : null
        }
      )
    },
  })
  const B_ = ({
    popupContainer: e,
    visible: t,
    defaultContainer: n = 'body',
    documentContainer: r,
  }) => {
    const i = J(e.value),
      o = J(),
      a = () => {
        const s = Yo(e.value),
          l = s ? e.value : n,
          c = s ?? (r ? document.documentElement : Yo(n))
        l !== i.value && (i.value = l), c !== o.value && (o.value = c)
      }
    return (
      Wt(() => a()),
      pt(t, (s) => {
        i.value !== e.value && s && a()
      }),
      { teleportContainer: i, containerRef: o }
    )
  }
  var c7 = Object.defineProperty,
    d7 = Object.defineProperties,
    f7 = Object.getOwnPropertyDescriptors,
    Y2 = Object.getOwnPropertySymbols,
    h7 = Object.prototype.hasOwnProperty,
    p7 = Object.prototype.propertyIsEnumerable,
    Z2 = (e, t, n) =>
      t in e
        ? c7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    v7 = (e, t) => {
      for (var n in t || (t = {})) h7.call(t, n) && Z2(e, n, t[n])
      if (Y2) for (var n of Y2(t)) p7.call(t, n) && Z2(e, n, t[n])
      return e
    },
    m7 = (e, t) => d7(e, f7(t))
  const g7 = [
    'onClick',
    'onMouseenter',
    'onMouseleave',
    'onFocusin',
    'onFocusout',
    'onContextmenu',
  ]
  var Jg = ce({
    name: 'Trigger',
    inheritAttrs: !1,
    props: {
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      trigger: { type: [String, Array], default: 'hover' },
      position: { type: String, default: 'bottom' },
      disabled: { type: Boolean, default: !1 },
      popupOffset: { type: Number, default: 0 },
      popupTranslate: { type: [Array, Object] },
      showArrow: { type: Boolean, default: !1 },
      alignPoint: { type: Boolean, default: !1 },
      popupHoverStay: { type: Boolean, default: !0 },
      blurToClose: { type: Boolean, default: !0 },
      clickToClose: { type: Boolean, default: !0 },
      clickOutsideToClose: { type: Boolean, default: !0 },
      unmountOnClose: { type: Boolean, default: !0 },
      contentClass: { type: [String, Array, Object] },
      contentStyle: { type: Object },
      arrowClass: { type: [String, Array, Object] },
      arrowStyle: { type: Object },
      popupStyle: { type: Object },
      animationName: { type: String, default: 'fade-in' },
      duration: { type: [Number, Object] },
      mouseEnterDelay: { type: Number, default: 100 },
      mouseLeaveDelay: { type: Number, default: 100 },
      focusDelay: { type: Number, default: 0 },
      autoFitPopupWidth: { type: Boolean, default: !1 },
      autoFitPopupMinWidth: { type: Boolean, default: !1 },
      autoFixPosition: { type: Boolean, default: !0 },
      popupContainer: { type: [String, Object] },
      updateAtScroll: { type: Boolean, default: !1 },
      autoFitTransformOrigin: { type: Boolean, default: !1 },
      hideEmpty: { type: Boolean, default: !1 },
      openedClass: { type: [String, Array, Object] },
      autoFitPosition: { type: Boolean, default: !0 },
      renderToBody: { type: Boolean, default: !0 },
      preventFocus: { type: Boolean, default: !1 },
      scrollToClose: { type: Boolean, default: !1 },
    },
    emits: {
      'update:popupVisible': (e) => !0,
      popupVisibleChange: (e) => !0,
      show: () => !0,
      hide: () => !0,
      resize: () => !0,
    },
    setup(e, { emit: t, slots: n, attrs: r }) {
      const { popupContainer: i } = tt(e),
        o = ye('trigger'),
        a = C(() => xr(r, g7)),
        s = zt(di, void 0),
        l = C(() => [].concat(e.trigger)),
        c = new Set(),
        d = zt(X2, void 0),
        { children: h, firstElement: p } = H4(),
        v = J(),
        g = J(e.defaultPopupVisible),
        _ = J(e.position),
        b = J({}),
        y = J({}),
        M = J({}),
        x = J(),
        w = J({ top: 0, left: 0 }),
        E = C(() => {
          var he
          return (he = e.popupVisible) != null ? he : g.value
        }),
        { teleportContainer: P, containerRef: A } = B_({
          popupContainer: i,
          visible: E,
          documentContainer: !0,
        }),
        { zIndex: F } = oc('popup', { visible: E })
      let T = 0,
        k = !1,
        R = !1
      const j = () => {
          T && (window.clearTimeout(T), (T = 0))
        },
        N = (he) => {
          if (e.alignPoint) {
            const { pageX: de, pageY: xe } = he
            w.value = { top: xe, left: de }
          }
        },
        I = () => {
          if (!p.value || !v.value || !A.value) return
          const he = A.value.getBoundingClientRect(),
            de = e.alignPoint
              ? {
                  top: w.value.top,
                  bottom: w.value.top,
                  left: w.value.left,
                  right: w.value.left,
                  scrollTop: w.value.top,
                  scrollBottom: w.value.top,
                  scrollLeft: w.value.left,
                  scrollRight: w.value.left,
                  width: 0,
                  height: 0,
                }
              : K2(p.value, he),
            xe = () => K2(v.value, he),
            ne = xe(),
            { style: Le, position: et } = n7(e.position, he, de, ne, {
              offset: e.popupOffset,
              translate: e.popupTranslate,
              customStyle: e.popupStyle,
              autoFitPosition: e.autoFitPosition,
            })
          e.autoFitTransformOrigin && (y.value = { transformOrigin: t7(et) }),
            e.autoFitPopupMinWidth
              ? (Le.minWidth = `${de.width}px`)
              : e.autoFitPopupWidth && (Le.width = `${de.width}px`),
            _.value !== et && (_.value = et),
            (b.value = Le),
            e.showArrow &&
              hn(() => {
                M.value = r7(et, de, xe(), { customStyle: e.arrowStyle })
              })
        },
        B = (he, de) => {
          if (he === E.value && T === 0) return
          const xe = () => {
            ;(g.value = he),
              t('update:popupVisible', he),
              t('popupVisibleChange', he),
              he &&
                hn(() => {
                  I()
                })
          }
          de ? (j(), he !== E.value && (T = window.setTimeout(xe, de))) : xe()
        },
        V = (he) => {
          var de
          ;(de = r.onClick) == null || de.call(r, he),
            !(e.disabled || (E.value && !e.clickToClose)) &&
              (l.value.includes('click')
                ? (N(he), B(!E.value))
                : l.value.includes('contextMenu') && E.value && B(!1))
        },
        L = (he) => {
          var de
          ;(de = r.onMouseenter) == null || de.call(r, he),
            !(e.disabled || !l.value.includes('hover')) &&
              (N(he), B(!0, e.mouseEnterDelay))
        },
        W = (he) => {
          d == null || d.onMouseenter(he), L(he)
        },
        Y = (he) => {
          var de
          ;(de = r.onMouseleave) == null || de.call(r, he),
            !(e.disabled || !l.value.includes('hover')) &&
              B(!1, e.mouseLeaveDelay)
        },
        U = (he) => {
          d == null || d.onMouseleave(he), Y(he)
        },
        le = (he) => {
          var de
          ;(de = r.onFocusin) == null || de.call(r, he),
            !(e.disabled || !l.value.includes('focus')) && B(!0, e.focusDelay)
        },
        q = (he) => {
          var de
          ;(de = r.onFocusout) == null || de.call(r, he),
            !(e.disabled || !l.value.includes('focus')) &&
              e.blurToClose &&
              B(!1)
        },
        oe = (he) => {
          var de
          ;(de = r.onContextmenu) == null || de.call(r, he),
            !(
              e.disabled ||
              !l.value.includes('contextMenu') ||
              (E.value && !e.clickToClose)
            ) && (N(he), B(!E.value), he.preventDefault())
        }
      sn(
        X2,
        Je({
          onMouseenter: W,
          onMouseleave: U,
          addChildRef: (he) => {
            c.add(he), d == null || d.addChildRef(he)
          },
          removeChildRef: (he) => {
            c.delete(he), d == null || d.removeChildRef(he)
          },
        })
      )
      const me = () => {
          kn(document.documentElement, 'mousedown', Ve), (k = !1)
        },
        Re = Mo(n, 'content'),
        qe = C(() => {
          var he
          return (
            e.hideEmpty && HB((he = Re.value) == null ? void 0 : he.call(Re))
          )
        }),
        Ve = (he) => {
          var de, xe, ne
          if (
            !(
              ((de = p.value) != null && de.contains(he.target)) ||
              ((xe = v.value) != null && xe.contains(he.target))
            )
          ) {
            for (const Le of c)
              if ((ne = Le.value) != null && ne.contains(he.target)) return
            me(), B(!1)
          }
        },
        nt = Gu(() => {
          E.value &&
            (e.scrollToClose || (s != null && s.scrollToClose) ? B(!1) : I())
        }),
        We = () => {
          kn(window, 'scroll', D), (R = !1)
        },
        D = Gu(() => {
          B(!1), We()
        }),
        G = () => {
          E.value && I()
        },
        z = () => {
          G(), t('resize')
        },
        ie = (he) => {
          e.preventFocus && he.preventDefault()
        }
      d == null || d.addChildRef(v)
      const ae = C(() => (E.value ? e.openedClass : void 0))
      let re
      pt(E, (he) => {
        if (
          (e.clickOutsideToClose &&
            (!he && k
              ? me()
              : he &&
                !k &&
                (Cn(document.documentElement, 'mousedown', Ve), (k = !0))),
          (e.scrollToClose || (s != null && s.scrollToClose)) &&
            (Cn(window, 'scroll', D), (R = !0)),
          e.updateAtScroll || (s != null && s.updateAtScroll))
        ) {
          if (he) {
            re = q2(p.value)
            for (const de of re) de.addEventListener('scroll', nt)
          } else if (re) {
            for (const de of re) de.removeEventListener('scroll', nt)
            re = void 0
          }
        }
        he && ($e.value = !0)
      }),
        pt(
          () => [e.autoFitPopupWidth, e.autoFitPopupMinWidth],
          () => {
            E.value && I()
          }
        )
      const { createResizeObserver: pe, destroyResizeObserver: we } = u7({
        elementRef: A,
        onResize: G,
      })
      Wt(() => {
        if (
          (pe(),
          E.value &&
            (I(),
            e.clickOutsideToClose &&
              !k &&
              (Cn(document.documentElement, 'mousedown', Ve), (k = !0)),
            e.updateAtScroll || (s != null && s.updateAtScroll)))
        ) {
          re = q2(p.value)
          for (const he of re) he.addEventListener('scroll', nt)
        }
      }),
        Zr(() => {
          E.value && I()
        }),
        QT(() => {
          B(!1)
        }),
        Pr(() => {
          if (
            (d == null || d.removeChildRef(v), we(), k && me(), R && We(), re)
          ) {
            for (const he of re) he.removeEventListener('scroll', nt)
            re = void 0
          }
        })
      const $e = J(E.value),
        Ae = J(!1),
        ft = () => {
          Ae.value = !0
        },
        Q = () => {
          ;(Ae.value = !1), E.value && t('show')
        },
        X = () => {
          ;(Ae.value = !1), E.value || (($e.value = !1), t('hide'))
        }
      return () => {
        var he, de
        return (
          (h.value =
            (de = (he = n.default) == null ? void 0 : he.call(n)) != null
              ? de
              : []),
          A4(h.value, {
            class: ae.value,
            onClick: V,
            onMouseenter: L,
            onMouseleave: Y,
            onFocusin: le,
            onFocusout: q,
            onContextmenu: oe,
          }),
          m(yt, null, [
            e.autoFixPosition
              ? m(ks, { onResize: z }, { default: () => [h.value] })
              : h.value,
            m(N_, null, {
              default: () => [
                m(
                  Dv,
                  { to: P.value, disabled: !e.renderToBody },
                  {
                    default: () => [
                      (!e.unmountOnClose || E.value || $e.value) &&
                        !qe.value &&
                        m(
                          ks,
                          { onResize: G },
                          {
                            default: () => [
                              m(
                                'div',
                                Fe(
                                  {
                                    ref: v,
                                    class: [
                                      `${o}-popup`,
                                      `${o}-position-${_.value}`,
                                    ],
                                    style: m7(v7({}, b.value), {
                                      zIndex: F.value,
                                      pointerEvents: Ae.value ? 'none' : 'auto',
                                    }),
                                    'trigger-placement': _.value,
                                    onMouseenter: W,
                                    onMouseleave: U,
                                    onMousedown: ie,
                                  },
                                  a.value
                                ),
                                [
                                  m(
                                    Fr,
                                    {
                                      name: e.animationName,
                                      duration: e.duration,
                                      appear: !0,
                                      onBeforeEnter: ft,
                                      onAfterEnter: Q,
                                      onBeforeLeave: ft,
                                      onAfterLeave: X,
                                    },
                                    {
                                      default: () => {
                                        var xe
                                        return [
                                          ro(
                                            m(
                                              'div',
                                              {
                                                class: `${o}-popup-wrapper`,
                                                style: y.value,
                                              },
                                              [
                                                m(
                                                  'div',
                                                  {
                                                    class: [
                                                      `${o}-content`,
                                                      e.contentClass,
                                                    ],
                                                    style: e.contentStyle,
                                                  },
                                                  [
                                                    (xe = n.content) == null
                                                      ? void 0
                                                      : xe.call(n),
                                                  ]
                                                ),
                                                e.showArrow &&
                                                  m(
                                                    'div',
                                                    {
                                                      ref: x,
                                                      class: [
                                                        `${o}-arrow`,
                                                        e.arrowClass,
                                                      ],
                                                      style: M.value,
                                                    },
                                                    null
                                                  ),
                                              ]
                                            ),
                                            [[oo, E.value]]
                                          ),
                                        ]
                                      },
                                    }
                                  ),
                                ]
                              ),
                            ],
                          }
                        ),
                    ],
                  }
                ),
              ],
            }),
          ])
        )
      }
    },
  })
  const Mr = Object.assign(Jg, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Jg.name, Jg)
      },
    }),
    y7 = ce({
      name: 'IconEmpty',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-empty`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    b7 = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    _7 = Se(
      'path',
      {
        d: 'M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z',
      },
      null,
      -1
    ),
    S7 = [_7]
  function C7(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        S7,
        14,
        b7
      )
    )
  }
  var Qg = Te(y7, [['render', C7]])
  const w7 = Object.assign(Qg, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + Qg.name, Qg)
    },
  })
  var Jh = ce({
    name: 'Empty',
    props: {
      description: String,
      imgSrc: String,
      inConfigProvider: { type: Boolean, default: !1 },
    },
    setup(e, { slots: t }) {
      const n = ye('empty'),
        { t: r } = Vn(),
        i = zt(di, void 0)
      return () => {
        var o, a, s, l
        return !e.inConfigProvider &&
          i != null &&
          i.slots.empty &&
          !(t.image || e.imgSrc || e.description)
          ? i.slots.empty({ component: 'empty' })
          : m('div', { class: n }, [
              m('div', { class: `${n}-image` }, [
                (a = (o = t.image) == null ? void 0 : o.call(t)) != null
                  ? a
                  : e.imgSrc
                  ? m(
                      'img',
                      { src: e.imgSrc, alt: e.description || 'empty' },
                      null
                    )
                  : m(w7, null, null),
              ]),
              m('div', { class: `${n}-description` }, [
                (l = (s = t.default) == null ? void 0 : s.call(t)) != null
                  ? l
                  : e.description || r('empty.description'),
              ]),
            ])
      }
    },
  })
  const Ls = Object.assign(Jh, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Jh.name, Jh)
      },
    }),
    x7 = 5
  var M7 = ce({
      name: 'DotLoading',
      props: { size: { type: Number } },
      setup(e) {
        const t = ye('dot-loading')
        return () => {
          const n = e.size
            ? { width: `${e.size}px`, height: `${e.size}px` }
            : {}
          return m(
            'div',
            {
              class: t,
              style: {
                width: e.size ? `${e.size * 7}px` : void 0,
                height: e.size ? `${e.size}px` : void 0,
              },
            },
            [
              Array(x7)
                .fill(1)
                .map((r, i) =>
                  m('div', { class: `${t}-item`, key: i, style: n }, null)
                ),
            ]
          )
        }
      },
    }),
    e0 = ce({
      name: 'Spin',
      props: {
        size: { type: Number },
        loading: Boolean,
        dot: Boolean,
        tip: String,
        hideIcon: { type: Boolean, default: !1 },
      },
      setup(e, { slots: t }) {
        const n = ye('spin'),
          r = zt(di, void 0),
          i = C(() => [
            n,
            {
              [`${n}-loading`]: e.loading,
              [`${n}-with-tip`]: e.tip && !t.default,
            },
          ]),
          o = () => {
            if (t.icon) {
              const s = Iu(t.icon())
              if (s) return Ti(s, { spin: !0 })
            }
            return t.element
              ? t.element()
              : e.dot
              ? m(M7, { size: e.size }, null)
              : r != null && r.slots.loading
              ? r.slots.loading()
              : m(Xr, { spin: !0, size: e.size }, null)
          },
          a = () => {
            var s, l, c
            const d = e.size ? { fontSize: `${e.size}px` } : void 0,
              h = !!((s = t.tip) != null ? s : e.tip)
            return m(yt, null, [
              !e.hideIcon && m('div', { class: `${n}-icon`, style: d }, [o()]),
              h &&
                m('div', { class: `${n}-tip` }, [
                  (c = (l = t.tip) == null ? void 0 : l.call(t)) != null
                    ? c
                    : e.tip,
                ]),
            ])
          }
        return () =>
          m('div', { class: i.value }, [
            t.default
              ? m(yt, null, [
                  t.default(),
                  e.loading &&
                    m('div', { class: `${n}-mask` }, [
                      m('div', { class: `${n}-mask-icon` }, [a()]),
                    ]),
                ])
              : a(),
          ])
      },
    })
  const Do = Object.assign(e0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + e0.name, e0)
      },
    }),
    E7 = ce({
      name: 'Thumb',
      props: {
        data: { type: Object },
        direction: { type: String, default: 'horizontal' },
        alwaysShow: { type: Boolean, default: !1 },
        both: { type: Boolean, default: !1 },
      },
      emits: ['scroll'],
      setup(e, { emit: t }) {
        const n = ye('scrollbar'),
          r = J(!1),
          i = J(),
          o = J(),
          a = C(() =>
            e.direction === 'horizontal'
              ? {
                  size: 'width',
                  direction: 'left',
                  offset: 'offsetWidth',
                  client: 'clientX',
                }
              : {
                  size: 'height',
                  direction: 'top',
                  offset: 'offsetHeight',
                  client: 'clientY',
                }
          ),
          s = J(0),
          l = J(!1),
          c = J(0),
          d = C(() => {
            var M, x
            return {
              [a.value.size]: `${
                (x = (M = e.data) == null ? void 0 : M.thumbSize) != null
                  ? x
                  : 0
              }px`,
              [a.value.direction]: `${s.value}px`,
            }
          }),
          h = (M) => {
            M.preventDefault(),
              o.value &&
                ((c.value =
                  M[a.value.client] -
                  o.value.getBoundingClientRect()[a.value.direction]),
                (l.value = !0),
                Cn(window, 'mousemove', g),
                Cn(window, 'mouseup', _),
                Cn(window, 'contextmenu', _))
          },
          p = (M) => {
            var x, w, E, P
            if ((M.preventDefault(), o.value)) {
              const A = v(
                M[a.value.client] >
                  o.value.getBoundingClientRect()[a.value.direction]
                  ? s.value +
                      ((w = (x = e.data) == null ? void 0 : x.thumbSize) != null
                        ? w
                        : 0)
                  : s.value -
                      ((P = (E = e.data) == null ? void 0 : E.thumbSize) != null
                        ? P
                        : 0)
              )
              A !== s.value && ((s.value = A), t('scroll', A))
            }
          },
          v = (M) => (M < 0 ? 0 : e.data && M > e.data.max ? e.data.max : M),
          g = (M) => {
            if (i.value && o.value) {
              const x = v(
                M[a.value.client] -
                  i.value.getBoundingClientRect()[a.value.direction] -
                  c.value
              )
              x !== s.value && ((s.value = x), t('scroll', x))
            }
          },
          _ = () => {
            ;(l.value = !1),
              kn(window, 'mousemove', g),
              kn(window, 'mouseup', _)
          },
          b = (M) => {
            l.value || ((M = v(M)), M !== s.value && (s.value = M))
          },
          y = C(() => [
            `${n}-thumb`,
            `${n}-thumb-direction-${e.direction}`,
            { [`${n}-thumb-dragging`]: l.value },
          ])
        return {
          visible: r,
          trackRef: i,
          thumbRef: o,
          prefixCls: n,
          thumbCls: y,
          thumbStyle: d,
          handleThumbMouseDown: h,
          handleTrackClick: p,
          setOffset: b,
        }
      },
    })
  function P7(e, t, n, r, i, o) {
    return (
      O(),
      Ee(Fr, null, {
        default: ze(() => [
          Se(
            'div',
            {
              ref: 'trackRef',
              class: H([
                `${e.prefixCls}-track`,
                `${e.prefixCls}-track-direction-${e.direction}`,
              ]),
              onMousedown:
                t[1] ||
                (t[1] = io(
                  (...a) => e.handleTrackClick && e.handleTrackClick(...a),
                  ['self']
                )),
            },
            [
              Se(
                'div',
                {
                  ref: 'thumbRef',
                  class: H(e.thumbCls),
                  style: at(e.thumbStyle),
                  onMousedown:
                    t[0] ||
                    (t[0] = (...a) =>
                      e.handleThumbMouseDown && e.handleThumbMouseDown(...a)),
                },
                [Se('div', { class: H(`${e.prefixCls}-thumb-bar`) }, null, 2)],
                38
              ),
            ],
            34
          ),
        ]),
        _: 1,
      })
    )
  }
  var T7 = Te(E7, [['render', P7]])
  const J2 = 20,
    ch = 15,
    k7 = ce({
      name: 'Scrollbar',
      components: { ResizeObserver: ks, Thumb: T7 },
      inheritAttrs: !1,
      props: {
        type: { type: String, default: 'embed' },
        outerClass: [String, Object, Array],
        outerStyle: { type: [String, Object, Array] },
        hide: { type: Boolean, default: !1 },
        disableHorizontal: { type: Boolean, default: !1 },
        disableVertical: { type: Boolean, default: !1 },
      },
      emits: { scroll: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('scrollbar'),
          r = J(),
          i = J(),
          o = J(),
          a = J(),
          s = J(),
          l = J(!1),
          c = J(!1),
          d = C(() => l.value && !e.disableHorizontal),
          h = C(() => c.value && !e.disableVertical),
          p = J(!1),
          v = () => {
            var w, E, P, A, F, T
            if (r.value) {
              const {
                clientWidth: k,
                clientHeight: R,
                offsetWidth: j,
                offsetHeight: N,
                scrollWidth: I,
                scrollHeight: B,
                scrollTop: V,
                scrollLeft: L,
              } = r.value
              ;(l.value = I > k),
                (c.value = B > R),
                (p.value = d.value && h.value)
              const W = e.type === 'embed' && p.value ? j - ch : j,
                Y = e.type === 'embed' && p.value ? N - ch : N,
                U = Math.round(W / Math.min(I / k, W / J2)),
                le = W - U,
                q = (I - k) / le,
                oe = Math.round(Y / Math.min(B / R, Y / J2)),
                te = Y - oe,
                ue = (B - R) / te
              if (
                ((i.value = { ratio: q, thumbSize: U, max: le }),
                (o.value = { ratio: ue, thumbSize: oe, max: te }),
                V > 0)
              ) {
                const me = Math.round(
                  V /
                    ((E = (w = o.value) == null ? void 0 : w.ratio) != null
                      ? E
                      : 1)
                )
                ;(P = s.value) == null || P.setOffset(me)
              }
              if (L > 0) {
                const me = Math.round(
                  L /
                    ((F = (A = o.value) == null ? void 0 : A.ratio) != null
                      ? F
                      : 1)
                )
                ;(T = a.value) == null || T.setOffset(me)
              }
            }
          }
        Wt(() => {
          v()
        })
        const g = () => {
            v()
          },
          _ = (w) => {
            var E, P, A, F, T, k
            if (r.value) {
              if (d.value && !e.disableHorizontal) {
                const R = Math.round(
                  r.value.scrollLeft /
                    ((P = (E = i.value) == null ? void 0 : E.ratio) != null
                      ? P
                      : 1)
                )
                ;(A = a.value) == null || A.setOffset(R)
              }
              if (h.value && !e.disableVertical) {
                const R = Math.round(
                  r.value.scrollTop /
                    ((T = (F = o.value) == null ? void 0 : F.ratio) != null
                      ? T
                      : 1)
                )
                ;(k = s.value) == null || k.setOffset(R)
              }
            }
            t('scroll', w)
          },
          b = (w) => {
            var E, P
            r.value &&
              r.value.scrollTo({
                left:
                  w *
                  ((P = (E = i.value) == null ? void 0 : E.ratio) != null
                    ? P
                    : 1),
              })
          },
          y = (w) => {
            var E, P
            r.value &&
              r.value.scrollTo({
                top:
                  w *
                  ((P = (E = o.value) == null ? void 0 : E.ratio) != null
                    ? P
                    : 1),
              })
          },
          M = C(() => {
            const w = {}
            return (
              e.type === 'track' &&
                (d.value && (w.paddingBottom = `${ch}px`),
                h.value && (w.paddingRight = `${ch}px`)),
              [w, e.outerStyle]
            )
          }),
          x = C(() => [
            `${n}`,
            `${n}-type-${e.type}`,
            { [`${n}-both`]: p.value },
            e.outerClass,
          ])
        return {
          prefixCls: n,
          cls: x,
          style: M,
          containerRef: r,
          horizontalThumbRef: a,
          verticalThumbRef: s,
          horizontalData: i,
          verticalData: o,
          isBoth: p,
          hasHorizontalScrollbar: d,
          hasVerticalScrollbar: h,
          handleResize: g,
          handleScroll: _,
          handleHorizontalScroll: b,
          handleVerticalScroll: y,
        }
      },
      methods: {
        scrollTo(e, t) {
          var n, r
          Ht(e)
            ? (n = this.$refs.containerRef) == null || n.scrollTo(e)
            : (e || t) &&
              ((r = this.$refs.containerRef) == null || r.scrollTo(e, t))
        },
        scrollTop(e) {
          var t
          ;(t = this.$refs.containerRef) == null || t.scrollTo({ top: e })
        },
        scrollLeft(e) {
          var t
          ;(t = this.$refs.containerRef) == null || t.scrollTo({ left: e })
        },
      },
    })
  function A7(e, t, n, r, i, o) {
    const a = ge('ResizeObserver'),
      s = ge('thumb')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls), style: at(e.style) },
        [
          m(
            a,
            { onResize: e.handleResize },
            {
              default: ze(() => [
                Se(
                  'div',
                  Fe(
                    { ref: 'containerRef', class: `${e.prefixCls}-container` },
                    e.$attrs,
                    {
                      onScroll:
                        t[0] ||
                        (t[0] = (...l) =>
                          e.handleScroll && e.handleScroll(...l)),
                    }
                  ),
                  [
                    m(
                      a,
                      { onResize: e.handleResize },
                      { default: ze(() => [ve(e.$slots, 'default')]), _: 3 },
                      8,
                      ['onResize']
                    ),
                  ],
                  16
                ),
              ]),
              _: 3,
            },
            8,
            ['onResize']
          ),
          !e.hide && e.hasHorizontalScrollbar
            ? (O(),
              Ee(
                s,
                {
                  key: 0,
                  ref: 'horizontalThumbRef',
                  data: e.horizontalData,
                  direction: 'horizontal',
                  both: e.isBoth,
                  onScroll: e.handleHorizontalScroll,
                },
                null,
                8,
                ['data', 'both', 'onScroll']
              ))
            : Ce('v-if', !0),
          !e.hide && e.hasVerticalScrollbar
            ? (O(),
              Ee(
                s,
                {
                  key: 1,
                  ref: 'verticalThumbRef',
                  data: e.verticalData,
                  direction: 'vertical',
                  both: e.isBoth,
                  onScroll: e.handleVerticalScroll,
                },
                null,
                8,
                ['data', 'both', 'onScroll']
              ))
            : Ce('v-if', !0),
        ],
        6
      )
    )
  }
  var t0 = Te(k7, [['render', A7]])
  const ia = Object.assign(t0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + t0.name, t0)
      },
    }),
    Mu = (e) => {
      const t = J(),
        n = () => (x4(t.value) ? t.value.$refs[e] : t.value),
        r = J()
      return (
        Wt(() => {
          r.value = n()
        }),
        pt([t], () => {
          r.value = n()
        }),
        { componentRef: t, elementRef: r }
      )
    }
  var $7 = Object.defineProperty,
    Q2 = Object.getOwnPropertySymbols,
    O7 = Object.prototype.hasOwnProperty,
    L7 = Object.prototype.propertyIsEnumerable,
    ex = (e, t, n) =>
      t in e
        ? $7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    I7 = (e, t) => {
      for (var n in t || (t = {})) O7.call(t, n) && ex(e, n, t[n])
      if (Q2) for (var n of Q2(t)) L7.call(t, n) && ex(e, n, t[n])
      return e
    }
  const qv = (e) => {
      const t = C(() => !!e.value),
        n = C(() => {
          if (e.value)
            return I7({ type: 'embed' }, Ui(e.value) ? void 0 : e.value)
        })
      return { displayScrollbar: t, scrollbarProps: n }
    },
    R7 = ce({
      name: 'SelectDropdown',
      components: { ScrollbarComponent: ia, Empty: Ls, Spin: Do },
      props: {
        loading: Boolean,
        empty: Boolean,
        virtualList: Boolean,
        bottomOffset: { type: Number, default: 0 },
        scrollbar: { type: [Boolean, Object], default: !0 },
        onScroll: { type: [Function, Array] },
        onReachBottom: { type: [Function, Array] },
        showHeaderOnEmpty: { type: Boolean, default: !1 },
        showFooterOnEmpty: { type: Boolean, default: !1 },
      },
      emits: ['scroll', 'reachBottom'],
      setup(e, { emit: t, slots: n }) {
        var r, i, o
        const { scrollbar: a } = tt(e),
          s = ye('select-dropdown'),
          l = zt(di, void 0),
          c =
            (o =
              (i = l == null ? void 0 : (r = l.slots).empty) == null
                ? void 0
                : i.call(r, { component: 'select' })) == null
              ? void 0
              : o[0],
          { componentRef: d, elementRef: h } = Mu('containerRef'),
          { displayScrollbar: p, scrollbarProps: v } = qv(a),
          g = (b) => {
            const { scrollTop: y, scrollHeight: M, offsetHeight: x } = b.target
            M - (y + x) <= e.bottomOffset && t('reachBottom', b), t('scroll', b)
          },
          _ = C(() => [
            s,
            {
              [`${s}-has-header`]: !!n.header,
              [`${s}-has-footer`]: !!n.footer,
            },
          ])
        return {
          prefixCls: s,
          SelectEmpty: c,
          cls: _,
          wrapperRef: h,
          wrapperComRef: d,
          handleScroll: g,
          displayScrollbar: p,
          scrollbarProps: v,
        }
      },
    })
  function D7(e, t, n, r, i, o) {
    const a = ge('spin')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          e.$slots.header && (!e.empty || e.showHeaderOnEmpty)
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-header`) },
                [ve(e.$slots, 'header')],
                2
              ))
            : Ce('v-if', !0),
          e.loading
            ? (O(),
              Ee(a, { key: 1, class: H(`${e.prefixCls}-loading`) }, null, 8, [
                'class',
              ]))
            : e.empty
            ? (O(),
              Z(
                'div',
                { key: 2, class: H(`${e.prefixCls}-empty`) },
                [
                  ve(e.$slots, 'empty', {}, () => [
                    (O(), Ee(xi(e.SelectEmpty ? e.SelectEmpty : 'Empty'))),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
          e.virtualList && !e.loading && !e.empty
            ? ve(e.$slots, 'virtual-list', { key: 3 })
            : Ce('v-if', !0),
          e.virtualList
            ? Ce('v-if', !0)
            : ro(
                (O(),
                Ee(
                  xi(e.displayScrollbar ? 'ScrollbarComponent' : 'div'),
                  Fe(
                    {
                      key: 4,
                      ref: 'wrapperComRef',
                      class: `${e.prefixCls}-list-wrapper`,
                    },
                    e.scrollbarProps,
                    { onScroll: e.handleScroll }
                  ),
                  {
                    default: ze(() => [
                      Se(
                        'ul',
                        { class: H(`${e.prefixCls}-list`) },
                        [ve(e.$slots, 'default')],
                        2
                      ),
                    ]),
                    _: 3,
                  },
                  16,
                  ['class', 'onScroll']
                )),
                [[oo, !e.loading && !e.empty]]
              ),
          e.$slots.footer && (!e.empty || e.showFooterOnEmpty)
            ? (O(),
              Z(
                'div',
                { key: 5, class: H(`${e.prefixCls}-footer`) },
                [ve(e.$slots, 'footer')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var F_ = Te(R7, [['render', D7]]),
    tx = ce({
      name: 'IconCheck',
      render() {
        return m(
          'svg',
          {
            'aria-hidden': 'true',
            focusable: 'false',
            viewBox: '0 0 1024 1024',
            width: '200',
            height: '200',
            fill: 'currentColor',
          },
          [
            m(
              'path',
              {
                d: 'M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z',
                'p-id': '840',
              },
              null
            ),
          ]
        )
      },
    })
  const W4 = Symbol('ArcoCheckboxGroup')
  var Qh = ce({
      name: 'Checkbox',
      components: { IconCheck: tx, IconHover: In },
      props: {
        modelValue: { type: [Boolean, Array], default: void 0 },
        defaultChecked: { type: Boolean, default: !1 },
        value: { type: [String, Number, Boolean] },
        disabled: { type: Boolean, default: !1 },
        indeterminate: { type: Boolean, default: !1 },
        uninjectGroupContext: { type: Boolean, default: !1 },
      },
      emits: { 'update:modelValue': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const { disabled: r, modelValue: i } = tt(e),
          o = ye('checkbox'),
          a = J(),
          s = e.uninjectGroupContext ? void 0 : zt(W4, void 0),
          l = (s == null ? void 0 : s.name) === 'ArcoCheckboxGroup',
          { mergedDisabled: c, eventHandlers: d } = Rn({ disabled: r }),
          h = J(e.defaultChecked),
          p = C(() => {
            var w
            return l
              ? s == null
                ? void 0
                : s.computedValue
              : (w = e.modelValue) != null
              ? w
              : h.value
          }),
          v = C(() => {
            var w
            return Ft(p.value)
              ? p.value.includes((w = e.value) != null ? w : !0)
              : p.value
          }),
          g = C(
            () =>
              (s == null ? void 0 : s.disabled) ||
              (c == null ? void 0 : c.value) ||
              (!v.value && (s == null ? void 0 : s.isMaxed))
          ),
          _ = (w) => {
            w.stopPropagation()
          },
          b = (w) => {
            var E, P, A, F
            const { checked: T } = w.target
            let k = T
            if (Ft(p.value)) {
              const R = new Set(p.value)
              T
                ? R.add((E = e.value) != null ? E : !0)
                : R.delete((P = e.value) != null ? P : !0),
                (k = Array.from(R))
            }
            ;(h.value = T),
              l && Ft(k)
                ? s == null || s.handleChange(k, w)
                : (t('update:modelValue', k),
                  t('change', k, w),
                  (F = (A = d.value) == null ? void 0 : A.onChange) == null ||
                    F.call(A, w)),
              hn(() => {
                a.value &&
                  a.value.checked !== v.value &&
                  (a.value.checked = v.value)
              })
          },
          y = C(() => [
            o,
            {
              [`${o}-checked`]: v.value,
              [`${o}-indeterminate`]: e.indeterminate,
              [`${o}-disabled`]: g.value,
            },
          ]),
          M = (w) => {
            var E, P
            ;(P = (E = d.value) == null ? void 0 : E.onFocus) == null ||
              P.call(E, w)
          },
          x = (w) => {
            var E, P
            ;(P = (E = d.value) == null ? void 0 : E.onBlur) == null ||
              P.call(E, w)
          }
        return (
          pt(i, (w) => {
            ;(Mt(w) || fi(w)) && (h.value = !1)
          }),
          pt(p, (w) => {
            var E
            let P
            Ft(w) ? (P = w.includes((E = e.value) != null ? E : !0)) : (P = w),
              h.value !== P && (h.value = P),
              a.value && a.value.checked !== P && (a.value.checked = P)
          }),
          () => {
            var w, E, P, A
            return m('label', { 'aria-disabled': g.value, class: y.value }, [
              m(
                'input',
                {
                  ref: a,
                  type: 'checkbox',
                  checked: v.value,
                  value: e.value,
                  class: `${o}-target`,
                  disabled: g.value,
                  onClick: _,
                  onChange: b,
                  onFocus: M,
                  onBlur: x,
                },
                null
              ),
              (A =
                (P =
                  (E = n.checkbox) != null
                    ? E
                    : (w = s == null ? void 0 : s.slots) == null
                    ? void 0
                    : w.checkbox) == null
                  ? void 0
                  : P({ checked: v.value, disabled: g.value })) != null
                ? A
                : m(
                    In,
                    { class: `${o}-icon-hover`, disabled: g.value || v.value },
                    {
                      default: () => [
                        m('div', { class: `${o}-icon` }, [
                          v.value && m(tx, { class: `${o}-icon-check` }, null),
                        ]),
                      ],
                    }
                  ),
              n.default && m('span', { class: `${o}-label` }, [n.default()]),
            ])
          }
        )
      },
    }),
    ep = ce({
      name: 'CheckboxGroup',
      props: {
        modelValue: { type: Array, default: void 0 },
        defaultValue: { type: Array, default: () => [] },
        max: { type: Number },
        options: { type: Array },
        direction: { type: String, default: 'horizontal' },
        disabled: { type: Boolean, default: !1 },
      },
      emits: { 'update:modelValue': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const { disabled: r } = tt(e),
          i = ye('checkbox-group'),
          { mergedDisabled: o, eventHandlers: a } = Rn({ disabled: r }),
          s = J(e.defaultValue),
          l = C(() => (Ft(e.modelValue) ? e.modelValue : s.value)),
          c = C(() => (e.max === void 0 ? !1 : l.value.length >= e.max)),
          d = C(() => {
            var g
            return ((g = e.options) != null ? g : []).map((_) =>
              ir(_) || it(_) ? { label: _, value: _ } : _
            )
          })
        sn(
          W4,
          Je({
            name: 'ArcoCheckboxGroup',
            computedValue: l,
            disabled: o,
            isMaxed: c,
            slots: n,
            handleChange: (g, _) => {
              var b, y
              ;(s.value = g),
                t('update:modelValue', g),
                t('change', g, _),
                (y = (b = a.value) == null ? void 0 : b.onChange) == null ||
                  y.call(b, _)
            },
          })
        )
        const p = C(() => [i, `${i}-direction-${e.direction}`])
        pt(
          () => e.modelValue,
          (g) => {
            Ft(g) ? (s.value = [...g]) : (s.value = [])
          }
        )
        const v = () =>
          d.value.map((g) => {
            const _ = l.value.includes(g.value)
            return m(
              Qh,
              {
                key: g.value,
                value: g.value,
                disabled: g.disabled || (!_ && c.value),
                indeterminate: g.indeterminate,
                modelValue: _,
              },
              {
                default: () => [
                  n.label
                    ? n.label({ data: g })
                    : xt(g.label)
                    ? g.label()
                    : g.label,
                ],
              }
            )
          })
        return () => {
          var g
          return m('span', { class: p.value }, [
            d.value.length > 0
              ? v()
              : (g = n.default) == null
              ? void 0
              : g.call(n),
          ])
        }
      },
    })
  const Lo = Object.assign(Qh, {
      Group: ep,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Qh.name, Qh), e.component(n + ep.name, ep)
      },
    }),
    j4 = Symbol('ArcoSelectContext')
  var N7 = Object.defineProperty,
    B7 = Object.defineProperties,
    F7 = Object.getOwnPropertyDescriptors,
    nx = Object.getOwnPropertySymbols,
    z7 = Object.prototype.hasOwnProperty,
    V7 = Object.prototype.propertyIsEnumerable,
    rx = (e, t, n) =>
      t in e
        ? N7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    z_ = (e, t) => {
      for (var n in t || (t = {})) z7.call(t, n) && rx(e, n, t[n])
      if (nx) for (var n of nx(t)) V7.call(t, n) && rx(e, n, t[n])
      return e
    },
    G4 = (e, t) => B7(e, F7(t))
  const U7 = (e) => Ht(e) && 'isGroup' in e,
    K4 = (e) => Ht(e) && 'isGroup' in e,
    H7 = (e, t = 'value') => String(Ht(e) ? e[t] : e),
    Ml = (e, t = 'value') =>
      Ht(e)
        ? `__arco__option__object__${e[t]}`
        : e || it(e) || ir(e)
        ? `__arco__option__${typeof e}-${e}`
        : '',
    W7 = (e) => e.has('__arco__option__string-'),
    j7 = (e, { valueKey: t, fieldNames: n, origin: r, index: i = -1 }) => {
      var o
      if (Ht(e)) {
        const s = e[n.value]
        return {
          raw: e,
          index: i,
          key: Ml(s, t),
          origin: r,
          value: s,
          label: (o = e[n.label]) != null ? o : H7(s, t),
          render: e[n.render],
          disabled: !!e[n.disabled],
          tagProps: e[n.tagProps],
        }
      }
      const a = { value: e, label: String(e), disabled: !1 }
      return z_({ raw: a, index: i, key: Ml(e, t), origin: r }, a)
    },
    _b = (e, { valueKey: t, fieldNames: n, origin: r, optionInfoMap: i }) => {
      var o
      const a = []
      for (const s of e)
        if (U7(s)) {
          const l = _b((o = s.options) != null ? o : [], {
            valueKey: t,
            fieldNames: n,
            origin: r,
            optionInfoMap: i,
          })
          l.length > 0 &&
            a.push(
              G4(z_({}, s), { key: `__arco__group__${s.label}`, options: l })
            )
        } else {
          const l = j7(s, { valueKey: t, fieldNames: n, origin: r })
          a.push(l), i.get(l.key) || i.set(l.key, l)
        }
      return a
    },
    ix = (e, { inputValue: t, filterOption: n }) => {
      const r = (i) => {
        var o
        const a = []
        for (const s of i)
          if (K4(s)) {
            const l = r((o = s.options) != null ? o : [])
            l.length > 0 && a.push(G4(z_({}, s), { options: l }))
          } else Xv(s, { inputValue: t, filterOption: n }) && a.push(s)
        return a
      }
      return r(e)
    },
    Xv = (e, { inputValue: t, filterOption: n }) =>
      xt(n)
        ? !t || n(t, e.raw)
        : n
        ? e.label.toLowerCase().includes((t ?? '').toLowerCase())
        : !0,
    G7 = (e, t) => {
      if (!e || !t || e.length !== t.length) return !1
      for (const n of Object.keys(e)) if (!ac(e[n], t[n])) return !1
      return !0
    },
    K7 = (e, t) => {
      if (!e || !t) return !1
      const { length: n } = e
      if (n !== t.length) return !1
      for (let r = 0; r < n; r++) if (!ac(e[r], t[r])) return !1
      return !0
    },
    ac = (e, t) => {
      const n = Object.prototype.toString.call(e)
      return n !== Object.prototype.toString.call(t)
        ? !1
        : n === '[object Object]'
        ? G7(e, t)
        : n === '[object Array]'
        ? K7(e, t)
        : n === '[object Function]'
        ? e === t
          ? !0
          : e.toString() === t.toString()
        : e === t
    },
    q7 = ce({
      name: 'Option',
      components: { Checkbox: Lo },
      props: {
        value: [String, Number, Object],
        label: String,
        disabled: Boolean,
        tagProps: { type: Object },
        extra: { type: Object },
        index: { type: Number },
        internal: Boolean,
      },
      setup(e) {
        const { disabled: t, tagProps: n, index: r } = tt(e),
          i = ye('select-option'),
          o = zt(j4, void 0),
          a = Jr(),
          s = J(),
          l = J(n.value)
        pt(n, (P, A) => {
          ac(P, A) || (l.value = P)
        })
        const c = J(''),
          d = C(() => {
            var P, A
            return (A = (P = e.value) != null ? P : e.label) != null
              ? A
              : c.value
          }),
          h = C(() => {
            var P
            return (P = e.label) != null ? P : c.value
          }),
          p = C(() => Ml(d.value, o == null ? void 0 : o.valueKey)),
          v = C(() => {
            var P
            return (P = o == null ? void 0 : o.component) != null ? P : 'li'
          }),
          g = () => {
            var P
            if (!e.label && s.value) {
              const A = (P = s.value.textContent) != null ? P : ''
              c.value !== A && (c.value = A)
            }
          }
        Wt(() => g()), Zr(() => g())
        const _ = C(() => {
            var P
            return (P = o == null ? void 0 : o.valueKeys.includes(p.value)) !=
              null
              ? P
              : !1
          }),
          b = C(() => (o == null ? void 0 : o.activeKey) === p.value)
        let y = J(!0)
        if (!e.internal) {
          const P = Je({
            raw: { value: d, label: h, disabled: t, tagProps: l },
            ref: s,
            index: r,
            key: p,
            origin: 'slot',
            value: d,
            label: h,
            disabled: t,
            tagProps: l,
          })
          ;(y = C(() =>
            Xv(P, {
              inputValue: o == null ? void 0 : o.inputValue,
              filterOption: o == null ? void 0 : o.filterOption,
            })
          )),
            a && (o == null || o.addSlotOptionInfo(a.uid, P)),
            Pr(() => {
              a && (o == null || o.removeSlotOptionInfo(a.uid))
            })
        }
        const M = (P) => {
            e.disabled || o == null || o.onSelect(p.value, P)
          },
          x = () => {
            e.disabled || o == null || o.setActiveKey(p.value)
          },
          w = () => {
            e.disabled || o == null || o.setActiveKey()
          },
          E = C(() => [
            i,
            {
              [`${i}-disabled`]: e.disabled,
              [`${i}-active`]: b.value,
              [`${i}-multiple`]: o == null ? void 0 : o.multiple,
            },
          ])
        return {
          prefixCls: i,
          cls: E,
          selectCtx: o,
          itemRef: s,
          component: v,
          isSelected: _,
          isValid: y,
          handleClick: M,
          handleMouseEnter: x,
          handleMouseLeave: w,
        }
      },
    })
  function X7(e, t, n, r, i, o) {
    const a = ge('checkbox')
    return ro(
      (O(),
      Ee(
        xi(e.component),
        {
          ref: 'itemRef',
          class: H([
            e.cls,
            { [`${e.prefixCls}-has-suffix`]: !!e.$slots.suffix },
          ]),
          onClick: e.handleClick,
          onMouseenter: e.handleMouseEnter,
          onMouseleave: e.handleMouseLeave,
        },
        {
          default: ze(() => [
            e.$slots.icon
              ? (O(),
                Z(
                  'span',
                  { key: 0, class: H(`${e.prefixCls}-icon`) },
                  [ve(e.$slots, 'icon')],
                  2
                ))
              : Ce('v-if', !0),
            e.selectCtx && e.selectCtx.multiple
              ? (O(),
                Ee(
                  a,
                  {
                    key: 1,
                    class: H(`${e.prefixCls}-checkbox`),
                    'model-value': e.isSelected,
                    disabled: e.disabled,
                    'uninject-group-context': '',
                  },
                  {
                    default: ze(() => [
                      ve(e.$slots, 'default', {}, () => [Lt(mt(e.label), 1)]),
                    ]),
                    _: 3,
                  },
                  8,
                  ['class', 'model-value', 'disabled']
                ))
              : (O(),
                Z(
                  'span',
                  { key: 2, class: H(`${e.prefixCls}-content`) },
                  [ve(e.$slots, 'default', {}, () => [Lt(mt(e.label), 1)])],
                  2
                )),
            e.$slots.suffix
              ? (O(),
                Z(
                  'span',
                  { key: 3, class: H(`${e.prefixCls}-suffix`) },
                  [ve(e.$slots, 'suffix')],
                  2
                ))
              : Ce('v-if', !0),
          ]),
          _: 3,
        },
        8,
        ['class', 'onClick', 'onMouseenter', 'onMouseleave']
      )),
      [[oo, e.isValid]]
    )
  }
  var pl = Te(q7, [['render', X7]]),
    Y7 = Object.defineProperty,
    Z7 = Object.defineProperties,
    J7 = Object.getOwnPropertyDescriptors,
    ox = Object.getOwnPropertySymbols,
    Q7 = Object.prototype.hasOwnProperty,
    ez = Object.prototype.propertyIsEnumerable,
    ax = (e, t, n) =>
      t in e
        ? Y7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    n0 = (e, t) => {
      for (var n in t || (t = {})) Q7.call(t, n) && ax(e, n, t[n])
      if (ox) for (var n of ox(t)) ez.call(t, n) && ax(e, n, t[n])
      return e
    },
    tz = (e, t) => Z7(e, J7(t))
  const nz = {
      value: 'value',
      label: 'label',
      disabled: 'disabled',
      tagProps: 'tagProps',
      render: 'render',
    },
    rz = ({
      options: e,
      extraOptions: t,
      inputValue: n,
      filterOption: r,
      showExtraOptions: i,
      valueKey: o,
      fieldNames: a,
    }) => {
      const s = C(() => n0(n0({}, nz), a == null ? void 0 : a.value)),
        l = Je(new Map()),
        c = C(() =>
          Array.from(l.values()).sort((x, w) =>
            it(x.index) && it(w.index) ? x.index - w.index : 0
          )
        ),
        d = C(() => {
          var x, w
          const E = new Map()
          return {
            optionInfos: _b(
              (x = e == null ? void 0 : e.value) != null ? x : [],
              {
                valueKey:
                  (w = o == null ? void 0 : o.value) != null ? w : 'value',
                fieldNames: s.value,
                origin: 'options',
                optionInfoMap: E,
              }
            ),
            optionInfoMap: E,
          }
        }),
        h = C(() => {
          var x, w
          const E = new Map()
          return {
            optionInfos: _b(
              (x = t == null ? void 0 : t.value) != null ? x : [],
              {
                valueKey:
                  (w = o == null ? void 0 : o.value) != null ? w : 'value',
                fieldNames: s.value,
                origin: 'extraOptions',
                optionInfoMap: E,
              }
            ),
            optionInfoMap: E,
          }
        }),
        p = Je(new Map())
      pt(
        [c, e ?? J([]), t ?? J([]), o ?? J('value')],
        () => {
          p.clear(),
            c.value.forEach((x, w) => {
              p.set(x.key, tz(n0({}, x), { index: w }))
            }),
            d.value.optionInfoMap.forEach((x) => {
              p.has(x.key) || ((x.index = p.size), p.set(x.key, x))
            }),
            h.value.optionInfoMap.forEach((x) => {
              p.has(x.key) || ((x.index = p.size), p.set(x.key, x))
            })
        },
        { immediate: !0, deep: !0 }
      )
      const v = C(() => {
          var x
          const w = ix(d.value.optionInfos, {
            inputValue: n == null ? void 0 : n.value,
            filterOption: r == null ? void 0 : r.value,
          })
          return (
            ((x = i == null ? void 0 : i.value) == null || x) &&
              w.push(
                ...ix(h.value.optionInfos, {
                  inputValue: n == null ? void 0 : n.value,
                  filterOption: r == null ? void 0 : r.value,
                })
              ),
            w
          )
        }),
        g = C(() =>
          Array.from(p.values()).filter((x) =>
            x.origin === 'extraOptions' && (i == null ? void 0 : i.value) === !1
              ? !1
              : Xv(x, {
                  inputValue: n == null ? void 0 : n.value,
                  filterOption: r == null ? void 0 : r.value,
                })
          )
        ),
        _ = C(() => g.value.filter((x) => !x.disabled).map((x) => x.key))
      return {
        validOptions: v,
        optionInfoMap: p,
        validOptionInfos: g,
        enabledOptionKeys: _,
        getNextSlotOptionIndex: () => l.size,
        addSlotOptionInfo: (x, w) => {
          l.set(x, w)
        },
        removeSlotOptionInfo: (x) => {
          l.delete(x)
        },
      }
    },
    fr = {
      ENTER: 'Enter',
      ESC: 'Escape',
      BACKSPACE: 'Backspace',
      TAB: 'Tab',
      SPACE: ' ',
      ARROW_UP: 'ArrowUp',
      ARROW_DOWN: 'ArrowDown',
      ARROW_LEFT: 'ArrowLeft',
      ARROW_RIGHT: 'ArrowRight',
    },
    sx = (e) =>
      JSON.stringify({
        key: e.key,
        ctrl: !!e.ctrl,
        shift: !!e.shift,
        alt: !!e.alt,
        meta: !!e.meta,
      }),
    Yv = (e) => {
      const t = {}
      return (
        e.forEach((n, r) => {
          const i = ir(r) ? { key: r } : r
          t[sx(i)] = n
        }),
        (n) => {
          const r = sx({
              key: n.key,
              ctrl: n.ctrlKey,
              shift: n.shiftKey,
              alt: n.altKey,
              meta: n.metaKey,
            }),
            i = t[r]
          i && (n.stopPropagation(), i(n))
        }
      )
    },
    V_ = ({
      multiple: e,
      options: t,
      extraOptions: n,
      inputValue: r,
      filterOption: i,
      showExtraOptions: o,
      component: a,
      valueKey: s,
      fieldNames: l,
      loading: c,
      popupVisible: d,
      valueKeys: h,
      dropdownRef: p,
      optionRefs: v,
      virtualListRef: g,
      onSelect: _,
      onPopupVisibleChange: b,
      enterToOpen: y = !0,
      defaultActiveFirstOption: M,
    }) => {
      const {
          validOptions: x,
          optionInfoMap: w,
          validOptionInfos: E,
          enabledOptionKeys: P,
          getNextSlotOptionIndex: A,
          addSlotOptionInfo: F,
          removeSlotOptionInfo: T,
        } = rz({
          options: t,
          extraOptions: n,
          inputValue: r,
          filterOption: i,
          showExtraOptions: o,
          valueKey: s,
          fieldNames: l,
        }),
        k = J()
      pt(P, (B) => {
        ;(!k.value || !B.includes(k.value)) && (k.value = B[0])
      })
      const R = (B) => {
          k.value = B
        },
        j = (B) => {
          const V = P.value.length
          if (V === 0) return
          if (!k.value) return B === 'down' ? P.value[0] : P.value[V - 1]
          const L = P.value.indexOf(k.value),
            W = (V + L + (B === 'up' ? -1 : 1)) % V
          return P.value[W]
        },
        N = (B) => {
          var V, L
          g != null && g.value && g.value.scrollTo({ key: B })
          const W = w.get(B),
            Y =
              (V = p == null ? void 0 : p.value) == null
                ? void 0
                : V.wrapperRef,
            U =
              (L = v == null ? void 0 : v.value[B]) != null
                ? L
                : W == null
                ? void 0
                : W.ref
          if (!Y || !U || Y.scrollHeight === Y.offsetHeight) return
          const le = GB(U, Y),
            q = Y.scrollTop
          le.top < 0
            ? Y.scrollTo(0, q + le.top)
            : le.bottom < 0 && Y.scrollTo(0, q - le.bottom)
        }
      pt(d, (B) => {
        var V
        if (B) {
          const L = h.value[h.value.length - 1]
          let W =
            (V = M == null ? void 0 : M.value) == null || V
              ? P.value[0]
              : void 0
          P.value.includes(L) && (W = L),
            W !== k.value && (k.value = W),
            hn(() => {
              k.value && N(k.value)
            })
        }
      })
      const I = Yv(
        new Map([
          [
            fr.ENTER,
            (B) => {
              !(c != null && c.value) &&
                !B.isComposing &&
                (d.value
                  ? k.value && (_(k.value, B), B.preventDefault())
                  : y && (b(!0), B.preventDefault()))
            },
          ],
          [
            fr.ESC,
            (B) => {
              d.value && (b(!1), B.preventDefault())
            },
          ],
          [
            fr.ARROW_DOWN,
            (B) => {
              if (d.value) {
                const V = j('down')
                V && ((k.value = V), N(V)), B.preventDefault()
              }
            },
          ],
          [
            fr.ARROW_UP,
            (B) => {
              if (d.value) {
                const V = j('up')
                V && ((k.value = V), N(V)), B.preventDefault()
              }
            },
          ],
        ])
      )
      return (
        sn(
          j4,
          Je({
            multiple: e,
            valueKey: s,
            inputValue: r,
            filterOption: i,
            component: a,
            valueKeys: h,
            activeKey: k,
            setActiveKey: R,
            onSelect: _,
            getNextSlotOptionIndex: A,
            addSlotOptionInfo: F,
            removeSlotOptionInfo: T,
          })
        ),
        {
          validOptions: x,
          optionInfoMap: w,
          validOptionInfos: E,
          enabledOptionKeys: P,
          activeKey: k,
          setActiveKey: R,
          addSlotOptionInfo: F,
          removeSlotOptionInfo: T,
          getNextActiveKey: j,
          scrollIntoView: N,
          handleKeyDown: I,
        }
      )
    }
  var r0 = ce({
    name: 'AutoComplete',
    inheritAttrs: !1,
    props: {
      modelValue: { type: String, default: void 0 },
      defaultValue: { type: String, default: '' },
      disabled: { type: Boolean, default: !1 },
      data: { type: Array, default: () => [] },
      popupContainer: { type: [String, Object] },
      strict: { type: Boolean, default: !1 },
      filterOption: { type: [Boolean, Function], default: !0 },
      triggerProps: { type: Object },
      allowClear: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      change: (e) => !0,
      search: (e) => !0,
      select: (e) => !0,
      clear: (e) => !0,
    },
    setup(e, { emit: t, attrs: n, slots: r }) {
      const { modelValue: i } = tt(e),
        o = ye('auto-complete'),
        { mergedDisabled: a, eventHandlers: s } = Rn({
          disabled: Vi(e, 'disabled'),
        }),
        l = J(e.defaultValue),
        c = J(),
        d = C(() => {
          var V
          return (V = e.modelValue) != null ? V : l.value
        })
      pt(i, (V) => {
        ;(Mt(V) || fi(V)) && (l.value = '')
      })
      const h = C(() => (d.value ? [Ml(d.value)] : [])),
        { data: p } = tt(e),
        v = J(),
        g = J({}),
        _ = J(!1),
        b = C(() => _.value && k.value.length > 0),
        y = (V) => {
          _.value = V
        },
        M = (V, L) => {
          var W
          return !!((W = L.label) != null && W.includes(V))
        },
        x = C(() =>
          xt(e.filterOption)
            ? e.filterOption
            : e.filterOption && e.strict
            ? M
            : e.filterOption
        ),
        w = (V) => {
          var L, W
          ;(l.value = V),
            t('update:modelValue', V),
            t('change', V),
            (W = (L = s.value) == null ? void 0 : L.onChange) == null ||
              W.call(L)
        },
        E = (V) => {
          var L, W
          ;(l.value = ''),
            t('update:modelValue', ''),
            t('change', ''),
            (W = (L = s.value) == null ? void 0 : L.onChange) == null ||
              W.call(L),
            t('clear', V)
        },
        P = (V, L) => {
          var W, Y
          const U = (W = T.get(V)) == null ? void 0 : W.value
          t('select', U), w(U), (Y = c.value) == null || Y.blur()
        },
        A = (V) => {
          t('search', V), w(V)
        },
        {
          validOptions: F,
          optionInfoMap: T,
          validOptionInfos: k,
          handleKeyDown: R,
        } = V_({
          options: p,
          inputValue: d,
          filterOption: x,
          popupVisible: b,
          valueKeys: h,
          dropdownRef: v,
          optionRefs: g,
          onSelect: P,
          onPopupVisibleChange: y,
        }),
        j = (V) => {
          if (xt(r.option) && V.value) {
            const L = T.get(V.key),
              W = r.option
            return () => W({ data: L })
          }
          return () => V.label
        },
        N = (V) =>
          m(
            pl,
            {
              ref: (L) => {
                L != null && L.$el && (g.value[V.key] = L.$el)
              },
              key: V.key,
              value: V.value,
              disabled: V.disabled,
              internal: !0,
            },
            { default: j(V) }
          ),
        I = () =>
          m(
            F_,
            { ref: v, class: `${o}-dropdown` },
            { default: () => [F.value.map((V) => N(V))], footer: r.footer }
          )
      return {
        inputRef: c,
        render: () =>
          m(
            Mr,
            Fe(
              {
                trigger: 'focus',
                position: 'bl',
                animationName: 'slide-dynamic-origin',
                autoFitTransformOrigin: !0,
                popupVisible: b.value,
                clickToClose: !1,
                preventFocus: !0,
                popupOffset: 4,
                disabled: a.value,
                autoFitPopupWidth: !0,
              },
              e.triggerProps,
              { onPopupVisibleChange: y }
            ),
            {
              default: () => [
                m(
                  ic,
                  Fe({ ref: c }, n, {
                    allowClear: e.allowClear,
                    modelValue: d.value,
                    disabled: a.value,
                    onInput: A,
                    onClear: E,
                    onKeydown: R,
                  }),
                  r
                ),
              ],
              content: I,
            }
          ),
      }
    },
    methods: {
      focus() {
        var e
        ;(e = this.inputRef) == null || e.focus()
      },
      blur() {
        var e
        ;(e = this.inputRef) == null || e.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const iz = Object.assign(r0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + r0.name, r0)
      },
    }),
    Zv = ({ itemRef: e, selector: t, index: n, parentClassName: r }) => {
      const i = J(-1),
        o = C(() => {
          var c
          return (c = n == null ? void 0 : n.value) != null ? c : i.value
        }),
        a = J(),
        s = () => {
          var c, d, h
          let p =
            (d = (c = e.value) == null ? void 0 : c.parentElement) != null
              ? d
              : void 0
          if (r)
            for (; p && !p.className.includes(r); )
              p = (h = p.parentElement) != null ? h : void 0
          return p
        },
        l = () => {
          if (Mt(n == null ? void 0 : n.value) && a.value && e.value) {
            const c = Array.from(a.value.querySelectorAll(t)).indexOf(e.value)
            c !== i.value && (i.value = c)
          }
        }
      return (
        pt(e, () => {
          e.value && !a.value && (a.value = s())
        }),
        Wt(() => {
          e.value && (a.value = s()), l()
        }),
        Zr(() => l()),
        { computedIndex: o }
      )
    },
    q4 = Symbol('ArcoAvatarGroup'),
    oz = ce({
      name: 'IconImageClose',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-image-close`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    az = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    sz = SN(
      '<path d="M41 26V9a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v30a2 2 0 0 0 2 2h17"></path><path d="m24 33 9-8.5V27s-2 1-3.5 2.5C27.841 31.159 27 33 27 33h-3Zm0 0-3.5-4.5L17 33h7Z"></path><path d="M20.5 28.5 17 33h7l-3.5-4.5ZM33 24.5 24 33h3s.841-1.841 2.5-3.5C31 28 33 27 33 27v-2.5Z" fill="currentColor" stroke="none"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M46 38a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-4.95-4.782 1.74 1.74-3.045 3.046 3.046 3.046-1.74 1.74-3.047-3.045-3.046 3.046-1.74-1.74 3.046-3.047-3.046-3.046 1.74-1.74 3.046 3.046 3.046-3.046Z" fill="currentColor" stroke="none"></path><path d="M17 15h-2v2h2v-2Z"></path>',
      5
    ),
    lz = [sz]
  function uz(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        lz,
        14,
        az
      )
    )
  }
  var i0 = Te(oz, [['render', uz]])
  const U_ = Object.assign(i0, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + i0.name, i0)
    },
  })
  var cz = Object.defineProperty,
    lx = Object.getOwnPropertySymbols,
    dz = Object.prototype.hasOwnProperty,
    fz = Object.prototype.propertyIsEnumerable,
    ux = (e, t, n) =>
      t in e
        ? cz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    cx = (e, t) => {
      for (var n in t || (t = {})) dz.call(t, n) && ux(e, n, t[n])
      if (lx) for (var n of lx(t)) fz.call(t, n) && ux(e, n, t[n])
      return e
    }
  const hz = ce({
      name: 'Avatar',
      components: { ResizeObserver: ks, IconImageClose: U_, IconLoading: Xr },
      props: {
        shape: { type: String, default: 'circle' },
        imageUrl: String,
        size: Number,
        autoFixFontSize: { type: Boolean, default: !0 },
        triggerType: { type: String, default: 'button' },
        triggerIconStyle: { type: Object },
      },
      emits: { click: (e) => !0, error: () => !0, load: () => !0 },
      setup(e, { slots: t, emit: n, attrs: r }) {
        const {
            shape: i,
            size: o,
            autoFixFontSize: a,
            triggerType: s,
            triggerIconStyle: l,
          } = tt(e),
          c = ye('avatar'),
          d = zt(q4, void 0),
          h = J(),
          p = J(),
          v = C(() => {
            var I
            return (I = d == null ? void 0 : d.shape) != null ? I : i.value
          }),
          g = C(() => {
            var I
            return (I = d == null ? void 0 : d.size) != null ? I : o.value
          }),
          _ = C(() => {
            var I
            return (I = d == null ? void 0 : d.autoFixFontSize) != null
              ? I
              : a.value
          }),
          b = J(!1),
          y = J(!1),
          M = J(!0),
          x = J(!1),
          w = d ? Zv({ itemRef: h, selector: `.${c}` }).computedIndex : J(-1),
          E = C(() => {
            var I
            const B = it(g.value)
              ? {
                  width: `${g.value}px`,
                  height: `${g.value}px`,
                  fontSize: `${g.value / 2}px`,
                }
              : {}
            return (
              d &&
                ((B.zIndex = d.zIndexAscend ? w.value + 1 : d.total - w.value),
                (B.marginLeft =
                  w.value !== 0
                    ? `-${((I = g.value) != null ? I : 40) / 4}px`
                    : '0')),
              B
            )
          }),
          P = pz({
            triggerIconStyle: l == null ? void 0 : l.value,
            inlineStyle: r.style,
            triggerType: s.value,
          }),
          A = () => {
            !b.value &&
              !e.imageUrl &&
              hn(() => {
                var I
                if (!p.value || !h.value) return
                const B = p.value.clientWidth,
                  V = (I = g.value) != null ? I : h.value.offsetWidth,
                  L = V / (B + 8)
                V &&
                  L < 1 &&
                  (p.value.style.transform = `scale(${L}) translateX(-50%)`),
                  (M.value = !0)
              })
          }
        Wt(() => {
          var I
          ;(I = p.value) != null &&
            I.firstElementChild &&
            ['IMG', 'PICTURE'].includes(p.value.firstElementChild.tagName) &&
            (b.value = !0),
            _.value && A()
        }),
          pt(o, () => {
            _.value && A()
          })
        const F = C(() => [c, `${c}-${v.value}`]),
          T = C(() => (b.value || e.imageUrl ? `${c}-image` : `${c}-text`))
        return {
          prefixCls: c,
          itemRef: h,
          cls: F,
          outerStyle: E,
          wrapperRef: p,
          wrapperCls: T,
          computedTriggerIconStyle: P,
          isImage: b,
          shouldLoad: M,
          isLoaded: x,
          hasError: y,
          onClick: (I) => {
            n('click', I)
          },
          handleResize: () => {
            _.value && A()
          },
          handleImgLoad: () => {
            ;(x.value = !0), n('load')
          },
          handleImgError: () => {
            ;(y.value = !0), n('error')
          },
        }
      },
    }),
    pz = ({
      triggerType: e,
      inlineStyle: t = {},
      triggerIconStyle: n = {},
    }) => {
      let r = {}
      return (
        e === 'button' &&
          (!n || (n && !n.color)) &&
          t &&
          t.backgroundColor &&
          (r = { color: t.backgroundColor }),
        cx(cx({}, n), r)
      )
    },
    vz = ['src']
  function mz(e, t, n, r, i, o) {
    const a = ge('IconImageClose'),
      s = ge('IconLoading'),
      l = ge('resize-observer')
    return (
      O(),
      Z(
        'div',
        {
          ref: 'itemRef',
          style: at(e.outerStyle),
          class: H([
            e.cls,
            {
              [`${e.prefixCls}-with-trigger-icon`]: !!e.$slots['trigger-icon'],
            },
          ]),
          onClick: t[2] || (t[2] = (...c) => e.onClick && e.onClick(...c)),
        },
        [
          m(
            l,
            { onResize: e.handleResize },
            {
              default: ze(() => [
                Se(
                  'span',
                  { ref: 'wrapperRef', class: H(e.wrapperCls) },
                  [
                    e.imageUrl
                      ? (O(),
                        Z(
                          yt,
                          { key: 0 },
                          [
                            e.hasError
                              ? ve(e.$slots, 'error', { key: 0 }, () => [
                                  Se(
                                    'div',
                                    { class: H(`${e.prefixCls}-image-icon`) },
                                    [m(a)],
                                    2
                                  ),
                                ])
                              : Ce('v-if', !0),
                            !(e.hasError || !e.shouldLoad) && !e.isLoaded
                              ? ve(e.$slots, 'default', { key: 1 }, () => [
                                  Se(
                                    'div',
                                    { class: H(`${e.prefixCls}-image-icon`) },
                                    [m(s)],
                                    2
                                  ),
                                ])
                              : Ce('v-if', !0),
                            e.hasError || !e.shouldLoad
                              ? Ce('v-if', !0)
                              : (O(),
                                Z(
                                  'img',
                                  {
                                    key: 2,
                                    src: e.imageUrl,
                                    style: at({
                                      width: e.size + 'px',
                                      height: e.size + 'px',
                                    }),
                                    alt: 'avatar',
                                    onLoad:
                                      t[0] ||
                                      (t[0] = (...c) =>
                                        e.handleImgLoad &&
                                        e.handleImgLoad(...c)),
                                    onError:
                                      t[1] ||
                                      (t[1] = (...c) =>
                                        e.handleImgError &&
                                        e.handleImgError(...c)),
                                  },
                                  null,
                                  44,
                                  vz
                                )),
                          ],
                          64
                        ))
                      : ve(e.$slots, 'default', { key: 1 }),
                  ],
                  2
                ),
              ]),
              _: 3,
            },
            8,
            ['onResize']
          ),
          e.$slots['trigger-icon']
            ? (O(),
              Z(
                'div',
                {
                  key: 0,
                  class: H(`${e.prefixCls}-trigger-icon-${e.triggerType}`),
                  style: at(e.computedTriggerIconStyle),
                },
                [ve(e.$slots, 'trigger-icon')],
                6
              ))
            : Ce('v-if', !0),
        ],
        6
      )
    )
  }
  var tp = Te(hz, [['render', mz]])
  const gz = ce({
    name: 'Popover',
    components: { Trigger: Mr },
    props: {
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      title: String,
      content: String,
      trigger: { type: [String, Array], default: 'hover' },
      position: { type: String, default: 'top' },
      contentClass: { type: [String, Array, Object] },
      contentStyle: { type: Object },
      arrowClass: { type: [String, Array, Object] },
      arrowStyle: { type: Object },
      popupContainer: { type: [String, Object] },
    },
    emits: { 'update:popupVisible': (e) => !0, popupVisibleChange: (e) => !0 },
    setup(e, { emit: t }) {
      const n = ye('popover'),
        r = J(e.defaultPopupVisible),
        i = C(() => {
          var l
          return (l = e.popupVisible) != null ? l : r.value
        }),
        o = (l) => {
          ;(r.value = l),
            t('update:popupVisible', l),
            t('popupVisibleChange', l)
        },
        a = C(() => [`${n}-popup-content`, e.contentClass]),
        s = C(() => [`${n}-popup-arrow`, e.arrowClass])
      return {
        prefixCls: n,
        computedPopupVisible: i,
        contentCls: a,
        arrowCls: s,
        handlePopupVisibleChange: o,
      }
    },
  })
  function yz(e, t, n, r, i, o) {
    const a = ge('trigger')
    return (
      O(),
      Ee(
        a,
        {
          class: H(e.prefixCls),
          trigger: e.trigger,
          position: e.position,
          'popup-visible': e.computedPopupVisible,
          'popup-offset': 10,
          'content-class': e.contentCls,
          'content-style': e.contentStyle,
          'arrow-class': e.arrowCls,
          'arrow-style': e.arrowStyle,
          'show-arrow': '',
          'popup-container': e.popupContainer,
          'animation-name': 'zoom-in-fade-out',
          'auto-fit-transform-origin': '',
          onPopupVisibleChange: e.handlePopupVisibleChange,
        },
        {
          content: ze(() => [
            Se(
              'div',
              { class: H(`${e.prefixCls}-title`) },
              [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
              2
            ),
            Se(
              'div',
              { class: H(`${e.prefixCls}-content`) },
              [ve(e.$slots, 'content', {}, () => [Lt(mt(e.content), 1)])],
              2
            ),
          ]),
          default: ze(() => [ve(e.$slots, 'default')]),
          _: 3,
        },
        8,
        [
          'class',
          'trigger',
          'position',
          'popup-visible',
          'content-class',
          'content-style',
          'arrow-class',
          'arrow-style',
          'popup-container',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var o0 = Te(gz, [['render', yz]])
  const H_ = Object.assign(o0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + o0.name, o0)
      },
    }),
    np = ce({
      name: 'AvatarGroup',
      props: {
        shape: { type: String, default: 'circle' },
        size: Number,
        autoFixFontSize: { type: Boolean, default: !0 },
        maxCount: { type: Number, default: 0 },
        zIndexAscend: { type: Boolean, default: !1 },
        maxStyle: { type: Object },
        maxPopoverTriggerProps: { type: Object },
      },
      setup(e, { slots: t }) {
        const {
            shape: n,
            size: r,
            autoFixFontSize: i,
            zIndexAscend: o,
          } = tt(e),
          a = ye('avatar-group'),
          s = J(0)
        return (
          sn(
            q4,
            Je({
              shape: n,
              size: r,
              autoFixFontSize: i,
              zIndexAscend: o,
              total: s,
            })
          ),
          () => {
            var l, c
            const d = ea(
                (c = (l = t.default) == null ? void 0 : l.call(t)) != null
                  ? c
                  : []
              ),
              h = e.maxCount > 0 ? d.slice(0, e.maxCount) : d,
              p = e.maxCount > 0 ? d.slice(e.maxCount) : []
            return (
              s.value !== h.length && (s.value = h.length),
              m('div', { class: a }, [
                h,
                p.length > 0 &&
                  m(H_, e.maxPopoverTriggerProps, {
                    default: () => [
                      m(
                        tp,
                        { class: `${a}-max-count-avatar`, style: e.maxStyle },
                        { default: () => [Lt('+'), p.length] }
                      ),
                    ],
                    content: () => m('div', null, [p]),
                  }),
              ])
            )
          }
        )
      },
    }),
    bz = Object.assign(tp, {
      Group: np,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + tp.name, tp), e.component(n + np.name, np)
      },
    }),
    _z = ce({
      name: 'IconToTop',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-to-top`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Sz = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Cz = Se(
      'path',
      { d: 'M43 7H5M24 20v23M24 13.96 30.453 21H17.546L24 13.96Zm.736-.804Z' },
      null,
      -1
    ),
    wz = Se(
      'path',
      { d: 'm24 14-6 7h12l-6-7Z', fill: 'currentColor', stroke: 'none' },
      null,
      -1
    ),
    xz = [Cz, wz]
  function Mz(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        xz,
        14,
        Sz
      )
    )
  }
  var a0 = Te(_z, [['render', Mz]])
  const Ez = Object.assign(a0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + a0.name, a0)
      },
    }),
    Pz = ce({
      name: 'BackTop',
      components: { IconToTop: Ez },
      props: {
        visibleHeight: { type: Number, default: 200 },
        targetContainer: { type: [String, Object] },
        easing: { type: String, default: 'quartOut' },
        duration: { type: Number, default: 200 },
      },
      setup(e) {
        const t = ye('back-top'),
          n = J(!1),
          r = J(),
          i = !e.targetContainer,
          o = Gu(() => {
            if (r.value) {
              const { visibleHeight: l } = e,
                { scrollTop: c } = r.value
              n.value = c >= l
            }
          }),
          a = (l) => (ir(l) ? document.querySelector(l) : l)
        return (
          Wt(() => {
            ;(r.value = i
              ? document == null
                ? void 0
                : document.documentElement
              : a(e.targetContainer)),
              r.value && (Cn(i ? window : r.value, 'scroll', o), o())
          }),
          wr(() => {
            o.cancel(), r.value && kn(i ? window : r.value, 'scroll', o)
          }),
          {
            prefixCls: t,
            visible: n,
            scrollToTop: () => {
              if (r.value) {
                const { scrollTop: l } = r.value
                new Ol({
                  from: { scrollTop: l },
                  to: { scrollTop: 0 },
                  easing: e.easing,
                  duration: e.duration,
                  onUpdate: (d) => {
                    r.value && (r.value.scrollTop = d.scrollTop)
                  },
                }).start()
              }
            },
          }
        )
      },
    })
  function Tz(e, t, n, r, i, o) {
    const a = ge('icon-to-top')
    return (
      O(),
      Ee(
        Fr,
        { name: 'fade-in' },
        {
          default: ze(() => [
            e.visible
              ? (O(),
                Z(
                  'div',
                  {
                    key: 0,
                    class: H(e.prefixCls),
                    onClick:
                      t[0] ||
                      (t[0] = (...s) => e.scrollToTop && e.scrollToTop(...s)),
                  },
                  [
                    ve(e.$slots, 'default', {}, () => [
                      Se(
                        'button',
                        { class: H(`${e.prefixCls}-btn`) },
                        [m(a)],
                        2
                      ),
                    ]),
                  ],
                  2
                ))
              : Ce('v-if', !0),
          ]),
          _: 3,
        }
      )
    )
  }
  var s0 = Te(Pz, [['render', Tz]])
  const kz = Object.assign(s0, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + s0.name, s0)
    },
  })
  var Az = Object.defineProperty,
    dx = Object.getOwnPropertySymbols,
    $z = Object.prototype.hasOwnProperty,
    Oz = Object.prototype.propertyIsEnumerable,
    fx = (e, t, n) =>
      t in e
        ? Az(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    l0 = (e, t) => {
      for (var n in t || (t = {})) $z.call(t, n) && fx(e, n, t[n])
      if (dx) for (var n of dx(t)) Oz.call(t, n) && fx(e, n, t[n])
      return e
    }
  const Lz = [
      'red',
      'orangered',
      'orange',
      'gold',
      'lime',
      'green',
      'cyan',
      'arcoblue',
      'purple',
      'pinkpurple',
      'magenta',
      'gray',
    ],
    Iz = ['normal', 'processing', 'success', 'warning', 'danger']
  var u0 = ce({
    name: 'Badge',
    props: {
      text: { type: String },
      dot: { type: Boolean },
      dotStyle: { type: Object },
      maxCount: { type: Number, default: 99 },
      offset: { type: Array, default: () => [] },
      color: { type: String },
      status: { type: String, validator: (e) => Iz.includes(e) },
      count: { type: Number },
    },
    setup(e, { slots: t }) {
      const {
          status: n,
          color: r,
          dotStyle: i,
          offset: o,
          text: a,
          dot: s,
          maxCount: l,
          count: c,
        } = tt(e),
        d = ye('badge'),
        h = Rz(d, n == null ? void 0 : n.value, t == null ? void 0 : t.default),
        p = C(() => {
          const g = l0({}, (i == null ? void 0 : i.value) || {}),
            [_, b] = (o == null ? void 0 : o.value) || []
          _ && (g.marginRight = `${-_}px`), b && (g.marginTop = `${b}px`)
          const y =
            !(r != null && r.value) || Lz.includes(r == null ? void 0 : r.value)
              ? {}
              : { backgroundColor: r.value }
          return {
            mergedStyle: l0(l0({}, y), g),
            computedDotStyle: g,
            computedColorStyle: y,
          }
        }),
        v = () => {
          const g = a == null ? void 0 : a.value,
            _ = r == null ? void 0 : r.value,
            b = n == null ? void 0 : n.value,
            y = s == null ? void 0 : s.value,
            M = Number(c == null ? void 0 : c.value),
            x = (c == null ? void 0 : c.value) != null,
            { computedDotStyle: w, mergedStyle: E } = p.value
          return t.content
            ? m('span', { class: `${d}-custom-dot`, style: w }, [t.content()])
            : g && !_ && !b
            ? m('span', { class: `${d}-text`, style: w }, [g])
            : b || (_ && !x)
            ? m('span', { class: `${d}-status-wrapper` }, [
                m(
                  'span',
                  {
                    class: [
                      `${d}-status-dot`,
                      { [`${d}-status-${b}`]: b, [`${d}-color-${_}`]: _ },
                    ],
                    style: E,
                  },
                  null
                ),
                g && m('span', { class: `${d}-status-text` }, [g]),
              ])
            : (y || _) && M > 0
            ? m(
                'span',
                { class: [`${d}-dot`, { [`${d}-color-${_}`]: _ }], style: E },
                null
              )
            : M === 0
            ? null
            : m('span', { class: `${d}-number`, style: E }, [
                m('span', null, [l.value && M > l.value ? `${l.value}+` : M]),
              ])
        }
      return () =>
        m('span', { class: h.value }, [t.default && t.default(), v()])
    },
  })
  const Rz = (e, t, n) =>
      C(() => [e, { [`${e}-status`]: t, [`${e}-no-children`]: !n }]),
    Dz = Object.assign(u0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + u0.name, u0)
      },
    }),
    X4 = Symbol('ArcoBreadcrumb'),
    Nz = ce({
      name: 'IconMore',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-more`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Bz = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Fz = Se(
      'path',
      {
        d: 'M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    zz = Se(
      'path',
      { d: 'M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z' },
      null,
      -1
    ),
    Vz = [Fz, zz]
  function Uz(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Vz,
        14,
        Bz
      )
    )
  }
  var c0 = Te(Nz, [['render', Uz]])
  const W_ = Object.assign(c0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + c0.name, c0)
      },
    }),
    Hz = ce({
      name: 'IconDown',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-down`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Wz = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    jz = Se('path', { d: 'M39.6 17.443 24.043 33 8.487 17.443' }, null, -1),
    Gz = [jz]
  function Kz(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Gz,
        14,
        Wz
      )
    )
  }
  var d0 = Te(Hz, [['render', Kz]])
  const sc = Object.assign(d0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + d0.name, d0)
      },
    }),
    qz = ce({
      name: 'IconObliqueLine',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-oblique-line`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Xz = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Yz = Se('path', { d: 'M29.506 6.502 18.493 41.498' }, null, -1),
    Zz = [Yz]
  function Jz(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Zz,
        14,
        Xz
      )
    )
  }
  var f0 = Te(qz, [['render', Jz]])
  const Qz = Object.assign(f0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + f0.name, f0)
      },
    }),
    j_ = Symbol('ArcoDropdown'),
    eV = ce({
      name: 'DropdownPanel',
      components: { Scrollbar: ia, Empty: Ls },
      props: {
        loading: { type: Boolean, default: !1 },
        isEmpty: { type: Boolean, default: !1 },
        bottomOffset: { type: Number, default: 0 },
        onScroll: { type: [Function, Array] },
        onReachBottom: { type: [Function, Array] },
      },
      emits: ['scroll', 'reachBottom'],
      setup(e, { emit: t, slots: n }) {
        const r = ye('dropdown'),
          i = zt(j_, {}),
          o = J(),
          a = (c) => {
            const { scrollTop: d, scrollHeight: h, offsetHeight: p } = c.target
            h - (d + p) <= e.bottomOffset && t('reachBottom', c), t('scroll', c)
          },
          s = C(() => {
            if (it(i.popupMaxHeight))
              return { maxHeight: `${i.popupMaxHeight}px` }
            if (!i.popupMaxHeight)
              return { maxHeight: 'none', overflowY: 'hidden' }
          }),
          l = C(() => [r, { [`${r}-has-footer`]: !!n.footer }])
        return {
          prefixCls: r,
          cls: l,
          style: s,
          wrapperRef: o,
          handleScroll: a,
        }
      },
    })
  function tV(e, t, n, r, i, o) {
    const a = ge('empty'),
      s = ge('Scrollbar')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          e.isEmpty
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-empty`) },
                [ve(e.$slots, 'empty', {}, () => [m(a)])],
                2
              ))
            : Ce('v-if', !0),
          m(
            s,
            {
              ref: 'wrapperRef',
              class: H(`${e.prefixCls}-list-wrapper`),
              style: at(e.style),
              onScroll: e.handleScroll,
            },
            {
              default: ze(() => [
                Se(
                  'ul',
                  { class: H(`${e.prefixCls}-list`) },
                  [ve(e.$slots, 'default')],
                  2
                ),
              ]),
              _: 3,
            },
            8,
            ['class', 'style', 'onScroll']
          ),
          e.$slots.footer && !e.isEmpty
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-footer`) },
                [ve(e.$slots, 'footer')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Y4 = Te(eV, [['render', tV]])
  const Jv = ({ popupVisible: e, defaultPopupVisible: t, emit: n }) => {
      var r
      const i = J((r = t == null ? void 0 : t.value) != null ? r : !1),
        o = C(() => {
          var s
          return (s = e == null ? void 0 : e.value) != null ? s : i.value
        }),
        a = (s) => {
          s !== o.value &&
            ((i.value = s),
            n('update:popupVisible', s),
            n('popupVisibleChange', s))
        }
      return (
        pt(o, (s) => {
          i.value !== s && (i.value = s)
        }),
        { computedPopupVisible: o, handlePopupVisibleChange: a }
      )
    },
    nV = ce({
      name: 'Dropdown',
      components: { Trigger: Mr, DropdownPanel: Y4 },
      props: {
        popupVisible: { type: Boolean, default: void 0 },
        defaultPopupVisible: { type: Boolean, default: !1 },
        trigger: { type: [String, Array], default: 'click' },
        position: { type: String, default: 'bottom' },
        popupContainer: { type: [String, Object] },
        popupMaxHeight: { type: [Boolean, Number], default: !0 },
        hideOnSelect: { type: Boolean, default: !0 },
      },
      emits: {
        'update:popupVisible': (e) => !0,
        popupVisibleChange: (e) => !0,
        select: (e, t) => !0,
      },
      setup(e, { emit: t }) {
        const {
            defaultPopupVisible: n,
            popupVisible: r,
            popupMaxHeight: i,
          } = tt(e),
          o = ye('dropdown'),
          { computedPopupVisible: a, handlePopupVisibleChange: s } = Jv({
            defaultPopupVisible: n,
            popupVisible: r,
            emit: t,
          })
        return (
          sn(
            j_,
            Je({
              popupMaxHeight: i,
              onOptionClick: (c, d) => {
                t('select', c, d), e.hideOnSelect && s(!1)
              },
            })
          ),
          { prefixCls: o, computedPopupVisible: a, handlePopupVisibleChange: s }
        )
      },
    })
  function rV(e, t, n, r, i, o) {
    const a = ge('DropdownPanel'),
      s = ge('Trigger')
    return (
      O(),
      Ee(
        s,
        {
          'popup-visible': e.computedPopupVisible,
          'animation-name': 'slide-dynamic-origin',
          'auto-fit-transform-origin': '',
          trigger: e.trigger,
          position: e.position,
          'popup-offset': 4,
          'popup-container': e.popupContainer,
          'opened-class': `${e.prefixCls}-open`,
          onPopupVisibleChange: e.handlePopupVisibleChange,
        },
        {
          content: ze(() => [
            m(
              a,
              null,
              Nn({ default: ze(() => [ve(e.$slots, 'content')]), _: 2 }, [
                e.$slots.footer
                  ? { name: 'footer', fn: ze(() => [ve(e.$slots, 'footer')]) }
                  : void 0,
              ]),
              1024
            ),
          ]),
          default: ze(() => [ve(e.$slots, 'default')]),
          _: 3,
        },
        8,
        [
          'popup-visible',
          'trigger',
          'position',
          'popup-container',
          'opened-class',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var rp = Te(nV, [['render', rV]])
  const iV = ce({
    name: 'Doption',
    props: {
      value: { type: [String, Number, Object] },
      disabled: { type: Boolean, default: !1 },
      active: Boolean,
      uninjectContext: Boolean,
    },
    emits: { click: (e) => !0 },
    setup(e, { emit: t }) {
      const n = ye('dropdown-option'),
        r = J(),
        i = C(() => {
          var l, c, d
          return (d =
            (c = e.value) != null
              ? c
              : (l = r.value) == null
              ? void 0
              : l.textContent) != null
            ? d
            : void 0
        }),
        o = e.uninjectContext ? void 0 : zt(j_, void 0),
        a = (l) => {
          e.disabled ||
            (t('click', l), o == null || o.onOptionClick(i.value, l))
        },
        s = C(() => [
          n,
          { [`${n}-disabled`]: e.disabled, [`${n}-active`]: e.active },
        ])
      return { prefixCls: n, cls: s, liRef: r, handleClick: a }
    },
  })
  function oV(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'li',
        {
          ref: 'liRef',
          class: H([
            e.cls,
            { [`${e.prefixCls}-has-suffix`]: !!e.$slots.suffix },
          ]),
          onClick:
            t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a)),
        },
        [
          e.$slots.icon
            ? (O(),
              Z(
                'span',
                { key: 0, class: H(`${e.prefixCls}-icon`) },
                [ve(e.$slots, 'icon')],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'span',
            { class: H(`${e.prefixCls}-content`) },
            [ve(e.$slots, 'default')],
            2
          ),
          e.$slots.suffix
            ? (O(),
              Z(
                'span',
                { key: 1, class: H(`${e.prefixCls}-suffix`) },
                [ve(e.$slots, 'suffix')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Du = Te(iV, [['render', oV]])
  const aV = ce({
    name: 'Dgroup',
    props: { title: String },
    setup() {
      return { prefixCls: ye('dropdown-group') }
    },
  })
  function sV(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        yt,
        null,
        [
          Se(
            'li',
            { class: H(`${e.prefixCls}-title`) },
            [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
            2
          ),
          ve(e.$slots, 'default'),
        ],
        64
      )
    )
  }
  var ip = Te(aV, [['render', sV]])
  const lV = ce({
      name: 'IconRight',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-right`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    uV = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    cV = Se('path', { d: 'm16 39.513 15.556-15.557L16 8.4' }, null, -1),
    dV = [cV]
  function fV(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        dV,
        14,
        uV
      )
    )
  }
  var h0 = Te(lV, [['render', fV]])
  const No = Object.assign(h0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + h0.name, h0)
      },
    }),
    hV = ce({
      name: 'Dsubmenu',
      components: {
        Trigger: Mr,
        DropdownPanel: Y4,
        DropdownOption: Du,
        IconRight: No,
      },
      props: {
        value: { type: [String, Number] },
        disabled: { type: Boolean, default: !1 },
        trigger: { type: [String, Array], default: 'click' },
        position: { type: String, default: 'rt' },
        popupVisible: { type: Boolean, default: void 0 },
        defaultPopupVisible: { type: Boolean, default: !1 },
        optionProps: { type: Object },
      },
      emits: {
        'update:popupVisible': (e) => !0,
        popupVisibleChange: (e) => !0,
      },
      setup(e, { emit: t }) {
        const { defaultPopupVisible: n, popupVisible: r } = tt(e),
          i = ye('dropdown'),
          { computedPopupVisible: o, handlePopupVisibleChange: a } = Jv({
            defaultPopupVisible: n,
            popupVisible: r,
            emit: t,
          })
        return {
          prefixCls: i,
          computedPopupVisible: o,
          handlePopupVisibleChange: a,
        }
      },
    })
  function pV(e, t, n, r, i, o) {
    const a = ge('IconRight'),
      s = ge('dropdown-option'),
      l = ge('dropdown-panel'),
      c = ge('Trigger')
    return (
      O(),
      Ee(
        c,
        {
          'popup-visible': e.computedPopupVisible,
          trigger: e.trigger,
          position: e.position,
          disabled: e.disabled,
          'popup-offset': 4,
          onPopupVisibleChange: e.handlePopupVisibleChange,
        },
        {
          content: ze(() => [
            m(
              l,
              { class: H(`${e.prefixCls}-submenu`) },
              Nn({ default: ze(() => [ve(e.$slots, 'content')]), _: 2 }, [
                e.$slots.footer
                  ? { name: 'footer', fn: ze(() => [ve(e.$slots, 'footer')]) }
                  : void 0,
              ]),
              1032,
              ['class']
            ),
          ]),
          default: ze(() => [
            m(
              s,
              Fe(e.optionProps, {
                active: e.computedPopupVisible,
                'uninject-context': '',
              }),
              Nn(
                {
                  suffix: ze(() => [ve(e.$slots, 'suffix', {}, () => [m(a)])]),
                  default: ze(() => [ve(e.$slots, 'default')]),
                  _: 2,
                },
                [
                  e.$slots.icon
                    ? { name: 'icon', fn: ze(() => [ve(e.$slots, 'icon')]) }
                    : void 0,
                ]
              ),
              1040,
              ['active']
            ),
          ]),
          _: 3,
        },
        8,
        [
          'popup-visible',
          'trigger',
          'position',
          'disabled',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var op = Te(hV, [['render', pV]])
  const vV = ce({
    name: 'DropdownButton',
    components: { IconMore: W_, Button: Yr, ButtonGroup: ld, Dropdown: rp },
    props: {
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      trigger: { type: [String, Array], default: 'click' },
      position: { type: String, default: 'br' },
      popupContainer: { type: [String, Object] },
      disabled: { type: Boolean, default: !1 },
      type: { type: String },
      size: { type: String },
      buttonProps: { type: Object },
      hideOnSelect: { type: Boolean, default: !0 },
    },
    emits: {
      'update:popupVisible': (e) => !0,
      popupVisibleChange: (e) => !0,
      click: (e) => !0,
      select: (e, t) => !0,
    },
    setup(e, { emit: t }) {
      const { defaultPopupVisible: n, popupVisible: r } = tt(e),
        i = ye('dropdown'),
        { computedPopupVisible: o, handlePopupVisibleChange: a } = Jv({
          defaultPopupVisible: n,
          popupVisible: r,
          emit: t,
        })
      return {
        prefixCls: i,
        computedPopupVisible: o,
        handleClick: (c) => {
          t('click', c)
        },
        handleSelect: (c, d) => {
          t('select', c, d)
        },
        handlePopupVisibleChange: a,
      }
    },
  })
  function mV(e, t, n, r, i, o) {
    const a = ge('Button'),
      s = ge('IconMore'),
      l = ge('Dropdown'),
      c = ge('ButtonGroup')
    return (
      O(),
      Ee(c, null, {
        default: ze(() => [
          m(
            a,
            Fe(
              { size: e.size, type: e.type, disabled: e.disabled },
              e.buttonProps,
              { onClick: e.handleClick }
            ),
            { default: ze(() => [ve(e.$slots, 'default')]), _: 3 },
            16,
            ['size', 'type', 'disabled', 'onClick']
          ),
          m(
            l,
            {
              'popup-visible': e.computedPopupVisible,
              trigger: e.trigger,
              position: e.position,
              'popup-container': e.popupContainer,
              'hide-on-select': e.hideOnSelect,
              onSelect: e.handleSelect,
              onPopupVisibleChange: e.handlePopupVisibleChange,
            },
            {
              content: ze(() => [ve(e.$slots, 'content')]),
              default: ze(() => [
                m(
                  a,
                  { size: e.size, type: e.type, disabled: e.disabled },
                  {
                    icon: ze(() => [
                      ve(
                        e.$slots,
                        'icon',
                        { popupVisible: e.computedPopupVisible },
                        () => [m(s)]
                      ),
                    ]),
                    _: 3,
                  },
                  8,
                  ['size', 'type', 'disabled']
                ),
              ]),
              _: 3,
            },
            8,
            [
              'popup-visible',
              'trigger',
              'position',
              'popup-container',
              'hide-on-select',
              'onSelect',
              'onPopupVisibleChange',
            ]
          ),
        ]),
        _: 3,
      })
    )
  }
  var ap = Te(vV, [['render', mV]])
  const Z4 = Object.assign(rp, {
    Option: Du,
    Group: ip,
    Submenu: op,
    Button: ap,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + rp.name, rp),
        e.component(n + Du.name, Du),
        e.component(n + ip.name, ip),
        e.component(n + op.name, op),
        e.component(n + ap.name, ap)
    },
  })
  var ud = ce({
      name: 'BreadcrumbItem',
      inheritAttrs: !1,
      props: {
        separator: { type: [String, Number] },
        droplist: { type: Array },
        dropdownProps: { type: Object },
        index: { type: Number, default: 0 },
      },
      setup(e, { slots: t, attrs: n }) {
        const r = ye('breadcrumb-item'),
          i = zt(X4, void 0),
          o = J(!1),
          a = C(
            () =>
              !(
                i &&
                i.needHide &&
                e.index > 1 &&
                e.index <= i.total - i.maxCount
              )
          ),
          s = C(() => (i && i.needHide ? e.index === 1 : !1)),
          l = C(() => (i ? e.index < i.total - 1 : !0)),
          c = (g) => {
            o.value = g
          },
          d = () => {
            var g, _, b, y, M, x, w
            if (!l.value) return null
            const E =
              (w =
                (x =
                  (M =
                    (_ = (g = t.separator) == null ? void 0 : g.call(t)) != null
                      ? _
                      : e.separator) != null
                    ? M
                    : (y = i == null ? void 0 : (b = i.slots).separator) == null
                    ? void 0
                    : y.call(b)) != null
                  ? x
                  : i == null
                  ? void 0
                  : i.separator) != null
                ? w
                : m(Qz, null, null)
            return m(
              'div',
              { 'aria-hidden': 'true', class: `${r}-separator` },
              [E]
            )
          },
          h = () => {
            var g, _, b, y
            return m(
              'div',
              Fe(
                {
                  role: 'listitem',
                  class: [
                    r,
                    { [`${r}-with-dropdown`]: e.droplist || t.droplist },
                  ],
                },
                s.value
                  ? { 'aria-label': 'ellipses of breadcrumb items' }
                  : void 0,
                n
              ),
              [
                s.value
                  ? (b =
                      (_ = i == null ? void 0 : (g = i.slots)['more-icon']) ==
                      null
                        ? void 0
                        : _.call(g)) != null
                    ? b
                    : m(W_, null, null)
                  : (y = t.default) == null
                  ? void 0
                  : y.call(t),
                (e.droplist || t.droplist) &&
                  m(
                    'span',
                    {
                      'aria-hidden': !0,
                      class: [
                        `${r}-dropdown-icon`,
                        { [`${r}-dropdown-icon-active`]: o.value },
                      ],
                    },
                    [m(sc, null, null)]
                  ),
              ]
            )
          },
          p = () => {
            var g, _, b
            return (b = (g = t.droplist) == null ? void 0 : g.call(t)) != null
              ? b
              : (_ = e.droplist) == null
              ? void 0
              : _.map((y) =>
                  m(Du, { value: y.path }, { default: () => [y.label] })
                )
          },
          v = () =>
            m(
              Z4,
              Fe(
                { popupVisible: o.value, onPopupVisibleChange: c },
                e.dropdownProps
              ),
              { default: () => [h()], content: p }
            )
        return () =>
          a.value
            ? m(yt, null, [t.droplist || e.droplist ? v() : h(), d()])
            : null
      },
    }),
    p0 = ce({
      name: 'Breadcrumb',
      props: {
        maxCount: { type: Number, default: 0 },
        routes: { type: Array },
        separator: { type: [String, Number] },
        customUrl: { type: Function },
      },
      setup(e, { slots: t }) {
        const { maxCount: n, separator: r, routes: i } = tt(e),
          o = ye('breadcrumb'),
          a = J(0),
          s = C(() => n.value > 0 && a.value > n.value + 1)
        sn(
          X4,
          Je({ total: a, maxCount: n, separator: r, needHide: s, slots: t })
        )
        const l = (h, p, v) => {
            var g, _
            if (p.indexOf(h) === p.length - 1) return m('span', null, [h.label])
            const b =
              (_ = (g = e.customUrl) == null ? void 0 : g.call(e, v)) != null
                ? _
                : `#/${v.join('/').replace(/^\//, '')}`
            return m('a', { href: b }, [h.label])
          },
          c = () => {
            var h
            if (!((h = i.value) != null && h.length)) return null
            a.value !== i.value.length && (a.value = i.value.length)
            const p = []
            return i.value.map((v, g, _) => {
              p.push((v.path || '').replace(/^\//, ''))
              const b = [...p]
              return m(
                ud,
                { key: v.path || v.label, index: g, droplist: v.children },
                {
                  default: () => {
                    var y, M
                    return [
                      (M =
                        (y = t['item-render']) == null
                          ? void 0
                          : y.call(t, { route: v, routes: _, paths: b })) !=
                      null
                        ? M
                        : l(v, _, b),
                    ]
                  },
                }
              )
            })
          },
          d = () => {
            var h, p
            const v = ea(
              (p = (h = t.default) == null ? void 0 : h.call(t)) != null
                ? p
                : []
            )
            return (
              a.value !== v.length && (a.value = v.length),
              v.map((g, _) => {
                var b
                return (
                  (g.props = Fe((b = g.props) != null ? b : {}, { index: _ })),
                  g
                )
              })
            )
          }
        return () =>
          m('div', { role: 'list', class: o }, [t.default ? d() : c()])
      },
    })
  const gV = Object.assign(p0, {
    Item: ud,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + p0.name, p0), e.component(n + ud.name, ud)
    },
  })
  var Bi =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {}
  function Ll(e) {
    return e &&
      e.__esModule &&
      Object.prototype.hasOwnProperty.call(e, 'default')
      ? e.default
      : e
  }
  var J4 = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      var n = 1e3,
        r = 6e4,
        i = 36e5,
        o = 'millisecond',
        a = 'second',
        s = 'minute',
        l = 'hour',
        c = 'day',
        d = 'week',
        h = 'month',
        p = 'quarter',
        v = 'year',
        g = 'date',
        _ = 'Invalid Date',
        b =
          /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y =
          /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        M = {
          name: 'en',
          weekdays:
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
            ),
          months:
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
            ),
          ordinal: function (N) {
            var I = ['th', 'st', 'nd', 'rd'],
              B = N % 100
            return '[' + N + (I[(B - 20) % 10] || I[B] || I[0]) + ']'
          },
        },
        x = function (N, I, B) {
          var V = String(N)
          return !V || V.length >= I
            ? N
            : '' + Array(I + 1 - V.length).join(B) + N
        },
        w = {
          s: x,
          z: function (N) {
            var I = -N.utcOffset(),
              B = Math.abs(I),
              V = Math.floor(B / 60),
              L = B % 60
            return (I <= 0 ? '+' : '-') + x(V, 2, '0') + ':' + x(L, 2, '0')
          },
          m: function N(I, B) {
            if (I.date() < B.date()) return -N(B, I)
            var V = 12 * (B.year() - I.year()) + (B.month() - I.month()),
              L = I.clone().add(V, h),
              W = B - L < 0,
              Y = I.clone().add(V + (W ? -1 : 1), h)
            return +(-(V + (B - L) / (W ? L - Y : Y - L)) || 0)
          },
          a: function (N) {
            return N < 0 ? Math.ceil(N) || 0 : Math.floor(N)
          },
          p: function (N) {
            return (
              { M: h, y: v, w: d, d: c, D: g, h: l, m: s, s: a, ms: o, Q: p }[
                N
              ] ||
              String(N || '')
                .toLowerCase()
                .replace(/s$/, '')
            )
          },
          u: function (N) {
            return N === void 0
          },
        },
        E = 'en',
        P = {}
      P[E] = M
      var A = function (N) {
          return N instanceof R
        },
        F = function N(I, B, V) {
          var L
          if (!I) return E
          if (typeof I == 'string') {
            var W = I.toLowerCase()
            P[W] && (L = W), B && ((P[W] = B), (L = W))
            var Y = I.split('-')
            if (!L && Y.length > 1) return N(Y[0])
          } else {
            var U = I.name
            ;(P[U] = I), (L = U)
          }
          return !V && L && (E = L), L || (!V && E)
        },
        T = function (N, I) {
          if (A(N)) return N.clone()
          var B = typeof I == 'object' ? I : {}
          return (B.date = N), (B.args = arguments), new R(B)
        },
        k = w
      ;(k.l = F),
        (k.i = A),
        (k.w = function (N, I) {
          return T(N, { locale: I.$L, utc: I.$u, x: I.$x, $offset: I.$offset })
        })
      var R = (function () {
          function N(B) {
            ;(this.$L = F(B.locale, null, !0)), this.parse(B)
          }
          var I = N.prototype
          return (
            (I.parse = function (B) {
              ;(this.$d = (function (V) {
                var L = V.date,
                  W = V.utc
                if (L === null) return new Date(NaN)
                if (k.u(L)) return new Date()
                if (L instanceof Date) return new Date(L)
                if (typeof L == 'string' && !/Z$/i.test(L)) {
                  var Y = L.match(b)
                  if (Y) {
                    var U = Y[2] - 1 || 0,
                      le = (Y[7] || '0').substring(0, 3)
                    return W
                      ? new Date(
                          Date.UTC(
                            Y[1],
                            U,
                            Y[3] || 1,
                            Y[4] || 0,
                            Y[5] || 0,
                            Y[6] || 0,
                            le
                          )
                        )
                      : new Date(
                          Y[1],
                          U,
                          Y[3] || 1,
                          Y[4] || 0,
                          Y[5] || 0,
                          Y[6] || 0,
                          le
                        )
                  }
                }
                return new Date(L)
              })(B)),
                (this.$x = B.x || {}),
                this.init()
            }),
            (I.init = function () {
              var B = this.$d
              ;(this.$y = B.getFullYear()),
                (this.$M = B.getMonth()),
                (this.$D = B.getDate()),
                (this.$W = B.getDay()),
                (this.$H = B.getHours()),
                (this.$m = B.getMinutes()),
                (this.$s = B.getSeconds()),
                (this.$ms = B.getMilliseconds())
            }),
            (I.$utils = function () {
              return k
            }),
            (I.isValid = function () {
              return this.$d.toString() !== _
            }),
            (I.isSame = function (B, V) {
              var L = T(B)
              return this.startOf(V) <= L && L <= this.endOf(V)
            }),
            (I.isAfter = function (B, V) {
              return T(B) < this.startOf(V)
            }),
            (I.isBefore = function (B, V) {
              return this.endOf(V) < T(B)
            }),
            (I.$g = function (B, V, L) {
              return k.u(B) ? this[V] : this.set(L, B)
            }),
            (I.unix = function () {
              return Math.floor(this.valueOf() / 1e3)
            }),
            (I.valueOf = function () {
              return this.$d.getTime()
            }),
            (I.startOf = function (B, V) {
              var L = this,
                W = !!k.u(V) || V,
                Y = k.p(B),
                U = function (qe, Ve) {
                  var nt = k.w(
                    L.$u ? Date.UTC(L.$y, Ve, qe) : new Date(L.$y, Ve, qe),
                    L
                  )
                  return W ? nt : nt.endOf(c)
                },
                le = function (qe, Ve) {
                  return k.w(
                    L.toDate()[qe].apply(
                      L.toDate('s'),
                      (W ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ve)
                    ),
                    L
                  )
                },
                q = this.$W,
                oe = this.$M,
                te = this.$D,
                ue = 'set' + (this.$u ? 'UTC' : '')
              switch (Y) {
                case v:
                  return W ? U(1, 0) : U(31, 11)
                case h:
                  return W ? U(1, oe) : U(0, oe + 1)
                case d:
                  var me = this.$locale().weekStart || 0,
                    Re = (q < me ? q + 7 : q) - me
                  return U(W ? te - Re : te + (6 - Re), oe)
                case c:
                case g:
                  return le(ue + 'Hours', 0)
                case l:
                  return le(ue + 'Minutes', 1)
                case s:
                  return le(ue + 'Seconds', 2)
                case a:
                  return le(ue + 'Milliseconds', 3)
                default:
                  return this.clone()
              }
            }),
            (I.endOf = function (B) {
              return this.startOf(B, !1)
            }),
            (I.$set = function (B, V) {
              var L,
                W = k.p(B),
                Y = 'set' + (this.$u ? 'UTC' : ''),
                U = ((L = {}),
                (L[c] = Y + 'Date'),
                (L[g] = Y + 'Date'),
                (L[h] = Y + 'Month'),
                (L[v] = Y + 'FullYear'),
                (L[l] = Y + 'Hours'),
                (L[s] = Y + 'Minutes'),
                (L[a] = Y + 'Seconds'),
                (L[o] = Y + 'Milliseconds'),
                L)[W],
                le = W === c ? this.$D + (V - this.$W) : V
              if (W === h || W === v) {
                var q = this.clone().set(g, 1)
                q.$d[U](le),
                  q.init(),
                  (this.$d = q.set(g, Math.min(this.$D, q.daysInMonth())).$d)
              } else U && this.$d[U](le)
              return this.init(), this
            }),
            (I.set = function (B, V) {
              return this.clone().$set(B, V)
            }),
            (I.get = function (B) {
              return this[k.p(B)]()
            }),
            (I.add = function (B, V) {
              var L,
                W = this
              B = Number(B)
              var Y = k.p(V),
                U = function (oe) {
                  var te = T(W)
                  return k.w(te.date(te.date() + Math.round(oe * B)), W)
                }
              if (Y === h) return this.set(h, this.$M + B)
              if (Y === v) return this.set(v, this.$y + B)
              if (Y === c) return U(1)
              if (Y === d) return U(7)
              var le =
                  ((L = {}), (L[s] = r), (L[l] = i), (L[a] = n), L)[Y] || 1,
                q = this.$d.getTime() + B * le
              return k.w(q, this)
            }),
            (I.subtract = function (B, V) {
              return this.add(-1 * B, V)
            }),
            (I.format = function (B) {
              var V = this,
                L = this.$locale()
              if (!this.isValid()) return L.invalidDate || _
              var W = B || 'YYYY-MM-DDTHH:mm:ssZ',
                Y = k.z(this),
                U = this.$H,
                le = this.$m,
                q = this.$M,
                oe = L.weekdays,
                te = L.months,
                ue = function (Ve, nt, We, D) {
                  return (Ve && (Ve[nt] || Ve(V, W))) || We[nt].slice(0, D)
                },
                me = function (Ve) {
                  return k.s(U % 12 || 12, Ve, '0')
                },
                Re =
                  L.meridiem ||
                  function (Ve, nt, We) {
                    var D = Ve < 12 ? 'AM' : 'PM'
                    return We ? D.toLowerCase() : D
                  },
                qe = {
                  YY: String(this.$y).slice(-2),
                  YYYY: k.s(this.$y, 4, '0'),
                  M: q + 1,
                  MM: k.s(q + 1, 2, '0'),
                  MMM: ue(L.monthsShort, q, te, 3),
                  MMMM: ue(te, q),
                  D: this.$D,
                  DD: k.s(this.$D, 2, '0'),
                  d: String(this.$W),
                  dd: ue(L.weekdaysMin, this.$W, oe, 2),
                  ddd: ue(L.weekdaysShort, this.$W, oe, 3),
                  dddd: oe[this.$W],
                  H: String(U),
                  HH: k.s(U, 2, '0'),
                  h: me(1),
                  hh: me(2),
                  a: Re(U, le, !0),
                  A: Re(U, le, !1),
                  m: String(le),
                  mm: k.s(le, 2, '0'),
                  s: String(this.$s),
                  ss: k.s(this.$s, 2, '0'),
                  SSS: k.s(this.$ms, 3, '0'),
                  Z: Y,
                }
              return W.replace(y, function (Ve, nt) {
                return nt || qe[Ve] || Y.replace(':', '')
              })
            }),
            (I.utcOffset = function () {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }),
            (I.diff = function (B, V, L) {
              var W,
                Y = k.p(V),
                U = T(B),
                le = (U.utcOffset() - this.utcOffset()) * r,
                q = this - U,
                oe = k.m(this, U)
              return (
                (oe =
                  ((W = {}),
                  (W[v] = oe / 12),
                  (W[h] = oe),
                  (W[p] = oe / 3),
                  (W[d] = (q - le) / 6048e5),
                  (W[c] = (q - le) / 864e5),
                  (W[l] = q / i),
                  (W[s] = q / r),
                  (W[a] = q / n),
                  W)[Y] || q),
                L ? oe : k.a(oe)
              )
            }),
            (I.daysInMonth = function () {
              return this.endOf(h).$D
            }),
            (I.$locale = function () {
              return P[this.$L]
            }),
            (I.locale = function (B, V) {
              if (!B) return this.$L
              var L = this.clone(),
                W = F(B, V, !0)
              return W && (L.$L = W), L
            }),
            (I.clone = function () {
              return k.w(this.$d, this)
            }),
            (I.toDate = function () {
              return new Date(this.valueOf())
            }),
            (I.toJSON = function () {
              return this.isValid() ? this.toISOString() : null
            }),
            (I.toISOString = function () {
              return this.$d.toISOString()
            }),
            (I.toString = function () {
              return this.$d.toUTCString()
            }),
            N
          )
        })(),
        j = R.prototype
      return (
        (T.prototype = j),
        [
          ['$ms', o],
          ['$s', a],
          ['$m', s],
          ['$H', l],
          ['$W', c],
          ['$M', h],
          ['$y', v],
          ['$D', g],
        ].forEach(function (N) {
          j[N[1]] = function (I) {
            return this.$g(I, N[0], N[1])
          }
        }),
        (T.extend = function (N, I) {
          return N.$i || (N(I, R, T), (N.$i = !0)), T
        }),
        (T.locale = F),
        (T.isDayjs = A),
        (T.unix = function (N) {
          return T(1e3 * N)
        }),
        (T.en = P[E]),
        (T.Ls = P),
        (T.p = {}),
        T
      )
    })
  })(J4)
  var Q4 = J4.exports
  const Kr = Ll(Q4)
  var ek = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      var n = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        r =
          /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        i = /\d\d/,
        o = /\d\d?/,
        a = /\d*[^-_:/,()\s\d]+/,
        s = {},
        l = function (_) {
          return (_ = +_) + (_ > 68 ? 1900 : 2e3)
        },
        c = function (_) {
          return function (b) {
            this[_] = +b
          }
        },
        d = [
          /[+-]\d\d:?(\d\d)?|Z/,
          function (_) {
            ;(this.zone || (this.zone = {})).offset = (function (b) {
              if (!b || b === 'Z') return 0
              var y = b.match(/([+-]|\d\d)/g),
                M = 60 * y[1] + (+y[2] || 0)
              return M === 0 ? 0 : y[0] === '+' ? -M : M
            })(_)
          },
        ],
        h = function (_) {
          var b = s[_]
          return b && (b.indexOf ? b : b.s.concat(b.f))
        },
        p = function (_, b) {
          var y,
            M = s.meridiem
          if (M) {
            for (var x = 1; x <= 24; x += 1)
              if (_.indexOf(M(x, 0, b)) > -1) {
                y = x > 12
                break
              }
          } else y = _ === (b ? 'pm' : 'PM')
          return y
        },
        v = {
          A: [
            a,
            function (_) {
              this.afternoon = p(_, !1)
            },
          ],
          a: [
            a,
            function (_) {
              this.afternoon = p(_, !0)
            },
          ],
          S: [
            /\d/,
            function (_) {
              this.milliseconds = 100 * +_
            },
          ],
          SS: [
            i,
            function (_) {
              this.milliseconds = 10 * +_
            },
          ],
          SSS: [
            /\d{3}/,
            function (_) {
              this.milliseconds = +_
            },
          ],
          s: [o, c('seconds')],
          ss: [o, c('seconds')],
          m: [o, c('minutes')],
          mm: [o, c('minutes')],
          H: [o, c('hours')],
          h: [o, c('hours')],
          HH: [o, c('hours')],
          hh: [o, c('hours')],
          D: [o, c('day')],
          DD: [i, c('day')],
          Do: [
            a,
            function (_) {
              var b = s.ordinal,
                y = _.match(/\d+/)
              if (((this.day = y[0]), b))
                for (var M = 1; M <= 31; M += 1)
                  b(M).replace(/\[|\]/g, '') === _ && (this.day = M)
            },
          ],
          M: [o, c('month')],
          MM: [i, c('month')],
          MMM: [
            a,
            function (_) {
              var b = h('months'),
                y =
                  (
                    h('monthsShort') ||
                    b.map(function (M) {
                      return M.slice(0, 3)
                    })
                  ).indexOf(_) + 1
              if (y < 1) throw new Error()
              this.month = y % 12 || y
            },
          ],
          MMMM: [
            a,
            function (_) {
              var b = h('months').indexOf(_) + 1
              if (b < 1) throw new Error()
              this.month = b % 12 || b
            },
          ],
          Y: [/[+-]?\d+/, c('year')],
          YY: [
            i,
            function (_) {
              this.year = l(_)
            },
          ],
          YYYY: [/\d{4}/, c('year')],
          Z: d,
          ZZ: d,
        }
      function g(_) {
        var b, y
        ;(b = _), (y = s && s.formats)
        for (
          var M = (_ = b.replace(
              /(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,
              function (T, k, R) {
                var j = R && R.toUpperCase()
                return (
                  k ||
                  y[R] ||
                  n[R] ||
                  y[j].replace(
                    /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                    function (N, I, B) {
                      return I || B.slice(1)
                    }
                  )
                )
              }
            )).match(r),
            x = M.length,
            w = 0;
          w < x;
          w += 1
        ) {
          var E = M[w],
            P = v[E],
            A = P && P[0],
            F = P && P[1]
          M[w] = F ? { regex: A, parser: F } : E.replace(/^\[|\]$/g, '')
        }
        return function (T) {
          for (var k = {}, R = 0, j = 0; R < x; R += 1) {
            var N = M[R]
            if (typeof N == 'string') j += N.length
            else {
              var I = N.regex,
                B = N.parser,
                V = T.slice(j),
                L = I.exec(V)[0]
              B.call(k, L), (T = T.replace(L, ''))
            }
          }
          return (
            (function (W) {
              var Y = W.afternoon
              if (Y !== void 0) {
                var U = W.hours
                Y ? U < 12 && (W.hours += 12) : U === 12 && (W.hours = 0),
                  delete W.afternoon
              }
            })(k),
            k
          )
        }
      }
      return function (_, b, y) {
        ;(y.p.customParseFormat = !0),
          _ && _.parseTwoDigitYear && (l = _.parseTwoDigitYear)
        var M = b.prototype,
          x = M.parse
        M.parse = function (w) {
          var E = w.date,
            P = w.utc,
            A = w.args
          this.$u = P
          var F = A[1]
          if (typeof F == 'string') {
            var T = A[2] === !0,
              k = A[3] === !0,
              R = T || k,
              j = A[2]
            k && (j = A[2]),
              (s = this.$locale()),
              !T && j && (s = y.Ls[j]),
              (this.$d = (function (V, L, W) {
                try {
                  if (['x', 'X'].indexOf(L) > -1)
                    return new Date((L === 'X' ? 1e3 : 1) * V)
                  var Y = g(L)(V),
                    U = Y.year,
                    le = Y.month,
                    q = Y.day,
                    oe = Y.hours,
                    te = Y.minutes,
                    ue = Y.seconds,
                    me = Y.milliseconds,
                    Re = Y.zone,
                    qe = new Date(),
                    Ve = q || (U || le ? 1 : qe.getDate()),
                    nt = U || qe.getFullYear(),
                    We = 0
                  ;(U && !le) || (We = le > 0 ? le - 1 : qe.getMonth())
                  var D = oe || 0,
                    G = te || 0,
                    z = ue || 0,
                    ie = me || 0
                  return Re
                    ? new Date(
                        Date.UTC(nt, We, Ve, D, G, z, ie + 60 * Re.offset * 1e3)
                      )
                    : W
                    ? new Date(Date.UTC(nt, We, Ve, D, G, z, ie))
                    : new Date(nt, We, Ve, D, G, z, ie)
                } catch {
                  return new Date('')
                }
              })(E, F, P)),
              this.init(),
              j && j !== !0 && (this.$L = this.locale(j).$L),
              R && E != this.format(F) && (this.$d = new Date('')),
              (s = {})
          } else if (F instanceof Array)
            for (var N = F.length, I = 1; I <= N; I += 1) {
              A[1] = F[I - 1]
              var B = y.apply(this, A)
              if (B.isValid()) {
                ;(this.$d = B.$d), (this.$L = B.$L), this.init()
                break
              }
              I === N && (this.$d = new Date(''))
            }
          else x.call(this, w)
        }
      }
    })
  })(ek)
  var yV = ek.exports
  const bV = Ll(yV)
  var tk = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      return function (n, r, i) {
        r.prototype.isBetween = function (o, a, s, l) {
          var c = i(o),
            d = i(a),
            h = (l = l || '()')[0] === '(',
            p = l[1] === ')'
          return (
            ((h ? this.isAfter(c, s) : !this.isBefore(c, s)) &&
              (p ? this.isBefore(d, s) : !this.isAfter(d, s))) ||
            ((h ? this.isBefore(c, s) : !this.isAfter(c, s)) &&
              (p ? this.isAfter(d, s) : !this.isBefore(d, s)))
          )
        }
      }
    })
  })(tk)
  var _V = tk.exports
  const SV = Ll(_V)
  var nk = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      var n = 'week',
        r = 'year'
      return function (i, o, a) {
        var s = o.prototype
        ;(s.week = function (l) {
          if ((l === void 0 && (l = null), l !== null))
            return this.add(7 * (l - this.week()), 'day')
          var c = this.$locale().yearStart || 1
          if (this.month() === 11 && this.date() > 25) {
            var d = a(this).startOf(r).add(1, r).date(c),
              h = a(this).endOf(n)
            if (d.isBefore(h)) return 1
          }
          var p = a(this)
              .startOf(r)
              .date(c)
              .startOf(n)
              .subtract(1, 'millisecond'),
            v = this.diff(p, n, !0)
          return v < 0 ? a(this).startOf('week').week() : Math.ceil(v)
        }),
          (s.weeks = function (l) {
            return l === void 0 && (l = null), this.week(l)
          })
      }
    })
  })(nk)
  var CV = nk.exports
  const wV = Ll(CV)
  var rk = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      return function (n, r) {
        var i = r.prototype,
          o = i.format
        i.format = function (a) {
          var s = this,
            l = this.$locale()
          if (!this.isValid()) return o.bind(this)(a)
          var c = this.$utils(),
            d = (a || 'YYYY-MM-DDTHH:mm:ssZ').replace(
              /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
              function (h) {
                switch (h) {
                  case 'Q':
                    return Math.ceil((s.$M + 1) / 3)
                  case 'Do':
                    return l.ordinal(s.$D)
                  case 'gggg':
                    return s.weekYear()
                  case 'GGGG':
                    return s.isoWeekYear()
                  case 'wo':
                    return l.ordinal(s.week(), 'W')
                  case 'w':
                  case 'ww':
                    return c.s(s.week(), h === 'w' ? 1 : 2, '0')
                  case 'W':
                  case 'WW':
                    return c.s(s.isoWeek(), h === 'W' ? 1 : 2, '0')
                  case 'k':
                  case 'kk':
                    return c.s(
                      String(s.$H === 0 ? 24 : s.$H),
                      h === 'k' ? 1 : 2,
                      '0'
                    )
                  case 'X':
                    return Math.floor(s.$d.getTime() / 1e3)
                  case 'x':
                    return s.$d.getTime()
                  case 'z':
                    return '[' + s.offsetName() + ']'
                  case 'zzz':
                    return '[' + s.offsetName('long') + ']'
                  default:
                    return h
                }
              }
            )
          return o.bind(this)(d)
        }
      }
    })
  })(rk)
  var xV = rk.exports
  const MV = Ll(xV)
  var ik = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      return function (n, r) {
        r.prototype.weekYear = function () {
          var i = this.month(),
            o = this.week(),
            a = this.year()
          return o === 1 && i === 11 ? a + 1 : i === 0 && o >= 52 ? a - 1 : a
        }
      }
    })
  })(ik)
  var EV = ik.exports
  const PV = Ll(EV)
  var ok = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r()
    })(Bi, function () {
      var n = 'month',
        r = 'quarter'
      return function (i, o) {
        var a = o.prototype
        a.quarter = function (c) {
          return this.$utils().u(c)
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((this.month() % 3) + 3 * (c - 1))
        }
        var s = a.add
        a.add = function (c, d) {
          return (
            (c = Number(c)),
            this.$utils().p(d) === r ? this.add(3 * c, n) : s.bind(this)(c, d)
          )
        }
        var l = a.startOf
        a.startOf = function (c, d) {
          var h = this.$utils(),
            p = !!h.u(d) || d
          if (h.p(c) === r) {
            var v = this.quarter() - 1
            return p
              ? this.month(3 * v)
                  .startOf(n)
                  .startOf('day')
              : this.month(3 * v + 2)
                  .endOf(n)
                  .endOf('day')
          }
          return l.bind(this)(c, d)
        }
      }
    })
  })(ok)
  var TV = ok.exports
  const kV = Ll(TV)
  var AV = { exports: {} }
  ;(function (e, t) {
    ;(function (n, r) {
      e.exports = r(Q4)
    })(Bi, function (n) {
      function r(a) {
        return a && typeof a == 'object' && 'default' in a ? a : { default: a }
      }
      var i = r(n),
        o = {
          name: 'zh-cn',
          weekdays: '______'.split(
            '_'
          ),
          weekdaysShort: '______'.split('_'),
          weekdaysMin: '______'.split('_'),
          months:
            '___________'.split(
              '_'
            ),
          monthsShort:
            '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
          ordinal: function (a, s) {
            return s === 'W' ? a + '' : a + ''
          },
          weekStart: 1,
          yearStart: 4,
          formats: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYYMD',
            LLL: 'YYYYMDAhmm',
            LLLL: 'YYYYMDddddAhmm',
            l: 'YYYY/M/D',
            ll: 'YYYYMD',
            lll: 'YYYYMD HH:mm',
            llll: 'YYYYMDdddd HH:mm',
          },
          relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d ',
          },
          meridiem: function (a, s) {
            var l = 100 * a + s
            return l < 600
              ? ''
              : l < 900
              ? ''
              : l < 1100
              ? ''
              : l < 1300
              ? ''
              : l < 1800
              ? ''
              : ''
          },
        }
      return i.default.locale(o, null, !0), o
    })
  })(AV)
  var $V = Object.defineProperty,
    OV = Object.defineProperties,
    LV = Object.getOwnPropertyDescriptors,
    hx = Object.getOwnPropertySymbols,
    IV = Object.prototype.hasOwnProperty,
    RV = Object.prototype.propertyIsEnumerable,
    px = (e, t, n) =>
      t in e
        ? $V(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    ak = (e, t) => {
      for (var n in t || (t = {})) IV.call(t, n) && px(e, n, t[n])
      if (hx) for (var n of hx(t)) RV.call(t, n) && px(e, n, t[n])
      return e
    },
    sk = (e, t) => OV(e, LV(t))
  const DV = (e, t, n) => {
    n = function (o, a) {
      if (ao(o)) return o.clone()
      const s = typeof a == 'object' ? a : {}
      return (s.date = o), (s.args = arguments), new t(s)
    }
    const r = t.prototype,
      i = r.$utils
    ;(r.$utils = () => {
      const o = i()
      return (o.i = ao), o
    }),
      (n.isDayjs = ao)
  }
  Kr.extend(DV)
  Kr.extend(bV)
  Kr.extend(SV)
  Kr.extend(wV)
  Kr.extend(MV)
  Kr.extend(PV)
  Kr.extend(kV)
  const nr = Kr,
    ur = {
      add(e, t, n) {
        return e.add(t, n)
      },
      subtract(e, t, n) {
        return e.subtract(t, n)
      },
      startOf(e, t) {
        return e.startOf(t)
      },
      endOf(e, t) {
        return e.endOf(t)
      },
      set(e, t, n) {
        return e.set(t, n)
      },
      isSameWeek(e, t, n, r) {
        return e
          .locale(sk(ak({}, nr.Ls[r.toLocaleLowerCase()]), { weekStart: n }))
          .isSame(t, 'week')
      },
    }
  function Nr() {
    return nr()
  }
  function Ld(e) {
    return [...e].sort((t, n) => t.valueOf() - n.valueOf())
  }
  function G_(e, t) {
    const n = (r, i) =>
      r === void 0 && i === void 0
        ? !1
        : (r && !i) || (!r && i)
        ? !0
        : (r == null ? void 0 : r.valueOf()) !==
          (i == null ? void 0 : i.valueOf())
    return t === void 0 && e === void 0
      ? !1
      : Ft(t) && Ft(e)
      ? n(t[0], e[0]) || n(t[1], e[1])
      : !Ft(t) && !Ft(e)
      ? n(t, e)
      : !0
  }
  function Hi(e, t) {
    const n = (i) => {
        const o = /(Q1)|(Q2)|(Q3)|(Q4)/,
          a = { Q1: '01', Q2: '04', Q3: '07', Q4: '10' },
          [s] = o.exec(i)
        return i.replace(o, a[s])
      },
      r = (i) => {
        if (i)
          return typeof i == 'string'
            ? dB(t)
              ? nr(n(i), t.replace(/\[Q]Q/, 'MM'))
              : nr(i, t)
            : nr(i)
      }
    return Ft(e) ? e.map(r) : r(e)
  }
  function wi(e) {
    const t = (n) => (n ? n.toDate() : void 0)
    return Ft(e) ? e.map(t) : t(e)
  }
  function lk(e, t) {
    nr.locale(sk(ak({}, nr.Ls[e.toLocaleLowerCase()]), { weekStart: t }))
  }
  function NV(e) {
    const t = {}
    return (
      e &&
        Object.keys(e).forEach((n) => {
          const r = String(n)
          r.indexOf('data-') === 0 && (t[r] = e[r]),
            r.indexOf('aria-') === 0 && (t[r] = e[r])
        }),
      t
    )
  }
  function vl(e, t, n = ' ') {
    const r = String(e)
    if (!t) return r
    const i = r.length < t ? `${n}${r}` : r
    return i.length < t ? vl(i, t, n) : i
  }
  var BV = ce({
    name: 'Week',
    props: {
      mode: { type: String },
      dayStartOfWeek: { type: Number },
      isWeek: { type: Boolean },
      panel: { type: Boolean },
      value: { type: Object, required: !0 },
      selectHandler: { type: Function },
      pageShowData: { type: Object, required: !0 },
      pageData: { type: Array },
    },
    setup(e) {
      const { dayStartOfWeek: t, isWeek: n, panel: r, mode: i } = tt(e),
        o = ye('calendar-week-list'),
        { t: a } = Vn(),
        s = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
      return (
        t.value === 0 ? s.unshift('sunday') : s.push('sunday'),
        n.value && s.unshift('self'),
        () =>
          m('div', { class: o }, [
            s.map((l) =>
              m('div', { class: `${o}-item`, key: l }, [
                a(
                  `calendar.week.${
                    r.value || i.value === 'year' ? 'short' : 'long'
                  }.${l}`
                ),
              ])
            ),
          ])
      )
    },
  })
  function dh(e, t) {
    if (e && Ft(e)) return e[t]
  }
  function uk({
    prefixCls: e,
    mergedValue: t,
    rangeValues: n,
    hoverRangeValues: r,
    panel: i,
    isSameTime: o,
    innerMode: a,
  }) {
    function s(l, c, d) {
      return !c || !d ? !1 : o(l, c) || o(l, d) || l.isBetween(c, d, null, '[]')
    }
    return function (c, d) {
      const h = dh(n, 0),
        p = dh(n, 1),
        v = dh(r, 0),
        g = dh(r, 1),
        _ = !c.isPrev && !c.isNext,
        b = _ && i,
        y = b && h && o(c.time, h),
        M = b && p && o(c.time, p),
        x = v && h && v.isBefore(h),
        w = p && g && g.isAfter(p),
        E = (x && y) || (w && M)
      let P = o(c.time, Nr())
      return (
        !i && a === 'year' && (P = Nr().isSame(c.time, 'date')),
        [
          `${e}-cell`,
          {
            [`${e}-cell-in-view`]: _,
            [`${e}-cell-today`]: P,
            [`${e}-cell-selected`]: t && o(c.time, t),
            [`${e}-cell-range-start`]: y,
            [`${e}-cell-range-end`]: M,
            [`${e}-cell-in-range`]: b && s(c.time, h, p),
            [`${e}-cell-in-range-near-hover`]: E,
            [`${e}-cell-hover-range-start`]: b && v && o(c.time, v),
            [`${e}-cell-hover-range-end`]: b && g && o(c.time, g),
            [`${e}-cell-hover-in-range`]: b && s(c.time, v, g),
            [`${e}-cell-disabled`]: d,
          },
        ]
      )
    }
  }
  var FV = Object.defineProperty,
    zV = Object.defineProperties,
    VV = Object.getOwnPropertyDescriptors,
    vx = Object.getOwnPropertySymbols,
    UV = Object.prototype.hasOwnProperty,
    HV = Object.prototype.propertyIsEnumerable,
    mx = (e, t, n) =>
      t in e
        ? FV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    v0 = (e, t) => {
      for (var n in t || (t = {})) UV.call(t, n) && mx(e, n, t[n])
      if (vx) for (var n of vx(t)) HV.call(t, n) && mx(e, n, t[n])
      return e
    },
    m0 = (e, t) => zV(e, VV(t))
  const gx = 6 * 7,
    av = (e) => ({
      year: e.year(),
      month: e.month() + 1,
      date: e.date(),
      day: e.day(),
      time: e,
    }),
    WV = (e) => ({
      start: av(ur.startOf(e, 'month')),
      end: av(ur.endOf(e, 'month')),
      days: e.daysInMonth(),
    })
  function ck(e, { dayStartOfWeek: t = 0, isWeek: n }) {
    const r = WV(e),
      i = Array(gx)
        .fill(null)
        .map(() => ({})),
      o = t === 0 ? r.start.day : (r.start.day || 7) - 1
    i[o] = m0(v0({}, r.start), { isCurrent: !0 })
    for (let s = 0; s < o; s++)
      i[o - s - 1] = m0(v0({}, av(ur.subtract(r.start.time, s + 1, 'day'))), {
        isPrev: !0,
      })
    for (let s = 0; s < gx - o - 1; s++)
      i[o + s + 1] = m0(v0({}, av(ur.add(r.start.time, s + 1, 'day'))), {
        isCurrent: s < r.days,
        isNext: s >= r.days - 1,
      })
    const a = Array(6)
      .fill(null)
      .map(() => [])
    for (let s = 0; s < 6; s++)
      if (((a[s] = i.slice(s * 7, 7 * (s + 1))), n)) {
        const l = a[s][0].time,
          c = [...a[s]]
        a[s].unshift({ weekRows: c, weekOfYear: l.week() })
      }
    return a
  }
  var dk = ce({
      name: 'Month',
      props: {
        cell: { type: Boolean },
        pageData: { type: Array },
        current: { type: Number },
        value: { type: Object, required: !0 },
        selectHandler: { type: Function, required: !0 },
        mode: { type: String },
        pageShowDate: { type: Object, required: !0 },
        panel: { type: Boolean },
        dayStartOfWeek: { type: Number, required: !0 },
        isWeek: { type: Boolean, required: !0 },
      },
      setup(e) {
        const { pageData: t } = tt(e),
          n = ye('calendar'),
          r = e.pageShowDate.year(),
          i = C(() =>
            uk({
              prefixCls: n,
              mergedValue: e.value,
              panel: !1,
              innerMode: e.mode,
              rangeValues: [],
              hoverRangeValues: [],
              isSameTime: (s, l) => s.isSame(l, 'day'),
            })
          )
        function o(s) {
          return s.map((l, c) => {
            if (l.time) {
              const d = () => e.selectHandler(l.time, !1),
                h = e.isWeek ? { onClick: d } : {},
                p = e.isWeek ? {} : { onClick: d }
              return m('div', Fe({ key: c, class: i.value(l, !1) }, h), [
                m('div', Fe({ class: `${n}-date` }, p), [
                  m('div', { class: `${n}-date-value` }, [
                    e.panel
                      ? l.date
                      : m('div', { class: `${n}-date-circle` }, [l.date]),
                  ]),
                ]),
              ])
            }
            if ('weekOfYear' in l) {
              const d = e.value.year(),
                h = e.value.month() + 1,
                p = e.value.week(),
                v =
                  e.value &&
                  l.weekRows.find((g) => g.year === d && g.month === h) &&
                  p === l.weekOfYear
              return m(
                'div',
                {
                  key: c,
                  class: [
                    `${n}-cell`,
                    `${n}-cell-week`,
                    {
                      [`${n}-cell-selected-week`]: v,
                      [`${n}-cell-in-range`]: v,
                    },
                  ],
                },
                [
                  m('div', { class: `${n}-date` }, [
                    m('div', { class: `${n}-date-value` }, [l.weekOfYear]),
                  ]),
                ]
              )
            }
            return null
          })
        }
        let a = t.value
        return (
          typeof e.current == 'number' &&
            (a = ck(nr(`${r}-${vl(e.current + 1, 2, '0')}-01`), {
              dayStartOfWeek: e.dayStartOfWeek,
              isWeek: e.isWeek,
            })),
          () =>
            m('div', { class: e.cell ? `${n}-month-cell` : `${n}-month` }, [
              m(
                BV,
                {
                  value: e.value,
                  selectHandler: e.selectHandler,
                  dayStartOfWeek: e.dayStartOfWeek,
                  isWeek: e.isWeek,
                  panel: e.panel,
                  mode: e.mode,
                  pageShowData: e.pageShowDate,
                  pageData: e.pageData,
                },
                null
              ),
              m('div', { class: `${n}-month-cell-body` }, [
                a == null
                  ? void 0
                  : a.map((s, l) =>
                      m(
                        'div',
                        {
                          key: l,
                          class: [
                            `${n}-month-row`,
                            { [`${n}-row-week`]: e.isWeek },
                          ],
                        },
                        [o(s)]
                      )
                    ),
              ]),
            ])
        )
      },
    }),
    jV = Object.defineProperty,
    GV = Object.defineProperties,
    KV = Object.getOwnPropertyDescriptors,
    yx = Object.getOwnPropertySymbols,
    qV = Object.prototype.hasOwnProperty,
    XV = Object.prototype.propertyIsEnumerable,
    bx = (e, t, n) =>
      t in e
        ? jV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    YV = (e, t) => {
      for (var n in t || (t = {})) qV.call(t, n) && bx(e, n, t[n])
      if (yx) for (var n of yx(t)) XV.call(t, n) && bx(e, n, t[n])
      return e
    },
    ZV = (e, t) => GV(e, KV(t))
  const fk = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ].map((e, t) => ({ name: e, value: t })),
    hk = Array(3)
  for (let e = 0; e < 3; e++) hk[e] = fk.slice(e * 4, 4 * (e + 1))
  const pk = Array(4)
  for (let e = 0; e < 4; e++) pk[e] = fk.slice(e * 3, 3 * (e + 1))
  var JV = ce({
    name: 'Year',
    props: {
      mode: { type: String, required: !0 },
      dayStartOfWeek: { type: Number, required: !0 },
      value: { type: Object, required: !0 },
      isWeek: { type: Boolean },
      panel: { type: Boolean, default: !1 },
      pageShowData: { type: Object, required: !0 },
      pageData: { type: Array },
      selectHandler: { type: Function, required: !0 },
    },
    setup(e) {
      const t = ye('calendar'),
        n = C(() =>
          uk({
            prefixCls: t,
            mergedValue: e.value,
            panel: !1,
            innerMode: e.mode,
            rangeValues: [],
            hoverRangeValues: [],
            isSameTime: (a, s) => a.isSame(s, 'month'),
          })
        ),
        { t: r } = Vn(),
        i = C(() => e.pageShowData.year()),
        o = e.panel ? pk : hk
      return () =>
        m('div', { class: `${t}-year` }, [
          o.map((a, s) =>
            m('div', { class: `${t}-year-row`, key: s }, [
              a.map((l) => {
                const c = nr(`${i.value}-${vl(l.value + 1, 2, '0')}-01`),
                  d = e.panel ? { onClick: () => e.selectHandler(c, !1) } : {}
                return m(
                  'div',
                  {
                    key: l.value,
                    class: n.value(ZV(YV({}, l), { time: c }), !1),
                  },
                  [
                    e.panel
                      ? m('div', Fe({ class: `${t}-date` }, d), [
                          m('div', { class: `${t}-date-value` }, [
                            r(`calendar.month.short.${l.name}`),
                          ]),
                        ])
                      : m('div', { class: `${t}-month-with-days` }, [
                          m('div', { class: `${t}-month-title` }, [
                            r(`calendar.month.long.${l.name}`),
                          ]),
                          m(
                            dk,
                            {
                              pageShowDate: e.pageShowData,
                              pageData: e.pageData,
                              dayStartOfWeek: e.dayStartOfWeek,
                              selectHandler: e.selectHandler,
                              isWeek: e.isWeek,
                              cell: !0,
                              current: l.value,
                              value: e.value,
                              mode: e.mode,
                            },
                            null
                          ),
                        ]),
                  ]
                )
              }),
            ])
          ),
        ])
    },
  })
  const QV = ({
    defaultValue: e,
    modelValue: t,
    emit: n,
    eventName: r = 'input',
    updateEventName: i = 'update:modelValue',
    eventHandlers: o,
  }) => {
    var a
    const s = J(),
      l = J((a = e == null ? void 0 : e.value) != null ? a : ''),
      c = J(!1),
      d = J(!1),
      h = J('')
    let p
    const v = C(() => {
        var P
        return (P = t == null ? void 0 : t.value) != null ? P : l.value
      }),
      g = (P, A) => {
        ;(l.value = P), n(i, P), n(r, P, A)
      },
      _ = (P) => {
        const { value: A } = P.target
        d.value ||
          (g(A, P),
          hn(() => {
            s.value && v.value !== s.value.value && (s.value.value = v.value)
          }))
      },
      b = (P) => {
        r === 'input' &&
          v.value !== p &&
          ((p = v.value), n('change', v.value, P))
      },
      y = (P) => {
        var A
        const { value: F } = P.target
        P.type === 'compositionend'
          ? ((d.value = !1),
            (h.value = ''),
            g(F, P),
            hn(() => {
              s.value && v.value !== s.value.value && (s.value.value = v.value)
            }))
          : ((d.value = !0),
            (h.value = v.value + ((A = P.data) != null ? A : '')))
      },
      M = (P) => {
        var A, F
        ;(c.value = !0),
          (p = v.value),
          n('focus', P),
          (F =
            (A = o == null ? void 0 : o.value) == null ? void 0 : A.onFocus) ==
            null || F.call(A, P)
      },
      x = (P) => {
        var A, F
        ;(c.value = !1),
          n('blur', P),
          (F =
            (A = o == null ? void 0 : o.value) == null ? void 0 : A.onBlur) ==
            null || F.call(A, P),
          b(P)
      },
      w = (P) => {
        const A = P.key || P.code
        !d.value && A === R_.key && (n('pressEnter', P), b(P))
      },
      E = (P) => {
        s.value && P.target !== s.value && (P.preventDefault(), s.value.focus())
      }
    return (
      pt(v, (P) => {
        s.value && P !== s.value.value && (s.value.value = P)
      }),
      {
        inputRef: s,
        _value: l,
        _focused: c,
        isComposition: d,
        compositionValue: h,
        computedValue: v,
        handleInput: _,
        handleComposition: y,
        handleFocus: M,
        handleBlur: x,
        handleKeyDown: w,
        handleMousedown: E,
      }
    )
  }
  var eU = ce({
      name: 'InputLabel',
      inheritAttrs: !1,
      props: {
        modelValue: Object,
        inputValue: { type: String, default: '' },
        enabledInput: Boolean,
        formatLabel: Function,
        placeholder: String,
        retainInputValue: Boolean,
        disabled: Boolean,
        baseCls: String,
        size: String,
        error: Boolean,
        focused: Boolean,
        uninjectFormItemContext: Boolean,
      },
      emits: ['update:inputValue', 'inputValueChange', 'focus', 'blur'],
      setup(e, { attrs: t, emit: n, slots: r }) {
        var i
        const {
            size: o,
            disabled: a,
            error: s,
            inputValue: l,
            uninjectFormItemContext: c,
          } = tt(e),
          d = (i = e.baseCls) != null ? i : ye('input-label'),
          {
            mergedSize: h,
            mergedDisabled: p,
            mergedError: v,
            eventHandlers: g,
          } = Rn({
            size: o,
            disabled: a,
            error: s,
            uninject: c == null ? void 0 : c.value,
          }),
          { mergedSize: _ } = Vr(h),
          {
            inputRef: b,
            _focused: y,
            computedValue: M,
            handleInput: x,
            handleComposition: w,
            handleFocus: E,
            handleBlur: P,
            handleMousedown: A,
          } = QV({
            modelValue: l,
            emit: n,
            eventName: 'inputValueChange',
            updateEventName: 'update:inputValue',
            eventHandlers: g,
          }),
          F = C(() => {
            var L
            return (L = e.focused) != null ? L : y.value
          }),
          T = C(() => (e.enabledInput && y.value) || !e.modelValue),
          k = () => {
            var L, W
            return e.modelValue
              ? (W =
                  (L = e.formatLabel) == null
                    ? void 0
                    : L.call(e, e.modelValue)) != null
                ? W
                : e.modelValue.label
              : ''
          },
          R = C(() => (e.enabledInput && e.modelValue ? k() : e.placeholder)),
          j = () => {
            var L, W
            return e.modelValue
              ? (W =
                  (L = r.default) == null
                    ? void 0
                    : L.call(r, { data: e.modelValue })) != null
                ? W
                : k()
              : null
          },
          N = C(() => [
            d,
            `${d}-size-${_.value}`,
            {
              [`${d}-search`]: e.enabledInput,
              [`${d}-focus`]: F.value,
              [`${d}-disabled`]: p.value,
              [`${d}-error`]: v.value,
            },
          ]),
          I = C(() => xr(t, Ts)),
          B = C(() => ra(t, Ts))
        return {
          inputRef: b,
          render: () =>
            m(
              'span',
              Fe(I.value, { class: N.value, title: k(), onMousedown: A }),
              [
                r.prefix && m('span', { class: `${d}-prefix` }, [r.prefix()]),
                m(
                  'input',
                  Fe(B.value, {
                    ref: b,
                    class: [`${d}-input`, { [`${d}-input-hidden`]: !T.value }],
                    value: M.value,
                    readonly: !e.enabledInput,
                    placeholder: R.value,
                    disabled: p.value,
                    onInput: x,
                    onFocus: E,
                    onBlur: P,
                    onCompositionstart: w,
                    onCompositionupdate: w,
                    onCompositionend: w,
                  }),
                  null
                ),
                m(
                  'span',
                  { class: [`${d}-value`, { [`${d}-value-hidden`]: T.value }] },
                  [j()]
                ),
                r.suffix && m('span', { class: `${d}-suffix` }, [r.suffix()]),
              ]
            ),
        }
      },
      methods: {
        focus() {
          var e
          ;(e = this.inputRef) == null || e.focus()
        },
        blur() {
          var e
          ;(e = this.inputRef) == null || e.blur()
        },
      },
      render() {
        return this.render()
      },
    }),
    tU = Object.defineProperty,
    _x = Object.getOwnPropertySymbols,
    nU = Object.prototype.hasOwnProperty,
    rU = Object.prototype.propertyIsEnumerable,
    Sx = (e, t, n) =>
      t in e
        ? tU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    iU = (e, t) => {
      for (var n in t || (t = {})) nU.call(t, n) && Sx(e, n, t[n])
      if (_x) for (var n of _x(t)) rU.call(t, n) && Sx(e, n, t[n])
      return e
    }
  const oU = (e, t) => {
      const n = []
      for (const r of e)
        if (Ht(r))
          n.push({
            raw: r,
            value: r[t.value],
            label: r[t.label],
            closable: r[t.closable],
            tagProps: r[t.tagProps],
          })
        else if (e || it(e)) {
          const i = { value: r, label: String(r), closable: !0 }
          n.push(iU({ raw: i }, i))
        }
      return n
    },
    Cx = [
      'red',
      'orangered',
      'orange',
      'gold',
      'lime',
      'green',
      'cyan',
      'blue',
      'arcoblue',
      'purple',
      'pinkpurple',
      'magenta',
      'gray',
    ],
    aU = ce({
      name: 'Tag',
      components: { IconHover: In, IconClose: zr, IconLoading: Xr },
      props: {
        color: { type: String },
        size: { type: String },
        bordered: { type: Boolean, default: !1 },
        visible: { type: Boolean, default: void 0 },
        defaultVisible: { type: Boolean, default: !0 },
        loading: { type: Boolean, default: !1 },
        closable: { type: Boolean, default: !1 },
        checkable: { type: Boolean, default: !1 },
        checked: { type: Boolean, default: void 0 },
        defaultChecked: { type: Boolean, default: !0 },
      },
      emits: {
        'update:visible': (e) => !0,
        'update:checked': (e) => !0,
        close: (e) => !0,
        check: (e, t) => !0,
      },
      setup(e, { emit: t }) {
        const { size: n } = tt(e),
          r = ye('tag'),
          i = C(() => e.color && Cx.includes(e.color)),
          o = C(() => e.color && !Cx.includes(e.color)),
          a = J(e.defaultVisible),
          s = J(e.defaultChecked),
          l = C(() => {
            var b
            return (b = e.visible) != null ? b : a.value
          }),
          c = C(() => {
            var b
            return e.checkable ? ((b = e.checked) != null ? b : s.value) : !0
          }),
          { mergedSize: d } = Vr(n),
          h = C(() => (d.value === 'mini' ? 'small' : d.value)),
          p = (b) => {
            ;(a.value = !1), t('update:visible', !1), t('close', b)
          },
          v = (b) => {
            if (e.checkable) {
              const y = !c.value
              ;(s.value = y), t('update:checked', y), t('check', y, b)
            }
          },
          g = C(() => [
            r,
            `${r}-size-${h.value}`,
            {
              [`${r}-loading`]: e.loading,
              [`${r}-hide`]: !l.value,
              [`${r}-${e.color}`]: i.value,
              [`${r}-bordered`]: e.bordered,
              [`${r}-checkable`]: e.checkable,
              [`${r}-checked`]: c.value,
              [`${r}-custom-color`]: o.value,
            },
          ]),
          _ = C(() => {
            if (o.value) return { backgroundColor: e.color }
          })
        return {
          prefixCls: r,
          cls: g,
          style: _,
          computedVisible: l,
          computedChecked: c,
          handleClick: v,
          handleClose: p,
        }
      },
    })
  function sU(e, t, n, r, i, o) {
    const a = ge('icon-close'),
      s = ge('icon-hover'),
      l = ge('icon-loading')
    return e.computedVisible
      ? (O(),
        Z(
          'span',
          {
            key: 0,
            class: H(e.cls),
            style: at(e.style),
            onClick:
              t[0] || (t[0] = (...c) => e.handleClick && e.handleClick(...c)),
          },
          [
            e.$slots.icon
              ? (O(),
                Z(
                  'span',
                  { key: 0, class: H(`${e.prefixCls}-icon`) },
                  [ve(e.$slots, 'icon')],
                  2
                ))
              : Ce('v-if', !0),
            ve(e.$slots, 'default'),
            e.closable
              ? (O(),
                Ee(
                  s,
                  {
                    key: 1,
                    role: 'button',
                    'aria-label': 'Close',
                    prefix: e.prefixCls,
                    class: H(`${e.prefixCls}-close-btn`),
                    onClick: io(e.handleClose, ['stop']),
                  },
                  {
                    default: ze(() => [
                      ve(e.$slots, 'close-icon', {}, () => [m(a)]),
                    ]),
                    _: 3,
                  },
                  8,
                  ['prefix', 'class', 'onClick']
                ))
              : Ce('v-if', !0),
            e.loading
              ? (O(),
                Z(
                  'span',
                  { key: 2, class: H(`${e.prefixCls}-loading-icon`) },
                  [m(l)],
                  2
                ))
              : Ce('v-if', !0),
          ],
          6
        ))
      : Ce('v-if', !0)
  }
  var g0 = Te(aU, [['render', sU]])
  const K_ = Object.assign(g0, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + g0.name, g0)
    },
  })
  var lU = Object.defineProperty,
    wx = Object.getOwnPropertySymbols,
    uU = Object.prototype.hasOwnProperty,
    cU = Object.prototype.propertyIsEnumerable,
    xx = (e, t, n) =>
      t in e
        ? lU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    fh = (e, t) => {
      for (var n in t || (t = {})) uU.call(t, n) && xx(e, n, t[n])
      if (wx) for (var n of wx(t)) cU.call(t, n) && xx(e, n, t[n])
      return e
    }
  const dU = {
    value: 'value',
    label: 'label',
    closable: 'closable',
    tagProps: 'tagProps',
  }
  var y0 = ce({
    name: 'InputTag',
    inheritAttrs: !1,
    props: {
      modelValue: { type: Array },
      defaultValue: { type: Array, default: () => [] },
      inputValue: String,
      defaultInputValue: { type: String, default: '' },
      placeholder: String,
      disabled: { type: Boolean, default: !1 },
      error: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      allowClear: { type: Boolean, default: !1 },
      size: { type: String },
      maxTagCount: { type: Number, default: 0 },
      retainInputValue: { type: [Boolean, Object], default: !1 },
      formatTag: { type: Function },
      uniqueValue: { type: Boolean, default: !1 },
      fieldNames: { type: Object },
      baseCls: String,
      focused: Boolean,
      disabledInput: Boolean,
      uninjectFormItemContext: Boolean,
    },
    emits: {
      'update:modelValue': (e) => !0,
      'update:inputValue': (e) => !0,
      change: (e, t) => !0,
      inputValueChange: (e, t) => !0,
      pressEnter: (e, t) => !0,
      remove: (e, t) => !0,
      clear: (e) => !0,
      focus: (e) => !0,
      blur: (e) => !0,
    },
    setup(e, { emit: t, slots: n, attrs: r }) {
      const {
          size: i,
          disabled: o,
          error: a,
          uninjectFormItemContext: s,
          modelValue: l,
        } = tt(e),
        c = e.baseCls || ye('input-tag'),
        d = J(),
        h = J(),
        {
          mergedSize: p,
          mergedDisabled: v,
          mergedError: g,
          feedback: _,
          eventHandlers: b,
        } = Rn({
          size: i,
          disabled: o,
          error: a,
          uninject: s == null ? void 0 : s.value,
        }),
        { mergedSize: y } = Vr(p),
        M = C(() => fh(fh({}, dU), e.fieldNames)),
        x = J(!1),
        w = J(e.defaultValue),
        E = J(e.defaultInputValue),
        P = J(!1),
        A = J(''),
        F = C(() =>
          Ht(e.retainInputValue)
            ? fh({ create: !1, blur: !1 }, e.retainInputValue)
            : { create: e.retainInputValue, blur: e.retainInputValue }
        ),
        T = Je({ width: '12px' }),
        k = C(() => e.focused || x.value),
        R = (z, ie) => {
          ;(E.value = z),
            t('update:inputValue', z),
            t('inputValueChange', z, ie)
        },
        j = (z) => {
          var ie
          const { value: ae } = z.target
          z.type === 'compositionend'
            ? ((P.value = !1),
              (A.value = ''),
              R(ae, z),
              hn(() => {
                d.value &&
                  I.value !== d.value.value &&
                  (d.value.value = I.value)
              }))
            : ((P.value = !0),
              (A.value = I.value + ((ie = z.data) != null ? ie : '')))
        },
        N = C(() => {
          var z
          return (z = e.modelValue) != null ? z : w.value
        }),
        I = C(() => {
          var z
          return (z = e.inputValue) != null ? z : E.value
        })
      pt(l, (z) => {
        ;(Mt(z) || fi(z)) && (w.value = [])
      })
      const B = (z) => {
          d.value &&
            z.target !== d.value &&
            (z.preventDefault(), d.value.focus())
        },
        V = (z) => {
          const { value: ie } = z.target
          P.value ||
            (R(ie, z),
            hn(() => {
              d.value && I.value !== d.value.value && (d.value.value = I.value)
            }))
        },
        L = C(() => oU(N.value, M.value)),
        W = C(() => {
          if (e.maxTagCount > 0) {
            const z = L.value.length - e.maxTagCount
            if (z > 0) {
              const ie = L.value.slice(0, e.maxTagCount),
                ae = { value: '__arco__more', label: `+${z}...`, closable: !1 }
              return ie.push(fh({ raw: ae }, ae)), ie
            }
          }
          return L.value
        }),
        Y = (z, ie) => {
          var ae, re
          ;(w.value = z),
            t('update:modelValue', z),
            t('change', z, ie),
            (re = (ae = b.value) == null ? void 0 : ae.onChange) == null ||
              re.call(ae, ie)
        },
        U = (z, ie, ae) => {
          var re
          const pe =
            (re = N.value) == null ? void 0 : re.filter((we, $e) => $e !== ie)
          Y(pe, ae), t('remove', z, ae)
        },
        le = (z) => {
          Y([], z), t('clear', z)
        },
        q = C(
          () => !v.value && !e.readonly && e.allowClear && !!N.value.length
        ),
        oe = (z) => {
          var ie
          if (I.value) {
            if (
              (z.preventDefault(),
              e.uniqueValue && (ie = N.value) != null && ie.includes(I.value))
            ) {
              t('pressEnter', I.value, z)
              return
            }
            const ae = N.value.concat(I.value)
            Y(ae, z), t('pressEnter', I.value, z), F.value.create || R('', z)
          }
        },
        te = (z) => {
          var ie, ae
          ;(x.value = !0),
            t('focus', z),
            (ae = (ie = b.value) == null ? void 0 : ie.onFocus) == null ||
              ae.call(ie, z)
        },
        ue = (z) => {
          var ie, ae
          ;(x.value = !1),
            !F.value.blur && I.value && R('', z),
            t('blur', z),
            (ae = (ie = b.value) == null ? void 0 : ie.onBlur) == null ||
              ae.call(ie, z)
        },
        me = () => {
          for (let z = L.value.length - 1; z >= 0; z--)
            if (L.value[z].closable) return z
          return -1
        },
        Re = (z) => {
          const ie = z.key || z.code
          if (
            (!P.value && I.value && ie === R_.key && oe(z),
            !P.value && W.value.length > 0 && !I.value && ie === fF.key)
          ) {
            const ae = me()
            ae >= 0 && U(L.value[ae].value, ae, z)
          }
        },
        qe = (z) => {
          z > 12 ? (T.width = `${z}px`) : (T.width = '12px')
        }
      Wt(() => {
        h.value && qe(h.value.offsetWidth)
      })
      const Ve = () => {
        h.value && qe(h.value.offsetWidth)
      }
      pt(I, (z) => {
        d.value && !P.value && z !== d.value.value && (d.value.value = z)
      })
      const nt = C(() => [
          c,
          `${c}-size-${y.value}`,
          {
            [`${c}-disabled`]: v.value,
            [`${c}-disabled-input`]: e.disabledInput,
            [`${c}-error`]: g.value,
            [`${c}-focus`]: k.value,
            [`${c}-readonly`]: e.readonly,
            [`${c}-has-tag`]: W.value.length > 0,
            [`${c}-has-prefix`]: !!n.prefix,
            [`${c}-has-suffix`]: !!n.suffix || q.value || _.value,
            [`${c}-has-placeholder`]: !N.value.length,
          },
        ]),
        We = C(() => xr(r, Ts)),
        D = C(() => ra(r, Ts))
      return {
        inputRef: d,
        render: () => {
          var z
          return m('span', Fe({ class: nt.value, onMousedown: B }, We.value), [
            m(
              Ro,
              { onResize: Ve },
              {
                default: () => [
                  m('span', { ref: h, class: `${c}-mirror` }, [
                    W.value.length > 0
                      ? A.value || I.value
                      : A.value || I.value || e.placeholder,
                  ]),
                ],
              }
            ),
            n.prefix && m('span', { class: `${c}-prefix` }, [n.prefix()]),
            m(
              jd,
              { tag: 'span', name: 'input-tag-zoom', class: `${c}-inner` },
              {
                default: () => [
                  W.value.map((ie, ae) =>
                    m(
                      K_,
                      Fe(
                        {
                          key: `tag-${ie.value}`,
                          class: `${c}-tag`,
                          closable: !v.value && !e.readonly && ie.closable,
                          visible: !0,
                        },
                        ie.tagProps,
                        { onClose: (re) => U(ie.value, ae, re) }
                      ),
                      {
                        default: () => {
                          var re, pe, we, $e
                          return [
                            ($e =
                              (we =
                                (re = n.tag) == null
                                  ? void 0
                                  : re.call(n, { data: ie.raw })) != null
                                ? we
                                : (pe = e.formatTag) == null
                                ? void 0
                                : pe.call(e, ie.raw)) != null
                              ? $e
                              : ie.label,
                          ]
                        },
                      }
                    )
                  ),
                  m(
                    'input',
                    Fe(D.value, {
                      ref: d,
                      key: 'input-tag-input',
                      class: `${c}-input`,
                      style: T,
                      placeholder:
                        W.value.length === 0 ? e.placeholder : void 0,
                      disabled: v.value,
                      readonly: e.readonly || e.disabledInput,
                      onInput: V,
                      onKeydown: Re,
                      onFocus: te,
                      onBlur: ue,
                      onCompositionstart: j,
                      onCompositionupdate: j,
                      onCompositionend: j,
                    }),
                    null
                  ),
                ],
              }
            ),
            q.value &&
              m(
                In,
                {
                  class: `${c}-clear-btn`,
                  onClick: le,
                  onMousedown: (ie) => ie.stopPropagation(),
                },
                { default: () => [m(zr, null, null)] }
              ),
            (n.suffix || !!_.value) &&
              m('span', { class: `${c}-suffix` }, [
                (z = n.suffix) == null ? void 0 : z.call(n),
                !!_.value && m(Zd, { type: _.value }, null),
              ]),
          ])
        },
      }
    },
    methods: {
      focus() {
        var e
        ;(e = this.inputRef) == null || e.focus()
      },
      blur() {
        var e
        ;(e = this.inputRef) == null || e.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const vk = Object.assign(y0, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + y0.name, y0)
    },
  })
  var sv = ce({
    name: 'SelectView',
    props: {
      modelValue: { type: Array, required: !0 },
      inputValue: String,
      placeholder: String,
      disabled: { type: Boolean, default: !1 },
      error: { type: Boolean, default: !1 },
      loading: { type: Boolean, default: !1 },
      opened: { type: Boolean, default: !1 },
      size: { type: String },
      bordered: { type: Boolean, default: !0 },
      multiple: { type: Boolean, default: !1 },
      allowClear: { type: Boolean, default: !1 },
      allowCreate: { type: Boolean, default: !1 },
      allowSearch: { type: Boolean, default: (e) => Ft(e.modelValue) },
      maxTagCount: { type: Number, default: 0 },
      retainInputValue: { type: Boolean, default: !1 },
    },
    emits: ['remove', 'clear', 'focus', 'blur'],
    setup(e, { emit: t, slots: n }) {
      const { size: r, disabled: i, error: o } = tt(e),
        a = ye('select-view'),
        {
          feedback: s,
          eventHandlers: l,
          mergedDisabled: c,
          mergedSize: d,
          mergedError: h,
        } = Rn({ size: r, disabled: i, error: o }),
        { mergedSize: p } = Vr(d),
        { opened: v } = tt(e),
        g = J(),
        _ = C(() => {
          var R
          return (R = g.value) == null ? void 0 : R.inputRef
        }),
        b = C(() => e.modelValue.length === 0),
        y = C(() => e.allowSearch || e.allowCreate),
        M = C(() => e.allowClear && !e.disabled && !b.value),
        x = (R) => {
          var j, N
          t('focus', R),
            (N = (j = l.value) == null ? void 0 : j.onFocus) == null ||
              N.call(j, R)
        },
        w = (R) => {
          var j, N
          t('blur', R),
            (N = (j = l.value) == null ? void 0 : j.onBlur) == null ||
              N.call(j, R)
        },
        E = (R) => {
          t('remove', R)
        },
        P = (R) => {
          t('clear', R)
        },
        A = () => {
          var R, j, N, I
          return e.loading
            ? (j = (R = n['loading-icon']) == null ? void 0 : R.call(n)) != null
              ? j
              : m(Xr, null, null)
            : e.allowSearch && e.opened
            ? (I = (N = n['search-icon']) == null ? void 0 : N.call(n)) != null
              ? I
              : m(bb, null, null)
            : n['arrow-icon']
            ? n['arrow-icon']()
            : m(sc, { class: `${a}-arrow-icon` }, null)
        },
        F = () =>
          m(yt, null, [
            M.value &&
              m(
                In,
                {
                  class: `${a}-clear-btn`,
                  onClick: P,
                  onMousedown: (R) => R.stopPropagation(),
                },
                { default: () => [m(zr, null, null)] }
              ),
            m('span', { class: `${a}-icon` }, [A()]),
            !!s.value && m(Zd, { type: s.value }, null),
          ])
      pt(v, (R) => {
        !R &&
          _.value &&
          _.value.isSameNode(document.activeElement) &&
          _.value.blur()
      })
      const T = C(() => [
        `${a}-${e.multiple ? 'multiple' : 'single'}`,
        { [`${a}-opened`]: e.opened, [`${a}-borderless`]: !e.bordered },
      ])
      return {
        inputRef: _,
        handleFocus: x,
        handleBlur: w,
        render: () =>
          e.multiple
            ? m(
                vk,
                {
                  ref: g,
                  baseCls: a,
                  class: T.value,
                  modelValue: e.modelValue,
                  inputValue: e.inputValue,
                  focused: e.opened,
                  placeholder: e.placeholder,
                  disabled: c.value,
                  size: p.value,
                  error: h.value,
                  maxTagCount: e.maxTagCount,
                  disabledInput: !e.allowSearch && !e.allowCreate,
                  retainInputValue: !0,
                  uninjectFormItemContext: !0,
                  onRemove: E,
                  onFocus: x,
                  onBlur: w,
                },
                { prefix: n.prefix, suffix: F, tag: n.label }
              )
            : m(
                eU,
                {
                  ref: g,
                  baseCls: a,
                  class: T.value,
                  modelValue: e.modelValue[0],
                  inputValue: e.inputValue,
                  focused: e.opened,
                  placeholder: e.placeholder,
                  disabled: c.value,
                  size: p.value,
                  error: h.value,
                  enabledInput: y.value,
                  uninjectFormItemContext: !0,
                  onFocus: x,
                  onBlur: w,
                },
                { default: n.label, prefix: n.prefix, suffix: F }
              ),
      }
    },
    methods: {
      focus() {
        this.inputRef && this.inputRef.focus()
      },
      blur() {
        this.inputRef && this.inputRef.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const fU = ce({
    name: 'Optgroup',
    props: { label: { type: String } },
    setup() {
      return { prefixCls: ye('select-group') }
    },
  })
  function hU(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        yt,
        null,
        [
          Se(
            'li',
            { class: H(`${e.prefixCls}-title`) },
            [ve(e.$slots, 'label', {}, () => [Lt(mt(e.label), 1)])],
            2
          ),
          ve(e.$slots, 'default'),
        ],
        64
      )
    )
  }
  var cd = Te(fU, [['render', hU]])
  const pU = ({
    dataKeys: e,
    contentRef: t,
    fixedSize: n,
    estimatedSize: r,
    buffer: i,
  }) => {
    const o = J(0),
      a = new Map(),
      s = C(() => e.value.length),
      l = J(0),
      c = C(() => {
        const A = l.value + i.value * 3
        return A > s.value ? s.value : A
      }),
      d = C(() => {
        const A = s.value - i.value * 3
        return A < 0 ? 0 : A
      }),
      h = (A) => {
        A < 0
          ? (l.value = 0)
          : A > d.value
          ? (l.value = d.value)
          : (l.value = A)
      },
      p = J(n.value),
      v = C(() => (r.value !== 30 ? r.value : o.value || r.value)),
      g = (A, F) => {
        a.set(A, F)
      },
      _ = (A) => {
        var F
        if (p.value) return v.value
        const T = e.value[A]
        return (F = a.get(T)) != null ? F : v.value
      },
      b = (A) => a.has(A)
    Wt(() => {
      const A = Array.from(a.values()).reduce((F, T) => F + T, 0)
      A > 0 && (o.value = A / a.size)
    })
    const y = (A) => (p.value ? v.value * A : M(0, A)),
      M = (A, F) => {
        let T = 0
        for (let k = A; k < F; k++) T += _(k)
        return T
      },
      x = C(() => (p.value ? v.value * l.value : M(0, l.value))),
      w = (A) => {
        const F = A >= x.value
        let T = Math.abs(A - x.value)
        const k = F ? l.value : l.value - 1
        let R = 0
        for (; T > 0; ) (T -= _(k + R)), F ? R++ : R--
        return R
      },
      E = (A) => {
        const F = w(A),
          T = l.value + F - i.value
        return T < 0 ? 0 : T > d.value ? d.value : T
      },
      P = C(() =>
        p.value ? v.value * (s.value - c.value) : M(c.value, s.value)
      )
    return {
      frontPadding: x,
      behindPadding: P,
      start: l,
      end: c,
      getStartByScroll: E,
      setItemSize: g,
      hasItemSize: b,
      setStart: h,
      getScrollOffset: y,
    }
  }
  var vU = ce({
      name: 'VirtualListItem',
      props: {
        hasItemSize: { type: Function, required: !0 },
        setItemSize: { type: Function, required: !0 },
      },
      setup(e, { slots: t }) {
        var n
        const r = (n = Jr()) == null ? void 0 : n.vnode.key,
          i = J(),
          o = () => {
            var a, s, l, c
            const d =
                (s = (a = i.value) == null ? void 0 : a.$el) != null
                  ? s
                  : i.value,
              h =
                (c =
                  (l = d == null ? void 0 : d.getBoundingClientRect) == null
                    ? void 0
                    : l.call(d).height) != null
                  ? c
                  : d == null
                  ? void 0
                  : d.offsetHeight
            h && e.setItemSize(r, h)
          }
        return (
          Wt(() => o()),
          Pr(() => o()),
          () => {
            var a
            const s = Iu((a = t.default) == null ? void 0 : a.call(t))
            return s ? Ti(s, { ref: i }, !0) : null
          }
        )
      },
    }),
    mU = Object.defineProperty,
    Mx = Object.getOwnPropertySymbols,
    gU = Object.prototype.hasOwnProperty,
    yU = Object.prototype.propertyIsEnumerable,
    Ex = (e, t, n) =>
      t in e
        ? mU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    bU = (e, t) => {
      for (var n in t || (t = {})) gU.call(t, n) && Ex(e, n, t[n])
      if (Mx) for (var n of Mx(t)) yU.call(t, n) && Ex(e, n, t[n])
      return e
    }
  const _U = ce({
    name: 'VirtualList',
    components: { VirtualListItem: vU },
    props: {
      height: { type: [Number, String], default: 200 },
      data: { type: Array, default: () => [] },
      threshold: { type: Number, default: 0 },
      itemKey: { type: String, default: 'key' },
      fixedSize: { type: Boolean, default: !1 },
      estimatedSize: { type: Number, default: 30 },
      buffer: { type: Number, default: 10 },
      component: { type: [String, Object], default: 'div' },
      listAttrs: { type: Object },
      contentAttrs: { type: Object },
      paddingPosition: { type: String, default: 'content' },
    },
    emits: { scroll: (e) => !0, reachBottom: (e) => !0 },
    setup(e, { emit: t }) {
      const {
          data: n,
          itemKey: r,
          fixedSize: i,
          estimatedSize: o,
          buffer: a,
          height: s,
        } = tt(e),
        l = ye('virtual-list'),
        c = C(() =>
          Ht(e.component)
            ? bU({ container: 'div', list: 'div', content: 'div' }, e.component)
            : { container: e.component, list: 'div', content: 'div' }
        ),
        d = J(),
        h = J(),
        p = C(() => ({
          height: it(s.value) ? `${s.value}px` : s.value,
          overflow: 'auto',
        })),
        v = C(() =>
          n.value.map((k, R) => {
            var j
            return (j = k[r.value]) != null ? j : R
          })
        ),
        {
          frontPadding: g,
          behindPadding: _,
          start: b,
          end: y,
          getStartByScroll: M,
          setItemSize: x,
          hasItemSize: w,
          setStart: E,
          getScrollOffset: P,
        } = pU({
          dataKeys: v,
          contentRef: h,
          fixedSize: i,
          estimatedSize: o,
          buffer: a,
        }),
        A = C(() =>
          e.threshold && n.value.length <= e.threshold
            ? n.value
            : n.value.slice(b.value, y.value)
        )
      return {
        prefixCls: l,
        containerRef: d,
        contentRef: h,
        frontPadding: g,
        currentList: A,
        behindPadding: _,
        onScroll: (k) => {
          const { scrollTop: R, scrollHeight: j, offsetHeight: N } = k.target,
            I = M(R)
          I !== b.value && E(I),
            t('scroll', k),
            Math.floor(j - (R + N)) <= 0 && t('reachBottom', k)
        },
        setItemSize: x,
        hasItemSize: w,
        start: b,
        scrollTo: (k) => {
          var R, j
          if (d.value)
            if (it(k)) d.value.scrollTop = k
            else {
              const N =
                (j = k.index) != null
                  ? j
                  : v.value.indexOf((R = k.key) != null ? R : '')
              E(N - a.value),
                (d.value.scrollTop = P(N)),
                hn(() => {
                  if (d.value) {
                    const I = P(N)
                    I !== d.value.scrollTop && (d.value.scrollTop = I)
                  }
                })
            }
        },
        style: p,
        mergedComponent: c,
      }
    },
  })
  function SU(e, t, n, r, i, o) {
    const a = ge('VirtualListItem')
    return (
      O(),
      Ee(
        xi(e.mergedComponent.container),
        {
          ref: 'containerRef',
          class: H(e.prefixCls),
          style: at(e.style),
          onScroll: e.onScroll,
        },
        {
          default: ze(() => [
            (O(),
            Ee(
              xi(e.mergedComponent.list),
              Fe(e.listAttrs, {
                style:
                  e.paddingPosition === 'list'
                    ? {
                        paddingTop: `${e.frontPadding}px`,
                        paddingBottom: `${e.behindPadding}px`,
                      }
                    : {},
              }),
              {
                default: ze(() => [
                  (O(),
                  Ee(
                    xi(e.mergedComponent.content),
                    Fe({ ref: 'contentRef' }, e.contentAttrs, {
                      style:
                        e.paddingPosition === 'content'
                          ? {
                              paddingTop: `${e.frontPadding}px`,
                              paddingBottom: `${e.behindPadding}px`,
                            }
                          : {},
                    }),
                    {
                      default: ze(() => [
                        (O(!0),
                        Z(
                          yt,
                          null,
                          Yn(e.currentList, (s, l) => {
                            var c
                            return (
                              O(),
                              Ee(
                                a,
                                {
                                  key:
                                    (c = s[e.itemKey]) != null
                                      ? c
                                      : e.start + l,
                                  'has-item-size': e.hasItemSize,
                                  'set-item-size': e.setItemSize,
                                },
                                {
                                  default: ze(() => [
                                    ve(e.$slots, 'item', {
                                      item: s,
                                      index: e.start + l,
                                    }),
                                  ]),
                                  _: 2,
                                },
                                1032,
                                ['has-item-size', 'set-item-size']
                              )
                            )
                          }),
                          128
                        )),
                      ]),
                      _: 3,
                    },
                    16,
                    ['style']
                  )),
                ]),
                _: 3,
              },
              16,
              ['style']
            )),
          ]),
          _: 3,
        },
        8,
        ['class', 'style', 'onScroll']
      )
    )
  }
  var Qv = Te(_U, [['render', SU]])
  const Px = typeof window > 'u' ? global : window
  function q_(e, t) {
    let n = 0
    return (...r) => {
      n && Px.clearTimeout(n),
        (n = Px.setTimeout(() => {
          ;(n = 0), e(...r)
        }, t))
    }
  }
  var CU = Object.defineProperty,
    wU = Object.defineProperties,
    xU = Object.getOwnPropertyDescriptors,
    Tx = Object.getOwnPropertySymbols,
    MU = Object.prototype.hasOwnProperty,
    EU = Object.prototype.propertyIsEnumerable,
    kx = (e, t, n) =>
      t in e
        ? CU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    Hc = (e, t) => {
      for (var n in t || (t = {})) MU.call(t, n) && kx(e, n, t[n])
      if (Tx) for (var n of Tx(t)) EU.call(t, n) && kx(e, n, t[n])
      return e
    },
    PU = (e, t) => wU(e, xU(t))
  function TU(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  const kU = {
    value: 'value',
    label: 'label',
    disabled: 'disabled',
    tagProps: 'tagProps',
    render: 'render',
  }
  var b0 = ce({
    name: 'Select',
    components: { Trigger: Mr, SelectView: sv },
    inheritAttrs: !1,
    props: {
      multiple: { type: Boolean, default: !1 },
      modelValue: { type: [String, Number, Object, Array] },
      defaultValue: {
        type: [String, Number, Object, Array],
        default: (e) => (Mt(e.multiple) ? '' : []),
      },
      inputValue: { type: String },
      defaultInputValue: { type: String, default: '' },
      size: { type: String },
      placeholder: String,
      loading: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      error: { type: Boolean, default: !1 },
      allowClear: { type: Boolean, default: !1 },
      allowSearch: { type: [Boolean, Object], default: (e) => !!e.multiple },
      allowCreate: { type: Boolean, default: !1 },
      maxTagCount: { type: Number, default: 0 },
      popupContainer: { type: [String, Object] },
      bordered: { type: Boolean, default: !0 },
      defaultActiveFirstOption: { type: Boolean, default: !0 },
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      unmountOnClose: { type: Boolean, default: !1 },
      filterOption: { type: [Boolean, Function], default: !0 },
      options: { type: Array, default: () => [] },
      virtualListProps: { type: Object },
      triggerProps: { type: Object },
      formatLabel: { type: Function },
      fallbackOption: { type: [Boolean, Function], default: !0 },
      showExtraOptions: { type: Boolean, default: !0 },
      valueKey: { type: String, default: 'value' },
      searchDelay: { type: Number, default: 500 },
      limit: { type: Number, default: 0 },
      fieldNames: { type: Object },
      scrollbar: { type: [Boolean, Object], default: !0 },
      showHeaderOnEmpty: { type: Boolean, default: !1 },
      showFooterOnEmpty: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      'update:inputValue': (e) => !0,
      'update:popupVisible': (e) => !0,
      change: (e) => !0,
      inputValueChange: (e) => !0,
      popupVisibleChange: (e) => !0,
      clear: (e) => !0,
      remove: (e) => !0,
      search: (e) => !0,
      dropdownScroll: (e) => !0,
      dropdownReachBottom: (e) => !0,
      exceedLimit: (e, t) => !0,
    },
    setup(e, { slots: t, emit: n, attrs: r }) {
      const {
          size: i,
          disabled: o,
          error: a,
          options: s,
          filterOption: l,
          valueKey: c,
          multiple: d,
          popupVisible: h,
          showExtraOptions: p,
          modelValue: v,
          fieldNames: g,
          loading: _,
          defaultActiveFirstOption: b,
        } = tt(e),
        y = ye('select'),
        {
          mergedSize: M,
          mergedDisabled: x,
          mergedError: w,
          eventHandlers: E,
        } = Rn({ size: i, disabled: o, error: a }),
        P = C(() => (e.virtualListProps ? 'div' : 'li')),
        A = C(() => Ht(e.allowSearch) && !!e.allowSearch.retainInputValue)
      C(() => {
        if (xt(e.formatLabel))
          return (de) => {
            const xe = re.get(de.value)
            return e.formatLabel(xe)
          }
      })
      const F = J(),
        T = J({}),
        k = J(),
        { computedPopupVisible: R, handlePopupVisibleChange: j } = Jv({
          popupVisible: h,
          emit: n,
        }),
        N = J(e.defaultValue),
        I = C(() => {
          var de
          const xe = (de = e.modelValue) != null ? de : N.value
          return (Ft(xe) ? xe : xe || it(xe) || ir(xe) ? [xe] : []).map(
            (Le) => ({ value: Le, key: Ml(Le, e.valueKey) })
          )
        })
      pt(v, (de) => {
        ;(Mt(de) || fi(de)) && (N.value = d.value ? [] : de)
      })
      const B = C(() => I.value.map((de) => de.key)),
        V = C(() => Hc(Hc({}, kU), g == null ? void 0 : g.value)),
        L = J(),
        W = (de) => {
          const xe = {}
          return (
            de.forEach((ne) => {
              xe[ne] = re.get(ne)
            }),
            xe
          )
        },
        Y = (de) => {
          L.value = W(de)
        },
        U = (de) =>
          xt(e.fallbackOption)
            ? e.fallbackOption(de)
            : {
                [V.value.value]: de,
                [V.value.label]: String(
                  Ht(de) ? de[c == null ? void 0 : c.value] : de
                ),
              },
        le = () => {
          const de = [],
            xe = []
          if (e.allowCreate || e.fallbackOption) {
            for (const ne of I.value)
              if (!xe.includes(ne.key) && ne.value !== '') {
                const Le = re.get(ne.key)
                ;(!Le || Le.origin === 'extraOptions') &&
                  (de.push(ne), xe.push(ne.key))
              }
          }
          if (e.allowCreate && ue.value) {
            const ne = Ml(ue.value)
            if (!xe.includes(ne)) {
              const Le = re.get(ne)
              ;(!Le || Le.origin === 'extraOptions') &&
                de.push({ value: ue.value, key: ne })
            }
          }
          return de
        },
        q = J([]),
        oe = C(() =>
          q.value.map((de) => {
            var xe
            let ne = U(de.value)
            const Le = (xe = L.value) == null ? void 0 : xe[de.key]
            return !Mt(Le) && !cB(Le) && (ne = Hc(Hc({}, ne), Le)), ne
          })
        )
      hn(() => {
        pr(() => {
          var de
          const xe = le()
          if (xe.length !== q.value.length) q.value = xe
          else if (xe.length > 0) {
            for (let ne = 0; ne < xe.length; ne++)
              if (
                xe[ne].key !== ((de = q.value[ne]) == null ? void 0 : de.key)
              ) {
                q.value = xe
                break
              }
          }
        })
      })
      const te = J(''),
        ue = C(() => {
          var de
          return (de = e.inputValue) != null ? de : te.value
        })
      pt(R, (de) => {
        !de && !A.value && ue.value && qe('')
      })
      const me = (de) => {
          var xe, ne
          return e.multiple
            ? de.map((Le) => {
                var et, Ne
                return (Ne = (et = re.get(Le)) == null ? void 0 : et.value) !=
                  null
                  ? Ne
                  : ''
              })
            : (ne = (xe = re.get(de[0])) == null ? void 0 : xe.value) != null
            ? ne
            : W7(re)
            ? void 0
            : ''
        },
        Re = (de) => {
          var xe, ne
          const Le = me(de)
          ;(N.value = Le),
            n('update:modelValue', Le),
            n('change', Le),
            (ne = (xe = E.value) == null ? void 0 : xe.onChange) == null ||
              ne.call(xe),
            Y(de)
        },
        qe = (de) => {
          ;(te.value = de),
            n('update:inputValue', de),
            n('inputValueChange', de)
        },
        Ve = (de, xe) => {
          if (e.multiple) {
            if (B.value.includes(de)) {
              const ne = B.value.filter((Le) => Le !== de)
              Re(ne)
            } else if (we.value.includes(de))
              if (e.limit > 0 && B.value.length >= e.limit) {
                const ne = re.get(de)
                n('exceedLimit', ne == null ? void 0 : ne.value, xe)
              } else {
                const ne = B.value.concat(de)
                Re(ne)
              }
            A.value || qe('')
          } else {
            if ((de !== B.value[0] && Re([de]), A.value)) {
              const ne = re.get(de)
              ne && qe(ne.label)
            }
            j(!1)
          }
        },
        nt = q_((de) => {
          n('search', de)
        }, e.searchDelay),
        We = (de) => {
          de !== ue.value && (R.value || j(!0), qe(de), e.allowSearch && nt(de))
        },
        D = (de) => {
          const xe = re.get(de),
            ne = B.value.filter((Le) => Le !== de)
          Re(ne), n('remove', xe == null ? void 0 : xe.value)
        },
        G = (de) => {
          de == null || de.stopPropagation()
          const xe = B.value.filter((ne) => {
            var Le
            return (Le = re.get(ne)) == null ? void 0 : Le.disabled
          })
          Re(xe), qe(''), n('clear', de)
        },
        z = (de) => {
          n('dropdownScroll', de)
        },
        ie = (de) => {
          n('dropdownReachBottom', de)
        },
        {
          validOptions: ae,
          optionInfoMap: re,
          validOptionInfos: pe,
          enabledOptionKeys: we,
          handleKeyDown: $e,
        } = V_({
          multiple: d,
          options: s,
          extraOptions: oe,
          inputValue: ue,
          filterOption: l,
          showExtraOptions: p,
          component: P,
          valueKey: c,
          fieldNames: g,
          loading: _,
          popupVisible: R,
          valueKeys: B,
          dropdownRef: F,
          optionRefs: T,
          virtualListRef: k,
          defaultActiveFirstOption: b,
          onSelect: Ve,
          onPopupVisibleChange: j,
        }),
        Ae = C(() => {
          var de
          const xe = []
          for (const ne of I.value) {
            const Le = re.get(ne.key)
            Le &&
              xe.push(
                PU(Hc({}, Le), {
                  value: ne.key,
                  label:
                    (de = Le == null ? void 0 : Le.label) != null
                      ? de
                      : String(
                          Ht(ne.value)
                            ? ne.value[c == null ? void 0 : c.value]
                            : ne.value
                        ),
                  closable: !(Le != null && Le.disabled),
                  tagProps: Le == null ? void 0 : Le.tagProps,
                })
              )
          }
          return xe
        }),
        ft = (de) => {
          if (xt(t.option)) {
            const xe = t.option
            return () => xe({ data: de.raw })
          }
          return xt(de.render) ? de.render : () => de.label
        },
        Q = (de) => {
          if (K4(de)) {
            let xe
            return m(
              cd,
              { key: de.key, label: de.label },
              TU((xe = de.options.map((ne) => Q(ne))))
                ? xe
                : { default: () => [xe] }
            )
          }
          return Xv(de, {
            inputValue: ue.value,
            filterOption: l == null ? void 0 : l.value,
          })
            ? m(
                pl,
                {
                  ref: (xe) => {
                    xe != null && xe.$el && (T.value[de.key] = xe.$el)
                  },
                  key: de.key,
                  value: de.value,
                  label: de.label,
                  disabled: de.disabled,
                  internal: !0,
                },
                { default: ft(de) }
              )
            : null
        },
        X = () =>
          m(
            F_,
            {
              ref: F,
              loading: e.loading,
              empty: pe.value.length === 0,
              virtualList: !!e.virtualListProps,
              scrollbar: e.scrollbar,
              showHeaderOnEmpty: e.showHeaderOnEmpty,
              showFooterOnEmpty: e.showFooterOnEmpty,
              onScroll: z,
              onReachBottom: ie,
            },
            {
              default: () => {
                var de, xe
                return [
                  ...((xe = (de = t.default) == null ? void 0 : de.call(t)) !=
                  null
                    ? xe
                    : []),
                  ...ae.value.map(Q),
                ]
              },
              'virtual-list': () =>
                m(Qv, Fe(e.virtualListProps, { ref: k, data: ae.value }), {
                  item: ({ item: de }) => Q(de),
                }),
              empty: t.empty,
              header: t.header,
              footer: t.footer,
            }
          ),
        he = ({ data: de }) => {
          var xe, ne, Le, et
          if ((t.label || xt(e.formatLabel)) && de) {
            const Ne = re.get(de.value)
            if (Ne != null && Ne.raw)
              return (Le =
                (xe = t.label) == null
                  ? void 0
                  : xe.call(t, { data: Ne.raw })) != null
                ? Le
                : (ne = e.formatLabel) == null
                ? void 0
                : ne.call(e, Ne.raw)
          }
          return (et = de == null ? void 0 : de.label) != null ? et : ''
        }
      return () =>
        m(
          Mr,
          Fe(
            {
              trigger: 'click',
              position: 'bl',
              popupOffset: 4,
              animationName: 'slide-dynamic-origin',
              hideEmpty: !0,
              preventFocus: !0,
              autoFitPopupWidth: !0,
              autoFitTransformOrigin: !0,
              disabled: x.value,
              popupVisible: R.value,
              unmountOnClose: e.unmountOnClose,
              clickToClose: !(e.allowSearch || e.allowCreate),
              popupContainer: e.popupContainer,
              onPopupVisibleChange: j,
            },
            e.triggerProps
          ),
          {
            default: () => {
              var de, xe
              return [
                (xe = (de = t.trigger) == null ? void 0 : de.call(t)) != null
                  ? xe
                  : m(
                      sv,
                      Fe(
                        {
                          class: y,
                          modelValue: Ae.value,
                          inputValue: ue.value,
                          multiple: e.multiple,
                          disabled: x.value,
                          error: w.value,
                          loading: e.loading,
                          allowClear: e.allowClear,
                          allowCreate: e.allowCreate,
                          allowSearch: !!e.allowSearch,
                          opened: R.value,
                          maxTagCount: e.maxTagCount,
                          placeholder: e.placeholder,
                          bordered: e.bordered,
                          size: M.value,
                          onInputValueChange: We,
                          onRemove: D,
                          onClear: G,
                          onKeydown: $e,
                        },
                        r
                      ),
                      {
                        label: he,
                        prefix: t.prefix,
                        'arrow-icon': t['arrow-icon'],
                        'loading-icon': t['loading-icon'],
                        'search-icon': t['search-icon'],
                      }
                    ),
              ]
            },
            content: X,
          }
        )
    },
  })
  const lv = Object.assign(b0, {
      Option: pl,
      OptGroup: cd,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + b0.name, b0),
          e.component(n + pl.name, pl),
          e.component(n + cd.name, cd)
      },
    }),
    mk = Symbol('RadioGroup')
  var sp = ce({
      name: 'Radio',
      components: { IconHover: In },
      props: {
        modelValue: { type: [String, Number, Boolean], default: void 0 },
        defaultChecked: { type: Boolean, default: !1 },
        value: { type: [String, Number, Boolean], default: !0 },
        type: { type: String, default: 'radio' },
        disabled: { type: Boolean, default: !1 },
        uninjectGroupContext: { type: Boolean, default: !1 },
      },
      emits: { 'update:modelValue': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const r = ye('radio'),
          { modelValue: i } = tt(e),
          o = e.uninjectGroupContext ? void 0 : zt(mk, void 0),
          { mergedDisabled: a, eventHandlers: s } = Rn({
            disabled: Vi(e, 'disabled'),
          }),
          l = J(null),
          c = J(e.defaultChecked),
          d = C(() => (o == null ? void 0 : o.name) === 'ArcoRadioGroup'),
          h = C(() => {
            var w
            return (w = o == null ? void 0 : o.type) != null ? w : e.type
          }),
          p = C(() => (o == null ? void 0 : o.disabled) || a.value),
          v = C(() => {
            var w, E
            return d.value
              ? (o == null ? void 0 : o.value) ===
                  ((w = e.value) != null ? w : !0)
              : Mt(e.modelValue)
              ? c.value
              : e.modelValue === ((E = e.value) != null ? E : !0)
          })
        pt(i, (w) => {
          ;(Mt(w) || fi(w)) && (c.value = !1)
        }),
          pt(v, (w, E) => {
            w !== E && ((c.value = w), l.value && (l.value.checked = w))
          })
        const g = (w) => {
            var E, P
            ;(P = (E = s.value) == null ? void 0 : E.onFocus) == null ||
              P.call(E, w)
          },
          _ = (w) => {
            var E, P
            ;(P = (E = s.value) == null ? void 0 : E.onBlur) == null ||
              P.call(E, w)
          },
          b = (w) => {
            w.stopPropagation()
          },
          y = (w) => {
            var E, P, A, F, T
            ;(c.value = !0),
              d.value
                ? o == null || o.handleChange((E = e.value) != null ? E : !0, w)
                : (t('update:modelValue', (P = e.value) != null ? P : !0),
                  t('change', (A = e.value) != null ? A : !0, w),
                  (T = (F = s.value) == null ? void 0 : F.onChange) == null ||
                    T.call(F, w)),
              hn(() => {
                l.value &&
                  l.value.checked !== v.value &&
                  (l.value.checked = v.value)
              })
          },
          M = C(() => [
            `${h.value === 'button' ? `${r}-button` : r}`,
            { [`${r}-checked`]: v.value, [`${r}-disabled`]: p.value },
          ]),
          x = () =>
            m(yt, null, [
              m(
                ge('icon-hover'),
                { class: `${r}-icon-hover`, disabled: p.value || v.value },
                { default: () => [m('span', { class: `${r}-icon` }, null)] }
              ),
              n.default && m('span', { class: `${r}-label` }, [n.default()]),
            ])
        return () => {
          var w, E, P, A
          return m('label', { class: M.value }, [
            m(
              'input',
              {
                ref: l,
                type: 'radio',
                checked: v.value,
                value: e.value,
                class: `${r}-target`,
                disabled: p.value,
                onClick: b,
                onChange: y,
                onFocus: g,
                onBlur: _,
              },
              null
            ),
            h.value === 'radio'
              ? (A =
                  (P =
                    (E = n.radio) != null
                      ? E
                      : (w = o == null ? void 0 : o.slots) == null
                      ? void 0
                      : w.radio) == null
                    ? void 0
                    : P({ checked: v.value, disabled: p.value })) != null
                ? A
                : x()
              : m('span', { class: `${r}-button-content` }, [
                  n.default && n.default(),
                ]),
          ])
        }
      },
    }),
    lp = ce({
      name: 'RadioGroup',
      props: {
        modelValue: { type: [String, Number, Boolean], default: void 0 },
        defaultValue: { type: [String, Number, Boolean], default: '' },
        type: { type: String, default: 'radio' },
        size: { type: String },
        options: { type: Array },
        direction: { type: String, default: 'horizontal' },
        disabled: { type: Boolean, default: !1 },
      },
      emits: { 'update:modelValue': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const r = ye('radio-group'),
          { size: i, type: o, disabled: a, modelValue: s } = tt(e),
          {
            mergedDisabled: l,
            mergedSize: c,
            eventHandlers: d,
          } = Rn({ size: i, disabled: a }),
          h = J(e.defaultValue),
          p = C(() => {
            var y
            return (y = e.modelValue) != null ? y : h.value
          }),
          v = C(() => {
            var y
            return ((y = e.options) != null ? y : []).map((M) =>
              ir(M) || it(M) ? { label: M, value: M } : M
            )
          })
        sn(
          mk,
          Je({
            name: 'ArcoRadioGroup',
            value: p,
            size: c,
            type: o,
            disabled: l,
            slots: n,
            handleChange: (y, M) => {
              var x, w
              ;(h.value = y),
                t('update:modelValue', y),
                t('change', y, M),
                (w = (x = d.value) == null ? void 0 : x.onChange) == null ||
                  w.call(x, M)
            },
          })
        ),
          pt(p, (y) => {
            h.value !== y && (h.value = y)
          }),
          pt(s, (y) => {
            ;(Mt(y) || fi(y)) && (h.value = '')
          })
        const _ = C(() => [
            `${r}${e.type === 'button' ? '-button' : ''}`,
            `${r}-size-${c.value}`,
            `${r}-direction-${e.direction}`,
            { [`${r}-disabled`]: l.value },
          ]),
          b = () =>
            v.value.map((y) =>
              m(
                sp,
                {
                  key: y.value,
                  value: y.value,
                  disabled: y.disabled,
                  modelValue: p.value === y.value,
                },
                {
                  default: () => [
                    n.label
                      ? n.label({ data: y })
                      : xt(y.label)
                      ? y.label()
                      : y.label,
                  ],
                }
              )
            )
        return () => {
          var y
          return m('span', { class: _.value }, [
            v.value.length > 0
              ? b()
              : (y = n.default) == null
              ? void 0
              : y.call(n),
          ])
        }
      },
    })
  const Ku = Object.assign(sp, {
      Group: lp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + sp.name, sp), e.component(n + lp.name, lp)
      },
    }),
    AU = ce({
      name: 'IconLeft',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-left`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    $U = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    OU = Se('path', { d: 'M32 8.4 16.444 23.956 32 39.513' }, null, -1),
    LU = [OU]
  function IU(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        LU,
        14,
        $U
      )
    )
  }
  var _0 = Te(AU, [['render', IU]])
  const ja = Object.assign(_0, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + _0.name, _0)
    },
  })
  function RU(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  function Ax(e) {
    return e.parentElement
  }
  var DU = ce({
    name: 'Header',
    props: {
      mode: { type: String },
      dayStartOfWeek: { type: Number },
      isWeek: { type: Boolean },
      panel: { type: Boolean },
      modes: { type: Array },
      headerType: { type: String },
      pageShowData: { type: Object, required: !0 },
      move: { type: Function, required: !0 },
      onYearChange: { type: Function, required: !0 },
      onMonthChange: { type: Function, required: !0 },
      changePageShowDate: { type: Function, required: !0 },
      onModeChange: { type: Function, required: !0 },
      headerValueFormat: { type: String, required: !0 },
    },
    emits: ['yearChange', 'monthChange'],
    setup(e) {
      const t = ye('calendar'),
        { t: n } = Vn(),
        r = Ft(e.modes)
          ? e.modes.map((c) => ({ label: n(`datePicker.view.${c}`), value: c }))
          : [],
        i = e.headerType === 'select',
        o = e.pageShowData.year(),
        a = e.pageShowData.month() + 1,
        s = C(() => {
          const c = [o]
          for (let d = 1; d <= 10; d++) c.unshift(o - d)
          for (let d = 1; d < 10; d++) c.push(o + d)
          return c
        }),
        l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      return () => {
        let c
        return m('div', { class: `${t}-header` }, [
          m('div', { class: `${t}-header-left` }, [
            i
              ? m(yt, null, [
                  m(
                    lv,
                    {
                      size: 'small',
                      class: `${t}-header-value-year`,
                      value: o,
                      options: s.value,
                      onChange: e.onYearChange,
                      getPopupContainer: Ax,
                    },
                    null
                  ),
                  e.mode === 'month' &&
                    m(
                      lv,
                      {
                        size: 'small',
                        class: `${t}-header-value-month`,
                        value: a,
                        options: l,
                        onChange: e.onMonthChange,
                        getPopupContainer: Ax,
                      },
                      null
                    ),
                ])
              : m(yt, null, [
                  m(
                    'div',
                    {
                      class: `${t}-header-icon`,
                      role: 'button',
                      tabIndex: 0,
                      onClick: () => e.changePageShowDate('prev', e.mode),
                    },
                    [m(ja, null, null)]
                  ),
                  m('div', { class: `${t}-header-value` }, [
                    e.pageShowData.format(e.headerValueFormat),
                  ]),
                  m(
                    'div',
                    {
                      role: 'button',
                      tabIndex: 0,
                      class: `${t}-header-icon`,
                      onClick: () => e.changePageShowDate('next', e.mode),
                    },
                    [m(No, null, null)]
                  ),
                ]),
            m(
              Yr,
              { size: 'small', onClick: () => e.move(Nr()) },
              RU((c = n('datePicker.today'))) ? c : { default: () => [c] }
            ),
          ]),
          m('div', { class: `${t}-header-right` }, [
            m(
              Ku.Group,
              {
                size: 'small',
                type: 'button',
                options: r,
                onChange: e.onModeChange,
                modelValue: e.mode,
              },
              null
            ),
          ]),
        ])
      }
    },
  })
  function NU(e, t) {
    return e === 'month' || (e === 'year' && !t) ? 'YYYY-MM-DD' : 'YYYY-MM'
  }
  var S0 = ce({
    name: 'Calendar',
    props: {
      modelValue: { type: Date, default: void 0 },
      defaultValue: { type: Date },
      mode: { type: String },
      defaultMode: { type: String, default: 'month' },
      modes: { type: Array, default: () => ['month', 'year'] },
      allowSelect: { type: Boolean, default: !0 },
      panel: { type: Boolean, default: !1 },
      panelWidth: { type: Number },
      panelTodayBtn: { type: Boolean, default: !1 },
      dayStartOfWeek: { type: Number, default: 0 },
      isWeek: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      change: (e) => !0,
      panelChange: (e) => !0,
    },
    setup(e, { emit: t }) {
      const { dayStartOfWeek: n, isWeek: r } = tt(e),
        i = ye('calendar'),
        o = J(e.defaultMode),
        { t: a } = Vn(),
        s = C(() => (e.mode ? e.mode : o.value)),
        l = NU(s.value, e.panel),
        c = J(Hi(e.defaultValue || Date.now(), l)),
        d = C(() => (e.modelValue ? Hi(e.modelValue, l) : c.value)),
        h = J(d.value || Nr()),
        p = C(() => ck(h.value, { dayStartOfWeek: n.value, isWeek: r.value }))
      function v(A) {
        ;(h.value = A), t('panelChange', A.toDate())
      }
      function g(A) {
        ;(c.value = A),
          t('change', A.toDate()),
          t('update:modelValue', A.toDate()),
          v(A)
      }
      function _(A, F = !1) {
        F || g(A)
      }
      let b = ''
      s.value === 'month'
        ? (b = a('calendar.formatMonth'))
        : s.value === 'year' && (b = a('calendar.formatYear'))
      function y(A, F) {
        A === 'prev' && (h.value = ur.subtract(h.value, 1, F)),
          A === 'next' && (h.value = ur.add(h.value, 1, F)),
          t('panelChange', h.value.toDate())
      }
      function M(A) {
        const F = ur.set(h.value, 'year', A)
        ;(h.value = F), t('panelChange', F.toDate())
      }
      function x(A) {
        const F = ur.set(h.value, 'month', A - 1)
        ;(h.value = F), t('panelChange', F.toDate())
      }
      function w(A) {
        o.value = A
      }
      const E = C(() => [
          i,
          s.value === 'month' ? `${i}-mode-month` : `${i}-mode-year`,
          {
            [`${i}-panel`]:
              e.panel && (s.value === 'month' || s.value === 'year'),
          },
        ]),
        P = e.panel ? { width: e.panelWidth } : {}
      return () =>
        m('div', Fe({ class: E.value, style: P }, NV(e)), [
          m(
            DU,
            {
              move: g,
              headerValueFormat: b,
              modes: ['month', 'year'],
              mode: s.value,
              pageShowData: h.value,
              dayStartOfWeek: e.dayStartOfWeek,
              isWeek: e.isWeek,
              onModeChange: w,
              onYearChange: M,
              onMonthChange: x,
              changePageShowDate: y,
            },
            null
          ),
          s.value === 'month' &&
            m('div', { class: `${i}-body` }, [
              m(
                dk,
                {
                  key: h.value.month(),
                  pageData: p.value,
                  value: d.value,
                  mode: s.value,
                  selectHandler: _,
                  isWeek: e.isWeek,
                  dayStartOfWeek: e.dayStartOfWeek,
                  pageShowDate: h.value,
                },
                null
              ),
            ]),
          s.value === 'year' &&
            m('div', { class: `${i}-body` }, [
              m(
                JV,
                {
                  key: h.value.year(),
                  pageData: p.value,
                  pageShowData: h.value,
                  mode: s.value,
                  isWeek: e.isWeek,
                  value: d.value,
                  dayStartOfWeek: e.dayStartOfWeek,
                  selectHandler: _,
                },
                null
              ),
            ]),
          e.panel &&
            e.panelTodayBtn &&
            m('div', { class: `${i}-footer-btn-wrapper` }, [a('today')]),
        ])
    },
  })
  const gk = Object.assign(S0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + S0.name, S0)
      },
    }),
    X_ = Symbol('ArcoCard')
  var C0 = ce({
      name: 'Card',
      components: { Spin: Do },
      props: {
        bordered: { type: Boolean, default: !0 },
        loading: { type: Boolean, default: !1 },
        hoverable: { type: Boolean, default: !1 },
        size: { type: String },
        headerStyle: { type: Object, default: () => ({}) },
        bodyStyle: { type: Object, default: () => ({}) },
        title: { type: String },
        extra: { type: String },
      },
      setup(e, { slots: t }) {
        const n = ye('card'),
          { size: r } = tt(e),
          { mergedSize: i } = Vr(r),
          o = C(() =>
            i.value === 'small' || i.value === 'mini' ? 'small' : 'medium'
          ),
          a = (c) => {
            const d = ea(c)
            return m('div', { class: `${n}-actions` }, [
              m('div', { class: `${n}-actions-right` }, [
                d.map((h, p) =>
                  m(
                    'span',
                    { key: `action-${p}`, class: `${n}-actions-item` },
                    [h]
                  )
                ),
              ]),
            ])
          },
          s = Je({ hasMeta: !1, hasGrid: !1, slots: t, renderActions: a })
        sn(X_, s)
        const l = C(() => [
          n,
          `${n}-size-${o.value}`,
          {
            [`${n}-loading`]: e.loading,
            [`${n}-bordered`]: e.bordered,
            [`${n}-hoverable`]: e.hoverable,
            [`${n}-contain-grid`]: s.hasGrid,
          },
        ])
        return () => {
          var c, d, h, p, v, g, _
          const b = !!((c = t.title) != null ? c : e.title),
            y = !!((d = t.extra) != null ? d : e.extra)
          return m('div', { class: l.value }, [
            (b || y) &&
              m(
                'div',
                {
                  class: [`${n}-header`, { [`${n}-header-no-title`]: !b }],
                  style: e.headerStyle,
                },
                [
                  b &&
                    m('div', { class: `${n}-header-title` }, [
                      (p = (h = t.title) == null ? void 0 : h.call(t)) != null
                        ? p
                        : e.title,
                    ]),
                  y &&
                    m('div', { class: `${n}-header-extra` }, [
                      (g = (v = t.extra) == null ? void 0 : v.call(t)) != null
                        ? g
                        : e.extra,
                    ]),
                ]
              ),
            t.cover && m('div', { class: `${n}-cover` }, [t.cover()]),
            m('div', { class: `${n}-body`, style: e.bodyStyle }, [
              e.loading
                ? m(Do, null, null)
                : (_ = t.default) == null
                ? void 0
                : _.call(t),
              t.actions && !s.hasMeta && a(t.actions()),
            ]),
          ])
        }
      },
    }),
    up = ce({
      name: 'CardMeta',
      props: { title: { type: String }, description: { type: String } },
      setup(e, { slots: t }) {
        const n = ye('card-meta'),
          r = zt(X_)
        return (
          Wt(() => {
            r && (r.hasMeta = !0)
          }),
          () => {
            var i, o, a, s, l, c
            const d = !!((i = t.title) != null ? i : e.title),
              h = !!((o = t.description) != null ? o : e.description)
            return m('div', { class: n }, [
              (d || h) &&
                m('div', { class: `${n}-content` }, [
                  d &&
                    m('div', { class: `${n}-title` }, [
                      (s = (a = t.title) == null ? void 0 : a.call(t)) != null
                        ? s
                        : e.title,
                    ]),
                  h &&
                    m('div', { class: `${n}-description` }, [
                      (c = (l = t.description) == null ? void 0 : l.call(t)) !=
                      null
                        ? c
                        : e.description,
                    ]),
                ]),
              (t.avatar || (r == null ? void 0 : r.slots.actions)) &&
                m(
                  'div',
                  {
                    class: [
                      `${n}-footer `,
                      { [`${n}-footer-only-actions`]: !t.avatar },
                    ],
                  },
                  [
                    t.avatar &&
                      m('div', { class: `${n}-avatar` }, [t.avatar()]),
                    r && r.slots.actions && r.renderActions(r.slots.actions()),
                  ]
                ),
            ])
          }
        )
      },
    })
  const BU = ce({
    name: 'CardGrid',
    props: { hoverable: { type: Boolean, default: !1 } },
    setup(e) {
      const t = ye('card-grid'),
        n = zt(X_)
      return (
        Wt(() => {
          n && (n.hasGrid = !0)
        }),
        { cls: C(() => [t, { [`${t}-hoverable`]: e.hoverable }]) }
      )
    },
  })
  function FU(e, t, n, r, i, o) {
    return O(), Z('div', { class: H(e.cls) }, [ve(e.$slots, 'default')], 2)
  }
  var cp = Te(BU, [['render', FU]])
  const zU = Object.assign(C0, {
      Meta: up,
      Grid: cp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + C0.name, C0),
          e.component(n + up.name, up),
          e.component(n + cp.name, cp)
      },
    }),
    VU = ce({
      name: 'Indicator',
      props: {
        count: { type: Number, default: 2 },
        activeIndex: { type: Number, default: 0 },
        type: { type: String, default: 'line' },
        position: { type: String, default: 'bottom' },
        trigger: { type: String, default: 'click' },
      },
      emits: ['select'],
      setup(e, { emit: t }) {
        const n = ye('carousel-indicator'),
          r = (s) => {
            var l
            if ((s.preventDefault(), e.type === 'slider')) {
              const c = s.offsetX,
                d = s.currentTarget.clientWidth
              if (s.target === s.currentTarget) {
                const h = Math.floor((c / d) * e.count)
                h !== e.activeIndex && t('select', h)
              }
            } else {
              const c = Number.parseInt(
                (l = s.target.getAttribute('data-index')) != null ? l : '',
                10
              )
              !Number.isNaN(c) && c !== e.activeIndex && t('select', c)
            }
          },
          i = C(() =>
            e.trigger === 'click' ? { onClick: r } : { onMouseover: r }
          ),
          o = C(() => [`${n}`, `${n}-${e.type}`, `${n}-${e.position}`]),
          a = C(() => {
            const s = 100 / e.count
            return { width: `${s}%`, left: `${e.activeIndex * s}%` }
          })
        return { prefixCls: n, eventHandlers: i, cls: o, sliderStyle: a }
      },
    }),
    UU = ['data-index']
  function HU(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        Fe({ class: e.cls }, e.eventHandlers),
        [
          e.type === 'slider'
            ? (O(),
              Z(
                'span',
                {
                  key: 0,
                  style: at(e.sliderStyle),
                  class: H([
                    `${e.prefixCls}-item`,
                    `${e.prefixCls}-item-active`,
                  ]),
                },
                null,
                6
              ))
            : (O(!0),
              Z(
                yt,
                { key: 1 },
                Yn(
                  Array(e.count),
                  (a, s) => (
                    O(),
                    Z(
                      'span',
                      {
                        key: s,
                        'data-index': s,
                        class: H([
                          `${e.prefixCls}-item`,
                          {
                            [`${e.prefixCls}-item-active`]: s === e.activeIndex,
                          },
                        ]),
                      },
                      null,
                      10,
                      UU
                    )
                  )
                ),
                128
              )),
        ],
        16
      )
    )
  }
  var WU = Te(VU, [['render', HU]])
  const jU = ce({
      name: 'IconUp',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-up`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    GU = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    KU = Se('path', { d: 'M39.6 30.557 24.043 15 8.487 30.557' }, null, -1),
    qU = [KU]
  function XU(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        qU,
        14,
        GU
      )
    )
  }
  var w0 = Te(jU, [['render', XU]])
  const Y_ = Object.assign(w0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + w0.name, w0)
      },
    }),
    YU = ce({
      name: 'Arrow',
      components: { IconUp: Y_, IconDown: sc, IconLeft: ja, IconRight: No },
      props: {
        direction: { type: String, default: 'horizontal' },
        showArrow: { type: String, default: 'always' },
      },
      emits: ['previousClick', 'nextClick'],
      setup(e, { emit: t }) {
        const n = ye('carousel'),
          r = (a) => {
            t('previousClick', a)
          },
          i = (a) => {
            t('nextClick', a)
          },
          o = C(() => [
            `${n}-arrow`,
            { [`${n}-arrow-hover`]: e.showArrow === 'hover' },
          ])
        return { prefixCls: n, cls: o, onPreviousClick: r, onNextClick: i }
      },
    })
  function ZU(e, t, n, r, i, o) {
    const a = ge('IconLeft'),
      s = ge('IconUp'),
      l = ge('IconRight'),
      c = ge('IconDown')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          Se(
            'div',
            {
              class: H(
                `${e.prefixCls}-arrow-${
                  e.direction === 'vertical' ? 'top' : 'left'
                }`
              ),
              onClick:
                t[0] ||
                (t[0] = (...d) => e.onPreviousClick && e.onPreviousClick(...d)),
            },
            [
              e.direction === 'horizontal'
                ? (O(), Ee(a, { key: 0 }))
                : (O(), Ee(s, { key: 1 })),
            ],
            2
          ),
          Se(
            'div',
            {
              class: H(
                `${e.prefixCls}-arrow-${
                  e.direction === 'vertical' ? 'bottom' : 'right'
                }`
              ),
              onClick:
                t[1] || (t[1] = (...d) => e.onNextClick && e.onNextClick(...d)),
            },
            [
              e.direction === 'horizontal'
                ? (O(), Ee(l, { key: 0 }))
                : (O(), Ee(c, { key: 1 })),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var JU = Te(YU, [['render', ZU]])
  const yk = Symbol('ArcoCarousel'),
    Jd = (e) => {
      const t = {},
        n = J([]),
        r = () => {
          if (t.value) {
            const i = I4(t.value, e)
            ;(i.length !== n.value.length ||
              i.toString() !== n.value.toString()) &&
              (n.value = i)
          }
        }
      return Wt(() => r()), Zr(() => r()), { children: t, components: n }
    }
  var QU = Object.defineProperty,
    $x = Object.getOwnPropertySymbols,
    eH = Object.prototype.hasOwnProperty,
    tH = Object.prototype.propertyIsEnumerable,
    Ox = (e, t, n) =>
      t in e
        ? QU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    Lx = (e, t) => {
      for (var n in t || (t = {})) eH.call(t, n) && Ox(e, n, t[n])
      if ($x) for (var n of $x(t)) tH.call(t, n) && Ox(e, n, t[n])
      return e
    }
  const Ix = { interval: 3e3, hoverToPause: !0 }
  function x0(e, t) {
    const n = +e
    return typeof n == 'number' && !Number.isNaN(n) ? (n + t) % t : e
  }
  var M0 = ce({
    name: 'Carousel',
    props: {
      current: { type: Number },
      defaultCurrent: { type: Number, default: 1 },
      autoPlay: { type: [Boolean, Object], default: !1 },
      moveSpeed: { type: Number, default: 500 },
      animationName: { type: String, default: 'slide' },
      trigger: { type: String, default: 'click' },
      direction: { type: String, default: 'horizontal' },
      showArrow: { type: String, default: 'always' },
      arrowClass: { type: String, default: '' },
      indicatorType: { type: String, default: 'dot' },
      indicatorPosition: { type: String, default: 'bottom' },
      indicatorClass: { type: String, default: '' },
      transitionTimingFunction: {
        type: String,
        default: 'cubic-bezier(0.34, 0.69, 0.1, 1)',
      },
    },
    emits: { 'update:current': (e) => !0, change: (e, t, n) => !0 },
    setup(e, { emit: t, slots: n }) {
      const {
          current: r,
          animationName: i,
          moveSpeed: o,
          transitionTimingFunction: a,
        } = tt(e),
        s = ye('carousel'),
        l = J(!1),
        c = J(),
        d = J(),
        h = C(() =>
          Ht(e.autoPlay) ? Lx(Lx({}, Ix), e.autoPlay) : e.autoPlay ? Ix : {}
        )
      let p = 0,
        v = 0
      const { children: g, components: _ } = Jd('CarouselItem'),
        b = J(e.defaultCurrent - 1),
        y = C(() => {
          const I = _.value.length,
            B = it(r.value) ? x0(r.value - 1, I) : b.value,
            V = x0(B - 1, I),
            L = x0(B + 1, I)
          return { mergedIndex: B, mergedPrevIndex: V, mergedNextIndex: L }
        }),
        M = Je({
          items: _,
          slideTo: w,
          mergedIndexes: y,
          previousIndex: c,
          animationName: i,
          slideDirection: d,
          transitionTimingFunction: a,
          moveSpeed: o,
        })
      sn(yk, M)
      const x = () => {
        p && window.clearInterval(p)
      }
      pr(() => {
        var I
        const { interval: B } = h.value || {},
          { mergedNextIndex: V } = y.value,
          L = ((I = _.value) == null ? void 0 : I.length) > 1 && !l.value && !!B
        x(),
          L &&
            (p = window.setInterval(() => {
              w({ targetIndex: V })
            }, B))
      }),
        Pr(() => {
          x()
        })
      function w({ targetIndex: I, isNegative: B = !1, isManual: V = !1 }) {
        !v &&
          I !== y.value.mergedIndex &&
          ((c.value = b.value),
          (b.value = I),
          (d.value = B ? 'negative' : 'positive'),
          (v = window.setTimeout(() => {
            v = 0
          }, o.value)),
          t('update:current', b.value + 1),
          t('change', b.value + 1, c.value + 1, V))
      }
      const E = () =>
          w({
            targetIndex: y.value.mergedPrevIndex,
            isNegative: !0,
            isManual: !0,
          }),
        P = () => w({ targetIndex: y.value.mergedNextIndex, isManual: !0 }),
        A = (I) =>
          w({
            targetIndex: I,
            isNegative: I < y.value.mergedIndex,
            isManual: !0,
          }),
        F = C(() =>
          h.value.hoverToPause
            ? {
                onMouseenter: () => {
                  l.value = !0
                },
                onMouseleave: () => {
                  l.value = !1
                },
              }
            : {}
        ),
        T = C(() => e.indicatorType !== 'never' && _.value.length > 1),
        k = C(() => e.showArrow !== 'never' && _.value.length > 1),
        R = C(() => [s, `${s}-indicator-position-${e.indicatorPosition}`]),
        j = C(() => [
          `${s}-${e.animationName}`,
          `${s}-${e.direction}`,
          { [`${s}-negative`]: d.value === 'negative' },
        ]),
        N = C(() => [
          `${s}-indicator-wrapper`,
          `${s}-indicator-wrapper-${e.indicatorPosition}`,
        ])
      return () => {
        var I
        return (
          (g.value = (I = n.default) == null ? void 0 : I.call(n)),
          m('div', Fe({ class: R.value }, F.value), [
            m('div', { class: j.value }, [g.value]),
            T.value &&
              m('div', { class: N.value }, [
                m(
                  WU,
                  {
                    class: e.indicatorClass,
                    type: e.indicatorType,
                    count: _.value.length,
                    activeIndex: y.value.mergedIndex,
                    position: e.indicatorPosition,
                    trigger: e.trigger,
                    onSelect: A,
                  },
                  null
                ),
              ]),
            k.value &&
              m(
                JU,
                {
                  class: e.arrowClass,
                  direction: e.direction,
                  showArrow: e.showArrow,
                  onPreviousClick: E,
                  onNextClick: P,
                },
                null
              ),
          ])
        )
      }
    },
  })
  const nH = ce({
      name: 'CarouselItem',
      setup() {
        const e = ye('carousel-item'),
          t = Jr(),
          n = zt(yk, {}),
          r = C(() => {
            var s, l, c
            return (c =
              (l = n.items) == null
                ? void 0
                : l.indexOf(
                    (s = t == null ? void 0 : t.uid) != null ? s : -1
                  )) != null
              ? c
              : -1
          }),
          i = C(() => {
            var s
            return (
              ((s = n.mergedIndexes) == null ? void 0 : s.mergedIndex) ===
              r.value
            )
          }),
          o = C(() => {
            const {
              previousIndex: s,
              animationName: l,
              slideDirection: c,
              mergedIndexes: d,
            } = n
            return {
              [`${e}-prev`]:
                r.value === (d == null ? void 0 : d.mergedPrevIndex),
              [`${e}-next`]:
                r.value === (d == null ? void 0 : d.mergedNextIndex),
              [`${e}-current`]: i.value,
              [`${e}-slide-in`]: l === 'slide' && c && i.value,
              [`${e}-slide-out`]: l === 'slide' && c && r.value === s,
            }
          }),
          a = C(() => {
            const { transitionTimingFunction: s, moveSpeed: l } = n
            return {
              transitionTimingFunction: s,
              transitionDuration: `${l}ms`,
              animationTimingFunction: s,
              animationDuration: `${l}ms`,
            }
          })
        return { cls: o, animationStyle: a, isCurrent: i }
      },
    }),
    rH = ['aria-hidden']
  function iH(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        {
          'aria-hidden': !e.isCurrent,
          class: H(e.cls),
          style: at(e.animationStyle),
        },
        [ve(e.$slots, 'default')],
        14,
        rH
      )
    )
  }
  var dp = Te(nH, [['render', iH]])
  const oH = Object.assign(M0, {
      Item: dp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + M0.name, M0), e.component(n + dp.name, dp)
      },
    }),
    bk = (
      e,
      {
        optionMap: t,
        leafOptionMap: n,
        leafOptionSet: r,
        leafOptionValueMap: i,
        totalLevel: o,
        checkStrictly: a,
        enabledLazyLoad: s,
        lazyLoadOptions: l,
        valueKey: c,
        fieldNames: d,
      }
    ) => {
      let h = 0
      const p = (g, _, b) => {
          var y
          const M = (y = _ == null ? void 0 : _.path) != null ? y : []
          return (
            (h = Math.max(h, b ?? 1)),
            g.map((x, w) => {
              var E
              const P = x[d.value],
                A = {
                  raw: x,
                  value: P,
                  label: (E = x[d.label]) != null ? E : String(P),
                  disabled: !!x[d.disabled],
                  selectionDisabled: !1,
                  render: x[d.render],
                  tagProps: x[d.tagProps],
                  isLeaf: x[d.isLeaf],
                  level: M.length,
                  index: w,
                  key: '',
                  valueKey: String(Ht(P) ? P[c.value] : P),
                  parent: _,
                  path: [],
                  pathValue: [],
                },
                F = M.concat(A),
                T = [],
                k = F.map((R) => (T.push(R.value), R.valueKey)).join('-')
              return (
                (A.path = F),
                (A.pathValue = T),
                (A.key = k),
                x[d.children]
                  ? ((A.isLeaf = !1),
                    (A.children = p(x[d.children], A, (b ?? 1) + 1)))
                  : s && !A.isLeaf
                  ? ((A.isLeaf = !1),
                    l[k] && (A.children = p(l[k], A, (b ?? 1) + 1)))
                  : (A.isLeaf = !0),
                A.children &&
                  !A.disabled &&
                  ((A.totalLeafOptions = A.children.reduce(
                    (R, j) =>
                      it(j.totalLeafOptions)
                        ? R + j.totalLeafOptions
                        : j.disabled || j.selectionDisabled
                        ? R
                        : R + (j.isLeaf ? 1 : 0),
                    0
                  )),
                  A.totalLeafOptions === 0 &&
                    !a.value &&
                    (A.selectionDisabled = !0)),
                t.set(A.key, A),
                (A.isLeaf || a.value) &&
                  (r.add(A),
                  n.set(A.key, A),
                  i.has(A.valueKey) || i.set(A.valueKey, A.key)),
                A
              )
            })
          )
        },
        v = p(e)
      return (o.value = h), v
    },
    Z_ = (e, t) => {
      var n, r
      let i = !1,
        o = !1
      if (e.isLeaf) t != null && t.has(e.key) && (i = !0)
      else {
        const a = new RegExp(`^${e.key}(-|$)`),
          s = Array.from(
            (n = t == null ? void 0 : t.keys()) != null ? n : []
          ).reduce((l, c) => (a.test(c) ? l + 1 : l), 0)
        s > 0 && s >= ((r = e.totalLeafOptions) != null ? r : 1)
          ? (i = !0)
          : s > 0 && (o = !0)
      }
      return { checked: i, indeterminate: o }
    },
    J_ = (e) => {
      const t = []
      if (e.isLeaf) t.push(e.key)
      else if (e.children) for (const n of e.children) t.push(...J_(n))
      return t
    },
    Q_ = (e) => {
      const t = []
      if (e.disabled || e.selectionDisabled) return t
      if (e.isLeaf) t.push(e)
      else if (e.children) for (const n of e.children) t.push(...Q_(n))
      return t
    },
    _k = (e, { valueKey: t, leafOptionValueMap: n }) => {
      var r
      if (Ft(e)) return e.map((o) => (Ht(o) ? o[t] : o)).join('-')
      const i = Ht(e) ? e[t] : e
      return (r = n.get(String(i))) != null ? r : String(i)
    },
    Sk = (e, { multiple: t, pathMode: n }) =>
      Ft(e)
        ? n && !t && e.length > 0 && !Ft(e[0])
          ? [e]
          : e
        : Mt(e) || fi(e) || e === ''
        ? []
        : [e],
    Ck = (e) => e.path.map((t) => t.label).join(' / '),
    eS = Symbol('ArcoCascader')
  var wk = ce({
    name: 'CascaderOption',
    props: {
      option: { type: Object, required: !0 },
      active: Boolean,
      multiple: Boolean,
      checkStrictly: Boolean,
      searchOption: Boolean,
      pathLabel: Boolean,
    },
    setup(e) {
      const t = ye('cascader-option'),
        n = zt(eS, {}),
        r = J(!1),
        i = {},
        o = (d) => {
          var h
          if (xt(n.loadMore) && !e.option.isLeaf) {
            const { isLeaf: p, children: v, key: g } = e.option
            !p &&
              !v &&
              ((r.value = !0),
              new Promise((_) => {
                var b
                ;(b = n.loadMore) == null || b.call(n, e.option.raw, _)
              }).then((_) => {
                var b
                ;(r.value = !1),
                  _ && ((b = n.addLazyLoadOptions) == null || b.call(n, _, g))
              }))
          }
          ;(h = n.setSelectedPath) == null || h.call(n, e.option.key)
        }
      e.option.disabled ||
        ((i.onMouseenter = [
          () => {
            var d
            return (d = n.setActiveKey) == null
              ? void 0
              : d.call(n, e.option.key)
          },
        ]),
        (i.onMouseleave = () => {
          var d
          return (d = n.setActiveKey) == null ? void 0 : d.call(n)
        }),
        (i.onClick = []),
        n.expandTrigger === 'hover'
          ? i.onMouseenter.push((d) => o())
          : i.onClick.push((d) => o()),
        e.option.isLeaf &&
          !e.multiple &&
          i.onClick.push((d) => {
            var h
            o(), (h = n.onClickOption) == null || h.call(n, e.option)
          }))
      const a = C(() => [
          t,
          { [`${t}-active`]: e.active, [`${t}-disabled`]: e.option.disabled },
        ]),
        s = C(() => {
          var d
          return e.checkStrictly
            ? {
                checked:
                  (d = n.valueMap) == null ? void 0 : d.has(e.option.key),
                indeterminate: !1,
              }
            : Z_(e.option, n.valueMap)
        }),
        l = () => {
          var d, h, p
          return e.pathLabel
            ? (h =
                (d = n == null ? void 0 : n.formatLabel) == null
                  ? void 0
                  : d.call(
                      n,
                      e.option.path.map((v) => v.raw)
                    )) != null
              ? h
              : Ck(e.option)
            : (p = n.slots) != null && p.option
            ? n.slots.option({ data: e.option })
            : xt(e.option.render)
            ? e.option.render()
            : e.option.label
        },
        c = () =>
          r.value
            ? m(Xr, null, null)
            : !e.searchOption && !e.option.isLeaf
            ? m(No, null, null)
            : null
      return () => {
        var d
        return m(
          'li',
          Fe(
            {
              tabindex: '0',
              role: 'menuitem',
              'aria-disabled': e.option.disabled,
              'aria-haspopup': !e.option.isLeaf,
              'aria-expanded': !e.option.isLeaf && e.active,
              title: e.option.label,
              class: a.value,
            },
            i
          ),
          [
            e.multiple &&
              m(
                Lo,
                {
                  modelValue: s.value.checked,
                  indeterminate: s.value.indeterminate,
                  disabled: e.option.disabled || e.option.selectionDisabled,
                  uninjectGroupContext: !0,
                  onChange: (h, p) => {
                    var v
                    p.stopPropagation(),
                      o(),
                      (v = n.onClickOption) == null ||
                        v.call(n, e.option, !s.value.checked)
                  },
                  onClick: (h) => h.stopPropagation(),
                },
                null
              ),
            e.checkStrictly &&
              !e.multiple &&
              m(
                Ku,
                {
                  modelValue:
                    (d = n.valueMap) == null ? void 0 : d.has(e.option.key),
                  disabled: e.option.disabled,
                  uninjectGroupContext: !0,
                  onChange: (h, p) => {
                    var v
                    p.stopPropagation(),
                      o(),
                      (v = n.onClickOption) == null || v.call(n, e.option, !0)
                  },
                  onClick: (h) => h.stopPropagation(),
                },
                null
              ),
            m('div', { class: `${t}-label` }, [l(), c()]),
          ]
        )
      }
    },
  })
  function aH(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var xk = ce({
    name: 'BaseCascaderPanel',
    props: {
      displayColumns: { type: Array, required: !0 },
      selectedPath: { type: Array, required: !0 },
      activeKey: String,
      totalLevel: { type: Number, required: !0 },
      multiple: Boolean,
      checkStrictly: Boolean,
      loading: Boolean,
      dropdown: Boolean,
    },
    setup(e, { slots: t }) {
      const n = ye('cascader'),
        r = zt(di, void 0),
        i = () => {
          var s, l, c, d, h
          return (h =
            (d = (s = t.empty) == null ? void 0 : s.call(t)) != null
              ? d
              : (c = r == null ? void 0 : (l = r.slots).empty) == null
              ? void 0
              : c.call(l, { component: 'cascader' })) != null
            ? h
            : m(Ls, null, null)
        },
        o = (s, l = 0) =>
          m(
            'div',
            {
              class: `${n}-panel-column`,
              key: `column-${l}`,
              style: { zIndex: e.totalLevel - l },
            },
            [
              m(
                ia,
                { class: `${n}-column-content` },
                {
                  default: () => [
                    s.length === 0
                      ? m('div', { class: `${n}-list-empty` }, [i()])
                      : m(
                          'ul',
                          {
                            role: 'menu',
                            class: [
                              `${n}-list`,
                              {
                                [`${n}-list-multiple`]: !!(
                                  e != null && e.multiple
                                ),
                                [`${n}-list-strictly`]: !!(
                                  e != null && e.checkStrictly
                                ),
                              },
                            ],
                          },
                          [
                            s.map((c) =>
                              m(
                                wk,
                                {
                                  key: c.key,
                                  option: c,
                                  active:
                                    e.selectedPath.includes(c.key) ||
                                    c.key === e.activeKey,
                                  multiple: e.multiple,
                                  checkStrictly: e.checkStrictly,
                                },
                                null
                              )
                            ),
                          ]
                        ),
                  ],
                }
              ),
            ]
          ),
        a = () =>
          e.loading
            ? m(
                'div',
                {
                  key: 'panel-column-loading',
                  class: [`${n}-panel-column`, `${n}-panel-column-loading`],
                },
                [m(Do, null, null)]
              )
            : e.displayColumns.length === 0
            ? m(
                'div',
                { key: 'panel-column-empty', class: `${n}-panel-column` },
                [m('div', { class: `${n}-list-empty` }, [i()])]
              )
            : e.displayColumns.map((s, l) => o(s, l))
      return () => {
        let s
        return m(
          jd,
          {
            tag: 'div',
            name: 'cascader-slide',
            class: [`${n}-panel`, { [`${n}-dropdown-panel`]: e.dropdown }],
          },
          aH((s = a())) ? s : { default: () => [s] }
        )
      }
    },
  })
  function sH(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var lH = ce({
    name: 'CascaderSearchPanel',
    props: {
      options: { type: Array, required: !0 },
      loading: Boolean,
      activeKey: String,
      multiple: Boolean,
      checkStrictly: Boolean,
      pathLabel: Boolean,
    },
    setup(e, { slots: t }) {
      const n = ye('cascader'),
        r = zt(di, void 0),
        i = () => {
          var o, a, s, l, c
          return e.loading
            ? m(Do, null, null)
            : e.options.length === 0
            ? m('div', { class: `${n}-list-empty` }, [
                (c =
                  (l = (o = t.empty) == null ? void 0 : o.call(t)) != null
                    ? l
                    : (s = r == null ? void 0 : (a = r.slots).empty) == null
                    ? void 0
                    : s.call(a, { component: 'cascader' })) != null
                  ? c
                  : m(Ls, null, null),
              ])
            : m(
                'ul',
                {
                  role: 'menu',
                  class: [
                    `${n}-list`,
                    `${n}-search-list`,
                    { [`${n}-list-multiple`]: e.multiple },
                  ],
                },
                [
                  e.options.map((d) =>
                    m(
                      wk,
                      {
                        key: d.key,
                        class: `${n}-search-option`,
                        option: d,
                        active: d.key === e.activeKey,
                        multiple: e.multiple,
                        checkStrictly: e.checkStrictly,
                        pathLabel: e.pathLabel,
                        searchOption: !0,
                      },
                      null
                    )
                  ),
                ]
              )
        }
      return () => {
        let o
        return m(
          ia,
          { class: [`${n}-panel`, `${n}-search-panel`] },
          sH((o = i())) ? o : { default: () => [o] }
        )
      }
    },
  })
  const Mk = (
    e,
    { optionMap: t, filteredLeafOptions: n, showSearchPanel: r, expandChild: i }
  ) => {
    const o = J(),
      a = C(() => {
        if (o.value) return t.get(o.value)
      }),
      s = J([]),
      l = C(() => {
        const g = [e.value]
        for (const _ of s.value) {
          const b = t.get(_)
          b != null && b.children && g.push(b.children)
        }
        return g
      }),
      c = (g) => {
        var _
        const b = p(g)
        s.value =
          (_ = b == null ? void 0 : b.path.map((y) => y.key)) != null ? _ : []
      },
      d = (g) => {
        o.value = g
      },
      h = C(() => {
        var g
        return r != null && r.value
          ? n.value.filter((_) => !_.disabled)
          : a.value && a.value.parent
          ? (g = a.value.parent.children) == null
            ? void 0
            : g.filter((_) => !_.disabled)
          : e.value.filter((_) => !_.disabled)
      }),
      p = (g) => {
        let _ = g ? t.get(g) : void 0
        if (i.value)
          for (; _ && _.children && _.children.length > 0; ) _ = _.children[0]
        return _
      }
    return {
      activeKey: o,
      activeOption: a,
      selectedPath: s,
      displayColumns: l,
      setActiveKey: d,
      setSelectedPath: c,
      getNextActiveNode: (g) => {
        var _, b, y, M, x, w, E
        const P =
          (b = (_ = h.value) == null ? void 0 : _.length) != null ? b : 0
        if (o.value) {
          const A =
            (M =
              (y = h.value) == null
                ? void 0
                : y.findIndex((F) => F.key === o.value)) != null
              ? M
              : 0
          return g === 'next'
            ? (x = h.value) == null
              ? void 0
              : x[(P + A + 1) % P]
            : (w = h.value) == null
            ? void 0
            : w[(P + A - 1) % P]
        }
        return (E = h.value) == null ? void 0 : E[0]
      },
    }
  }
  var uH = Object.defineProperty,
    Rx = Object.getOwnPropertySymbols,
    cH = Object.prototype.hasOwnProperty,
    dH = Object.prototype.propertyIsEnumerable,
    Dx = (e, t, n) =>
      t in e
        ? uH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    Nx = (e, t) => {
      for (var n in t || (t = {})) cH.call(t, n) && Dx(e, n, t[n])
      if (Rx) for (var n of Rx(t)) dH.call(t, n) && Dx(e, n, t[n])
      return e
    }
  const fH = ce({
    name: 'Cascader',
    components: {
      Trigger: Mr,
      SelectView: sv,
      BaseCascaderPanel: xk,
      CascaderSearchPanel: lH,
    },
    inheritAttrs: !1,
    props: {
      pathMode: { type: Boolean, default: !1 },
      multiple: { type: Boolean, default: !1 },
      modelValue: { type: [String, Number, Object, Array] },
      defaultValue: {
        type: [String, Number, Object, Array],
        default: (e) => (e.multiple ? [] : e.pathMode ? void 0 : ''),
      },
      options: { type: Array, default: () => [] },
      disabled: { type: Boolean, default: !1 },
      error: { type: Boolean, default: !1 },
      size: { type: String },
      allowSearch: { type: Boolean, default: (e) => !!e.multiple },
      allowClear: { type: Boolean, default: !1 },
      inputValue: { type: String, default: void 0 },
      defaultInputValue: { type: String, default: '' },
      popupVisible: { type: Boolean, default: void 0 },
      expandTrigger: { type: String, default: 'click' },
      defaultPopupVisible: { type: Boolean, default: !1 },
      placeholder: String,
      filterOption: { type: Function },
      popupContainer: { type: [String, Object] },
      maxTagCount: { type: Number, default: 0 },
      formatLabel: { type: Function },
      triggerProps: { type: Object },
      checkStrictly: { type: Boolean, default: !1 },
      loadMore: { type: Function },
      loading: { type: Boolean, default: !1 },
      searchOptionOnlyLabel: { type: Boolean, default: !1 },
      searchDelay: { type: Number, default: 500 },
      fieldNames: { type: Object },
      valueKey: { type: String, default: 'value' },
      fallback: { type: [Boolean, Function], default: !0 },
      expandChild: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      'update:popupVisible': (e) => !0,
      change: (e) => !0,
      inputValueChange: (e) => !0,
      clear: () => !0,
      search: (e) => !0,
      popupVisibleChange: (e) => !0,
      focus: (e) => !0,
      blur: (e) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const {
          options: r,
          checkStrictly: i,
          loadMore: o,
          formatLabel: a,
          modelValue: s,
          disabled: l,
          valueKey: c,
          expandTrigger: d,
          expandChild: h,
        } = tt(e),
        p = J(e.defaultValue),
        v = J(e.defaultInputValue),
        g = J(e.defaultPopupVisible),
        { mergedDisabled: _, eventHandlers: b } = Rn({ disabled: l })
      pt(s, (re) => {
        ;(Mt(re) || fi(re)) && (p.value = e.multiple ? [] : void 0)
      })
      const y = J([]),
        M = J(1),
        x = Je(new Map()),
        w = Je(new Map()),
        E = Je(new Map()),
        P = Je(new Set()),
        A = Je({}),
        F = (re, pe) => {
          A[pe] = re
        },
        T = {
          value: 'value',
          label: 'label',
          disabled: 'disabled',
          children: 'children',
          tagProps: 'tagProps',
          render: 'render',
          isLeaf: 'isLeaf',
        },
        k = C(() => Nx(Nx({}, T), e.fieldNames))
      pt(
        [r, A, k],
        ([re, pe, we]) => {
          x.clear(),
            w.clear(),
            E.clear(),
            P.clear(),
            (y.value = bk(re ?? [], {
              enabledLazyLoad: !!e.loadMore,
              lazyLoadOptions: A,
              optionMap: x,
              leafOptionSet: P,
              leafOptionMap: w,
              leafOptionValueMap: E,
              totalLevel: M,
              checkStrictly: i,
              valueKey: c,
              fieldNames: we,
            }))
        },
        { immediate: !0, deep: !0 }
      )
      const R = C(() => {
          var re
          const pe = Sk((re = e.modelValue) != null ? re : p.value, {
            multiple: e.multiple,
            pathMode: e.pathMode,
          })
          return new Map(
            pe.map((we) => [
              _k(we, { valueKey: e.valueKey, leafOptionValueMap: E }),
              we,
            ])
          )
        }),
        j = C(() => {
          var re
          return (re = e.inputValue) != null ? re : v.value
        }),
        N = C(() => {
          var re
          return (re = e.popupVisible) != null ? re : g.value
        }),
        I = (re) => {
          var pe
          return re == null
            ? void 0
            : re
                .toLocaleLowerCase()
                .includes(
                  (pe = j.value) == null ? void 0 : pe.toLocaleLowerCase()
                )
        },
        B = C(() =>
          (e.checkStrictly ? Array.from(x.values()) : Array.from(P)).filter(
            (pe) => {
              var we
              return xt(e.filterOption)
                ? e.filterOption(j.value, pe.raw)
                : e.checkStrictly
                ? I(pe.label)
                : (we = pe.path) == null
                ? void 0
                : we.find(($e) => I($e.label))
            }
          )
        ),
        V = (re) => {
          var pe, we, $e
          const Ae = e.multiple ? re : (pe = re[0]) != null ? pe : ''
          re.length === 0 && (G(), D()),
            (p.value = Ae),
            t('update:modelValue', Ae),
            t('change', Ae),
            ($e = (we = b.value) == null ? void 0 : we.onChange) == null ||
              $e.call(we)
        },
        L = (re) => {
          N.value !== re && ((g.value = re), t('popupVisibleChange', re))
        },
        W = (re) => {
          if (e.multiple) {
            const pe = w.get(re)
            if (pe) U(pe, !1)
            else {
              const we = []
              R.value.forEach(($e, Ae) => {
                Ae !== re && we.push($e)
              }),
                V(we)
            }
          }
        },
        Y = (re) => {
          V([e.pathMode ? re.pathValue : re.value]), L(!1)
        },
        U = (re, pe) => {
          if (pe) {
            const we = e.checkStrictly ? [re] : Q_(re)
            V([
              ...R.value.values(),
              ...we
                .filter(($e) => !R.value.has($e.key))
                .map(($e) => (e.pathMode ? $e.pathValue : $e.value)),
            ])
          } else {
            const we = e.checkStrictly ? [re.key] : J_(re),
              $e = []
            R.value.forEach((Ae, ft) => {
              we.includes(ft) || $e.push(Ae)
            }),
              V($e)
          }
          oe('', 'optionChecked')
        },
        le = (re, pe) => {
          e.multiple ? U(re, pe ?? !0) : Y(re)
        },
        q = q_((re) => {
          t('search', re)
        }, e.searchDelay),
        oe = (re, pe) => {
          re !== j.value &&
            (pe === 'manual' &&
              !N.value &&
              ((g.value = !0), t('popupVisibleChange', !0)),
            (v.value = re),
            t('inputValueChange', re),
            e.allowSearch && q(re))
        }
      pt(N, (re) => {
        if (re) {
          if (R.value.size > 0) {
            const pe = Array.from(R.value.keys()),
              we = pe[pe.length - 1],
              $e = w.get(we)
            $e && $e.key !== qe.value && (G($e.key), D($e.key))
          }
        } else R.value.size === 0 && (G(), D()), oe('', 'optionListHide')
      })
      const te = (re) => {
          if ((re.stopPropagation(), e.multiple)) {
            const pe = []
            R.value.forEach((we, $e) => {
              const Ae = w.get($e)
              Ae != null &&
                Ae.disabled &&
                pe.push(e.pathMode ? Ae.pathValue : Ae.value)
            }),
              V(pe)
          } else V([])
          oe('', 'manual'), t('clear')
        },
        ue = C(() => e.allowSearch && j.value.length > 0),
        me = (re) => {
          t('focus', re)
        },
        Re = (re) => {
          t('blur', re)
        },
        {
          activeKey: qe,
          activeOption: Ve,
          selectedPath: nt,
          displayColumns: We,
          setActiveKey: D,
          setSelectedPath: G,
          getNextActiveNode: z,
        } = Mk(y, {
          optionMap: x,
          filteredLeafOptions: B,
          showSearchPanel: ue,
          expandChild: h,
        })
      sn(
        eS,
        Je({
          onClickOption: le,
          setActiveKey: D,
          setSelectedPath: G,
          loadMore: o,
          expandTrigger: d,
          addLazyLoadOptions: F,
          formatLabel: a,
          slots: n,
          valueMap: R,
        })
      )
      const ie = Yv(
          new Map([
            [
              fr.ENTER,
              (re) => {
                if (N.value) {
                  if (Ve.value) {
                    let pe
                    e.checkStrictly || Ve.value.isLeaf
                      ? (pe = !R.value.has(Ve.value.key))
                      : (pe = !Z_(Ve.value, R.value).checked),
                      G(Ve.value.key),
                      le(Ve.value, pe)
                  }
                } else L(!0)
              },
            ],
            [
              fr.ESC,
              (re) => {
                L(!1)
              },
            ],
            [
              fr.ARROW_DOWN,
              (re) => {
                re.preventDefault()
                const pe = z('next')
                D(pe == null ? void 0 : pe.key)
              },
            ],
            [
              fr.ARROW_UP,
              (re) => {
                re.preventDefault()
                const pe = z('preview')
                D(pe == null ? void 0 : pe.key)
              },
            ],
            [
              fr.ARROW_RIGHT,
              (re) => {
                var pe, we
                ue.value ||
                  (re.preventDefault(),
                  (pe = Ve.value) != null &&
                    pe.children &&
                    (G(Ve.value.key),
                    D((we = Ve.value.children[0]) == null ? void 0 : we.key)))
              },
            ],
            [
              fr.ARROW_LEFT,
              (re) => {
                var pe
                ue.value ||
                  (re.preventDefault(),
                  (pe = Ve.value) != null &&
                    pe.parent &&
                    (G(Ve.value.parent.key), D(Ve.value.parent.key)))
              },
            ],
          ])
        ),
        ae = C(() => {
          const re = []
          return (
            R.value.forEach((pe, we) => {
              var $e, Ae
              const ft = w.get(we)
              if (ft)
                re.push({
                  value: we,
                  label:
                    (Ae =
                      ($e = e.formatLabel) == null
                        ? void 0
                        : $e.call(
                            e,
                            ft.path.map((Q) => Q.raw)
                          )) != null
                      ? Ae
                      : Ck(ft),
                  closable: !ft.disabled,
                  tagProps: ft.tagProps,
                })
              else if (e.fallback) {
                const Q = xt(e.fallback)
                  ? e.fallback(pe)
                  : Ft(pe)
                  ? pe.join(' / ')
                  : String(pe)
                re.push({ value: we, label: Q, closable: !0 })
              }
            }),
            re
          )
        })
      return {
        optionInfos: y,
        filteredLeafOptions: B,
        selectedPath: nt,
        activeKey: qe,
        displayColumns: We,
        computedInputValue: j,
        computedPopupVisible: N,
        handleClear: te,
        selectViewValue: ae,
        handleInputValueChange: oe,
        showSearchPanel: ue,
        handlePopupVisibleChange: L,
        handleFocus: me,
        handleBlur: Re,
        handleRemove: W,
        mergedDisabled: _,
        handleKeyDown: ie,
        totalLevel: M,
      }
    },
  })
  function hH(e, t, n, r, i, o) {
    const a = ge('select-view'),
      s = ge('cascader-search-panel'),
      l = ge('base-cascader-panel'),
      c = ge('trigger')
    return (
      O(),
      Ee(
        c,
        Fe(e.triggerProps, {
          trigger: 'click',
          'animation-name': 'slide-dynamic-origin',
          'auto-fit-transform-origin': '',
          'popup-visible': e.computedPopupVisible,
          position: 'bl',
          disabled: e.mergedDisabled,
          'popup-offset': 4,
          'auto-fit-popup-width': e.showSearchPanel,
          'popup-container': e.popupContainer,
          'prevent-focus': !0,
          'click-to-close': !e.allowSearch,
          onPopupVisibleChange: e.handlePopupVisibleChange,
        }),
        {
          content: ze(() => [
            e.showSearchPanel
              ? (O(),
                Ee(
                  s,
                  {
                    key: 0,
                    options: e.filteredLeafOptions,
                    'active-key': e.activeKey,
                    multiple: e.multiple,
                    'check-strictly': e.checkStrictly,
                    loading: e.loading,
                    'path-label': !e.searchOptionOnlyLabel,
                  },
                  Nn({ _: 2 }, [
                    e.$slots.empty
                      ? { name: 'empty', fn: ze(() => [ve(e.$slots, 'empty')]) }
                      : void 0,
                  ]),
                  1032,
                  [
                    'options',
                    'active-key',
                    'multiple',
                    'check-strictly',
                    'loading',
                    'path-label',
                  ]
                ))
              : (O(),
                Ee(
                  l,
                  {
                    key: 1,
                    'display-columns': e.displayColumns,
                    'selected-path': e.selectedPath,
                    'active-key': e.activeKey,
                    multiple: e.multiple,
                    'total-level': e.totalLevel,
                    'check-strictly': e.checkStrictly,
                    loading: e.loading,
                    dropdown: '',
                  },
                  Nn({ _: 2 }, [
                    e.$slots.empty
                      ? { name: 'empty', fn: ze(() => [ve(e.$slots, 'empty')]) }
                      : void 0,
                  ]),
                  1032,
                  [
                    'display-columns',
                    'selected-path',
                    'active-key',
                    'multiple',
                    'total-level',
                    'check-strictly',
                    'loading',
                  ]
                )),
          ]),
          default: ze(() => [
            m(
              a,
              Fe(
                {
                  'model-value': e.selectViewValue,
                  'input-value': e.computedInputValue,
                  disabled: e.mergedDisabled,
                  error: e.error,
                  multiple: e.multiple,
                  'allow-clear': e.allowClear,
                  'allow-search': e.allowSearch,
                  size: e.size,
                  opened: e.computedPopupVisible,
                  placeholder: e.placeholder,
                  loading: e.loading,
                  'max-tag-count': e.maxTagCount,
                },
                e.$attrs,
                {
                  onInputValueChange: e.handleInputValueChange,
                  onClear: e.handleClear,
                  onFocus: e.handleFocus,
                  onBlur: e.handleBlur,
                  onRemove: e.handleRemove,
                  onKeydown: e.handleKeyDown,
                }
              ),
              Nn({ _: 2 }, [
                e.$slots.label
                  ? {
                      name: 'label',
                      fn: ze((d) => [ve(e.$slots, 'label', En(Rr(d)))]),
                    }
                  : void 0,
                e.$slots.prefix
                  ? { name: 'prefix', fn: ze(() => [ve(e.$slots, 'prefix')]) }
                  : void 0,
                e.$slots['arrow-icon']
                  ? {
                      name: 'arrow-icon',
                      fn: ze(() => [ve(e.$slots, 'arrow-icon')]),
                    }
                  : void 0,
                e.$slots['loading-icon']
                  ? {
                      name: 'loading-icon',
                      fn: ze(() => [ve(e.$slots, 'loading-icon')]),
                    }
                  : void 0,
                e.$slots['search-icon']
                  ? {
                      name: 'search-icon',
                      fn: ze(() => [ve(e.$slots, 'search-icon')]),
                    }
                  : void 0,
              ]),
              1040,
              [
                'model-value',
                'input-value',
                'disabled',
                'error',
                'multiple',
                'allow-clear',
                'allow-search',
                'size',
                'opened',
                'placeholder',
                'loading',
                'max-tag-count',
                'onInputValueChange',
                'onClear',
                'onFocus',
                'onBlur',
                'onRemove',
                'onKeydown',
              ]
            ),
          ]),
          _: 3,
        },
        16,
        [
          'popup-visible',
          'disabled',
          'auto-fit-popup-width',
          'popup-container',
          'click-to-close',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var E0 = Te(fH, [['render', hH]]),
    pH = Object.defineProperty,
    Bx = Object.getOwnPropertySymbols,
    vH = Object.prototype.hasOwnProperty,
    mH = Object.prototype.propertyIsEnumerable,
    Fx = (e, t, n) =>
      t in e
        ? pH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    zx = (e, t) => {
      for (var n in t || (t = {})) vH.call(t, n) && Fx(e, n, t[n])
      if (Bx) for (var n of Bx(t)) mH.call(t, n) && Fx(e, n, t[n])
      return e
    }
  const gH = ce({
    name: 'CascaderPanel',
    components: { BaseCascaderPanel: xk },
    props: {
      pathMode: { type: Boolean, default: !1 },
      multiple: { type: Boolean, default: !1 },
      modelValue: { type: [String, Number, Array] },
      defaultValue: {
        type: [String, Number, Array],
        default: (e) => (e.multiple ? [] : e.pathMode ? void 0 : ''),
      },
      options: { type: Array, default: () => [] },
      expandTrigger: { type: String, default: 'click' },
      checkStrictly: { type: Boolean, default: !1 },
      loadMore: { type: Function },
      fieldNames: { type: Object },
      valueKey: { type: String, default: 'value' },
      expandChild: { type: Boolean, default: !1 },
    },
    emits: { 'update:modelValue': (e) => !0, change: (e) => !0 },
    setup(e, { emit: t, slots: n }) {
      const {
          options: r,
          checkStrictly: i,
          loadMore: o,
          modelValue: a,
          valueKey: s,
          expandChild: l,
          expandTrigger: c,
        } = tt(e),
        d = J(e.defaultValue)
      pt(a, (Y) => {
        ;(Mt(Y) || fi(Y)) && (d.value = e.multiple ? [] : void 0)
      })
      const h = J([]),
        p = J(1),
        v = Je(new Map()),
        g = Je(new Map()),
        _ = Je(new Map()),
        b = Je(new Set()),
        y = Je({}),
        M = (Y, U) => {
          y[U] = Y
        },
        x = {
          value: 'value',
          label: 'label',
          disabled: 'disabled',
          children: 'children',
          tagProps: 'tagProps',
          render: 'render',
          isLeaf: 'isLeaf',
        },
        w = C(() => zx(zx({}, x), e.fieldNames))
      pt(
        [r, y, w],
        ([Y, U, le]) => {
          v.clear(),
            g.clear(),
            _.clear(),
            b.clear(),
            (h.value = bk(Y ?? [], {
              enabledLazyLoad: !!e.loadMore,
              lazyLoadOptions: U,
              optionMap: v,
              leafOptionSet: b,
              leafOptionMap: g,
              leafOptionValueMap: _,
              totalLevel: p,
              checkStrictly: i,
              fieldNames: le,
              valueKey: s,
            }))
        },
        { immediate: !0 }
      )
      const E = C(() => {
          var Y
          const U = Sk((Y = e.modelValue) != null ? Y : d.value, {
            multiple: e.multiple,
            pathMode: e.pathMode,
          })
          return new Map(
            U.map((le) => [
              _k(le, { valueKey: e.valueKey, leafOptionValueMap: _ }),
              le,
            ])
          )
        }),
        P = C(() => (e.checkStrictly ? Array.from(v.values()) : Array.from(b))),
        A = (Y) => {
          var U
          const le = e.multiple ? Y : (U = Y[0]) != null ? U : ''
          Y.length === 0 && (V(), B()),
            (d.value = le),
            t('update:modelValue', le),
            t('change', le)
        },
        F = (Y) => {
          A([e.pathMode ? Y.pathValue : Y.value])
        },
        T = (Y, U) => {
          if (U) {
            const le = e.checkStrictly ? [Y] : Q_(Y)
            A([
              ...E.value.values(),
              ...le
                .filter((q) => !E.value.has(q.key))
                .map((q) => (e.pathMode ? q.pathValue : q.value)),
            ])
          } else {
            const le = e.checkStrictly ? [Y.key] : J_(Y),
              q = []
            E.value.forEach((oe, te) => {
              le.includes(te) || q.push(oe)
            }),
              A(q)
          }
        },
        k = (Y, U) => {
          e.multiple ? T(Y, U ?? !0) : F(Y)
        },
        {
          activeKey: R,
          activeOption: j,
          selectedPath: N,
          displayColumns: I,
          setActiveKey: B,
          setSelectedPath: V,
          getNextActiveNode: L,
        } = Mk(h, { optionMap: v, filteredLeafOptions: P, expandChild: l })
      sn(
        eS,
        Je({
          onClickOption: k,
          setActiveKey: B,
          setSelectedPath: V,
          loadMore: o,
          addLazyLoadOptions: M,
          slots: n,
          valueMap: E,
          expandTrigger: c,
        })
      )
      const W = Yv(
        new Map([
          [
            fr.ENTER,
            (Y) => {
              if (j.value) {
                let U
                e.checkStrictly || j.value.isLeaf
                  ? (U = !E.value.has(j.value.key))
                  : (U = !Z_(j.value, E.value).checked),
                  V(j.value.key),
                  k(j.value, U)
              }
            },
          ],
          [
            fr.ARROW_DOWN,
            (Y) => {
              Y.preventDefault()
              const U = L('next')
              B(U == null ? void 0 : U.key)
            },
          ],
          [
            fr.ARROW_UP,
            (Y) => {
              Y.preventDefault()
              const U = L('preview')
              B(U == null ? void 0 : U.key)
            },
          ],
          [
            fr.ARROW_RIGHT,
            (Y) => {
              var U, le
              Y.preventDefault(),
                (U = j.value) != null &&
                  U.children &&
                  (V(j.value.key),
                  B((le = j.value.children[0]) == null ? void 0 : le.key))
            },
          ],
          [
            fr.ARROW_LEFT,
            (Y) => {
              var U
              Y.preventDefault(),
                (U = j.value) != null &&
                  U.parent &&
                  (V(j.value.parent.key), B(j.value.parent.key))
            },
          ],
        ])
      )
      return {
        optionInfos: h,
        filteredLeafOptions: P,
        selectedPath: N,
        activeKey: R,
        displayColumns: I,
        handleKeyDown: W,
        totalLevel: p,
      }
    },
  })
  function yH(e, t, n, r, i, o) {
    const a = ge('base-cascader-panel')
    return (
      O(),
      Ee(
        a,
        {
          'display-columns': e.displayColumns,
          'selected-path': e.selectedPath,
          'active-key': e.activeKey,
          multiple: e.multiple,
          'total-level': e.totalLevel,
          'check-strictly': e.checkStrictly,
          onKeydown: e.handleKeyDown,
        },
        Nn({ _: 2 }, [
          e.$slots.empty
            ? { name: 'empty', fn: ze(() => [ve(e.$slots, 'empty')]) }
            : void 0,
        ]),
        1032,
        [
          'display-columns',
          'selected-path',
          'active-key',
          'multiple',
          'total-level',
          'check-strictly',
          'onKeydown',
        ]
      )
    )
  }
  var fp = Te(gH, [['render', yH]])
  const bH = Object.assign(E0, {
      CascaderPanel: fp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + E0.name, E0), e.component(n + fp.name, fp)
      },
    }),
    Ek = Symbol('collapseCtx'),
    _H = ce({
      name: 'Collapse',
      props: {
        activeKey: { type: Array, default: void 0 },
        defaultActiveKey: { type: Array, default: () => [] },
        accordion: { type: Boolean, default: !1 },
        showExpandIcon: { type: Boolean, default: void 0 },
        expandIconPosition: { type: String, default: 'left' },
        bordered: { type: Boolean, default: !0 },
        destroyOnHide: { type: Boolean, default: !1 },
      },
      emits: { 'update:activeKey': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const {
            expandIconPosition: r,
            destroyOnHide: i,
            showExpandIcon: o,
          } = tt(e),
          a = ye('collapse'),
          s = J(e.defaultActiveKey),
          l = C(() => {
            var h
            const p = (h = e.activeKey) != null ? h : s.value
            return Ft(p) ? p : [p]
          })
        sn(
          Ek,
          Je({
            activeKeys: l,
            slots: n,
            showExpandIcon: o,
            expandIconPosition: r,
            destroyOnHide: i,
            handleClick: (h, p) => {
              let v = []
              if (e.accordion) l.value.includes(h) || (v = [h]), (s.value = v)
              else {
                v = [...l.value]
                const g = v.indexOf(h)
                g > -1 ? v.splice(g, 1) : e.accordion ? (v = [h]) : v.push(h),
                  (s.value = v)
              }
              t('update:activeKey', v), t('change', v, p)
            },
          })
        )
        const d = C(() => [a, { [`${a}-borderless`]: !e.bordered }])
        return { prefixCls: a, cls: d }
      },
    })
  function SH(e, t, n, r, i, o) {
    return O(), Z('div', { class: H(e.cls) }, [ve(e.$slots, 'default')], 2)
  }
  var P0 = Te(_H, [['render', SH]])
  const CH = ce({
      name: 'IconCaretRight',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-caret-right`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    wH = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    xH = Se(
      'path',
      {
        d: 'M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    MH = [xH]
  function EH(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        MH,
        14,
        wH
      )
    )
  }
  var T0 = Te(CH, [['render', EH]])
  const PH = Object.assign(T0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + T0.name, T0)
      },
    }),
    TH = ce({
      name: 'IconCaretLeft',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-caret-left`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    kH = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    AH = Se(
      'path',
      {
        d: 'M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    $H = [AH]
  function OH(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        $H,
        14,
        kH
      )
    )
  }
  var k0 = Te(TH, [['render', OH]])
  const LH = Object.assign(k0, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + k0.name, k0)
    },
  })
  var hp = ce({
    name: 'CollapseItem',
    components: { IconHover: In, IconCaretRight: PH, IconCaretLeft: LH },
    props: {
      key: [String, Number],
      header: String,
      disabled: { type: Boolean, default: !1 },
      showExpandIcon: { type: Boolean, default: !0 },
      destroyOnHide: { type: Boolean, default: !1 },
    },
    setup(e, { slots: t }) {
      var n
      const r = Jr(),
        i = ye('collapse-item'),
        o = zt(Ek, {}),
        a =
          r && it(r == null ? void 0 : r.vnode.key)
            ? r.vnode.key
            : String((n = r == null ? void 0 : r.vnode.key) != null ? n : ''),
        s = C(() => {
          var w
          return (w = o.activeKeys) == null ? void 0 : w.includes(a)
        }),
        l = C(() => o.destroyOnHide || e.destroyOnHide),
        c = C(() => {
          var w
          return (w = o == null ? void 0 : o.showExpandIcon) != null
            ? w
            : e.showExpandIcon
        }),
        d = J(l.value ? s.value : !0),
        h = C(() => {
          var w
          return (w = o == null ? void 0 : o.expandIconPosition) != null
            ? w
            : 'left'
        }),
        p = (w) => {
          var E
          e.disabled || (E = o.handleClick) == null || E.call(o, a, w)
        }
      pt(s, (w) => {
        w && !d.value && (d.value = !0)
      })
      const v = {
          onEnter: (w) => {
            w.style.height = `${w.scrollHeight}px`
          },
          onAfterEnter: (w) => {
            w.style.height = 'auto'
          },
          onBeforeLeave: (w) => {
            w.style.height = `${w.scrollHeight}px`
          },
          onLeave: (w) => {
            w.style.height = '0'
          },
          onAfterLeave: () => {
            l.value && (d.value = !1)
          },
        },
        g = C(() => [i, { [`${i}-active`]: s.value }]),
        _ = C(() => [
          `${i}-header`,
          `${i}-header-${o == null ? void 0 : o.expandIconPosition}`,
          { [`${i}-header-disabled`]: e.disabled },
        ]),
        b = C(() => [
          {
            [`${i}-icon-right`]:
              (o == null ? void 0 : o.expandIconPosition) === 'right',
          },
        ]),
        y = C(() => [`${i}-content`, { [`${i}-content-expend`]: s.value }]),
        M = () =>
          h.value === 'right'
            ? m(ge('icon-caret-left'), { class: `${i}-expand-icon` }, null)
            : m(ge('icon-caret-right'), { class: `${i}-expand-icon` }, null),
        x = () =>
          c.value &&
          m(
            ge('icon-hover'),
            { prefix: i, class: b.value, disabled: e.disabled },
            {
              default: () => {
                var w, E, P, A
                return [
                  (A =
                    (P =
                      (E = t['expand-icon']) != null
                        ? E
                        : (w = o == null ? void 0 : o.slots) == null
                        ? void 0
                        : w['expand-icon']) == null
                      ? void 0
                      : P({
                          active: s.value,
                          disabled: e.disabled,
                          position: h.value,
                        })) != null
                    ? A
                    : M(),
                ]
              },
            }
          )
      return () => {
        var w, E, P
        return m('div', { class: g.value }, [
          m(
            'div',
            {
              role: 'button',
              'aria-disabled': e.disabled,
              'aria-expanded': s.value,
              tabindex: '0',
              class: _.value,
              onClick: p,
            },
            [
              x(),
              m('div', { class: `${i}-header-title` }, [
                (E = (w = t.header) == null ? void 0 : w.call(t)) != null
                  ? E
                  : e.header,
              ]),
              t.extra &&
                m('div', { class: `${i}-header-extra` }, [
                  (P = t.extra) == null ? void 0 : P.call(t),
                ]),
            ]
          ),
          m(Fr, Fe({ name: 'collapse-slider' }, v), {
            default: () => {
              var A
              return [
                ro(
                  m('div', { role: 'region', class: y.value }, [
                    d.value &&
                      m(
                        'div',
                        { ref: 'contentBoxRef', class: `${i}-content-box` },
                        [(A = t.default) == null ? void 0 : A.call(t)]
                      ),
                  ]),
                  [[oo, s.value]]
                ),
              ]
            },
          }),
        ])
      }
    },
  })
  const IH = Object.assign(P0, {
    Item: hp,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + P0.name, P0), e.component(n + hp.name, hp)
    },
  })
  function Pk(e, t, n) {
    return C(() => !!(e[n] || t[n]))
  }
  var RH = Object.defineProperty,
    Vx = Object.getOwnPropertySymbols,
    DH = Object.prototype.hasOwnProperty,
    NH = Object.prototype.propertyIsEnumerable,
    Ux = (e, t, n) =>
      t in e
        ? RH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    BH = (e, t) => {
      for (var n in t || (t = {})) DH.call(t, n) && Ux(e, n, t[n])
      if (Vx) for (var n of Vx(t)) NH.call(t, n) && Ux(e, n, t[n])
      return e
    }
  const FH = ce({
      name: 'Comment',
      props: {
        author: { type: String },
        avatar: { type: String },
        content: { type: String },
        datetime: { type: String },
        align: { type: [String, Object], default: 'left' },
      },
      setup(e, { slots: t }) {
        const n = ye('comment'),
          [r, i, o, a] = ['author', 'avatar', 'content', 'datetime'].map((l) =>
            Pk(e, t, l)
          ),
          s = C(() => {
            const { align: l } = e
            return BH({}, ir(l) ? { datetime: l, actions: l } : l)
          })
        return {
          prefixCls: n,
          hasAuthor: r,
          hasAvatar: i,
          hasContent: o,
          hasDatetime: a,
          computedAlign: s,
        }
      },
    }),
    zH = ['src'],
    VH = { key: 0 },
    UH = { key: 0 },
    HH = { key: 0 }
  function WH(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          e.hasAvatar
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-avatar`) },
                [
                  e.avatar
                    ? (O(),
                      Z(
                        'img',
                        { key: 0, src: e.avatar, alt: 'comment-avatar' },
                        null,
                        8,
                        zH
                      ))
                    : ve(e.$slots, 'avatar', { key: 1 }),
                ],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-inner`) },
            [
              Se(
                'div',
                { class: H(`${e.prefixCls}-inner-content`) },
                [
                  e.hasAuthor || e.hasDatetime
                    ? (O(),
                      Z(
                        'div',
                        {
                          key: 0,
                          class: H(
                            `${e.prefixCls}-title ${e.prefixCls}-title-align-${e.computedAlign.datetime}`
                          ),
                        },
                        [
                          e.hasAuthor
                            ? (O(),
                              Z(
                                'span',
                                { key: 0, class: H(`${e.prefixCls}-author`) },
                                [
                                  e.author
                                    ? (O(), Z('span', VH, mt(e.author), 1))
                                    : ve(e.$slots, 'author', { key: 1 }),
                                ],
                                2
                              ))
                            : Ce('v-if', !0),
                          e.hasDatetime
                            ? (O(),
                              Z(
                                'span',
                                { key: 1, class: H(`${e.prefixCls}-datetime`) },
                                [
                                  e.datetime
                                    ? (O(), Z('span', UH, mt(e.datetime), 1))
                                    : ve(e.$slots, 'datetime', { key: 1 }),
                                ],
                                2
                              ))
                            : Ce('v-if', !0),
                        ],
                        2
                      ))
                    : Ce('v-if', !0),
                  e.hasContent
                    ? (O(),
                      Z(
                        'div',
                        { key: 1, class: H(`${e.prefixCls}-content`) },
                        [
                          e.content
                            ? (O(), Z('span', HH, mt(e.content), 1))
                            : ve(e.$slots, 'content', { key: 1 }),
                        ],
                        2
                      ))
                    : Ce('v-if', !0),
                  e.$slots.actions
                    ? (O(),
                      Z(
                        'div',
                        {
                          key: 2,
                          class: H(
                            `${e.prefixCls}-actions ${e.prefixCls}-actions-align-${e.computedAlign.actions}`
                          ),
                        },
                        [ve(e.$slots, 'actions')],
                        2
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ),
              e.$slots.default
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-inner-comment`) },
                    [ve(e.$slots, 'default')],
                    2
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var A0 = Te(FH, [['render', WH]])
  const jH = Object.assign(A0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + A0.name, A0)
      },
    }),
    GH = ce({
      name: 'ConfigProvider',
      props: {
        prefixCls: { type: String, default: 'arco' },
        locale: { type: Object },
        size: { type: String },
        global: { type: Boolean, default: !1 },
        updateAtScroll: { type: Boolean, default: !1 },
        scrollToClose: { type: Boolean, default: !1 },
      },
      setup(e, { slots: t }) {
        const {
            prefixCls: n,
            locale: r,
            size: i,
            updateAtScroll: o,
            scrollToClose: a,
          } = tt(e),
          s = Je({
            slots: t,
            prefixCls: n,
            locale: r,
            size: i,
            updateAtScroll: o,
            scrollToClose: a,
          })
        if (e.global) {
          const l = Jr()
          l && l.appContext.app.provide(di, s)
        } else sn(di, s)
      },
    })
  function KH(e, t, n, r, i, o) {
    return ve(e.$slots, 'default')
  }
  var $0 = Te(GH, [['render', KH]])
  const qH = Object.assign($0, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + $0.name, $0)
    },
  })
  function zi(e) {
    const t = J(e)
    return [
      t,
      (r) => {
        t.value = r
      },
    ]
  }
  function XH(e) {
    const { modelValue: t, defaultValue: n, format: r } = tt(e),
      i = C(() => Hi(t.value, r.value)),
      o = C(() => Hi(n.value, r.value)),
      [a, s] = zi(Mt(i.value) ? (Mt(o.value) ? void 0 : o.value) : i.value)
    return (
      pt(i, () => {
        Mt(i.value) && s(void 0)
      }),
      { value: C(() => i.value || a.value), setValue: s }
    )
  }
  const YH = ce({
      name: 'DateInput',
      components: { IconHover: In, IconClose: zr, FeedbackIcon: Zd },
      props: {
        size: { type: String },
        focused: { type: Boolean },
        disabled: { type: Boolean },
        readonly: { type: Boolean },
        error: { type: Boolean },
        allowClear: { type: Boolean },
        placeholder: { type: String },
        inputValue: { type: String },
        value: { type: Object },
        format: { type: [String, Function], required: !0 },
      },
      emits: ['clear', 'press-enter', 'change', 'blur'],
      setup(e, { emit: t, slots: n }) {
        const {
            error: r,
            focused: i,
            disabled: o,
            size: a,
            value: s,
            format: l,
            inputValue: c,
          } = tt(e),
          {
            mergedSize: d,
            mergedDisabled: h,
            mergedError: p,
            feedback: v,
          } = Rn({ size: a, disabled: o, error: r }),
          { mergedSize: g } = Vr(d),
          _ = ye('picker'),
          b = C(() => [
            _,
            `${_}-size-${g.value}`,
            {
              [`${_}-focused`]: i.value,
              [`${_}-disabled`]: h.value,
              [`${_}-error`]: p.value,
              [`${_}-has-prefix`]: n.prefix,
            },
          ]),
          y = C(() => {
            if (c != null && c.value) return c == null ? void 0 : c.value
            if (s != null && s.value && ao(s.value))
              return xt(l.value) ? l.value(s.value) : s.value.format(l.value)
          }),
          M = J()
        return {
          feedback: v,
          prefixCls: _,
          classNames: b,
          displayValue: y,
          mergedDisabled: h,
          refInput: M,
          onPressEnter() {
            t('press-enter')
          },
          onChange(x) {
            t('change', x)
          },
          onClear(x) {
            t('clear', x)
          },
          onBlur(x) {
            t('blur', x)
          },
        }
      },
      methods: {
        focus() {
          this.refInput && this.refInput.focus && this.refInput.focus()
        },
        blur() {
          this.refInput && this.refInput.blur && this.refInput.blur()
        },
      },
    }),
    ZH = ['disabled', 'placeholder', 'value']
  function JH(e, t, n, r, i, o) {
    const a = ge('IconClose'),
      s = ge('IconHover'),
      l = ge('FeedbackIcon')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.$slots.prefix
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-prefix`) },
                [ve(e.$slots, 'prefix')],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-input`) },
            [
              Se(
                'input',
                Fe(
                  {
                    ref: 'refInput',
                    disabled: e.mergedDisabled,
                    placeholder: e.placeholder,
                    class: `${e.prefixCls}-start-time`,
                    value: e.displayValue,
                  },
                  e.readonly ? { readonly: !0 } : {},
                  {
                    onKeydown:
                      t[0] ||
                      (t[0] = xu(
                        (...c) => e.onPressEnter && e.onPressEnter(...c),
                        ['enter']
                      )),
                    onInput:
                      t[1] || (t[1] = (...c) => e.onChange && e.onChange(...c)),
                    onBlur:
                      t[2] || (t[2] = (...c) => e.onBlur && e.onBlur(...c)),
                  }
                ),
                null,
                16,
                ZH
              ),
            ],
            2
          ),
          Se(
            'div',
            { class: H(`${e.prefixCls}-suffix`) },
            [
              e.allowClear && !e.mergedDisabled && e.displayValue
                ? (O(),
                  Ee(
                    s,
                    {
                      key: 0,
                      prefix: e.prefixCls,
                      class: H(`${e.prefixCls}-clear-icon`),
                      onClick: e.onClear,
                    },
                    { default: ze(() => [m(a)]), _: 1 },
                    8,
                    ['prefix', 'class', 'onClick']
                  ))
                : Ce('v-if', !0),
              Se(
                'span',
                { class: H(`${e.prefixCls}-suffix-icon`) },
                [ve(e.$slots, 'suffix-icon')],
                2
              ),
              e.feedback
                ? (O(), Ee(l, { key: 1, type: e.feedback }, null, 8, ['type']))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Tk = Te(YH, [['render', JH]])
  function Sb(e) {
    const t = ['H', 'h', 'm', 's', 'a', 'A'],
      n = []
    let r = !1
    return (
      t.forEach((i) => {
        e.indexOf(i) !== -1 && (n.push(i), (i === 'a' || i === 'A') && (r = !0))
      }),
      { list: n, use12Hours: r }
    )
  }
  const Hx = new Map()
  function QH(e, t, n) {
    const r = Hx.get(e)
    Mt(r) || cancelAnimationFrame(r),
      n <= 0 && (e.scrollTop = t),
      Hx.set(
        e,
        requestAnimationFrame(() => {
          new Ol({
            from: { scrollTop: e.scrollTop },
            to: { scrollTop: t },
            duration: n,
            onUpdate: (o) => {
              e.scrollTop = o.scrollTop
            },
          }).start()
        })
      )
  }
  function Jo(e, t) {
    const n = (r) => {
      if (Ft(r)) return r.map((i) => n(i))
      if (!Mt(r)) return r.format(t)
    }
    return n(e)
  }
  function ed(e) {
    return Mt(e)
      ? !0
      : Ft(e)
      ? e.length === 0 || (e.length === 2 && ao(e[0]) && ao(e[1]))
      : !1
  }
  function uv(e, t) {
    return e ? typeof e == 'string' && nr(e, t).format(t) === e : !1
  }
  function eW(e, { disabledHours: t, disabledMinutes: n, disabledSeconds: r }) {
    if (!e) return !1
    const i = e.hour(),
      o = e.minute(),
      a = e.second(),
      s = (t == null ? void 0 : t()) || [],
      l = (n == null ? void 0 : n(i)) || [],
      c = (r == null ? void 0 : r(i, o)) || [],
      d = (h, p) => !Mt(h) && p.includes(h)
    return d(i, s) || d(o, l) || d(a, c)
  }
  var Ga = ce({
    name: 'RenderFunction',
    props: { renderFunc: { type: Function, required: !0 } },
    render() {
      return this.renderFunc(this.$attrs)
    },
  })
  const kk = Symbol('PickerInjectionKey')
  function Qd() {
    const { datePickerT: e } = zt(kk) || {}
    return e || ((t, ...n) => t)
  }
  const tW = ce({
    name: 'PanelShortcuts',
    components: { Button: Yr, RenderFunction: Ga },
    props: {
      prefixCls: { type: String, required: !0 },
      shortcuts: { type: Array, default: () => [] },
      showNowBtn: { type: Boolean },
    },
    emits: ['item-click', 'item-mouse-enter', 'item-mouse-leave', 'now-click'],
    setup(e, { emit: t }) {
      return {
        datePickerT: Qd(),
        onItemClick: (r) => {
          t('item-click', r)
        },
        onItemMouseEnter: (r) => {
          t('item-mouse-enter', r)
        },
        onItemMouseLeave: (r) => {
          t('item-mouse-leave', r)
        },
        onNowClick: () => {
          t('now-click')
        },
        isFunction: xt,
      }
    },
  })
  function nW(e, t, n, r, i, o) {
    const a = ge('Button'),
      s = ge('RenderFunction')
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-shortcuts`) },
        [
          e.showNowBtn
            ? (O(),
              Ee(
                a,
                {
                  key: 0,
                  size: 'mini',
                  onClick: t[0] || (t[0] = () => e.onNowClick()),
                },
                {
                  default: ze(() => [
                    Lt(mt(e.datePickerT('datePicker.now')), 1),
                  ]),
                  _: 1,
                }
              ))
            : Ce('v-if', !0),
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.shortcuts,
              (l, c) => (
                O(),
                Ee(
                  a,
                  {
                    key: c,
                    size: 'mini',
                    onClick: () => e.onItemClick(l),
                    onMouseenter: () => e.onItemMouseEnter(l),
                    onMouseleave: () => e.onItemMouseLeave(l),
                  },
                  {
                    default: ze(() => [
                      e.isFunction(l.label)
                        ? (O(),
                          Ee(s, { key: 0, 'render-func': l.label }, null, 8, [
                            'render-func',
                          ]))
                        : (O(), Z(yt, { key: 1 }, [Lt(mt(l.label), 1)], 2112)),
                    ]),
                    _: 2,
                  },
                  1032,
                  ['onClick', 'onMouseenter', 'onMouseleave']
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var Ak = Te(tW, [['render', nW]])
  function qu(e) {
    return [...Array(e)]
  }
  function Cb(e) {
    if (!Mt(e)) return Ft(e) ? e : [e, void 0]
  }
  function ms(e) {
    return !!e && ao(e[0]) && ao(e[1])
  }
  function rW(e) {
    return Mt(e) || e.length === 0 || ms(e)
  }
  function $k(e, t, n) {
    const r = t || e
    return (n || e)
      .set('year', r.year())
      .set('month', r.month())
      .set('date', r.date())
  }
  const iW = ce({
      name: 'IconDoubleLeft',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-double-left`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    oW = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    aW = Se(
      'path',
      {
        d: 'M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142',
      },
      null,
      -1
    ),
    sW = [aW]
  function lW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        sW,
        14,
        oW
      )
    )
  }
  var O0 = Te(iW, [['render', lW]])
  const uW = Object.assign(O0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + O0.name, O0)
      },
    }),
    cW = ce({
      name: 'IconDoubleRight',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-double-right`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    dW = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    fW = Se(
      'path',
      {
        d: 'm11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816',
      },
      null,
      -1
    ),
    hW = [fW]
  function pW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        hW,
        14,
        dW
      )
    )
  }
  var L0 = Te(cW, [['render', pW]])
  const vW = Object.assign(L0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + L0.name, L0)
      },
    }),
    mW = ce({
      name: 'PanelHeader',
      components: {
        IconLeft: ja,
        IconRight: No,
        IconDoubleLeft: uW,
        IconDoubleRight: vW,
        RenderFunction: Ga,
      },
      props: {
        prefixCls: { type: String, required: !0 },
        title: { type: String, required: !0 },
        mode: { type: String, default: 'date' },
        value: { type: Object },
        icons: { type: Object },
        onPrev: { type: Function },
        onSuperPrev: { type: Function },
        onNext: { type: Function },
        onSuperNext: { type: Function },
        onLabelClick: { type: Function },
      },
      emits: ['label-click'],
      setup(e) {
        return {
          showPrev: C(() => xt(e.onPrev)),
          showSuperPrev: C(() => xt(e.onSuperPrev)),
          showNext: C(() => xt(e.onNext)),
          showSuperNext: C(() => xt(e.onSuperNext)),
          year: C(() =>
            ['date', 'quarter', 'month', 'week'].includes(e.mode) && e.value
              ? e.value.format('YYYY')
              : ''
          ),
          month: C(() =>
            ['date', 'week'].includes(e.mode) && e.value
              ? e.value.format('MM')
              : ''
          ),
          getIconClassName: (t) => [
            `${e.prefixCls}-header-icon`,
            { [`${e.prefixCls}-header-icon-hidden`]: !t },
          ],
        }
      },
    }),
    gW = { key: 1 }
  function yW(e, t, n, r, i, o) {
    const a = ge('RenderFunction'),
      s = ge('IconDoubleLeft'),
      l = ge('IconLeft'),
      c = ge('IconRight'),
      d = ge('IconDoubleRight')
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-header`) },
        [
          Se(
            'div',
            {
              class: H(e.getIconClassName(e.showSuperPrev)),
              onClick:
                t[0] || (t[0] = (...h) => e.onSuperPrev && e.onSuperPrev(...h)),
            },
            [
              e.showSuperPrev
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.icons && e.icons.prevDouble
                        ? (O(),
                          Ee(
                            a,
                            {
                              key: 0,
                              'render-func': e.icons && e.icons.prevDouble,
                            },
                            null,
                            8,
                            ['render-func']
                          ))
                        : (O(), Ee(s, { key: 1 })),
                    ],
                    2112
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          Se(
            'div',
            {
              class: H(e.getIconClassName(e.showPrev)),
              onClick: t[1] || (t[1] = (...h) => e.onPrev && e.onPrev(...h)),
            },
            [
              e.showPrev
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.icons && e.icons.prev
                        ? (O(),
                          Ee(
                            a,
                            { key: 0, 'render-func': e.icons && e.icons.prev },
                            null,
                            8,
                            ['render-func']
                          ))
                        : (O(), Ee(l, { key: 1 })),
                    ],
                    2112
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          Se(
            'div',
            { class: H(`${e.prefixCls}-header-title`) },
            [
              e.onLabelClick && (e.year || e.month)
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.year
                        ? (O(),
                          Z(
                            'span',
                            {
                              key: 0,
                              class: H(`${e.prefixCls}-header-label`),
                              onClick:
                                t[2] ||
                                (t[2] = () =>
                                  e.onLabelClick && e.onLabelClick('year')),
                            },
                            mt(e.year),
                            3
                          ))
                        : Ce('v-if', !0),
                      e.year && e.month
                        ? (O(), Z('span', gW, '-'))
                        : Ce('v-if', !0),
                      e.month
                        ? (O(),
                          Z(
                            'span',
                            {
                              key: 2,
                              class: H(`${e.prefixCls}-header-label`),
                              onClick:
                                t[3] ||
                                (t[3] = () =>
                                  e.onLabelClick && e.onLabelClick('month')),
                            },
                            mt(e.month),
                            3
                          ))
                        : Ce('v-if', !0),
                    ],
                    64
                  ))
                : (O(), Z(yt, { key: 1 }, [Lt(mt(e.title), 1)], 2112)),
            ],
            2
          ),
          Se(
            'div',
            {
              class: H(e.getIconClassName(e.showNext)),
              onClick: t[4] || (t[4] = (...h) => e.onNext && e.onNext(...h)),
            },
            [
              e.showNext
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.icons && e.icons.next
                        ? (O(),
                          Ee(
                            a,
                            { key: 0, 'render-func': e.icons && e.icons.next },
                            null,
                            8,
                            ['render-func']
                          ))
                        : (O(), Ee(c, { key: 1 })),
                    ],
                    2112
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          Se(
            'div',
            {
              class: H(e.getIconClassName(e.showSuperNext)),
              onClick:
                t[5] || (t[5] = (...h) => e.onSuperNext && e.onSuperNext(...h)),
            },
            [
              e.showSuperNext
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.icons && e.icons.nextDouble
                        ? (O(),
                          Ee(
                            a,
                            {
                              key: 0,
                              'render-func': e.icons && e.icons.nextDouble,
                            },
                            null,
                            8,
                            ['render-func']
                          ))
                        : (O(), Ee(d, { key: 1 })),
                    ],
                    2112
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var em = Te(mW, [['render', yW]])
  function bW(e) {
    const { rangeValues: t } = tt(e),
      n = C(() =>
        t != null && t.value && t.value.every(ao)
          ? Ld(t.value)
          : t == null
          ? void 0
          : t.value
      ),
      r = C(() => {
        var o
        return (o = n.value) == null ? void 0 : o[0]
      }),
      i = C(() => {
        var o
        return (o = n.value) == null ? void 0 : o[1]
      })
    return {
      getCellClassName: (o, a) => {
        const { value: s, isSameTime: l, mode: c, prefixCls: d } = e,
          h = !o.isPrev && !o.isNext,
          p = s && l(o.value, s)
        let v = l(o.value, Nr())
        c === 'week' && (v = Nr().isSame(o.value, 'date'))
        const g = h && r.value && l(o.value, r.value),
          _ = h && i.value && l(o.value, i.value),
          b =
            h &&
            r.value &&
            i.value &&
            (g || _ || o.value.isBetween(r.value, i.value, null, '[]'))
        return [
          `${d}-cell`,
          {
            [`${d}-cell-in-view`]: h,
            [`${d}-cell-today`]: v,
            [`${d}-cell-selected`]: p,
            [`${d}-cell-range-start`]: g,
            [`${d}-cell-range-end`]: _,
            [`${d}-cell-in-range`]: b,
            [`${d}-cell-disabled`]: a,
          },
          o.classNames,
        ]
      },
    }
  }
  const _W = ce({
      name: 'PanelBody',
      components: { RenderFunction: Ga },
      props: {
        prefixCls: { type: String, required: !0 },
        rows: { type: Array, default: () => [] },
        value: { type: Object },
        disabledDate: { type: Function },
        isSameTime: { type: Function, required: !0 },
        mode: { type: String },
        rangeValues: { type: Array },
        dateRender: { type: Function },
      },
      emits: ['cell-click', 'cell-mouse-enter'],
      setup(e, { emit: t }) {
        const {
            prefixCls: n,
            value: r,
            disabledDate: i,
            isSameTime: o,
            mode: a,
            rangeValues: s,
          } = tt(e),
          { getCellClassName: l } = bW(
            Je({
              prefixCls: n,
              value: r,
              isSameTime: o,
              mode: a,
              rangeValues: s,
            })
          ),
          c = (d) =>
            !!(
              xt(i == null ? void 0 : i.value) &&
              i != null &&
              i.value(wi(d.value))
            )
        return {
          isWeek: C(() => (a == null ? void 0 : a.value) === 'week'),
          getCellClassName: (d) => {
            const h = c(d)
            return l(d, h)
          },
          onCellClick: (d) => {
            c(d) || t('cell-click', d)
          },
          onCellMouseEnter: (d) => {
            c(d) || t('cell-mouse-enter', d)
          },
          onCellMouseLeave: (d) => {
            c(d) || t('cell-mouse-enter', d)
          },
          getDateValue: wi,
        }
      },
    }),
    SW = ['onMouseenter', 'onMouseleave', 'onClick']
  function CW(e, t, n, r, i, o) {
    const a = ge('RenderFunction')
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-body`) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.rows,
              (s, l) => (
                O(),
                Z(
                  'div',
                  {
                    key: l,
                    class: H([
                      `${e.prefixCls}-row`,
                      { [`${e.prefixCls}-row-week`]: e.isWeek },
                    ]),
                  },
                  [
                    (O(!0),
                    Z(
                      yt,
                      null,
                      Yn(
                        s,
                        (c, d) => (
                          O(),
                          Z(
                            yt,
                            null,
                            [
                              Ce('  week  '),
                              e.isWeek && d === 0
                                ? (O(),
                                  Z(
                                    'div',
                                    {
                                      key: d,
                                      class: H([
                                        `${e.prefixCls}-cell`,
                                        `${e.prefixCls}-cell-week`,
                                      ]),
                                    },
                                    [
                                      Se(
                                        'div',
                                        { class: H(`${e.prefixCls}-date`) },
                                        [
                                          Se(
                                            'div',
                                            {
                                              class: H(
                                                `${e.prefixCls}-date-value`
                                              ),
                                            },
                                            mt(c.label),
                                            3
                                          ),
                                        ],
                                        2
                                      ),
                                    ],
                                    2
                                  ))
                                : (O(),
                                  Z(
                                    'div',
                                    {
                                      key: d,
                                      class: H(e.getCellClassName(c)),
                                      onMouseenter: () => {
                                        e.onCellMouseEnter(c)
                                      },
                                      onMouseleave: () => {
                                        e.onCellMouseLeave(c)
                                      },
                                      onClick: () => {
                                        e.onCellClick(c)
                                      },
                                    },
                                    [
                                      e.dateRender
                                        ? (O(),
                                          Ee(
                                            a,
                                            {
                                              key: 0,
                                              'render-func': e.dateRender,
                                              date: e.getDateValue(c.value),
                                            },
                                            null,
                                            8,
                                            ['render-func', 'date']
                                          ))
                                        : (O(),
                                          Z(
                                            'div',
                                            {
                                              key: 1,
                                              class: H(`${e.prefixCls}-date`),
                                            },
                                            [
                                              Se(
                                                'div',
                                                {
                                                  class: H(
                                                    `${e.prefixCls}-date-value`
                                                  ),
                                                },
                                                mt(c.label),
                                                3
                                              ),
                                            ],
                                            2
                                          )),
                                    ],
                                    42,
                                    SW
                                  )),
                            ],
                            64
                          )
                        )
                      ),
                      256
                    )),
                  ],
                  2
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var tm = Te(_W, [['render', CW]])
  const wW = ce({
    name: 'PanelWeekList',
    props: {
      prefixCls: { type: String, required: !0 },
      weekList: { type: Array, required: !0 },
    },
    setup() {
      const e = Qd()
      return {
        labelList: C(() =>
          [
            'sunday',
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
          ].map((n) => e(`datePicker.week.short.${n}`))
        ),
      }
    },
  })
  function xW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-week-list`) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.weekList,
              (a) => (
                O(),
                Z(
                  'div',
                  { key: a, class: H(`${e.prefixCls}-week-list-item`) },
                  mt(e.labelList[a] || ''),
                  3
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var MW = Te(wW, [['render', xW]])
  const EW = ce({
      name: 'TimePickerColumn',
      props: {
        prefixCls: { type: String, required: !0 },
        list: { type: Array, required: !0 },
        value: { type: [Number, String] },
        visible: { type: Boolean },
      },
      emits: ['select'],
      setup(e, { emit: t }) {
        const { visible: n, value: r } = tt(e),
          i = J(new Map()),
          o = J()
        function a(s = !1) {
          if (
            !o.value ||
            Mt(r == null ? void 0 : r.value) ||
            !(n != null && n.value)
          )
            return
          const l = i.value.get(r.value)
          l && QH(o.value, l.offsetTop, s ? 100 : 0)
        }
        return (
          pt([r, n], (s, [, l]) => {
            n.value !== l
              ? hn(() => {
                  a()
                })
              : a(!0)
          }),
          Wt(() => {
            a()
          }),
          {
            refWrapper: o,
            refMap: i,
            onItemRef(s, l) {
              i.value.set(l.value, s)
            },
            onItemClick(s) {
              s.disabled || t('select', s.value)
            },
          }
        )
      },
    }),
    PW = ['onClick']
  function TW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { ref: 'refWrapper', class: H(`${e.prefixCls}-column`) },
        [
          Se('ul', null, [
            (O(!0),
            Z(
              yt,
              null,
              Yn(
                e.list,
                (a) => (
                  O(),
                  Z(
                    'li',
                    {
                      key: a.value,
                      ref: (s) => {
                        e.onItemRef(s, a)
                      },
                      class: H([
                        `${e.prefixCls}-cell`,
                        {
                          [`${e.prefixCls}-cell-disabled`]: a.disabled,
                          [`${e.prefixCls}-cell-selected`]: a.selected,
                        },
                      ]),
                      onClick: () => {
                        e.onItemClick(a)
                      },
                    },
                    [
                      Se(
                        'div',
                        { class: H(`${e.prefixCls}-cell-inner`) },
                        mt(a.label),
                        3
                      ),
                    ],
                    10,
                    PW
                  )
                )
              ),
              128
            )),
          ]),
        ],
        2
      )
    )
  }
  var kW = Te(EW, [['render', TW]])
  function AW(e) {
    const {
        format: t,
        step: n,
        use12Hours: r,
        hideDisabledOptions: i,
        disabledHours: o,
        disabledMinutes: a,
        disabledSeconds: s,
        selectedHour: l,
        selectedMinute: c,
        selectedSecond: d,
        selectedAmpm: h,
        disabled: p,
      } = tt(e),
      v = C(() => {
        var M
        const { hour: x = 1 } = (n == null ? void 0 : n.value) || {},
          w =
            ((M = o == null ? void 0 : o.value) == null ? void 0 : M.call(o)) ||
            []
        let E = []
        for (let P = 0; P < (r.value ? 12 : 24); P += x) E.push(P)
        return (
          r.value && (E[0] = 12),
          i.value && w.length && (E = E.filter((P) => w.indexOf(P) < 0)),
          E.map((P) => ({
            label: vl(P, 2, '0'),
            value: P,
            selected: l.value === P,
            disabled: (p == null ? void 0 : p.value) || w.includes(P),
          }))
        )
      }),
      g = C(() => {
        var M
        const { minute: x = 1 } = (n == null ? void 0 : n.value) || {},
          w =
            ((M = a == null ? void 0 : a.value) == null
              ? void 0
              : M.call(a, l.value)) || []
        let E = []
        for (let P = 0; P < 60; P += x) E.push(P)
        return (
          i.value && w.length && (E = E.filter((P) => w.indexOf(P) < 0)),
          E.map((P) => ({
            label: vl(P, 2, '0'),
            value: P,
            selected: c.value === P,
            disabled: (p == null ? void 0 : p.value) || w.includes(P),
          }))
        )
      }),
      _ = C(() => {
        var M
        const { second: x = 1 } = (n == null ? void 0 : n.value) || {},
          w =
            ((M = s == null ? void 0 : s.value) == null
              ? void 0
              : M.call(s, l.value, c.value)) || []
        let E = []
        for (let P = 0; P < 60; P += x) E.push(P)
        return (
          i.value && w.length && (E = E.filter((P) => w.indexOf(P) < 0)),
          E.map((P) => ({
            label: vl(P, 2, '0'),
            value: P,
            selected: d.value === P,
            disabled: (p == null ? void 0 : p.value) || w.includes(P),
          }))
        )
      }),
      b = ['am', 'pm'],
      y = C(() => {
        const M = Sb(t.value).list.includes('A')
        return b.map((x) => ({
          label: M ? x.toUpperCase() : x,
          value: x,
          selected: h.value === x,
          disabled: p == null ? void 0 : p.value,
        }))
      })
    return { hours: v, minutes: g, seconds: _, ampmList: y }
  }
  function tS(e) {
    const { format: t, use12Hours: n, defaultFormat: r } = tt(e),
      i = C(() => {
        let c = (t == null ? void 0 : t.value) || (r == null ? void 0 : r.value)
        return (
          (!c || !Sb(c).list.length) &&
            (c = n != null && n.value ? 'hh:mm:ss a' : 'HH:mm:ss'),
          c
        )
      }),
      o = C(() => Sb(i.value)),
      a = C(() => o.value.list),
      s = C(() => o.value.use12Hours),
      l = C(() => !!((n != null && n.value) || s.value))
    return { columns: a, use12Hours: l, format: i }
  }
  function Ok(e) {
    const t = (n) =>
      eW(n, {
        disabledHours: e.disabledHours,
        disabledMinutes: e.disabledMinutes,
        disabledSeconds: e.disabledSeconds,
      })
    return (n) => (Ft(n) ? n.some((r) => t(r)) : t(n))
  }
  const $W = ce({
    name: 'TimePickerPanel',
    components: { TimeColumn: kW, Button: Yr },
    props: {
      value: { type: Object },
      visible: { type: Boolean },
      format: { type: String, default: 'HH:mm:ss' },
      use12Hours: { type: Boolean },
      step: { type: Object },
      disabledHours: { type: Function },
      disabledMinutes: { type: Function },
      disabledSeconds: { type: Function },
      hideDisabledOptions: { type: Boolean },
      hideFooter: { type: Boolean },
      isRange: { type: Boolean },
      disabled: { type: Boolean },
    },
    emits: { select: (e) => ao(e), confirm: (e) => ao(e) },
    setup(e, { emit: t }) {
      const {
          value: n,
          visible: r,
          format: i,
          step: o,
          use12Hours: a,
          hideDisabledOptions: s,
          disabledHours: l,
          disabledMinutes: c,
          disabledSeconds: d,
          disabled: h,
        } = tt(e),
        p = ye('timepicker'),
        { t: v } = Vn(),
        {
          columns: g,
          use12Hours: _,
          format: b,
        } = tS(Je({ format: i, use12Hours: a })),
        y = J(n == null ? void 0 : n.value),
        M = (V) => {
          y.value = V
        }
      pt([r, n], () => {
        r.value && M(n == null ? void 0 : n.value)
      })
      const x = C(() => {
          var V
          const L = (V = y.value) == null ? void 0 : V.hour()
          return Mt(L) || !_.value ? L : L > 12 ? L - 12 : L === 0 ? 12 : L
        }),
        w = C(() => {
          var V
          return (V = y.value) == null ? void 0 : V.minute()
        }),
        E = C(() => {
          var V
          return (V = y.value) == null ? void 0 : V.second()
        }),
        P = C(() => {
          var V
          const L = (V = y.value) == null ? void 0 : V.hour()
          return !Mt(L) && L >= 12 ? 'pm' : 'am'
        }),
        {
          hours: A,
          minutes: F,
          seconds: T,
          ampmList: k,
        } = AW(
          Je({
            format: b,
            step: o,
            use12Hours: _,
            hideDisabledOptions: s,
            disabledHours: l,
            disabledMinutes: c,
            disabledSeconds: d,
            selectedHour: x,
            selectedMinute: w,
            selectedSecond: E,
            selectedAmpm: P,
            disabled: h,
          })
        ),
        R = Ok(
          Je({ disabledHours: l, disabledMinutes: c, disabledSeconds: d })
        ),
        j = C(() => R(y.value))
      function N(V) {
        Mt(V) || t('confirm', V)
      }
      function I(V) {
        M(V), t('select', V)
      }
      function B(V, L = 'hour') {
        let W
        const Y = x.value || '00',
          U = w.value || '00',
          le = E.value || '00',
          q = P.value || 'am'
        switch (L) {
          case 'hour':
            W = `${V}:${U}:${le}`
            break
          case 'minute':
            W = `${Y}:${V}:${le}`
            break
          case 'second':
            W = `${Y}:${U}:${V}`
            break
          case 'ampm':
            W = `${Y}:${U}:${le} ${V}`
            break
          default:
            W = '00:00:00'
        }
        let oe = 'HH:mm:ss'
        _.value && ((oe = 'HH:mm:ss a'), L !== 'ampm' && (W = `${W} ${q}`)),
          (W = nr(W, oe)),
          I(W)
      }
      return {
        prefixCls: p,
        t: v,
        hours: A,
        minutes: F,
        seconds: T,
        ampmList: k,
        selectedValue: y,
        selectedHour: x,
        selectedMinute: w,
        selectedSecond: E,
        selectedAmpm: P,
        computedUse12Hours: _,
        confirmBtnDisabled: j,
        columns: g,
        onSelect: B,
        onSelectNow() {
          const V = nr(new Date())
          I(V)
        },
        onConfirm() {
          N(y.value)
        },
      }
    },
  })
  function OW(e, t, n, r, i, o) {
    const a = ge('TimeColumn'),
      s = ge('Button')
    return (
      O(),
      Z(
        yt,
        null,
        [
          Se(
            'div',
            { class: H(e.prefixCls) },
            [
              e.columns.includes('H') || e.columns.includes('h')
                ? (O(),
                  Ee(
                    a,
                    {
                      key: 0,
                      value: e.selectedHour,
                      list: e.hours,
                      'prefix-cls': e.prefixCls,
                      visible: e.visible,
                      onSelect:
                        t[0] ||
                        (t[0] = (l) => {
                          e.onSelect(l, 'hour')
                        }),
                    },
                    null,
                    8,
                    ['value', 'list', 'prefix-cls', 'visible']
                  ))
                : Ce('v-if', !0),
              e.columns.includes('m')
                ? (O(),
                  Ee(
                    a,
                    {
                      key: 1,
                      value: e.selectedMinute,
                      list: e.minutes,
                      'prefix-cls': e.prefixCls,
                      visible: e.visible,
                      onSelect:
                        t[1] ||
                        (t[1] = (l) => {
                          e.onSelect(l, 'minute')
                        }),
                    },
                    null,
                    8,
                    ['value', 'list', 'prefix-cls', 'visible']
                  ))
                : Ce('v-if', !0),
              e.columns.includes('s')
                ? (O(),
                  Ee(
                    a,
                    {
                      key: 2,
                      value: e.selectedSecond,
                      list: e.seconds,
                      'prefix-cls': e.prefixCls,
                      visible: e.visible,
                      onSelect:
                        t[2] ||
                        (t[2] = (l) => {
                          e.onSelect(l, 'second')
                        }),
                    },
                    null,
                    8,
                    ['value', 'list', 'prefix-cls', 'visible']
                  ))
                : Ce('v-if', !0),
              e.computedUse12Hours
                ? (O(),
                  Ee(
                    a,
                    {
                      key: 3,
                      value: e.selectedAmpm,
                      list: e.ampmList,
                      'prefix-cls': e.prefixCls,
                      visible: e.visible,
                      onSelect:
                        t[3] ||
                        (t[3] = (l) => {
                          e.onSelect(l, 'ampm')
                        }),
                    },
                    null,
                    8,
                    ['value', 'list', 'prefix-cls', 'visible']
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          e.$slots['extra-footer']
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-footer-extra-wrapper`) },
                [ve(e.$slots, 'extra-footer')],
                2
              ))
            : Ce('v-if', !0),
          e.hideFooter
            ? Ce('v-if', !0)
            : (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-footer-btn-wrapper`) },
                [
                  e.isRange
                    ? Ce('v-if', !0)
                    : (O(),
                      Ee(
                        s,
                        { key: 0, size: 'mini', onClick: e.onSelectNow },
                        {
                          default: ze(() => [Lt(mt(e.t('datePicker.now')), 1)]),
                          _: 1,
                        },
                        8,
                        ['onClick']
                      )),
                  m(
                    s,
                    {
                      type: 'primary',
                      size: 'mini',
                      disabled: e.confirmBtnDisabled || !e.selectedValue,
                      onClick: e.onConfirm,
                    },
                    {
                      default: ze(() => [Lt(mt(e.t('datePicker.ok')), 1)]),
                      _: 1,
                    },
                    8,
                    ['disabled', 'onClick']
                  ),
                ],
                2
              )),
        ],
        64
      )
    )
  }
  var cv = Te($W, [['render', OW]])
  const LW = ce({
      name: 'IconCalendar',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-calendar`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    IW = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    RW = Se(
      'path',
      {
        d: 'M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z',
      },
      null,
      -1
    ),
    DW = [RW]
  function NW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        DW,
        14,
        IW
      )
    )
  }
  var I0 = Te(LW, [['render', NW]])
  const nS = Object.assign(I0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + I0.name, I0)
      },
    }),
    BW = ce({
      name: 'IconClockCircle',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-clock-circle`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    FW = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    zW = Se(
      'path',
      {
        d: 'M24 14v10h9.5m8.5 0c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z',
      },
      null,
      -1
    ),
    VW = [zW]
  function UW(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        VW,
        14,
        FW
      )
    )
  }
  var R0 = Te(BW, [['render', UW]])
  const Lk = Object.assign(R0, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + R0.name, R0)
    },
  })
  function Er(e, t) {
    const { value: n } = tt(t),
      [r, i] = zi(Mt(n.value) ? e : n.value)
    return (
      pt(n, (a) => {
        Mt(a) && i(void 0)
      }),
      [C(() => (Mt(n.value) ? r.value : n.value)), i, r]
    )
  }
  var HW = Object.defineProperty,
    WW = Object.defineProperties,
    jW = Object.getOwnPropertyDescriptors,
    Wx = Object.getOwnPropertySymbols,
    GW = Object.prototype.hasOwnProperty,
    KW = Object.prototype.propertyIsEnumerable,
    jx = (e, t, n) =>
      t in e
        ? HW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    pp = (e, t) => {
      for (var n in t || (t = {})) GW.call(t, n) && jx(e, n, t[n])
      if (Wx) for (var n of Wx(t)) KW.call(t, n) && jx(e, n, t[n])
      return e
    },
    Ik = (e, t) => WW(e, jW(t))
  const Rk = 6,
    wb = 7,
    qW = Rk * wb
  function XW(e) {
    return { label: e.date(), value: e }
  }
  const YW = ce({
    name: 'DatePanel',
    components: {
      PanelHeader: em,
      PanelBody: tm,
      PanelWeekList: MW,
      TimePanel: cv,
      IconCalendar: nS,
      IconClockCircle: Lk,
    },
    props: {
      isRange: { type: Boolean },
      value: { type: Object },
      rangeValues: { type: Array },
      headerValue: { type: Object, required: !0 },
      footerValue: { type: Object },
      timePickerValue: { type: Object },
      headerOperations: { type: Object, default: () => ({}) },
      headerIcons: { type: Object, default: () => ({}) },
      dayStartOfWeek: { type: Number, default: 0 },
      disabledDate: { type: Function },
      disabledTime: { type: Function },
      isSameTime: { type: Function },
      mode: { type: String, default: 'date' },
      showTime: { type: Boolean },
      timePickerProps: { type: Object },
      currentView: { type: String },
      dateRender: { type: Function },
      disabled: { type: Boolean },
      onHeaderLabelClick: { type: Function },
    },
    emits: [
      'select',
      'time-picker-select',
      'cell-mouse-enter',
      'current-view-change',
      'update:currentView',
    ],
    setup(e, { emit: t }) {
      const {
          isRange: n,
          headerValue: r,
          footerValue: i,
          dayStartOfWeek: o,
          isSameTime: a,
          mode: s,
          showTime: l,
          currentView: c,
          disabledTime: d,
        } = tt(e),
        h = Qd(),
        p = C(() => (s == null ? void 0 : s.value) === 'week'),
        v = C(() => ye(p.value ? 'panel-week' : 'panel-date')),
        g = ye('picker'),
        [_, b] = Er('date', Je({ value: c })),
        y = C(() => l.value && n.value),
        M = C(() => !l.value || !y.value || _.value === 'date'),
        x = C(() => l.value && (!y.value || _.value === 'time')),
        w = C(() => [v.value, { [`${v.value}-with-view-tabs`]: y.value }]),
        E = C(() => r.value.format('YYYY-MM')),
        P = C(() => {
          var N
          return (
            (l.value &&
              ((N = d == null ? void 0 : d.value) == null
                ? void 0
                : N.call(d, wi((i == null ? void 0 : i.value) || Nr())))) ||
            {}
          )
        }),
        A = C(() => {
          const N = [0, 1, 2, 3, 4, 5, 6],
            I = Math.max(o.value % 7, 0)
          return [...N.slice(I), ...N.slice(0, I)]
        }),
        F = C(() => {
          const N = ur.startOf(r.value, 'month'),
            I = N.day(),
            B = N.daysInMonth(),
            V = A.value.indexOf(I),
            L = qu(qW)
          for (let Y = 0; Y < L.length; Y++)
            L[Y] = Ik(pp({}, XW(ur.add(N, Y - V, 'day'))), {
              isPrev: Y < V,
              isNext: Y > V + B - 1,
            })
          return qu(Rk).map((Y, U) => {
            const le = L.slice(U * wb, (U + 1) * wb)
            if (p.value) {
              const q = le[0].value
              le.unshift({ label: q.week(), value: q })
            }
            return le
          })
        }),
        T = C(
          () => (a == null ? void 0 : a.value) || ((N, I) => N.isSame(I, 'day'))
        )
      function k(N) {
        t('select', N.value)
      }
      function R(N) {
        t('time-picker-select', N)
      }
      function j(N) {
        t('cell-mouse-enter', N.value)
      }
      return {
        prefixCls: v,
        classNames: w,
        pickerPrefixCls: g,
        headerTitle: E,
        rows: F,
        weekList: C(() => (p.value ? [-1, ...A.value] : A.value)),
        mergedIsSameTime: T,
        disabledTimeProps: P,
        onCellClick: k,
        onCellMouseEnter: j,
        onTimePanelSelect: R,
        showViewTabs: y,
        showDateView: M,
        showTimeView: x,
        changeViewTo: (N) => {
          t('current-view-change', N), t('update:currentView', N), b(N)
        },
        datePickerT: h,
      }
    },
  })
  function ZW(e, t, n, r, i, o) {
    const a = ge('PanelHeader'),
      s = ge('PanelWeekList'),
      l = ge('PanelBody'),
      c = ge('TimePanel'),
      d = ge('IconCalendar'),
      h = ge('IconClockCircle')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.showDateView
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-inner`) },
                [
                  m(
                    a,
                    Fe(
                      Ik(pp({}, e.headerOperations), { icons: e.headerIcons }),
                      {
                        'prefix-cls': e.pickerPrefixCls,
                        title: e.headerTitle,
                        mode: e.mode,
                        value: e.headerValue,
                        'on-label-click': e.onHeaderLabelClick,
                      }
                    ),
                    null,
                    16,
                    ['prefix-cls', 'title', 'mode', 'value', 'on-label-click']
                  ),
                  m(
                    s,
                    {
                      'prefix-cls': e.pickerPrefixCls,
                      'week-list': e.weekList,
                    },
                    null,
                    8,
                    ['prefix-cls', 'week-list']
                  ),
                  m(
                    l,
                    {
                      mode: e.mode,
                      'prefix-cls': e.pickerPrefixCls,
                      rows: e.rows,
                      value: e.isRange ? void 0 : e.value,
                      'range-values': e.rangeValues,
                      'disabled-date': e.disabledDate,
                      'is-same-time': e.mergedIsSameTime,
                      'date-render': e.dateRender,
                      onCellClick: e.onCellClick,
                      onCellMouseEnter: e.onCellMouseEnter,
                    },
                    null,
                    8,
                    [
                      'mode',
                      'prefix-cls',
                      'rows',
                      'value',
                      'range-values',
                      'disabled-date',
                      'is-same-time',
                      'date-render',
                      'onCellClick',
                      'onCellMouseEnter',
                    ]
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          e.showTimeView
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-timepicker`) },
                [
                  Se(
                    'header',
                    { class: H(`${e.prefixCls}-timepicker-title`) },
                    mt(e.datePickerT('datePicker.selectTime')),
                    3
                  ),
                  m(
                    c,
                    Fe(pp(pp({}, e.timePickerProps), e.disabledTimeProps), {
                      'hide-footer': '',
                      value: e.value || e.isRange ? e.timePickerValue : void 0,
                      disabled: e.disabled,
                      onSelect: e.onTimePanelSelect,
                    }),
                    null,
                    16,
                    ['value', 'disabled', 'onSelect']
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          e.showViewTabs
            ? (O(),
              Z(
                'div',
                { key: 2, class: H(`${e.prefixCls}-footer`) },
                [
                  Se(
                    'div',
                    { class: H(`${e.prefixCls}-view-tabs`) },
                    [
                      Se(
                        'div',
                        {
                          class: H([
                            `${e.prefixCls}-view-tab-pane`,
                            {
                              [`${e.prefixCls}-view-tab-pane-active`]:
                                e.showDateView,
                            },
                          ]),
                          onClick:
                            t[0] || (t[0] = () => e.changeViewTo('date')),
                        },
                        [
                          m(d),
                          Se(
                            'span',
                            { class: H(`${e.prefixCls}-view-tab-pane-text`) },
                            mt(
                              e.footerValue &&
                                e.footerValue.format('YYYY-MM-DD')
                            ),
                            3
                          ),
                        ],
                        2
                      ),
                      Se(
                        'div',
                        {
                          class: H([
                            `${e.prefixCls}-view-tab-pane`,
                            {
                              [`${e.prefixCls}-view-tab-pane-active`]:
                                e.showTimeView,
                            },
                          ]),
                          onClick:
                            t[1] || (t[1] = () => e.changeViewTo('time')),
                        },
                        [
                          m(h),
                          Se(
                            'span',
                            { class: H(`${e.prefixCls}-view-tab-pane-text`) },
                            mt(
                              e.timePickerValue &&
                                e.timePickerValue.format('HH:mm:ss')
                            ),
                            3
                          ),
                        ],
                        2
                      ),
                    ],
                    2
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var rS = Te(YW, [['render', ZW]])
  const JW = ce({
    name: 'WeekPanel',
    components: { DatePanel: rS },
    props: { dayStartOfWeek: { type: Number, default: 0 } },
    emits: ['select', 'cell-mouse-enter'],
    setup(e, { emit: t }) {
      const { locale: n } = Vn()
      return {
        isSameTime: (i, o) => ur.isSameWeek(i, o, e.dayStartOfWeek, n.value),
        onSelect: (i) => {
          const o = ur.startOf(i, 'week')
          t('select', o)
        },
        onCellMouseEnter: (i) => {
          const o = ur.startOf(i, 'week')
          t('cell-mouse-enter', o)
        },
      }
    },
  })
  function QW(e, t, n, r, i, o) {
    const a = ge('DatePanel')
    return (
      O(),
      Ee(
        a,
        Fe(e.$attrs, {
          mode: 'week',
          'is-week': '',
          'day-start-of-week': e.dayStartOfWeek,
          'is-same-time': e.isSameTime,
          onSelect: e.onSelect,
          onCellMouseEnter: e.onCellMouseEnter,
        }),
        null,
        16,
        ['day-start-of-week', 'is-same-time', 'onSelect', 'onCellMouseEnter']
      )
    )
  }
  var Dk = Te(JW, [['render', QW]]),
    ej = Object.defineProperty,
    tj = Object.defineProperties,
    nj = Object.getOwnPropertyDescriptors,
    Gx = Object.getOwnPropertySymbols,
    rj = Object.prototype.hasOwnProperty,
    ij = Object.prototype.propertyIsEnumerable,
    Kx = (e, t, n) =>
      t in e
        ? ej(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    oj = (e, t) => {
      for (var n in t || (t = {})) rj.call(t, n) && Kx(e, n, t[n])
      if (Gx) for (var n of Gx(t)) ij.call(t, n) && Kx(e, n, t[n])
      return e
    },
    aj = (e, t) => tj(e, nj(t))
  const sj = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ],
    lj = 12,
    uj = 4,
    qx = 3,
    cj = ce({
      name: 'MonthPanel',
      components: { PanelHeader: em, PanelBody: tm },
      props: {
        headerValue: { type: Object, required: !0 },
        headerOperations: { type: Object, default: () => ({}) },
        headerIcons: { type: Object, default: () => ({}) },
        value: { type: Object },
        disabledDate: { type: Function },
        rangeValues: { type: Array },
        dateRender: { type: Function },
        onHeaderLabelClick: { type: Function },
        abbreviation: { type: Boolean, default: !0 },
      },
      emits: ['select', 'cell-mouse-enter'],
      setup(e, { emit: t }) {
        const n = Qd(),
          { headerValue: r } = tt(e),
          i = C(() => ye('panel-month')),
          o = ye('picker'),
          a = C(() => r.value.format('YYYY')),
          s = C(() => {
            const h = r.value.year(),
              p = e.abbreviation ? 'short' : 'long',
              v = qu(lj).map((_, b) => ({
                label: n(`datePicker.month.${p}.${sj[b]}`),
                value: nr(`${h}-${b + 1}`, 'YYYY-M'),
              }))
            return qu(uj).map((_, b) => v.slice(b * qx, (b + 1) * qx))
          }),
          l = (h, p) => h.isSame(p, 'month')
        function c(h) {
          t('select', h.value)
        }
        function d(h) {
          t('cell-mouse-enter', h.value)
        }
        return {
          prefixCls: i,
          pickerPrefixCls: o,
          headerTitle: a,
          rows: s,
          isSameTime: l,
          onCellClick: c,
          onCellMouseEnter: d,
        }
      },
    })
  function dj(e, t, n, r, i, o) {
    const a = ge('PanelHeader'),
      s = ge('PanelBody')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-inner`) },
            [
              m(
                a,
                Fe(aj(oj({}, e.headerOperations), { icons: e.headerIcons }), {
                  'prefix-cls': e.pickerPrefixCls,
                  title: e.headerTitle,
                  mode: 'month',
                  value: e.headerValue,
                  'on-label-click': e.onHeaderLabelClick,
                }),
                null,
                16,
                ['prefix-cls', 'title', 'value', 'on-label-click']
              ),
              m(
                s,
                {
                  mode: 'month',
                  'prefix-cls': e.pickerPrefixCls,
                  rows: e.rows,
                  value: e.value,
                  'range-values': e.rangeValues,
                  'disabled-date': e.disabledDate,
                  'is-same-time': e.isSameTime,
                  'date-render': e.dateRender,
                  onCellClick: e.onCellClick,
                  onCellMouseEnter: e.onCellMouseEnter,
                },
                null,
                8,
                [
                  'prefix-cls',
                  'rows',
                  'value',
                  'range-values',
                  'disabled-date',
                  'is-same-time',
                  'date-render',
                  'onCellClick',
                  'onCellMouseEnter',
                ]
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Nk = Te(cj, [['render', dj]]),
    fj = Object.defineProperty,
    hj = Object.defineProperties,
    pj = Object.getOwnPropertyDescriptors,
    Xx = Object.getOwnPropertySymbols,
    vj = Object.prototype.hasOwnProperty,
    mj = Object.prototype.propertyIsEnumerable,
    Yx = (e, t, n) =>
      t in e
        ? fj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    gj = (e, t) => {
      for (var n in t || (t = {})) vj.call(t, n) && Yx(e, n, t[n])
      if (Xx) for (var n of Xx(t)) mj.call(t, n) && Yx(e, n, t[n])
      return e
    },
    yj = (e, t) => hj(e, pj(t))
  const xb = 4,
    vp = 3,
    bj = xb * vp,
    D0 = 10,
    _j = ce({
      name: 'YearPanel',
      components: { PanelHeader: em, PanelBody: tm },
      props: {
        headerValue: { type: Object, required: !0 },
        headerOperations: { type: Object, default: () => ({}) },
        headerIcons: { type: Object, default: () => ({}) },
        value: { type: Object },
        disabledDate: { type: Function },
        rangeValues: { type: Array },
        dateRender: { type: Function },
      },
      emits: ['select', 'cell-mouse-enter'],
      setup(e, { emit: t }) {
        const { headerValue: n } = tt(e),
          r = C(() => ye('panel-year')),
          i = ye('picker'),
          o = C(() => {
            const d = Math.floor(n.value.year() / D0) * D0 - 1,
              h = qu(bj).map((v, g) => ({
                label: d + g,
                value: nr(`${d + g}`, 'YYYY'),
                isPrev: g < 1,
                isNext: g > D0,
              }))
            return qu(xb).map((v, g) => h.slice(g * vp, (g + 1) * vp))
          }),
          a = C(
            () => `${o.value[0][1].label}-${o.value[xb - 1][vp - 1].label}`
          ),
          s = (d, h) => d.isSame(h, 'year')
        function l(d) {
          t('select', d.value)
        }
        function c(d) {
          t('cell-mouse-enter', d.value)
        }
        return {
          prefixCls: r,
          pickerPrefixCls: i,
          headerTitle: a,
          rows: o,
          isSameTime: s,
          onCellClick: l,
          onCellMouseEnter: c,
        }
      },
    })
  function Sj(e, t, n, r, i, o) {
    const a = ge('PanelHeader'),
      s = ge('PanelBody')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-inner`) },
            [
              m(
                a,
                Fe(yj(gj({}, e.headerOperations), { icons: e.headerIcons }), {
                  'prefix-cls': e.pickerPrefixCls,
                  title: e.headerTitle,
                }),
                null,
                16,
                ['prefix-cls', 'title']
              ),
              m(
                s,
                {
                  mode: 'year',
                  'prefix-cls': e.pickerPrefixCls,
                  rows: e.rows,
                  value: e.value,
                  'range-values': e.rangeValues,
                  'disabled-date': e.disabledDate,
                  'is-same-time': e.isSameTime,
                  'date-render': e.dateRender,
                  onCellClick: e.onCellClick,
                  onCellMouseEnter: e.onCellMouseEnter,
                },
                null,
                8,
                [
                  'prefix-cls',
                  'rows',
                  'value',
                  'range-values',
                  'disabled-date',
                  'is-same-time',
                  'date-render',
                  'onCellClick',
                  'onCellMouseEnter',
                ]
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Bk = Te(_j, [['render', Sj]]),
    Cj = Object.defineProperty,
    wj = Object.defineProperties,
    xj = Object.getOwnPropertyDescriptors,
    Zx = Object.getOwnPropertySymbols,
    Mj = Object.prototype.hasOwnProperty,
    Ej = Object.prototype.propertyIsEnumerable,
    Jx = (e, t, n) =>
      t in e
        ? Cj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    Pj = (e, t) => {
      for (var n in t || (t = {})) Mj.call(t, n) && Jx(e, n, t[n])
      if (Zx) for (var n of Zx(t)) Ej.call(t, n) && Jx(e, n, t[n])
      return e
    },
    Tj = (e, t) => wj(e, xj(t))
  const kj = ce({
    name: 'QuarterPanel',
    components: { PanelHeader: em, PanelBody: tm },
    props: {
      headerValue: { type: Object, required: !0 },
      headerOperations: { type: Object, default: () => ({}) },
      headerIcons: { type: Object, default: () => ({}) },
      value: { type: Object },
      disabledDate: { type: Function },
      rangeValues: { type: Array },
      dateRender: { type: Function },
      onHeaderLabelClick: { type: Function },
    },
    emits: ['select', 'cell-mouse-enter'],
    setup(e, { emit: t }) {
      const { headerValue: n } = tt(e),
        r = C(() => ye('panel-quarter')),
        i = ye('picker'),
        o = C(() => n.value.format('YYYY')),
        a = C(() => {
          const d = n.value.year()
          return [
            [1, 2, 3, 4].map((h) => ({
              label: `Q${h}`,
              value: nr(`${d}-${vl((h - 1) * 3 + 1, 2, '0')}-01`),
            })),
          ]
        }),
        s = (d, h) =>
          d.isSame(h, 'month') ||
          (d.isSame(h, 'year') &&
            Math.floor(d.month() / 3) === Math.floor(h.month() / 3))
      function l(d) {
        t('select', d.value)
      }
      function c(d) {
        t('cell-mouse-enter', d.value)
      }
      return {
        prefixCls: r,
        pickerPrefixCls: i,
        headerTitle: o,
        rows: a,
        isSameTime: s,
        onCellClick: l,
        onCellMouseEnter: c,
      }
    },
  })
  function Aj(e, t, n, r, i, o) {
    const a = ge('PanelHeader'),
      s = ge('PanelBody')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-inner`) },
            [
              m(
                a,
                Fe(Tj(Pj({}, e.headerOperations), { icons: e.headerIcons }), {
                  'prefix-cls': e.pickerPrefixCls,
                  title: e.headerTitle,
                  mode: 'quarter',
                  value: e.headerValue,
                  'on-label-click': e.onHeaderLabelClick,
                }),
                null,
                16,
                ['prefix-cls', 'title', 'value', 'on-label-click']
              ),
              m(
                s,
                {
                  mode: 'quarter',
                  'prefix-cls': e.pickerPrefixCls,
                  rows: e.rows,
                  value: e.value,
                  'range-values': e.rangeValues,
                  'disabled-date': e.disabledDate,
                  'is-same-time': e.isSameTime,
                  'date-render': e.dateRender,
                  onCellClick: e.onCellClick,
                  onCellMouseEnter: e.onCellMouseEnter,
                },
                null,
                8,
                [
                  'prefix-cls',
                  'rows',
                  'value',
                  'range-values',
                  'disabled-date',
                  'is-same-time',
                  'date-render',
                  'onCellClick',
                  'onCellMouseEnter',
                ]
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Fk = Te(kj, [['render', Aj]])
  const $j = ce({
      name: 'IconLink',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-link`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Oj = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Lj = Se(
      'path',
      {
        d: 'm14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485',
      },
      null,
      -1
    ),
    Ij = [Lj]
  function Rj(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Ij,
        14,
        Oj
      )
    )
  }
  var N0 = Te($j, [['render', Rj]])
  const Dj = Object.assign(N0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + N0.name, N0)
      },
    }),
    Nj = ce({
      name: 'Link',
      components: { IconLink: Dj, IconLoading: Xr },
      props: {
        href: String,
        status: { type: String, default: 'normal' },
        hoverable: { type: Boolean, default: !0 },
        icon: Boolean,
        loading: Boolean,
        disabled: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { slots: t, emit: n }) {
        const r = ye('link'),
          i = Pk(e, t, 'icon'),
          o = (s) => {
            if (e.disabled || e.loading) {
              s.preventDefault()
              return
            }
            n('click', s)
          }
        return {
          cls: C(() => [
            r,
            `${r}-status-${e.status}`,
            {
              [`${r}-disabled`]: e.disabled,
              [`${r}-loading`]: e.loading,
              [`${r}-hoverless`]: !e.hoverable,
              [`${r}-with-icon`]: e.loading || i.value,
            },
          ]),
          prefixCls: r,
          showIcon: i,
          handleClick: o,
        }
      },
    }),
    Bj = ['href']
  function Fj(e, t, n, r, i, o) {
    const a = ge('icon-loading'),
      s = ge('icon-link')
    return (
      O(),
      Z(
        'a',
        {
          href: e.disabled ? void 0 : e.href,
          class: H(e.cls),
          onClick:
            t[0] || (t[0] = (...l) => e.handleClick && e.handleClick(...l)),
        },
        [
          e.loading || e.showIcon
            ? (O(),
              Z(
                'span',
                { key: 0, class: H(`${e.prefixCls}-icon`) },
                [
                  e.loading
                    ? (O(), Ee(a, { key: 0 }))
                    : ve(e.$slots, 'icon', { key: 1 }, () => [m(s)]),
                ],
                2
              ))
            : Ce('v-if', !0),
          ve(e.$slots, 'default'),
        ],
        10,
        Bj
      )
    )
  }
  var B0 = Te(Nj, [['render', Fj]])
  const zk = Object.assign(B0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + B0.name, B0)
      },
    }),
    zj = ce({
      name: 'PanelFooter',
      components: { Link: zk, Button: Yr },
      props: {
        prefixCls: { type: String, required: !0 },
        showTodayBtn: { type: Boolean },
        showConfirmBtn: { type: Boolean },
        confirmBtnDisabled: { type: Boolean },
      },
      emits: ['today-btn-click', 'confirm-btn-click'],
      setup(e, { emit: t }) {
        return {
          datePickerT: Qd(),
          onTodayClick: () => {
            t('today-btn-click')
          },
          onConfirmBtnClick: () => {
            t('confirm-btn-click')
          },
        }
      },
    })
  function Vj(e, t, n, r, i, o) {
    const a = ge('Link'),
      s = ge('Button')
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-footer`) },
        [
          e.$slots.extra
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-footer-extra-wrapper`) },
                [ve(e.$slots, 'extra')],
                2
              ))
            : Ce('v-if', !0),
          e.showTodayBtn
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-footer-now-wrapper`) },
                [
                  m(
                    a,
                    { onClick: e.onTodayClick },
                    {
                      default: ze(() => [
                        Lt(mt(e.datePickerT('datePicker.today')), 1),
                      ]),
                      _: 1,
                    },
                    8,
                    ['onClick']
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          e.$slots.btn || e.showConfirmBtn
            ? (O(),
              Z(
                'div',
                { key: 2, class: H(`${e.prefixCls}-footer-btn-wrapper`) },
                [
                  ve(e.$slots, 'btn'),
                  e.showConfirmBtn
                    ? (O(),
                      Ee(
                        s,
                        {
                          key: 0,
                          class: H(`${e.prefixCls}-btn-confirm`),
                          type: 'primary',
                          size: 'mini',
                          disabled: e.confirmBtnDisabled,
                          onClick: e.onConfirmBtnClick,
                        },
                        {
                          default: ze(() => [
                            Lt(mt(e.datePickerT('datePicker.ok')), 1),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'disabled', 'onClick']
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Vk = Te(zj, [['render', Vj]])
  function Uk(e) {
    const { mode: t } = tt(e),
      n = C(
        () =>
          ({ date: 1, week: 1, year: 10 * 12, quarter: 12, month: 12 }[t.value])
      ),
      r = C(() => (['year'].includes(t.value) ? 10 * 12 : 12))
    return { span: n, superSpan: r }
  }
  function dv(e) {
    const {
        mode: t,
        value: n,
        defaultValue: r,
        selectedValue: i,
        format: o,
        onChange: a,
      } = tt(e),
      s = C(() => (t == null ? void 0 : t.value) || 'date'),
      { span: l, superSpan: c } = Uk(Je({ mode: s })),
      d = (E, P) => {
        const A = s.value === 'date' || s.value === 'week' ? 'M' : 'y'
        return E.isSame(P, A)
      },
      h = C(() => Hi(n == null ? void 0 : n.value, o.value)),
      p = C(() => Hi(r == null ? void 0 : r.value, o.value)),
      v = J(p.value || Nr()),
      g = C(() => h.value || v.value),
      _ = (E) => {
        E && (v.value = E)
      },
      b = (E, P = !0) => {
        var A
        E &&
          (P &&
            !d(g.value, E) &&
            ((A = a == null ? void 0 : a.value) == null || A.call(a, E)),
          _(E))
      }
    i != null && i.value && _(i.value),
      pt(
        () => (i == null ? void 0 : i.value),
        (E) => {
          b(E)
        }
      )
    function y() {
      return (i == null ? void 0 : i.value) || p.value || Nr()
    }
    function M(E = !0) {
      const P = y()
      E ? b(P) : _(P)
    }
    const x = C(() => l.value !== c.value),
      w = C(() => ({
        onSuperPrev: () => {
          b(ur.subtract(g.value, c.value, 'M'))
        },
        onPrev: x.value
          ? () => {
              b(ur.subtract(g.value, l.value, 'M'))
            }
          : void 0,
        onNext: x.value
          ? () => {
              b(ur.add(g.value, l.value, 'M'))
            }
          : void 0,
        onSuperNext: () => {
          b(ur.add(g.value, c.value, 'M'))
        },
      }))
    return {
      headerValue: g,
      setHeaderValue: b,
      headerOperations: w,
      resetHeaderValue: M,
      getDefaultLocalValue: y,
    }
  }
  const Uj = ce({
    name: 'DatePikerPanel',
    components: {
      DatePanel: rS,
      PanelShortcuts: Ak,
      PanelFooter: Vk,
      WeekPanel: Dk,
      MonthPanel: Nk,
      YearPanel: Bk,
      QuarterPanel: Fk,
      RenderFunction: Ga,
    },
    props: {
      mode: { type: String },
      headerMode: { type: String },
      prefixCls: { type: String, required: !0 },
      value: { type: Object },
      headerValue: { type: Object, required: !0 },
      timePickerValue: { type: Object },
      showTime: { type: Boolean },
      showConfirmBtn: { type: Boolean },
      shortcuts: { type: Array, default: () => [] },
      shortcutsPosition: { type: String, default: 'bottom' },
      format: { type: String, required: !0 },
      dayStartOfWeek: { type: Number, default: 0 },
      disabledDate: { type: Function },
      disabledTime: { type: Function },
      timePickerProps: { type: Object },
      extra: { type: Function },
      dateRender: { type: Function },
      hideTrigger: { type: Boolean },
      confirmBtnDisabled: { type: Boolean },
      showNowBtn: { type: Boolean },
      headerIcons: { type: Object, default: () => ({}) },
      headerOperations: { type: Object },
      abbreviation: { type: Boolean },
    },
    emits: [
      'cell-click',
      'time-picker-select',
      'shortcut-click',
      'shortcut-mouse-enter',
      'shortcut-mouse-leave',
      'confirm',
      'today-btn-click',
      'header-label-click',
      'header-select',
      'month-header-click',
    ],
    setup(e, { emit: t }) {
      const {
          prefixCls: n,
          shortcuts: r,
          shortcutsPosition: i,
          format: o,
          value: a,
          disabledDate: s,
          hideTrigger: l,
          showNowBtn: c,
          dateRender: d,
          showConfirmBtn: h,
          headerValue: p,
          headerIcons: v,
          headerOperations: g,
          headerMode: _,
        } = tt(e),
        b = C(() => !!(r.value && r.value.length)),
        y = C(() => c.value && h.value && !b.value),
        M = C(() => y.value || b.value),
        x = C(() => M.value && i.value === 'left'),
        w = C(() => M.value && i.value === 'right'),
        E = C(() => M.value && i.value === 'bottom'),
        P = C(() => [
          `${n.value}-container`,
          {
            [`${n.value}-container-panel-only`]: l.value,
            [`${n.value}-container-shortcuts-placement-left`]: x.value,
            [`${n.value}-container-shortcuts-placement-right`]: w.value,
          },
        ]),
        A = C(() => (a == null ? void 0 : a.value) || Nr()),
        {
          headerValue: F,
          setHeaderValue: T,
          headerOperations: k,
        } = dv(Je({ mode: _, format: o }))
      pt(p, (te) => {
        T(te)
      })
      function R(te) {
        const { value: ue } = te
        return Hi(xt(ue) ? ue() : ue, te.format || o.value)
      }
      function j(te) {
        t('shortcut-click', R(te), te)
      }
      function N(te) {
        t('shortcut-mouse-enter', R(te))
      }
      function I(te) {
        t('shortcut-mouse-leave', R(te))
      }
      function B(te) {
        t('cell-click', te)
      }
      function V(te) {
        t('time-picker-select', te)
      }
      function L() {
        t('today-btn-click', Nr())
      }
      function W() {
        t('confirm')
      }
      function Y(te) {
        t('header-label-click', te)
      }
      function U(te) {
        t('header-select', te)
      }
      function le() {
        t('month-header-click')
      }
      const q = Je({
          prefixCls: n,
          shortcuts: r,
          showNowBtn: y,
          onItemClick: j,
          onItemMouseEnter: N,
          onItemMouseLeave: I,
          onNowClick: L,
        }),
        oe = Je({
          value: a,
          headerValue: p,
          headerIcons: v,
          headerOperations: g,
          disabledDate: s,
          dateRender: d,
          onSelect: B,
          onHeaderLabelClick: Y,
        })
      return {
        classNames: P,
        showShortcutsInLeft: x,
        showShortcutsInRight: w,
        showShortcutsInBottom: E,
        shortcutsProps: q,
        commonPanelProps: oe,
        footerValue: A,
        onTodayBtnClick: L,
        onConfirmBtnClick: W,
        onTimePickerSelect: V,
        onHeaderPanelSelect: U,
        headerPanelHeaderValue: F,
        headerPanelHeaderOperations: k,
        onMonthHeaderLabelClick: le,
      }
    },
  })
  function Hj(e, t, n, r, i, o) {
    const a = ge('PanelShortcuts'),
      s = ge('YearPanel'),
      l = ge('MonthPanel'),
      c = ge('WeekPanel'),
      d = ge('QuarterPanel'),
      h = ge('DatePanel'),
      p = ge('RenderFunction'),
      v = ge('PanelFooter')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.showShortcutsInLeft
            ? (O(), Ee(a, En(Fe({ key: 0 }, e.shortcutsProps)), null, 16))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-panel-wrapper`) },
            [
              e.headerMode
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      e.headerMode === 'year'
                        ? (O(),
                          Ee(
                            s,
                            {
                              key: 0,
                              'header-value': e.headerPanelHeaderValue,
                              'header-icons': e.headerIcons,
                              'header-operations':
                                e.headerPanelHeaderOperations,
                              onSelect: e.onHeaderPanelSelect,
                            },
                            null,
                            8,
                            [
                              'header-value',
                              'header-icons',
                              'header-operations',
                              'onSelect',
                            ]
                          ))
                        : e.headerMode === 'month'
                        ? (O(),
                          Ee(
                            l,
                            {
                              key: 1,
                              'header-value': e.headerPanelHeaderValue,
                              'header-icons': e.headerIcons,
                              'header-operations':
                                e.headerPanelHeaderOperations,
                              abbreviation: e.abbreviation,
                              onSelect: e.onHeaderPanelSelect,
                              onHeaderLabelClick: e.onMonthHeaderLabelClick,
                            },
                            null,
                            8,
                            [
                              'header-value',
                              'header-icons',
                              'header-operations',
                              'abbreviation',
                              'onSelect',
                              'onHeaderLabelClick',
                            ]
                          ))
                        : Ce('v-if', !0),
                    ],
                    2112
                  ))
                : (O(),
                  Z(
                    yt,
                    { key: 1 },
                    [
                      e.mode === 'week'
                        ? (O(),
                          Ee(
                            c,
                            Fe({ key: 0 }, e.commonPanelProps, {
                              'day-start-of-week': e.dayStartOfWeek,
                            }),
                            null,
                            16,
                            ['day-start-of-week']
                          ))
                        : e.mode === 'month'
                        ? (O(),
                          Ee(
                            l,
                            Fe(
                              { key: 1, abbreviation: e.abbreviation },
                              e.commonPanelProps
                            ),
                            null,
                            16,
                            ['abbreviation']
                          ))
                        : e.mode === 'year'
                        ? (O(),
                          Ee(
                            s,
                            En(Fe({ key: 2 }, e.commonPanelProps)),
                            null,
                            16
                          ))
                        : e.mode === 'quarter'
                        ? (O(),
                          Ee(
                            d,
                            En(Fe({ key: 3 }, e.commonPanelProps)),
                            null,
                            16
                          ))
                        : (O(),
                          Ee(
                            h,
                            Fe({ key: 4 }, e.commonPanelProps, {
                              mode: 'date',
                              'show-time': e.showTime,
                              'time-picker-props': e.timePickerProps,
                              'day-start-of-week': e.dayStartOfWeek,
                              'footer-value': e.footerValue,
                              'time-picker-value': e.timePickerValue,
                              'disabled-time': e.disabledTime,
                              onTimePickerSelect: e.onTimePickerSelect,
                            }),
                            null,
                            16,
                            [
                              'show-time',
                              'time-picker-props',
                              'day-start-of-week',
                              'footer-value',
                              'time-picker-value',
                              'disabled-time',
                              'onTimePickerSelect',
                            ]
                          )),
                      m(
                        v,
                        {
                          'prefix-cls': e.prefixCls,
                          'show-today-btn':
                            e.showNowBtn &&
                            !(e.showConfirmBtn || e.showShortcutsInBottom),
                          'show-confirm-btn': e.showConfirmBtn,
                          'confirm-btn-disabled': e.confirmBtnDisabled,
                          onTodayBtnClick: e.onTodayBtnClick,
                          onConfirmBtnClick: e.onConfirmBtnClick,
                        },
                        Nn({ _: 2 }, [
                          e.extra
                            ? {
                                name: 'extra',
                                fn: ze(() => [
                                  e.extra
                                    ? (O(),
                                      Ee(
                                        p,
                                        { key: 0, 'render-func': e.extra },
                                        null,
                                        8,
                                        ['render-func']
                                      ))
                                    : Ce('v-if', !0),
                                ]),
                              }
                            : void 0,
                          e.showShortcutsInBottom
                            ? {
                                name: 'btn',
                                fn: ze(() => [
                                  m(a, En(Rr(e.shortcutsProps)), null, 16),
                                ]),
                              }
                            : void 0,
                        ]),
                        1032,
                        [
                          'prefix-cls',
                          'show-today-btn',
                          'show-confirm-btn',
                          'confirm-btn-disabled',
                          'onTodayBtnClick',
                          'onConfirmBtnClick',
                        ]
                      ),
                    ],
                    64
                  )),
            ],
            2
          ),
          e.showShortcutsInRight
            ? (O(), Ee(a, En(Fe({ key: 1 }, e.shortcutsProps)), null, 16))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Wj = Te(Uj, [['render', Hj]])
  function jj(e = 'date', t = !1) {
    switch (e) {
      case 'date':
        return t ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD'
      case 'month':
        return 'YYYY-MM'
      case 'year':
        return 'YYYY'
      case 'week':
        return 'gggg-wo'
      case 'quarter':
        return 'YYYY-[Q]Q'
      default:
        return 'YYYY-MM-DD'
    }
  }
  function Gj(e = 'date', t = !1) {
    switch (e) {
      case 'date':
        return t ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD'
      case 'month':
        return 'YYYY-MM'
      case 'year':
        return 'YYYY'
      case 'week':
        return 'YYYY-MM-DD'
      case 'quarter':
        return 'YYYY-MM'
      default:
        return 'YYYY-MM-DD'
    }
  }
  function Hk(e) {
    const { format: t, mode: n, showTime: r, valueFormat: i } = tt(e),
      o = C(
        () =>
          (!xt(t == null ? void 0 : t.value) &&
            (t == null ? void 0 : t.value)) ||
          jj(n == null ? void 0 : n.value, r == null ? void 0 : r.value)
      ),
      a = C(
        () =>
          (i == null ? void 0 : i.value) ||
          Gj(n == null ? void 0 : n.value, r == null ? void 0 : r.value)
      ),
      s = C(() => (['timestamp', 'Date'].includes(a.value) ? o.value : a.value))
    return { format: o, valueFormat: a, parseValueFormat: s }
  }
  function Wk(e) {
    const {
        mode: t,
        showTime: n,
        disabledDate: r,
        disabledTime: i,
        isRange: o,
      } = tt(e),
      a = C(
        () =>
          (t == null ? void 0 : t.value) === 'date' &&
          (n == null ? void 0 : n.value)
      ),
      s = C(() => (d, h) => {
        if (!(r != null && r.value)) return !1
        const p = wi(d)
        return o != null && o.value ? r.value(p, h) : r.value(p)
      }),
      l = (d, h) => ((h == null ? void 0 : h()) || []).includes(d),
      c = C(() => (d, h) => {
        if (!a.value || !(i != null && i.value)) return !1
        const p = wi(d),
          v = o != null && o.value ? i.value(p, h) : i.value(p)
        return (
          l(d.hour(), v.disabledHours) ||
          l(d.minute(), v.disabledMinutes) ||
          l(d.second(), v.disabledSeconds)
        )
      })
    return function (h, p) {
      return h && (s.value(h, p || 'start') || c.value(h, p || 'start'))
    }
  }
  const ml = (e, t) => {
      if (!e || !t) return
      t = t.replace(/\[(\w+)\]/g, '.$1')
      const n = t.split('.')
      if (n.length === 0) return
      let r = e
      for (let i = 0; i < n.length; i++) {
        if ((!Ht(r) && !Ft(r)) || !n[i]) return
        if (i !== n.length - 1) r = r[n[i]]
        else return r[n[i]]
      }
    },
    fv = (e, t, n, { addPath: r } = {}) => {
      if (!e || !t) return
      t = t.replace(/\[(\w+)\]/g, '.$1')
      const i = t.split('.')
      if (i.length === 0) return
      let o = e
      for (let a = 0; a < i.length; a++) {
        if ((!Ht(o) && !Ft(o)) || !i[a]) return
        a !== i.length - 1
          ? (r && Mt(o[i[a]]) && (o[i[a]] = {}), (o = o[i[a]]))
          : (o[i[a]] = n)
      }
    }
  function jk(e) {
    const { locale: t } = tt(e),
      { locale: n, t: r } = Vn()
    nr.locale(n.value.toLowerCase())
    const i = (o, ...a) => {
      const s = o.startsWith('datePicker.')
        ? o.split('.').slice(1).join('.')
        : o
      return ml((t == null ? void 0 : t.value) || {}, s) || r(o, ...a)
    }
    return sn(kk, { datePickerT: i }), i
  }
  function Mb(e) {
    const { timePickerProps: t, selectedValue: n } = tt(e),
      r = C(() => {
        var h
        return (h = t == null ? void 0 : t.value) == null ? void 0 : h.format
      }),
      i = C(() => {
        var h
        return !!((h = t == null ? void 0 : t.value) != null && h.use12Hours)
      }),
      { format: o } = tS(Je({ format: r, use12Hours: i })),
      a = C(() => {
        var h
        return Hi(
          (h = t == null ? void 0 : t.value) == null ? void 0 : h.defaultValue,
          o.value
        )
      }),
      s = () => (n == null ? void 0 : n.value) || a.value || Nr(),
      l = J(s())
    function c(h) {
      h && (l.value = h)
    }
    function d() {
      l.value = s()
    }
    return (
      pt(n, (h) => {
        c(h)
      }),
      [l, c, d]
    )
  }
  function Gk(e, t) {
    return t === 'timestamp'
      ? e.toDate().getTime()
      : t === 'Date'
      ? e.toDate()
      : e.format(t)
  }
  function Kj(e) {
    const { format: t } = tt(e)
    return (n) => Gk(n, t.value)
  }
  function F0(e, t) {
    return e.map((n) => (n ? Gk(n, t) : void 0))
  }
  var qj = Object.defineProperty,
    Xj = Object.defineProperties,
    Yj = Object.getOwnPropertyDescriptors,
    Qx = Object.getOwnPropertySymbols,
    Zj = Object.prototype.hasOwnProperty,
    Jj = Object.prototype.propertyIsEnumerable,
    eM = (e, t, n) =>
      t in e
        ? qj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    hv = (e, t) => {
      for (var n in t || (t = {})) Zj.call(t, n) && eM(e, n, t[n])
      if (Qx) for (var n of Qx(t)) Jj.call(t, n) && eM(e, n, t[n])
      return e
    },
    tM = (e, t) => Xj(e, Yj(t))
  const Qj = ce({
    name: 'Picker',
    components: {
      DateInput: Tk,
      Trigger: Mr,
      PickerPanel: Wj,
      IconCalendar: nS,
    },
    inheritAttrs: !1,
    props: {
      locale: { type: Object },
      hideTrigger: { type: Boolean },
      allowClear: { type: Boolean, default: !0 },
      readonly: { type: Boolean },
      error: { type: Boolean },
      size: { type: String },
      shortcuts: { type: Array, default: () => [] },
      shortcutsPosition: { type: String, default: 'bottom' },
      position: { type: String, default: 'bl' },
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      triggerProps: { type: Object },
      unmountOnClose: { type: Boolean },
      placeholder: { type: String },
      disabled: { type: Boolean },
      disabledDate: { type: Function },
      disabledTime: { type: Function },
      pickerValue: { type: [Object, String, Number] },
      defaultPickerValue: { type: [Object, String, Number] },
      popupContainer: { type: [String, Object] },
      mode: { type: String, default: 'date' },
      format: { type: [String, Function] },
      valueFormat: { type: String },
      previewShortcut: { type: Boolean, default: !0 },
      showConfirmBtn: { type: Boolean },
      showTime: { type: Boolean },
      timePickerProps: { type: Object },
      showNowBtn: { type: Boolean, default: !0 },
      dayStartOfWeek: { type: Number, default: 0 },
      modelValue: { type: [Object, String, Number] },
      defaultValue: { type: [Object, String, Number] },
      disabledInput: { type: Boolean, default: !1 },
      abbreviation: { type: Boolean, default: !0 },
    },
    emits: {
      change: (e, t, n) => !0,
      'update:modelValue': (e) => !0,
      select: (e, t, n) => !0,
      'popup-visible-change': (e) => !0,
      'update:popupVisible': (e) => !0,
      ok: (e, t, n) => !0,
      clear: () => !0,
      'select-shortcut': (e) => !0,
      'picker-value-change': (e, t, n) => !0,
      'update:pickerValue': (e) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const {
          mode: r,
          modelValue: i,
          defaultValue: o,
          format: a,
          valueFormat: s,
          placeholder: l,
          popupVisible: c,
          defaultPopupVisible: d,
          disabled: h,
          showTime: p,
          timePickerProps: v,
          disabledDate: g,
          disabledTime: _,
          readonly: b,
          locale: y,
          pickerValue: M,
          defaultPickerValue: x,
          dayStartOfWeek: w,
          previewShortcut: E,
          showConfirmBtn: P,
        } = tt(e),
        { locale: A } = Vn()
      pr(() => {
        lk(A.value, w.value)
      })
      const { mergedDisabled: F, eventHandlers: T } = Rn({ disabled: h }),
        k = jk(Je({ locale: y })),
        R = ye('picker'),
        j = J(),
        N = C(
          () =>
            (l == null ? void 0 : l.value) ||
            {
              date: k('datePicker.placeholder.date'),
              month: k('datePicker.placeholder.month'),
              year: k('datePicker.placeholder.year'),
              week: k('datePicker.placeholder.week'),
              quarter: k('datePicker.placeholder.quarter'),
            }[r.value] ||
            k('datePicker.placeholder.date')
        ),
        {
          format: I,
          valueFormat: B,
          parseValueFormat: V,
        } = Hk(Je({ format: a, mode: r, showTime: p, valueFormat: s })),
        L = C(() =>
          a && xt(a.value)
            ? (vt) => {
                var Gt
                return (Gt = a.value) == null ? void 0 : Gt.call(a, wi(vt))
              }
            : I.value
        ),
        W = Kj(Je({ format: B })),
        Y = Wk(Je({ mode: r, disabledDate: g, disabledTime: _, showTime: p })),
        U = C(() => p.value || P.value),
        le = C(() => U.value && (!Ve.value || Y(Ve.value))),
        q = C(() => r.value === 'date' && p.value),
        { value: oe, setValue: te } = XH(
          Je({ modelValue: i, defaultValue: o, format: V })
        ),
        [ue, me] = zi(),
        [Re, qe] = zi(),
        Ve = C(() => {
          var vt
          return (vt = ue.value) != null ? vt : oe.value
        }),
        nt = C(() => {
          var vt, Gt
          return (Gt = (vt = Re.value) != null ? vt : ue.value) != null
            ? Gt
            : oe.value
        }),
        [We, D] = zi(),
        [G, z] = Er(d.value, Je({ value: c })),
        ie = (vt) => {
          G.value !== vt &&
            (z(vt), t('popup-visible-change', vt), t('update:popupVisible', vt))
        },
        {
          headerValue: ae,
          setHeaderValue: re,
          headerOperations: pe,
          resetHeaderValue: we,
        } = dv(
          Je({
            mode: r,
            value: M,
            defaultValue: x,
            selectedValue: nt,
            format: V,
            onChange: (vt) => {
              const Gt = W(vt),
                pn = Jo(vt, V.value),
                yr = wi(vt)
              t('picker-value-change', Gt, yr, pn), t('update:pickerValue', Gt)
            },
          })
        ),
        [$e, , Ae] = Mb(Je({ timePickerProps: v, selectedValue: nt })),
        ft = C(() => !b.value && !xt(L.value)),
        Q = J()
      pt(G, (vt) => {
        me(void 0),
          qe(void 0),
          (Q.value = void 0),
          vt && (we(), Ae()),
          vt || D(void 0)
      })
      function X(vt, Gt) {
        var pn, yr
        const hi = vt ? W(vt) : void 0,
          Qr = Jo(vt, V.value),
          Ur = wi(vt)
        G_(vt, oe.value) &&
          (t('update:modelValue', hi),
          t('change', hi, Ur, Qr),
          (yr = (pn = T.value) == null ? void 0 : pn.onChange) == null ||
            yr.call(pn)),
          Gt && t('ok', hi, Ur, Qr)
      }
      function he(vt, Gt, pn) {
        Y(vt) ||
          (X(vt, pn),
          te(vt),
          me(void 0),
          qe(void 0),
          D(void 0),
          (Q.value = void 0),
          Ui(Gt) && ie(Gt))
      }
      function de(vt, Gt) {
        if ((me(vt), qe(void 0), D(void 0), (Q.value = void 0), Gt)) {
          const pn = vt ? W(vt) : void 0,
            yr = Jo(vt, V.value),
            hi = wi(vt)
          t('select', pn, hi, yr)
        }
      }
      function xe(vt) {
        j.value && j.value.focus && j.value.focus(vt)
      }
      function ne(vt, Gt) {
        return !q.value && !v.value ? vt : $k(Nr(), vt, Gt)
      }
      function Le(vt) {
        F.value || ie(vt)
      }
      function et(vt) {
        vt.stopPropagation(), he(void 0), t('clear')
      }
      function Ne() {
        var vt, Gt
        ;(Gt = (vt = T.value) == null ? void 0 : vt.onBlur) == null ||
          Gt.call(vt)
      }
      function Et(vt) {
        ie(!0)
        const Gt = vt.target.value
        if ((D(Gt), !uv(Gt, I.value))) return
        const pn = nr(Gt, I.value)
        Y(pn) || (U.value ? de(pn) : he(pn, !0))
      }
      function kt() {
        he(nt.value, !1)
      }
      function je(vt) {
        U.value ? de(vt, !0) : he(vt, !1)
      }
      function Ge(vt) {
        const Gt = ne(vt, $e.value)
        je(Gt)
      }
      function Ye(vt) {
        const Gt = ne(nt.value || Nr(), vt)
        je(Gt)
      }
      function lt() {
        he(nt.value, !1, !0)
      }
      function gt() {
        e.disabledInput && xe()
      }
      let _e
      wr(() => {
        clearTimeout(_e)
      })
      function bt(vt) {
        clearTimeout(_e), qe(vt), D(void 0)
      }
      function He() {
        clearTimeout(_e),
          (_e = setTimeout(() => {
            qe(void 0)
          }, 100))
      }
      function _t(vt, Gt) {
        t('select-shortcut', Gt), he(vt, !1)
      }
      function wt(vt) {
        Q.value = vt
      }
      function Zt() {
        Q.value = 'year'
      }
      function ln(vt) {
        let Gt = ae.value
        if (
          ((Gt = Gt.set('year', vt.year())),
          Q.value === 'month' && (Gt = Gt.set('month', vt.month())),
          re(Gt),
          r.value === 'quarter' || r.value === 'month')
        ) {
          Q.value = void 0
          return
        }
        Q.value = Q.value === 'year' ? 'month' : void 0
      }
      const Pn = C(() =>
          tM(
            hv(
              { format: I.value },
              xr((v == null ? void 0 : v.value) || {}, ['defaultValue'])
            ),
            { visible: G.value }
          )
        ),
        Tr = C(() =>
          tM(
            hv(
              {},
              ra(e, [
                'mode',
                'shortcuts',
                'shortcutsPosition',
                'dayStartOfWeek',
                'disabledDate',
                'disabledTime',
                'showTime',
                'hideTrigger',
                'abbreviation',
              ])
            ),
            {
              showNowBtn: e.showNowBtn && r.value === 'date',
              prefixCls: R,
              format: V.value,
              value: nt.value,
              visible: G.value,
              showConfirmBtn: U.value,
              confirmBtnDisabled: le.value,
              timePickerProps: Pn.value,
              extra: n.extra,
              dateRender: n.cell,
              headerValue: ae.value,
              headerIcons: {
                prev: n['icon-prev'],
                prevDouble: n['icon-prev-double'],
                next: n['icon-next'],
                nextDouble: n['icon-next-double'],
              },
              headerOperations: pe.value,
              timePickerValue: $e.value,
              headerMode: Q.value,
              onCellClick: Ge,
              onTimePickerSelect: Ye,
              onConfirm: lt,
              onShortcutClick: _t,
              onShortcutMouseEnter: E.value ? bt : void 0,
              onShortcutMouseLeave: E.value ? He : void 0,
              onTodayBtnClick: je,
              onHeaderLabelClick: wt,
              onHeaderSelect: ln,
              onMonthHeaderClick: Zt,
            }
          )
        )
      return {
        prefixCls: R,
        refInput: j,
        panelProps: Tr,
        panelValue: nt,
        inputValue: We,
        selectedValue: oe,
        inputFormat: L,
        computedPlaceholder: N,
        panelVisible: G,
        inputEditable: ft,
        needConfirm: U,
        mergedDisabled: F,
        onPanelVisibleChange: Le,
        onInputClear: et,
        onInputChange: Et,
        onInputPressEnter: kt,
        onInputBlur: Ne,
        onPanelClick: gt,
      }
    },
  })
  function eG(e, t, n, r, i, o) {
    const a = ge('IconCalendar'),
      s = ge('DateInput'),
      l = ge('PickerPanel'),
      c = ge('Trigger')
    return e.hideTrigger
      ? (O(),
        Ee(l, En(Fe({ key: 1 }, hv(hv({}, e.$attrs), e.panelProps))), null, 16))
      : (O(),
        Ee(
          c,
          Fe(
            {
              key: 0,
              trigger: 'click',
              'animation-name': 'slide-dynamic-origin',
              'auto-fit-transform-origin': '',
              'click-to-close': !1,
              'popup-offset': 4,
            },
            e.triggerProps,
            {
              position: e.position,
              disabled: e.mergedDisabled || e.readonly,
              'prevent-focus': !0,
              'popup-visible': e.panelVisible,
              'unmount-on-close': e.unmountOnClose,
              'popup-container': e.popupContainer,
              onPopupVisibleChange: e.onPanelVisibleChange,
            }
          ),
          {
            content: ze(() => [
              m(l, Fe(e.panelProps, { onClick: e.onPanelClick }), null, 16, [
                'onClick',
              ]),
            ]),
            default: ze(() => [
              ve(e.$slots, 'default', {}, () => [
                m(
                  s,
                  Fe(e.$attrs, {
                    ref: 'refInput',
                    size: e.size,
                    focused: e.panelVisible,
                    visible: e.panelVisible,
                    error: e.error,
                    disabled: e.mergedDisabled,
                    readonly: !e.inputEditable || e.disabledInput,
                    'allow-clear': e.allowClear && !e.readonly,
                    placeholder: e.computedPlaceholder,
                    'input-value': e.inputValue,
                    value: e.needConfirm ? e.panelValue : e.selectedValue,
                    format: e.inputFormat,
                    onClear: e.onInputClear,
                    onChange: e.onInputChange,
                    onPressEnter: e.onInputPressEnter,
                    onBlur: e.onInputBlur,
                  }),
                  Nn(
                    {
                      'suffix-icon': ze(() => [
                        ve(e.$slots, 'suffix-icon', {}, () => [m(a)]),
                      ]),
                      _: 2,
                    },
                    [
                      e.$slots.prefix
                        ? {
                            name: 'prefix',
                            fn: ze(() => [ve(e.$slots, 'prefix')]),
                          }
                        : void 0,
                    ]
                  ),
                  1040,
                  [
                    'size',
                    'focused',
                    'visible',
                    'error',
                    'disabled',
                    'readonly',
                    'allow-clear',
                    'placeholder',
                    'input-value',
                    'value',
                    'format',
                    'onClear',
                    'onChange',
                    'onPressEnter',
                    'onBlur',
                  ]
                ),
              ]),
            ]),
            _: 3,
          },
          16,
          [
            'position',
            'disabled',
            'popup-visible',
            'unmount-on-close',
            'popup-container',
            'onPopupVisibleChange',
          ]
        ))
  }
  var ef = Te(Qj, [['render', eG]]),
    z0 = ce({
      name: 'DatePicker',
      props: {
        modelValue: { type: [Object, String, Number] },
        defaultValue: { type: [Object, String, Number] },
        format: { type: [String, Function] },
        dayStartOfWeek: { type: Number, default: 0 },
        showTime: { type: Boolean },
        timePickerProps: { type: Object },
        disabled: { type: Boolean },
        disabledDate: { type: Function },
        disabledTime: { type: Function },
        showNowBtn: { type: Boolean, default: !0 },
      },
      setup(e, { attrs: t, slots: n }) {
        return () => m(ef, Fe(e, t, { mode: 'date' }), n)
      },
    }),
    mp = ce({
      name: 'WeekPicker',
      props: {
        modelValue: { type: [Object, String, Number] },
        defaultValue: { type: [Object, String, Number] },
        format: { type: String, default: 'gggg-wo' },
        valueFormat: { type: String, default: 'YYYY-MM-DD' },
        dayStartOfWeek: { type: Number, default: 0 },
      },
      setup(e, { attrs: t, slots: n }) {
        return () => m(ef, Fe(e, t, { mode: 'week' }), n)
      },
    }),
    gp = ce({
      name: 'MonthPicker',
      props: {
        modelValue: { type: [Object, String, Number] },
        defaultValue: { type: [Object, String, Number] },
        format: { type: String, default: 'YYYY-MM' },
      },
      setup(e, { attrs: t, slots: n }) {
        return () => m(ef, Fe(e, t, { mode: 'month' }), n)
      },
    }),
    yp = ce({
      name: 'YearPicker',
      props: {
        modelValue: { type: [Object, String, Number] },
        defaultValue: { type: [Object, String, Number] },
        format: { type: String, default: 'YYYY' },
      },
      setup(e, { attrs: t, slots: n }) {
        return () => m(ef, Fe(e, t, { mode: 'year' }), n)
      },
    }),
    bp = ce({
      name: 'QuarterPicker',
      props: {
        modelValue: { type: [Object, String, Number] },
        defaultValue: { type: [Object, String, Number] },
        format: { type: String, default: 'YYYY-[Q]Q' },
        valueFormat: { type: String, default: 'YYYY-MM' },
      },
      setup(e, { attrs: t, slots: n }) {
        return () => m(ef, Fe(e, t, { mode: 'quarter' }), n)
      },
    })
  function tG(e) {
    const { modelValue: t, defaultValue: n, format: r } = tt(e),
      i = C(() => Hi(Cb(t.value), r.value)),
      o = C(() => Hi(Cb(n.value), r.value)),
      [a, s] = zi(Mt(i.value) ? (Mt(o.value) ? [] : o.value) : i.value)
    return (
      pt(i, () => {
        Mt(i.value) && s([])
      }),
      { value: C(() => i.value || a.value), setValue: s }
    )
  }
  function nG(e) {
    const {
        startHeaderMode: t,
        endHeaderMode: n,
        mode: r,
        value: i,
        defaultValue: o,
        selectedValue: a,
        format: s,
        onChange: l,
      } = tt(e),
      c = C(() => ['date', 'week'].includes(r.value)),
      d = C(() => (c.value ? 'M' : 'y')),
      h = (oe, te) => oe.isSame(te, d.value),
      { span: p, superSpan: v } = Uk(Je({ mode: r })),
      g = C(() => {
        var oe
        return (oe = i.value) == null ? void 0 : oe[0]
      }),
      _ = C(() => {
        var oe
        return (oe = i.value) == null ? void 0 : oe[1]
      }),
      b = C(() => {
        var oe
        return (oe = o.value) == null ? void 0 : oe[0]
      }),
      y = C(() => {
        var oe
        return (oe = o.value) == null ? void 0 : oe[1]
      }),
      M = (oe) => {
        l != null && l.value && l.value(oe)
      },
      {
        headerValue: x,
        setHeaderValue: w,
        headerOperations: E,
        getDefaultLocalValue: P,
      } = dv(
        Je({
          mode: (t == null ? void 0 : t.value) || r,
          value: g,
          defaultValue: b,
          selectedValue: void 0,
          format: s,
          onChange: (oe) => {
            M([oe, A.value])
          },
        })
      ),
      {
        headerValue: A,
        setHeaderValue: F,
        headerOperations: T,
        getDefaultLocalValue: k,
      } = dv(
        Je({
          mode: (n == null ? void 0 : n.value) || r,
          value: _,
          defaultValue: y,
          selectedValue: void 0,
          format: s,
          onChange: (oe) => {
            M([x.value, oe])
          },
        })
      ),
      R = (oe) => {
        const te = h(x.value, oe[0]),
          ue = h(A.value, oe[1])
        w(oe[0], !1),
          F(oe[1], !1),
          (!te || !ue) && l != null && l.value && (l == null || l.value(oe))
      }
    function j(oe) {
      let [te, ue] = Ld(oe)
      const me = ur.add(te, p.value, 'M')
      return ue.isBefore(me, d.value) && (ue = me), [te, ue]
    }
    function N() {
      var oe, te
      let ue = (oe = a.value) == null ? void 0 : oe[0],
        me = (te = a.value) == null ? void 0 : te[1]
      return ue && me && ([ue, me] = Ld([ue, me])), [ue, me]
    }
    const [I, B] = N(),
      [V, L] = j([I || x.value, B || A.value])
    w(V, !1), F(L, !1)
    const W = () => {
        const oe = P(),
          te = k()
        hn(() => {
          const [ue, me] = N(),
            [Re, qe] = j([ue || oe, me || te])
          R([Re, qe])
        })
      },
      Y = C(() => ur.add(x.value, p.value, 'M').isBefore(A.value, d.value)),
      U = C(() => ur.add(x.value, v.value, 'M').isBefore(A.value, d.value)),
      le = C(() => {
        const oe = ['onSuperPrev']
        return (
          c.value && oe.push('onPrev'),
          Y.value && c && oe.push('onNext'),
          U.value && oe.push('onSuperNext'),
          ra(E.value, oe)
        )
      }),
      q = C(() => {
        const oe = ['onSuperNext']
        return (
          c.value && oe.push('onNext'),
          Y.value && c.value && oe.push('onPrev'),
          U.value && oe.push('onSuperPrev'),
          ra(T.value, oe)
        )
      })
    return {
      startHeaderValue: x,
      endHeaderValue: A,
      startHeaderOperations: le,
      endHeaderOperations: q,
      setHeaderValue: R,
      resetHeaderValue: W,
    }
  }
  const rG = ce({
      name: 'DateInputRange',
      components: { IconHover: In, IconClose: zr, FeedbackIcon: Zd },
      props: {
        size: { type: String },
        focused: { type: Boolean },
        focusedIndex: { type: Number },
        error: { type: Boolean },
        disabled: { type: [Boolean, Array], default: !1 },
        readonly: { type: Boolean },
        allowClear: { type: Boolean },
        placeholder: { type: Array, default: () => [] },
        inputValue: { type: Array },
        value: { type: Array, default: () => [] },
        format: { type: [String, Function], required: !0 },
      },
      emits: [
        'focused-index-change',
        'update:focusedIndex',
        'change',
        'clear',
        'press-enter',
      ],
      setup(e, { emit: t, slots: n }) {
        const {
            error: r,
            focused: i,
            disabled: o,
            size: a,
            value: s,
            format: l,
            focusedIndex: c,
            inputValue: d,
          } = tt(e),
          {
            mergedSize: h,
            mergedDisabled: p,
            mergedError: v,
            feedback: g,
          } = Rn({ size: a, error: r }),
          { mergedSize: _ } = Vr(h),
          b = J(),
          y = J(),
          M = (V) => (p.value ? p.value : Ft(o.value) ? o.value[V] : o.value),
          x = C(() => M(0)),
          w = C(() => M(1)),
          E = ye('picker'),
          P = C(() => [
            E,
            `${E}-range`,
            `${E}-size-${_.value}`,
            {
              [`${E}-focused`]: i.value,
              [`${E}-disabled`]: x.value && w.value,
              [`${E}-error`]: v.value,
              [`${E}-has-prefix`]: n.prefix,
            },
          ])
        function A(V) {
          return [
            `${E}-input`,
            { [`${E}-input-active`]: V === (c == null ? void 0 : c.value) },
          ]
        }
        function F(V) {
          var L, W
          if (d != null && d.value)
            return (L = d == null ? void 0 : d.value) == null ? void 0 : L[V]
          const Y = (W = s == null ? void 0 : s.value) == null ? void 0 : W[V]
          if (Y && ao(Y)) return xt(l.value) ? l.value(Y) : Y.format(l.value)
        }
        const T = C(() => F(0)),
          k = C(() => F(1))
        function R(V) {
          t('focused-index-change', V), t('update:focusedIndex', V)
        }
        function j(V) {
          V.stopPropagation(), t('change', V)
        }
        function N() {
          t('press-enter')
        }
        function I(V) {
          V.preventDefault()
        }
        function B(V) {
          t('clear', V)
        }
        return {
          prefixCls: E,
          classNames: P,
          refInput0: b,
          refInput1: y,
          disabled0: x,
          disabled1: w,
          mergedDisabled: p,
          getDisabled: M,
          getInputWrapClassName: A,
          displayValue0: T,
          displayValue1: k,
          changeFocusedInput: R,
          onChange: j,
          onPressEnter: N,
          onPressTab: I,
          onClear: B,
          feedback: g,
        }
      },
      methods: {
        focus(e) {
          const t = it(e) ? e : this.focusedIndex,
            n = t === 0 ? this.refInput0 : this.refInput1
          !Mt(t) && !this.getDisabled(t) && n && n.focus && n.focus()
        },
        blur() {
          const e = this.focusedIndex === 0 ? this.refInput0 : this.refInput1
          e && e.blur && e.blur()
        },
      },
    }),
    iG = ['disabled', 'placeholder', 'value'],
    oG = Lt(' - '),
    aG = ['disabled', 'placeholder', 'value']
  function sG(e, t, n, r, i, o) {
    const a = ge('IconClose'),
      s = ge('IconHover'),
      l = ge('FeedbackIcon')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.$slots.prefix
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-prefix`) },
                [ve(e.$slots, 'prefix')],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(e.getInputWrapClassName(0)) },
            [
              Se(
                'input',
                Fe(
                  {
                    ref: 'refInput0',
                    disabled: e.disabled0,
                    placeholder: e.placeholder[0],
                    value: e.displayValue0,
                  },
                  e.readonly ? { readonly: !0 } : {},
                  {
                    onInput:
                      t[0] || (t[0] = (...c) => e.onChange && e.onChange(...c)),
                    onKeydown: [
                      t[1] ||
                        (t[1] = xu(
                          (...c) => e.onPressEnter && e.onPressEnter(...c),
                          ['enter']
                        )),
                      t[2] ||
                        (t[2] = xu(
                          (...c) => e.onPressTab && e.onPressTab(...c),
                          ['tab']
                        )),
                    ],
                    onClick: t[3] || (t[3] = () => e.changeFocusedInput(0)),
                  }
                ),
                null,
                16,
                iG
              ),
            ],
            2
          ),
          Se(
            'span',
            { class: H(`${e.prefixCls}-separator`) },
            [ve(e.$slots, 'separator', {}, () => [oG])],
            2
          ),
          Se(
            'div',
            { class: H(e.getInputWrapClassName(1)) },
            [
              Se(
                'input',
                Fe(
                  {
                    ref: 'refInput1',
                    disabled: e.disabled1,
                    placeholder: e.placeholder[1],
                    value: e.displayValue1,
                  },
                  e.readonly ? { readonly: !0 } : {},
                  {
                    onInput:
                      t[4] || (t[4] = (...c) => e.onChange && e.onChange(...c)),
                    onKeydown: [
                      t[5] ||
                        (t[5] = xu(
                          (...c) => e.onPressEnter && e.onPressEnter(...c),
                          ['enter']
                        )),
                      t[6] ||
                        (t[6] = xu(
                          (...c) => e.onPressTab && e.onPressTab(...c),
                          ['tab']
                        )),
                    ],
                    onClick: t[7] || (t[7] = () => e.changeFocusedInput(1)),
                  }
                ),
                null,
                16,
                aG
              ),
            ],
            2
          ),
          Se(
            'div',
            { class: H(`${e.prefixCls}-suffix`) },
            [
              e.allowClear && !e.mergedDisabled && e.value.length === 2
                ? (O(),
                  Ee(
                    s,
                    {
                      key: 0,
                      prefix: e.prefixCls,
                      class: H(`${e.prefixCls}-clear-icon`),
                      onClick: e.onClear,
                    },
                    { default: ze(() => [m(a)]), _: 1 },
                    8,
                    ['prefix', 'class', 'onClick']
                  ))
                : Ce('v-if', !0),
              Se(
                'span',
                { class: H(`${e.prefixCls}-suffix-icon`) },
                [ve(e.$slots, 'suffix-icon')],
                2
              ),
              e.feedback
                ? (O(), Ee(l, { key: 1, type: e.feedback }, null, 8, ['type']))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Kk = Te(rG, [['render', sG]]),
    lG = Object.defineProperty,
    uG = Object.defineProperties,
    cG = Object.getOwnPropertyDescriptors,
    nM = Object.getOwnPropertySymbols,
    dG = Object.prototype.hasOwnProperty,
    fG = Object.prototype.propertyIsEnumerable,
    rM = (e, t, n) =>
      t in e
        ? lG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    V0 = (e, t) => {
      for (var n in t || (t = {})) dG.call(t, n) && rM(e, n, t[n])
      if (nM) for (var n of nM(t)) fG.call(t, n) && rM(e, n, t[n])
      return e
    },
    U0 = (e, t) => uG(e, cG(t))
  const hG = ce({
    name: 'DateRangePikerPanel',
    components: {
      PanelShortcuts: Ak,
      PanelFooter: Vk,
      RenderFunction: Ga,
      DatePanel: rS,
      WeekPanel: Dk,
      MonthPanel: Nk,
      YearPanel: Bk,
      QuarterPanel: Fk,
    },
    props: {
      mode: { type: String, default: 'date' },
      value: { type: Array, default: () => [] },
      footerValue: { type: Array },
      timePickerValue: { type: Array },
      showTime: { type: Boolean },
      showConfirmBtn: { type: Boolean },
      prefixCls: { type: String, required: !0 },
      shortcuts: { type: Array, default: () => [] },
      shortcutsPosition: { type: String, default: 'bottom' },
      format: { type: String, required: !0 },
      dayStartOfWeek: { type: Number, default: 0 },
      disabledDate: { type: Function },
      disabledTime: { type: Function },
      timePickerProps: { type: Object },
      extra: { type: Function },
      dateRender: { type: Function },
      hideTrigger: { type: Boolean },
      startHeaderProps: { type: Object, default: () => ({}) },
      endHeaderProps: { type: Object, default: () => ({}) },
      confirmBtnDisabled: { type: Boolean },
      disabled: { type: Array, default: () => [!1, !1] },
      visible: { type: Boolean },
      startHeaderMode: { type: String },
      endHeaderMode: { type: String },
      abbreviation: { type: Boolean },
    },
    emits: [
      'cell-click',
      'cell-mouse-enter',
      'time-picker-select',
      'shortcut-click',
      'shortcut-mouse-enter',
      'shortcut-mouse-leave',
      'confirm',
      'start-header-label-click',
      'end-header-label-click',
      'start-header-select',
      'end-header-select',
    ],
    setup(e, { emit: t }) {
      const {
          prefixCls: n,
          shortcuts: r,
          shortcutsPosition: i,
          format: o,
          hideTrigger: a,
          value: s,
          disabledDate: l,
          disabledTime: c,
          startHeaderProps: d,
          endHeaderProps: h,
          dateRender: p,
          visible: v,
          startHeaderMode: g,
          endHeaderMode: _,
        } = tt(e),
        b = C(() => Ft(r.value) && r.value.length),
        y = C(() => [
          `${n.value}-range-container`,
          {
            [`${n.value}-range-container-panel-only`]: a.value,
            [`${n.value}-range-container-shortcuts-placement-left`]:
              b.value && i.value === 'left',
            [`${n.value}-range-container-shortcuts-placement-right`]:
              b.value && i.value === 'right',
          },
        ]),
        M = J('date')
      pt(v, (q, oe) => {
        q && !oe && (M.value = 'date')
      })
      function x(q) {
        return Hi(Cb(xt(q.value) ? q.value() : q.value), q.format || o.value)
      }
      function w(q) {
        t('shortcut-click', x(q), q)
      }
      function E(q) {
        t('shortcut-mouse-enter', x(q))
      }
      function P(q) {
        t('shortcut-mouse-leave', x(q))
      }
      function A(q) {
        t('cell-click', q)
      }
      function F(q) {
        t('cell-mouse-enter', q)
      }
      function T() {
        t('confirm')
      }
      function k(q) {
        t('time-picker-select', q, 'start')
      }
      function R(q) {
        t('time-picker-select', q, 'end')
      }
      function j(q) {
        t('start-header-label-click', q)
      }
      function N(q) {
        t('end-header-label-click', q)
      }
      function I(q) {
        t('start-header-select', q)
      }
      function B(q) {
        t('end-header-select', q)
      }
      function V(q) {
        return xt(l == null ? void 0 : l.value)
          ? (oe) => {
              var te
              return (
                ((te = l == null ? void 0 : l.value) == null
                  ? void 0
                  : te.call(l, oe, q === 0 ? 'start' : 'end')) || !1
              )
            }
          : void 0
      }
      function L(q) {
        return xt(c == null ? void 0 : c.value)
          ? (oe) => {
              var te
              return (
                ((te = c == null ? void 0 : c.value) == null
                  ? void 0
                  : te.call(c, oe, q === 0 ? 'start' : 'end')) || !1
              )
            }
          : void 0
      }
      function W(q) {
        return xt(p == null ? void 0 : p.value)
          ? (oe) => {
              var te
              const ue = U0(V0({}, oe), { type: q === 0 ? 'start' : 'end' })
              return (te = p == null ? void 0 : p.value) == null
                ? void 0
                : te.call(p, ue)
            }
          : void 0
      }
      const Y = Je({
          prefixCls: n,
          shortcuts: r,
          onItemClick: w,
          onItemMouseEnter: E,
          onItemMouseLeave: P,
        }),
        U = C(() =>
          U0(V0({}, d.value), {
            rangeValues: s.value,
            disabledDate: V(0),
            dateRender: W(0),
            onSelect: g.value ? I : A,
            onCellMouseEnter: F,
            onHeaderLabelClick: j,
          })
        ),
        le = C(() =>
          U0(V0({}, h.value), {
            rangeValues: s.value,
            disabledDate: V(1),
            dateRender: W(1),
            onSelect: _.value ? B : A,
            onCellMouseEnter: F,
            onHeaderLabelClick: N,
          })
        )
      return {
        pick: ra,
        classNames: y,
        showShortcuts: b,
        shortcutsProps: Y,
        startPanelProps: U,
        endPanelProps: le,
        getDisabledTimeFunc: L,
        onConfirmBtnClick: T,
        currentDateView: M,
        onStartTimePickerSelect: k,
        onEndTimePickerSelect: R,
        onStartHeaderPanelSelect: I,
        onEndHeaderPanelSelect: B,
      }
    },
  })
  function pG(e, t, n, r, i, o) {
    const a = ge('PanelShortcuts'),
      s = ge('YearPanel'),
      l = ge('MonthPanel'),
      c = ge('WeekPanel'),
      d = ge('QuarterPanel'),
      h = ge('DatePanel'),
      p = ge('RenderFunction'),
      v = ge('PanelFooter')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.showShortcuts && e.shortcutsPosition === 'left'
            ? (O(), Ee(a, En(Fe({ key: 0 }, e.shortcutsProps)), null, 16))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-range-panel-wrapper`) },
            [
              Ce(' panel '),
              Se(
                'div',
                { class: H(`${e.prefixCls}-range`) },
                [
                  Se(
                    'div',
                    { class: H(`${e.prefixCls}-range-wrapper`) },
                    [
                      e.startHeaderMode || e.endHeaderMode
                        ? (O(),
                          Z(
                            yt,
                            { key: 0 },
                            [
                              e.startHeaderMode === 'year'
                                ? (O(),
                                  Ee(
                                    s,
                                    En(Fe({ key: 0 }, e.startPanelProps)),
                                    null,
                                    16
                                  ))
                                : Ce('v-if', !0),
                              e.endHeaderMode === 'year'
                                ? (O(),
                                  Ee(
                                    s,
                                    En(Fe({ key: 1 }, e.endPanelProps)),
                                    null,
                                    16
                                  ))
                                : e.startHeaderMode === 'month'
                                ? (O(),
                                  Ee(
                                    l,
                                    Fe({ key: 2 }, e.startPanelProps, {
                                      abbreviation: e.abbreviation,
                                    }),
                                    null,
                                    16,
                                    ['abbreviation']
                                  ))
                                : e.endHeaderMode === 'month'
                                ? (O(),
                                  Ee(
                                    l,
                                    Fe({ key: 3 }, e.endPanelProps, {
                                      abbreviation: e.abbreviation,
                                    }),
                                    null,
                                    16,
                                    ['abbreviation']
                                  ))
                                : Ce('v-if', !0),
                            ],
                            64
                          ))
                        : (O(),
                          Z(
                            yt,
                            { key: 1 },
                            [
                              Ce(' week '),
                              e.mode === 'week'
                                ? (O(),
                                  Z(
                                    yt,
                                    { key: 0 },
                                    [
                                      m(
                                        c,
                                        Fe(e.startPanelProps, {
                                          'day-start-of-week': e.dayStartOfWeek,
                                        }),
                                        null,
                                        16,
                                        ['day-start-of-week']
                                      ),
                                      m(
                                        c,
                                        Fe(e.endPanelProps, {
                                          'day-start-of-week': e.dayStartOfWeek,
                                        }),
                                        null,
                                        16,
                                        ['day-start-of-week']
                                      ),
                                    ],
                                    64
                                  ))
                                : e.mode === 'month'
                                ? (O(),
                                  Z(
                                    yt,
                                    { key: 1 },
                                    [
                                      Ce(' month '),
                                      m(
                                        l,
                                        Fe(e.startPanelProps, {
                                          abbreviation: e.abbreviation,
                                        }),
                                        null,
                                        16,
                                        ['abbreviation']
                                      ),
                                      m(
                                        l,
                                        Fe(e.endPanelProps, {
                                          abbreviation: e.abbreviation,
                                        }),
                                        null,
                                        16,
                                        ['abbreviation']
                                      ),
                                    ],
                                    64
                                  ))
                                : e.mode === 'year'
                                ? (O(),
                                  Z(
                                    yt,
                                    { key: 2 },
                                    [
                                      Ce(' year '),
                                      m(s, En(Rr(e.startPanelProps)), null, 16),
                                      m(s, En(Rr(e.endPanelProps)), null, 16),
                                    ],
                                    64
                                  ))
                                : e.mode === 'quarter'
                                ? (O(),
                                  Z(
                                    yt,
                                    { key: 3 },
                                    [
                                      Ce(' quarter '),
                                      m(d, En(Rr(e.startPanelProps)), null, 16),
                                      m(d, En(Rr(e.endPanelProps)), null, 16),
                                    ],
                                    64
                                  ))
                                : (O(),
                                  Z(
                                    yt,
                                    { key: 4 },
                                    [
                                      Ce(' date '),
                                      m(
                                        h,
                                        Fe(
                                          {
                                            currentView: e.currentDateView,
                                            'onUpdate:currentView':
                                              t[0] ||
                                              (t[0] = (g) =>
                                                (e.currentDateView = g)),
                                          },
                                          e.startPanelProps,
                                          {
                                            'is-range': '',
                                            value: e.value && e.value[0],
                                            'footer-value':
                                              e.footerValue && e.footerValue[0],
                                            'time-picker-value':
                                              e.timePickerValue &&
                                              e.timePickerValue[0],
                                            'day-start-of-week':
                                              e.dayStartOfWeek,
                                            'show-time': e.showTime,
                                            'time-picker-props':
                                              e.timePickerProps,
                                            'disabled-time':
                                              e.getDisabledTimeFunc(0),
                                            disabled: e.disabled[0],
                                            onTimePickerSelect:
                                              e.onStartTimePickerSelect,
                                          }
                                        ),
                                        null,
                                        16,
                                        [
                                          'currentView',
                                          'value',
                                          'footer-value',
                                          'time-picker-value',
                                          'day-start-of-week',
                                          'show-time',
                                          'time-picker-props',
                                          'disabled-time',
                                          'disabled',
                                          'onTimePickerSelect',
                                        ]
                                      ),
                                      m(
                                        h,
                                        Fe(
                                          {
                                            currentView: e.currentDateView,
                                            'onUpdate:currentView':
                                              t[1] ||
                                              (t[1] = (g) =>
                                                (e.currentDateView = g)),
                                          },
                                          e.endPanelProps,
                                          {
                                            'is-range': '',
                                            value: e.value && e.value[1],
                                            'footer-value':
                                              e.footerValue && e.footerValue[1],
                                            'time-picker-value':
                                              e.timePickerValue &&
                                              e.timePickerValue[1],
                                            'day-start-of-week':
                                              e.dayStartOfWeek,
                                            'show-time': e.showTime,
                                            'time-picker-props':
                                              e.timePickerProps,
                                            'disabled-time':
                                              e.getDisabledTimeFunc(1),
                                            disabled: e.disabled[1],
                                            onTimePickerSelect:
                                              e.onEndTimePickerSelect,
                                          }
                                        ),
                                        null,
                                        16,
                                        [
                                          'currentView',
                                          'value',
                                          'footer-value',
                                          'time-picker-value',
                                          'day-start-of-week',
                                          'show-time',
                                          'time-picker-props',
                                          'disabled-time',
                                          'disabled',
                                          'onTimePickerSelect',
                                        ]
                                      ),
                                    ],
                                    64
                                  )),
                            ],
                            2112
                          )),
                    ],
                    2
                  ),
                ],
                2
              ),
              Ce(' footer '),
              m(
                v,
                {
                  'prefix-cls': e.prefixCls,
                  'show-today-btn': !1,
                  'show-confirm-btn': e.showConfirmBtn,
                  'confirm-btn-disabled': e.confirmBtnDisabled,
                  onConfirmBtnClick: e.onConfirmBtnClick,
                },
                Nn({ _: 2 }, [
                  e.extra || e.$slots.extra
                    ? {
                        name: 'extra',
                        fn: ze(() => [
                          e.$slots.extra
                            ? ve(e.$slots, 'extra', { key: 0 })
                            : (O(),
                              Ee(
                                p,
                                { key: 1, 'render-func': e.extra },
                                null,
                                8,
                                ['render-func']
                              )),
                        ]),
                      }
                    : void 0,
                  e.showShortcuts && e.shortcutsPosition === 'bottom'
                    ? {
                        name: 'btn',
                        fn: ze(() => [
                          m(a, En(Rr(e.shortcutsProps)), null, 16),
                        ]),
                      }
                    : void 0,
                ]),
                1032,
                [
                  'prefix-cls',
                  'show-confirm-btn',
                  'confirm-btn-disabled',
                  'onConfirmBtnClick',
                ]
              ),
            ],
            2
          ),
          e.showShortcuts && e.shortcutsPosition === 'right'
            ? (O(), Ee(a, En(Fe({ key: 1 }, e.shortcutsProps)), null, 16))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var vG = Te(hG, [['render', pG]]),
    mG = Object.defineProperty,
    gG = Object.defineProperties,
    yG = Object.getOwnPropertyDescriptors,
    iM = Object.getOwnPropertySymbols,
    bG = Object.prototype.hasOwnProperty,
    _G = Object.prototype.propertyIsEnumerable,
    oM = (e, t, n) =>
      t in e
        ? mG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    aM = (e, t) => {
      for (var n in t || (t = {})) bG.call(t, n) && oM(e, n, t[n])
      if (iM) for (var n of iM(t)) _G.call(t, n) && oM(e, n, t[n])
      return e
    },
    sM = (e, t) => gG(e, yG(t))
  function SG(e) {
    const { timePickerProps: t, selectedValue: n } = tt(e),
      r = C(() => {
        var y
        return (y = n == null ? void 0 : n.value) == null ? void 0 : y[0]
      }),
      i = C(() => {
        var y
        return (y = n == null ? void 0 : n.value) == null ? void 0 : y[1]
      }),
      o = C(() => {
        var y
        return (y = t == null ? void 0 : t.value) == null
          ? void 0
          : y.defaultValue
      }),
      a = C(() =>
        Ft(o.value)
          ? sM(aM({}, t == null ? void 0 : t.value), {
              defaultValue: o.value[0],
            })
          : t == null
          ? void 0
          : t.value
      ),
      s = C(() =>
        Ft(o.value)
          ? sM(aM({}, t == null ? void 0 : t.value), {
              defaultValue: o.value[1],
            })
          : t == null
          ? void 0
          : t.value
      ),
      [l, c, d] = Mb(Je({ timePickerProps: a, selectedValue: r })),
      [h, p, v] = Mb(Je({ timePickerProps: s, selectedValue: i })),
      g = C(() => [l.value, h.value])
    function _(y) {
      y && (c(y[0]), p(y[1]))
    }
    function b() {
      d(), v()
    }
    return [g, _, b]
  }
  var CG = Object.defineProperty,
    wG = Object.defineProperties,
    xG = Object.getOwnPropertyDescriptors,
    lM = Object.getOwnPropertySymbols,
    MG = Object.prototype.hasOwnProperty,
    EG = Object.prototype.propertyIsEnumerable,
    uM = (e, t, n) =>
      t in e
        ? CG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    pv = (e, t) => {
      for (var n in t || (t = {})) MG.call(t, n) && uM(e, n, t[n])
      if (lM) for (var n of lM(t)) EG.call(t, n) && uM(e, n, t[n])
      return e
    },
    cM = (e, t) => wG(e, xG(t))
  const PG = ce({
    name: 'RangePicker',
    components: {
      RangePickerPanel: vG,
      DateRangeInput: Kk,
      Trigger: Mr,
      IconCalendar: nS,
    },
    inheritAttrs: !1,
    props: {
      mode: { type: String, default: 'date' },
      modelValue: { type: Array },
      defaultValue: { type: Array },
      pickerValue: { type: Array },
      defaultPickerValue: { type: Array },
      disabled: { type: [Boolean, Array], default: !1 },
      dayStartOfWeek: { type: Number, default: 0 },
      format: { type: String },
      valueFormat: { type: String },
      showTime: { type: Boolean },
      timePickerProps: { type: Object },
      placeholder: { type: Array },
      disabledDate: { type: Function },
      disabledTime: { type: Function },
      separator: { type: String },
      exchangeTime: { type: Boolean, default: !0 },
      popupContainer: { type: [String, Object] },
      locale: { type: Object },
      hideTrigger: { type: Boolean },
      allowClear: { type: Boolean, default: !0 },
      readonly: { type: Boolean },
      error: { type: Boolean },
      size: { type: String },
      shortcuts: { type: Array, default: () => [] },
      shortcutsPosition: { type: String, default: 'bottom' },
      position: { type: String, default: 'bl' },
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean },
      triggerProps: { type: Object },
      unmountOnClose: { type: Boolean },
      previewShortcut: { type: Boolean, default: !0 },
      showConfirmBtn: { type: Boolean },
      disabledInput: { type: Boolean, default: !1 },
      abbreviation: { type: Boolean, default: !0 },
    },
    emits: {
      change: (e, t, n) => !0,
      'update:modelValue': (e) => !0,
      select: (e, t, n) => !0,
      'popup-visible-change': (e) => !0,
      'update:popupVisible': (e) => !0,
      ok: (e, t, n) => !0,
      clear: () => !0,
      'select-shortcut': (e) => !0,
      'picker-value-change': (e, t, n) => !0,
      'update:pickerValue': (e) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const {
          mode: r,
          showTime: i,
          format: o,
          modelValue: a,
          defaultValue: s,
          popupVisible: l,
          defaultPopupVisible: c,
          placeholder: d,
          timePickerProps: h,
          disabled: p,
          disabledDate: v,
          disabledTime: g,
          locale: _,
          pickerValue: b,
          defaultPickerValue: y,
          valueFormat: M,
          size: x,
          error: w,
          dayStartOfWeek: E,
          exchangeTime: P,
          previewShortcut: A,
          showConfirmBtn: F,
        } = tt(e),
        { locale: T } = Vn()
      pr(() => {
        lk(T.value, E.value)
      })
      const {
          mergedSize: k,
          mergedDisabled: R,
          mergedError: j,
          eventHandlers: N,
        } = Rn({ size: x, error: w }),
        I = jk(Je({ locale: _ })),
        B = ye('picker'),
        V = C(
          () =>
            (d == null ? void 0 : d.value) ||
            {
              date: I('datePicker.rangePlaceholder.date'),
              month: I('datePicker.rangePlaceholder.month'),
              year: I('datePicker.rangePlaceholder.year'),
              week: I('datePicker.rangePlaceholder.week'),
              quarter: I('datePicker.rangePlaceholder.quarter'),
            }[r.value] ||
            I('datePicker.rangePlaceholder.date')
        ),
        {
          format: L,
          valueFormat: W,
          parseValueFormat: Y,
        } = Hk(Je({ mode: r, format: o, showTime: i, valueFormat: M })),
        U = C(() => {
          const Ke =
              p.value === !0 || R.value || (Ft(p.value) && p.value[0] === !0),
            ct = p.value === !0 || R.value || (Ft(p.value) && p.value[1] === !0)
          return [Ke, ct]
        }),
        le = C(() => U.value[0] && U.value[1])
      function q(Ke = 0) {
        return U.value[Ke] ? Ke ^ 1 : Ke
      }
      const oe = J(),
        te = J(q()),
        ue = C(() => {
          const Ke = te.value,
            ct = Ke ^ 1
          return U.value[ct] ? Ke : ct
        }),
        me = C(() => U.value[te.value ^ 1]),
        { value: Re, setValue: qe } = tG(
          Je({ modelValue: a, defaultValue: s, format: Y })
        ),
        [Ve, nt] = zi(),
        [We, D] = zi(),
        G = C(() => {
          var Ke
          return (Ke = Ve.value) != null ? Ke : Re.value
        }),
        z = C(() => {
          var Ke, ct
          return (ct = (Ke = We.value) != null ? Ke : Ve.value) != null
            ? ct
            : Re.value
        }),
        [ie, ae] = zi(),
        re = J(),
        pe = J(),
        [we, $e] = Er(c.value, Je({ value: l })),
        Ae = (Ke) => {
          we.value !== Ke &&
            ($e(Ke),
            t('popup-visible-change', Ke),
            t('update:popupVisible', Ke))
        },
        {
          startHeaderValue: ft,
          endHeaderValue: Q,
          startHeaderOperations: X,
          endHeaderOperations: he,
          resetHeaderValue: de,
          setHeaderValue: xe,
        } = nG(
          Je({
            mode: r,
            startHeaderMode: re,
            endHeaderMode: pe,
            value: b,
            defaultValue: y,
            selectedValue: z,
            format: Y,
            onChange: (Ke) => {
              const ct = F0(Ke, W.value),
                Tt = Jo(Ke, Y.value),
                Bt = wi(Ke)
              t('picker-value-change', ct, Bt, Tt), t('update:pickerValue', ct)
            },
          })
        )
      function ne(Ke) {
        re.value = Ke
      }
      function Le(Ke) {
        pe.value = Ke
      }
      function et(Ke) {
        let ct = ft.value
        ;(ct = ct.set('year', Ke.year())),
          re.value === 'month' && (ct = ct.set('month', Ke.month())),
          xe([ct, Q.value]),
          (re.value = void 0)
      }
      function Ne(Ke) {
        let ct = Q.value
        ;(ct = ct.set('year', Ke.year())),
          pe.value === 'month' && (ct = ct.set('month', Ke.month())),
          xe([ft.value, ct]),
          (pe.value = void 0)
      }
      const Et = J([z.value[0] || Nr(), z.value[1] || Nr()])
      pt(z, () => {
        const [Ke, ct] = z.value
        ;(Et.value[0] = Ke || Et.value[0]), (Et.value[1] = ct || Et.value[1])
      })
      const [kt, je, Ge] = SG(Je({ timePickerProps: h, selectedValue: z })),
        Ye = C(() => r.value === 'date' && i.value),
        lt = C(() => Ye.value || h.value),
        gt = Wk(
          Je({
            mode: r,
            isRange: !0,
            showTime: i,
            disabledDate: v,
            disabledTime: g,
          })
        ),
        _e = C(() => Ye.value || F.value),
        bt = C(
          () =>
            _e.value &&
            (!ms(G.value) || gt(G.value[0], 'start') || gt(G.value[1], 'end'))
        )
      pt(we, (Ke) => {
        ;(re.value = void 0),
          (pe.value = void 0),
          nt(void 0),
          D(void 0),
          Ke && (de(), Ge(), (te.value = q(te.value)), hn(() => Tr(te.value))),
          Ke || ae(void 0)
      }),
        pt(te, () => {
          e.disabledInput && (Tr(te.value), ae(void 0))
        })
      function He(Ke, ct) {
        var Tt, Bt
        const Dt = Ke ? F0(Ke, W.value) : void 0,
          jt = Jo(Ke, Y.value),
          _n = wi(Ke)
        G_(Ke, Re.value) &&
          (t('update:modelValue', Dt),
          t('change', Dt, _n, jt),
          (Bt = (Tt = N.value) == null ? void 0 : Tt.onChange) == null ||
            Bt.call(Tt)),
          ct && t('ok', Dt, _n, jt)
      }
      function _t(Ke) {
        let ct = Ld(Ke)
        return (
          lt.value && !P.value && (ct = [vt(ct[0], Ke[0]), vt(ct[1], Ke[1])]),
          ct
        )
      }
      function wt(Ke, ct, Tt) {
        if (
          gt(Ke == null ? void 0 : Ke[0], 'start') ||
          gt(Ke == null ? void 0 : Ke[1], 'end')
        )
          return
        let Bt = Ke ? [...Ke] : void 0
        ms(Bt) && (Bt = _t(Bt)),
          He(Bt, Tt),
          qe(Bt || []),
          nt(void 0),
          D(void 0),
          ae(void 0),
          (re.value = void 0),
          (pe.value = void 0),
          Ui(ct) && Ae(ct)
      }
      function Zt(Ke) {
        const ct = F0(Ke, W.value),
          Tt = Jo(Ke, Y.value),
          Bt = wi(Ke)
        t('select', ct, Bt, Tt)
      }
      function ln(Ke, ct) {
        const { emitSelect: Tt = !1, updateHeader: Bt = !1 } = ct || {}
        let Dt = [...Ke]
        ms(Dt) && (Dt = _t(Dt)),
          nt(Dt),
          D(void 0),
          ae(void 0),
          (re.value = void 0),
          (pe.value = void 0),
          Tt && Zt(Dt),
          Bt && de()
      }
      function Pn(Ke, ct) {
        const { updateHeader: Tt = !1 } = ct || {}
        D(Ke), ae(void 0), Tt && de()
      }
      function Tr(Ke) {
        oe.value && oe.value.focus && oe.value.focus(Ke)
      }
      function vt(Ke, ct) {
        return lt.value ? $k(Nr(), Ke, ct) : Ke
      }
      function Gt(Ke) {
        Ae(Ke)
      }
      function pn(Ke) {
        if (Ve.value && z.value[ue.value] && (!_e.value || !ms(Ve.value))) {
          const ct = [...z.value],
            Tt = vt(Ke, kt.value[te.value])
          ;(ct[te.value] = Tt), Pn(ct)
        }
      }
      function yr(Ke = !1) {
        return me.value
          ? [...Re.value]
          : Ve.value
          ? Ke || !ms(Ve.value)
            ? [...Ve.value]
            : []
          : Ke
          ? [...Re.value]
          : []
      }
      function hi(Ke) {
        const ct = yr(),
          Tt = vt(Ke, kt.value[te.value])
        ;(ct[te.value] = Tt),
          Zt(ct),
          !_e.value && ms(ct)
            ? wt(ct, !1)
            : (ln(ct), ms(ct) ? (te.value = 0) : (te.value = ue.value))
      }
      function Qr(Ke, ct) {
        const Tt = ct === 'start' ? 0 : 1,
          Bt = vt(kt.value[Tt], Ke),
          Dt = [...kt.value]
        ;(Dt[Tt] = Bt), je(Dt)
        const jt = yr(!0)
        jt[Tt] && ((jt[Tt] = Bt), ln(jt, { emitSelect: !0 }))
      }
      let Ur
      wr(() => {
        clearTimeout(Ur)
      })
      function da(Ke) {
        clearTimeout(Ur), Pn(Ke, { updateHeader: !0 })
      }
      function co() {
        clearTimeout(Ur),
          (Ur = setTimeout(() => {
            D(void 0), ae(void 0), de()
          }, 100))
      }
      function ki(Ke, ct) {
        t('select-shortcut', ct), wt(Ke, !1)
      }
      function fo() {
        wt(z.value, !1, !0)
      }
      function ho(Ke) {
        Ke.stopPropagation(), wt(void 0), t('clear')
      }
      function Rs(Ke) {
        Ae(!0)
        const ct = Ke.target.value
        if (!ct) {
          ae(void 0)
          return
        }
        const Tt = Jo(z.value, L.value),
          Bt = Ft(ie.value) ? [...ie.value] : Tt || []
        if (((Bt[te.value] = ct), ae(Bt), !uv(ct, L.value))) return
        const Dt = nr(ct, L.value)
        if (gt(Dt, te.value === 0 ? 'start' : 'end')) return
        const jt = Ft(z.value) ? [...z.value] : []
        ;(jt[te.value] = Dt), ln(jt, { updateHeader: !0 })
      }
      function fe() {
        rW(z.value) ? wt(z.value, !1) : (te.value = ue.value)
      }
      const Ue = C(() =>
          cM(
            pv(
              { format: L.value },
              xr((h == null ? void 0 : h.value) || {}, ['defaultValue'])
            ),
            { visible: we.value }
          )
        ),
        Xe = C(() => ({
          prev: n['icon-prev'],
          prevDouble: n['icon-prev-double'],
          next: n['icon-next'],
          nextDouble: n['icon-next-double'],
        })),
        De = Je({ headerValue: ft, headerOperations: X, headerIcons: Xe }),
        rt = Je({ headerValue: Q, headerOperations: he, headerIcons: Xe }),
        Ot = C(() =>
          cM(
            pv(
              {},
              ra(e, [
                'mode',
                'showTime',
                'shortcuts',
                'shortcutsPosition',
                'dayStartOfWeek',
                'disabledDate',
                'disabledTime',
                'hideTrigger',
                'abbreviation',
              ])
            ),
            {
              prefixCls: B,
              format: Y.value,
              value: z.value,
              showConfirmBtn: _e.value,
              confirmBtnDisabled: bt.value,
              timePickerValue: kt.value,
              timePickerProps: Ue.value,
              extra: n.extra,
              dateRender: n.cell,
              startHeaderProps: De,
              endHeaderProps: rt,
              footerValue: Et.value,
              disabled: U.value,
              visible: we.value,
              onCellClick: hi,
              onCellMouseEnter: pn,
              onShortcutClick: ki,
              onShortcutMouseEnter: A.value ? da : void 0,
              onShortcutMouseLeave: A.value ? co : void 0,
              onConfirm: fo,
              onTimePickerSelect: Qr,
              startHeaderMode: re.value,
              endHeaderMode: pe.value,
              onStartHeaderLabelClick: ne,
              onEndHeaderLabelClick: Le,
              onStartHeaderSelect: et,
              onEndHeaderSelect: Ne,
            }
          )
        )
      return {
        prefixCls: B,
        refInput: oe,
        computedFormat: L,
        computedPlaceholder: V,
        panelVisible: we,
        panelValue: z,
        inputValue: ie,
        focusedIndex: te,
        triggerDisabled: le,
        mergedSize: k,
        mergedError: j,
        onPanelVisibleChange: Gt,
        onInputClear: ho,
        onInputChange: Rs,
        onInputPressEnter: fe,
        rangePanelProps: Ot,
      }
    },
  })
  function TG(e, t, n, r, i, o) {
    const a = ge('IconCalendar'),
      s = ge('DateRangeInput'),
      l = ge('RangePickerPanel'),
      c = ge('Trigger')
    return e.hideTrigger
      ? (O(),
        Ee(
          l,
          En(Fe({ key: 1 }, pv(pv({}, e.$attrs), e.rangePanelProps))),
          null,
          16
        ))
      : (O(),
        Ee(
          c,
          Fe(
            {
              key: 0,
              trigger: 'click',
              'animation-name': 'slide-dynamic-origin',
              'auto-fit-transform-origin': '',
              'click-to-close': !1,
              'popup-offset': 4,
            },
            e.triggerProps,
            {
              'unmount-on-close': e.unmountOnClose,
              position: e.position,
              disabled: e.triggerDisabled || e.readonly,
              'popup-visible': e.panelVisible,
              'popup-container': e.popupContainer,
              onPopupVisibleChange: e.onPanelVisibleChange,
            }
          ),
          {
            content: ze(() => [m(l, En(Rr(e.rangePanelProps)), null, 16)]),
            default: ze(() => [
              ve(e.$slots, 'default', {}, () => [
                m(
                  s,
                  Fe({ ref: 'refInput' }, e.$attrs, {
                    focusedIndex: e.focusedIndex,
                    'onUpdate:focusedIndex':
                      t[0] || (t[0] = (d) => (e.focusedIndex = d)),
                    size: e.size,
                    focused: e.panelVisible,
                    visible: e.panelVisible,
                    error: e.error,
                    disabled: e.disabled,
                    readonly: e.readonly || e.disabledInput,
                    'allow-clear': e.allowClear && !e.readonly,
                    placeholder: e.computedPlaceholder,
                    'input-value': e.inputValue,
                    value: e.panelValue,
                    format: e.computedFormat,
                    onClear: e.onInputClear,
                    onChange: e.onInputChange,
                    onPressEnter: e.onInputPressEnter,
                  }),
                  Nn(
                    {
                      'suffix-icon': ze(() => [
                        ve(e.$slots, 'suffix-icon', {}, () => [m(a)]),
                      ]),
                      separator: ze(() => [
                        ve(e.$slots, 'separator', {}, () => [
                          Lt(mt(e.separator || '-'), 1),
                        ]),
                      ]),
                      _: 2,
                    },
                    [
                      e.$slots.prefix
                        ? {
                            name: 'prefix',
                            fn: ze(() => [ve(e.$slots, 'prefix')]),
                          }
                        : void 0,
                    ]
                  ),
                  1040,
                  [
                    'focusedIndex',
                    'size',
                    'focused',
                    'visible',
                    'error',
                    'disabled',
                    'readonly',
                    'allow-clear',
                    'placeholder',
                    'input-value',
                    'value',
                    'format',
                    'onClear',
                    'onChange',
                    'onPressEnter',
                  ]
                ),
              ]),
            ]),
            _: 3,
          },
          16,
          [
            'unmount-on-close',
            'position',
            'disabled',
            'popup-visible',
            'popup-container',
            'onPopupVisibleChange',
          ]
        ))
  }
  var _p = Te(PG, [['render', TG]])
  const kG = Object.assign(z0, {
      WeekPicker: mp,
      MonthPicker: gp,
      YearPicker: yp,
      QuarterPicker: bp,
      RangePicker: _p,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + z0.name, z0),
          e.component(n + yp.name, yp),
          e.component(n + bp.name, bp),
          e.component(n + gp.name, gp),
          e.component(n + mp.name, mp),
          e.component(n + _p.name, _p)
      },
    }),
    qk = Symbol('ArcoDescriptions')
  var AG = Object.defineProperty,
    $G = Object.defineProperties,
    OG = Object.getOwnPropertyDescriptors,
    dM = Object.getOwnPropertySymbols,
    LG = Object.prototype.hasOwnProperty,
    IG = Object.prototype.propertyIsEnumerable,
    fM = (e, t, n) =>
      t in e
        ? AG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    RG = (e, t) => {
      for (var n in t || (t = {})) LG.call(t, n) && fM(e, n, t[n])
      if (dM) for (var n of dM(t)) IG.call(t, n) && fM(e, n, t[n])
      return e
    },
    DG = (e, t) => $G(e, OG(t))
  const vv = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'],
    hh = {
      xs: '(max-width: 575px)',
      sm: '(min-width: 576px)',
      md: '(min-width: 768px)',
      lg: '(min-width: 992px)',
      xl: '(min-width: 1200px)',
      xxl: '(min-width: 1600px)',
    }
  let Ys = [],
    NG = -1,
    ph = {}
  const mv = {
    matchHandlers: {},
    dispatch(e, t) {
      return (
        (ph = e),
        Ys.length < 1
          ? !1
          : (Ys.forEach((n) => {
              n.func(ph, t)
            }),
            !0)
      )
    },
    subscribe(e) {
      Ys.length === 0 && this.register()
      const t = (++NG).toString()
      return Ys.push({ token: t, func: e }), e(ph, null), t
    },
    unsubscribe(e) {
      ;(Ys = Ys.filter((t) => t.token !== e)),
        Ys.length === 0 && this.unregister()
    },
    unregister() {
      Object.keys(hh).forEach((e) => {
        const t = hh[e]
        if (!t) return
        const n = this.matchHandlers[t]
        n &&
          n.mql &&
          n.listener &&
          (n.mql.removeEventListener
            ? n.mql.removeEventListener('change', n.listener)
            : n.mql.removeListener(n.listener))
      })
    },
    register() {
      Object.keys(hh).forEach((e) => {
        const t = hh[e]
        if (!t) return
        const n = ({ matches: i }) => {
            this.dispatch(DG(RG({}, ph), { [e]: i }), e)
          },
          r = window.matchMedia(t)
        r.addEventListener ? r.addEventListener('change', n) : r.addListener(n),
          (this.matchHandlers[t] = { mql: r, listener: n }),
          n(r)
      })
    },
  }
  function hM(e) {
    return Ht(e)
  }
  function Da(e, t, n = !1) {
    const r = J({ xs: !0, sm: !0, md: !0, lg: !0, xl: !0, xxl: !0 }),
      i = C(() => {
        let a = t
        if (hM(e.value))
          for (let s = 0; s < vv.length; s++) {
            const l = vv[s]
            if ((r.value[l] || (l === 'xs' && n)) && e.value[l] !== void 0) {
              a = e.value[l]
              break
            }
          }
        else a = e.value
        return a
      })
    let o = ''
    return (
      Wt(() => {
        o = mv.subscribe((a) => {
          hM(e.value) && (r.value = a)
        })
      }),
      wr(() => {
        o && mv.unsubscribe(o)
      }),
      i
    )
  }
  var BG = Object.defineProperty,
    pM = Object.getOwnPropertySymbols,
    FG = Object.prototype.hasOwnProperty,
    zG = Object.prototype.propertyIsEnumerable,
    vM = (e, t, n) =>
      t in e
        ? BG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    mM = (e, t) => {
      for (var n in t || (t = {})) FG.call(t, n) && vM(e, n, t[n])
      if (pM) for (var n of pM(t)) zG.call(t, n) && vM(e, n, t[n])
      return e
    }
  const gM = (e) => (e ? e.reduce((t, n) => t + n.span, 0) : 0)
  var H0 = ce({
    name: 'Descriptions',
    props: {
      data: { type: Array, default: () => [] },
      column: { type: [Number, Object], default: 3 },
      title: String,
      layout: { type: String, default: 'horizontal' },
      align: { type: [String, Object], default: 'left' },
      size: { type: String },
      bordered: { type: Boolean, default: !1 },
      labelStyle: { type: Object },
      valueStyle: { type: Object },
      tableLayout: { type: String, default: 'auto' },
    },
    setup(e, { slots: t }) {
      const { column: n, size: r } = tt(e),
        i = ye('descriptions'),
        { mergedSize: o } = Vr(r),
        a = Da(n, 3, !0),
        s = C(() => {
          var T
          return (T = Ht(e.align) ? e.align.label : e.align) != null
            ? T
            : 'left'
        }),
        l = C(() => {
          var T
          return (T = Ht(e.align) ? e.align.value : e.align) != null
            ? T
            : 'left'
        }),
        c = C(() => mM({ textAlign: s.value }, e.labelStyle)),
        d = C(() => mM({ textAlign: l.value }, e.valueStyle)),
        h = Je(new Map()),
        p = C(() =>
          Array.from(h.values())
            .sort((T, k) => T.index - k.index)
            .map((T) => T.span)
        )
      sn(
        qk,
        Je({
          addItem: (T, k) => {
            h.set(T, k)
          },
          removeItem: (T) => {
            h.delete(T)
          },
        })
      )
      const _ = (T) => {
          const k = []
          if (
            (T.forEach((R, j) => {
              var N
              const I = Math.min(
                  (N = An(R) ? p.value[j] : R.span) != null ? N : 1,
                  a.value
                ),
                B = k[k.length - 1],
                V = gM(B)
              V === 0 || V >= a.value
                ? k.push([{ data: R, span: I }])
                : B.push({ data: R, span: I + V > a.value ? a.value - V : I })
            }),
            k.length)
          ) {
            const R = k[k.length - 1],
              j = gM(R)
            j < a.value && (R[R.length - 1].span += a.value - j)
          }
          return k
        },
        b = C(() => {
          var T
          return _((T = e.data) != null ? T : [])
        }),
        y = (T, k) => {
          var R, j, N, I, B
          return An(T)
            ? (Wv(T, T.children) &&
                ((j = (R = T.children).label) == null ? void 0 : j.call(R))) ||
                ((N = T.props) == null ? void 0 : N.label)
            : (B =
                (I = t.label) == null
                  ? void 0
                  : I.call(t, { label: T.label, index: k, data: T })) != null
            ? B
            : xt(T.label)
            ? T.label()
            : T.label
        },
        M = (T, k) => {
          var R, j
          return An(T)
            ? T
            : (j =
                (R = t.value) == null
                  ? void 0
                  : R.call(t, { value: T.value, index: k, data: T })) != null
            ? j
            : xt(T.value)
            ? T.value()
            : T.value
        },
        x = (T) =>
          m(yt, null, [
            m('tr', { class: `${i}-row` }, [
              T.map((k, R) =>
                m(
                  'td',
                  {
                    key: `label-${R}`,
                    class: [`${i}-item-label`, `${i}-item-label-block`],
                    style: c.value,
                    colspan: k.span,
                  },
                  [y(k.data, R)]
                )
              ),
            ]),
            m('tr', { class: `${i}-row` }, [
              T.map((k, R) =>
                m(
                  'td',
                  {
                    key: `value-${R}`,
                    class: [`${i}-item-value`, `${i}-item-value-block`],
                    style: d.value,
                    colspan: k.span,
                  },
                  [M(k.data, R)]
                )
              ),
            ]),
          ]),
        w = (T, k) =>
          m('tr', { class: `${i}-row`, key: `tr-${k}` }, [
            T.map((R) =>
              m(yt, null, [
                m(
                  'td',
                  {
                    class: [`${i}-item-label`, `${i}-item-label-block`],
                    style: c.value,
                  },
                  [y(R.data, k)]
                ),
                m(
                  'td',
                  {
                    class: [`${i}-item-value`, `${i}-item-value-block`],
                    style: d.value,
                    colspan: R.span * 2 - 1,
                  },
                  [M(R.data, k)]
                ),
              ])
            ),
          ]),
        E = (T, k) =>
          m('tr', { class: `${i}-row`, key: `inline-${k}` }, [
            T.map((R, j) =>
              m(
                'td',
                { key: `item-${j}`, class: `${i}-item`, colspan: R.span },
                [
                  m(
                    'div',
                    {
                      class: [`${i}-item-label`, `${i}-item-label-inline`],
                      style: c.value,
                    },
                    [y(R.data, j)]
                  ),
                  m(
                    'div',
                    {
                      class: [`${i}-item-value`, `${i}-item-value-inline`],
                      style: d.value,
                    },
                    [M(R.data, j)]
                  ),
                ]
              )
            ),
          ]),
        P = (T, k) =>
          ['inline-horizontal', 'inline-vertical'].includes(e.layout)
            ? E(T, k)
            : e.layout === 'vertical'
            ? x(T)
            : w(T, k),
        A = C(() => [
          i,
          `${i}-layout-${e.layout}`,
          `${i}-size-${o.value}`,
          { [`${i}-border`]: e.bordered },
          { [`${i}-table-layout-fixed`]: e.tableLayout === 'fixed' },
        ]),
        F = () => {
          var T, k
          const R =
            (k = (T = t.title) == null ? void 0 : T.call(t)) != null
              ? k
              : e.title
          return R ? m('div', { class: `${i}-title` }, [R]) : null
        }
      return () => {
        const T = t.default ? _(ea(t.default())) : b.value
        return m('div', { class: A.value }, [
          F(),
          m('div', { class: `${i}-body` }, [
            m('table', { class: `${i}-table` }, [
              m('tbody', null, [T.map((k, R) => P(k, R))]),
            ]),
          ]),
        ])
      }
    },
  })
  const VG = ce({
    name: 'DescriptionsItem',
    props: { span: { type: Number, default: 1 }, label: String },
    setup(e) {
      var t
      const { span: n } = tt(e),
        r = ye('descriptions'),
        i = zt(qk, {}),
        o = Jr(),
        a = J(),
        { computedIndex: s } = Zv({
          itemRef: a,
          selector: `.${r}-item-value`,
          parentClassName: `${r}-table`,
        }),
        l = Je({ index: s, span: n })
      o != null && o.uid && ((t = i.addItem) == null || t.call(i, o.uid, l))
      const c = () => {
        var d
        const h = ((d = o == null ? void 0 : o.proxy) == null ? void 0 : d.$el)
          .parentElement
        h && h !== a.value && (a.value = h)
      }
      return (
        Wt(() => c()),
        Zr(() => c()),
        Pr(() => {
          var d
          o != null && o.uid && ((d = i.removeItem) == null || d.call(i, o.uid))
        }),
        { prefixCls: r }
      )
    },
  })
  function UG(e, t, n, r, i, o) {
    return ve(e.$slots, 'default')
  }
  var Sp = Te(VG, [['render', UG]])
  const HG = Object.assign(H0, {
    DescriptionsItem: Sp,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + H0.name, H0), e.component(n + Sp.name, Sp)
    },
  })
  var W0 = ce({
    name: 'Divider',
    props: {
      direction: { type: String, default: 'horizontal' },
      orientation: { type: String, default: 'center' },
      type: { type: String },
      size: { type: Number },
      margin: { type: [Number, String] },
    },
    setup(e, { slots: t }) {
      const n = ye('divider'),
        r = C(() => e.direction === 'horizontal'),
        i = C(() => {
          const o = {}
          if (
            (e.size &&
              (o[r.value ? 'border-bottom-width' : 'border-left-width'] = it(
                e.size
              )
                ? `${e.size}px`
                : e.size),
            e.type &&
              (o[r.value ? 'border-bottom-style' : 'border-left-style'] =
                e.type),
            !Mt(e.margin))
          ) {
            const a = it(e.margin) ? `${e.margin}px` : e.margin
            o.margin = r.value ? `${a} 0` : `0 ${a}`
          }
          return o
        })
      return () => {
        var o
        const a = (o = t.default) == null ? void 0 : o.call(t),
          s = [n, `${n}-${e.direction}`, { [`${n}-with-text`]: a }]
        return m('div', { role: 'separator', class: s, style: i.value }, [
          a &&
            e.direction === 'horizontal' &&
            m('span', { class: [`${n}-text`, `${n}-text-${e.orientation}`] }, [
              a,
            ]),
        ])
      }
    },
  })
  const WG = Object.assign(W0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + W0.name, W0)
      },
    }),
    Xk = (e) => {
      const t = J(!1),
        n = { overflow: '', width: '', boxSizing: '' }
      return {
        setOverflowHidden: () => {
          if (e.value) {
            const o = e.value
            if (!t.value && o.style.overflow !== 'hidden') {
              const a = qB(o)
              ;(a > 0 || KB(o)) &&
                ((n.overflow = o.style.overflow),
                (n.width = o.style.width),
                (n.boxSizing = o.style.boxSizing),
                (o.style.overflow = 'hidden'),
                (o.style.width = `${o.offsetWidth - a}px`),
                (o.style.boxSizing = 'border-box'),
                (t.value = !0))
            }
          }
        },
        resetOverflow: () => {
          if (e.value && t.value) {
            const o = e.value
            ;(o.style.overflow = n.overflow),
              (o.style.width = n.width),
              (o.style.boxSizing = n.boxSizing),
              (t.value = !1)
          }
        },
      }
    }
  var jG = Object.defineProperty,
    yM = Object.getOwnPropertySymbols,
    GG = Object.prototype.hasOwnProperty,
    KG = Object.prototype.propertyIsEnumerable,
    bM = (e, t, n) =>
      t in e
        ? jG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    qG = (e, t) => {
      for (var n in t || (t = {})) GG.call(t, n) && bM(e, n, t[n])
      if (yM) for (var n of yM(t)) KG.call(t, n) && bM(e, n, t[n])
      return e
    }
  const XG = ['top', 'right', 'bottom', 'left'],
    YG = ce({
      name: 'Drawer',
      components: {
        ClientOnly: N_,
        ArcoButton: Yr,
        IconHover: In,
        IconClose: zr,
      },
      inheritAttrs: !1,
      props: {
        visible: { type: Boolean, default: !1 },
        defaultVisible: { type: Boolean, default: !1 },
        placement: {
          type: String,
          default: 'right',
          validator: (e) => XG.includes(e),
        },
        title: String,
        mask: { type: Boolean, default: !0 },
        maskClosable: { type: Boolean, default: !0 },
        closable: { type: Boolean, default: !0 },
        okText: String,
        cancelText: String,
        okLoading: { type: Boolean, default: !1 },
        okButtonProps: { type: Object },
        cancelButtonProps: { type: Object },
        unmountOnClose: Boolean,
        width: { type: [Number, String], default: 250 },
        height: { type: [Number, String], default: 250 },
        popupContainer: { type: [String, Object], default: 'body' },
        drawerStyle: { type: Object },
        onBeforeOk: { type: Function },
        onBeforeCancel: { type: Function },
        escToClose: { type: Boolean, default: !0 },
        renderToBody: { type: Boolean, default: !0 },
        header: { type: Boolean, default: !0 },
        footer: { type: Boolean, default: !0 },
        hideCancel: { type: Boolean, default: !1 },
      },
      emits: {
        'update:visible': (e) => !0,
        ok: (e) => !0,
        cancel: (e) => !0,
        open: () => !0,
        close: () => !0,
        beforeOpen: () => !0,
        beforeClose: () => !0,
      },
      setup(e, { emit: t }) {
        const { popupContainer: n } = tt(e),
          r = ye('drawer'),
          { t: i } = Vn(),
          o = J(e.defaultVisible),
          a = C(() => {
            var N
            return (N = e.visible) != null ? N : o.value
          }),
          s = J(!1),
          l = C(() => e.okLoading || s.value),
          { teleportContainer: c, containerRef: d } = B_({
            popupContainer: n,
            visible: a,
          }),
          h = J(a.value)
        let p = !1
        const v = (N) => {
            e.escToClose && N.key === fr.ESC && y() && P(N)
          },
          g = () => {
            e.escToClose &&
              !p &&
              ((p = !0), Cn(document.documentElement, 'keydown', v))
          },
          _ = () => {
            p && ((p = !1), kn(document.documentElement, 'keydown', v))
          },
          { zIndex: b, isLastDialog: y } = oc('dialog', { visible: a }),
          M = C(() => (d == null ? void 0 : d.value) === document.body)
        let x = 0
        const w = () => {
            x++,
              s.value && (s.value = !1),
              (o.value = !1),
              t('update:visible', !1)
          },
          E = async (N) => {
            const I = x,
              B = await new Promise(async (V) => {
                var L
                if (xt(e.onBeforeOk)) {
                  let W = e.onBeforeOk((Y = !0) => V(Y))
                  if (((xl(W) || !Ui(W)) && (s.value = !0), xl(W)))
                    try {
                      W = (L = await W) != null ? L : !0
                    } catch {
                      W = !1
                    }
                  Ui(W) && V(W)
                } else V(!0)
              })
            I === x && (B ? (t('ok', N), w()) : s.value && (s.value = !1))
          },
          P = (N) => {
            var I
            let B = !0
            xt(e.onBeforeCancel) &&
              (B = (I = e.onBeforeCancel()) != null ? I : !1),
              B && (t('cancel', N), w())
          },
          A = (N) => {
            e.maskClosable && P(N)
          },
          F = () => {
            a.value && t('open')
          },
          T = () => {
            a.value || ((h.value = !1), R(), t('close'))
          },
          { setOverflowHidden: k, resetOverflow: R } = Xk(d)
        Wt(() => {
          a.value && ((h.value = !0), k(), g())
        }),
          Pr(() => {
            R(), _()
          }),
          pt(a, (N) => {
            o.value !== N && (o.value = N),
              N
                ? (t('beforeOpen'), (h.value = !0), k(), g())
                : (t('beforeClose'), _())
          })
        const j = C(() => {
          var N
          const I = qG(
            { [e.placement]: 0 },
            (N = e.drawerStyle) != null ? N : {}
          )
          return (
            ['right', 'left'].includes(e.placement)
              ? (I.width = it(e.width) ? `${e.width}px` : e.width)
              : (I.height = it(e.height) ? `${e.height}px` : e.height),
            I
          )
        })
        return {
          prefixCls: r,
          style: j,
          t: i,
          mounted: h,
          computedVisible: a,
          mergedOkLoading: l,
          zIndex: b,
          handleOk: E,
          handleCancel: P,
          handleOpen: F,
          handleClose: T,
          handleMask: A,
          isFixed: M,
          teleportContainer: c,
        }
      },
    })
  function ZG(e, t, n, r, i, o) {
    const a = ge('icon-close'),
      s = ge('icon-hover'),
      l = ge('arco-button'),
      c = ge('client-only')
    return (
      O(),
      Ee(c, null, {
        default: ze(() => [
          (O(),
          Ee(
            Dv,
            { to: e.teleportContainer, disabled: !e.renderToBody },
            [
              !e.unmountOnClose || e.computedVisible || e.mounted
                ? ro(
                    (O(),
                    Z(
                      'div',
                      Fe(
                        {
                          key: 0,
                          class: `${e.prefixCls}-container`,
                          style: e.isFixed
                            ? { zIndex: e.zIndex }
                            : { zIndex: 'inherit', position: 'absolute' },
                        },
                        e.$attrs
                      ),
                      [
                        m(
                          Fr,
                          { name: 'fade-drawer', appear: '' },
                          {
                            default: ze(() => [
                              e.mask
                                ? ro(
                                    (O(),
                                    Z(
                                      'div',
                                      {
                                        key: 0,
                                        class: H(`${e.prefixCls}-mask`),
                                        onClick:
                                          t[0] ||
                                          (t[0] = (...d) =>
                                            e.handleMask && e.handleMask(...d)),
                                      },
                                      null,
                                      2
                                    )),
                                    [[oo, e.computedVisible]]
                                  )
                                : Ce('v-if', !0),
                            ]),
                            _: 1,
                          }
                        ),
                        m(
                          Fr,
                          {
                            name: `slide-${e.placement}-drawer`,
                            appear: '',
                            onAfterEnter: e.handleOpen,
                            onAfterLeave: e.handleClose,
                          },
                          {
                            default: ze(() => [
                              ro(
                                Se(
                                  'div',
                                  { class: H(e.prefixCls), style: at(e.style) },
                                  [
                                    e.header
                                      ? (O(),
                                        Z(
                                          'div',
                                          {
                                            key: 0,
                                            class: H(`${e.prefixCls}-header`),
                                          },
                                          [
                                            ve(e.$slots, 'header', {}, () => [
                                              e.$slots.title || e.title
                                                ? (O(),
                                                  Z(
                                                    'div',
                                                    {
                                                      key: 0,
                                                      class: H(
                                                        `${e.prefixCls}-title`
                                                      ),
                                                    },
                                                    [
                                                      ve(
                                                        e.$slots,
                                                        'title',
                                                        {},
                                                        () => [
                                                          Lt(mt(e.title), 1),
                                                        ]
                                                      ),
                                                    ],
                                                    2
                                                  ))
                                                : Ce('v-if', !0),
                                              e.closable
                                                ? (O(),
                                                  Z(
                                                    'div',
                                                    {
                                                      key: 1,
                                                      tabindex: '-1',
                                                      role: 'button',
                                                      'aria-label': 'Close',
                                                      class: H(
                                                        `${e.prefixCls}-close-btn`
                                                      ),
                                                      onClick:
                                                        t[1] ||
                                                        (t[1] = (...d) =>
                                                          e.handleCancel &&
                                                          e.handleCancel(...d)),
                                                    },
                                                    [
                                                      m(s, null, {
                                                        default: ze(() => [
                                                          m(a),
                                                        ]),
                                                        _: 1,
                                                      }),
                                                    ],
                                                    2
                                                  ))
                                                : Ce('v-if', !0),
                                            ]),
                                          ],
                                          2
                                        ))
                                      : Ce('v-if', !0),
                                    Se(
                                      'div',
                                      { class: H(`${e.prefixCls}-body`) },
                                      [ve(e.$slots, 'default')],
                                      2
                                    ),
                                    e.footer
                                      ? (O(),
                                        Z(
                                          'div',
                                          {
                                            key: 1,
                                            class: H(`${e.prefixCls}-footer`),
                                          },
                                          [
                                            ve(e.$slots, 'footer', {}, () => [
                                              e.hideCancel
                                                ? Ce('v-if', !0)
                                                : (O(),
                                                  Ee(
                                                    l,
                                                    Fe(
                                                      { key: 0 },
                                                      e.cancelButtonProps,
                                                      {
                                                        onClick: e.handleCancel,
                                                      }
                                                    ),
                                                    {
                                                      default: ze(() => [
                                                        Lt(
                                                          mt(
                                                            e.cancelText ||
                                                              e.t(
                                                                'drawer.cancelText'
                                                              )
                                                          ),
                                                          1
                                                        ),
                                                      ]),
                                                      _: 1,
                                                    },
                                                    16,
                                                    ['onClick']
                                                  )),
                                              m(
                                                l,
                                                Fe(
                                                  {
                                                    type: 'primary',
                                                    loading: e.mergedOkLoading,
                                                  },
                                                  e.okButtonProps,
                                                  { onClick: e.handleOk }
                                                ),
                                                {
                                                  default: ze(() => [
                                                    Lt(
                                                      mt(
                                                        e.okText ||
                                                          e.t('drawer.okText')
                                                      ),
                                                      1
                                                    ),
                                                  ]),
                                                  _: 1,
                                                },
                                                16,
                                                ['loading', 'onClick']
                                              ),
                                            ]),
                                          ],
                                          2
                                        ))
                                      : Ce('v-if', !0),
                                  ],
                                  6
                                ),
                                [[oo, e.computedVisible]]
                              ),
                            ]),
                            _: 3,
                          },
                          8,
                          ['name', 'onAfterEnter', 'onAfterLeave']
                        ),
                      ],
                      16
                    )),
                    [[oo, e.computedVisible || e.mounted]]
                  )
                : Ce('v-if', !0),
            ],
            8,
            ['to', 'disabled']
          )),
        ]),
        _: 3,
      })
    )
  }
  var Cp = Te(YG, [['render', ZG]]),
    JG = Object.defineProperty,
    _M = Object.getOwnPropertySymbols,
    QG = Object.prototype.hasOwnProperty,
    eK = Object.prototype.propertyIsEnumerable,
    SM = (e, t, n) =>
      t in e
        ? JG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    j0 = (e, t) => {
      for (var n in t || (t = {})) QG.call(t, n) && SM(e, n, t[n])
      if (_M) for (var n of _M(t)) eK.call(t, n) && SM(e, n, t[n])
      return e
    }
  const CM = (e, t) => {
      let n = jv('drawer')
      const r = () => {
          c.component && (c.component.props.visible = !1),
            xt(e.onOk) && e.onOk()
        },
        i = () => {
          c.component && (c.component.props.visible = !1),
            xt(e.onCancel) && e.onCancel()
        },
        o = async () => {
          await hn(),
            n && (Ua(null, n), document.body.removeChild(n)),
            (n = null),
            xt(e.onClose) && e.onClose()
        },
        a = () => {
          c.component && (c.component.props.visible = !1)
        },
        s = (d) => {
          c.component &&
            Object.entries(d).forEach(([h, p]) => {
              c.component.props[h] = p
            })
        },
        c = m(
          Cp,
          j0(
            j0(
              j0(
                {},
                {
                  visible: !0,
                  renderToBody: !1,
                  unmountOnClose: !0,
                  onOk: r,
                  onCancel: i,
                  onClose: o,
                }
              ),
              xr(e, [
                'content',
                'title',
                'footer',
                'visible',
                'unmountOnClose',
                'onOk',
                'onCancel',
                'onClose',
              ])
            ),
            {
              header: typeof e.header == 'boolean' ? e.header : void 0,
              footer: typeof e.footer == 'boolean' ? e.footer : void 0,
            }
          ),
          {
            default: ui(e.content),
            header: typeof e.header != 'boolean' ? ui(e.header) : void 0,
            title: ui(e.title),
            footer: typeof e.footer != 'boolean' ? ui(e.footer) : void 0,
          }
        )
      return (
        (t ?? Eb._context) && (c.appContext = t ?? Eb._context),
        Ua(c, n),
        document.body.appendChild(n),
        { close: a, update: s }
      )
    },
    Eb = Object.assign(Cp, {
      open: CM,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Cp.name, Cp)
        const r = { open: (i, o = e._context) => CM(i, o) }
        e.config.globalProperties.$drawer = r
      },
      _context: null,
    }),
    tK = ce({
      name: 'Form',
      props: {
        model: { type: Object, required: !0 },
        layout: { type: String, default: 'horizontal' },
        size: { type: String },
        labelColProps: {
          type: Object,
          default: () => ({ span: 5, offset: 0 }),
        },
        wrapperColProps: {
          type: Object,
          default: () => ({ span: 19, offset: 0 }),
        },
        labelColStyle: Object,
        wrapperColStyle: Object,
        labelAlign: { type: String, default: 'right' },
        disabled: { type: Boolean, default: void 0 },
        rules: { type: Object },
        autoLabelWidth: { type: Boolean, default: !1 },
      },
      emits: {
        submit: (e, t) => !0,
        submitSuccess: (e, t) => !0,
        submitFailed: (e, t) => !0,
      },
      setup(e, { emit: t }) {
        const n = ye('form'),
          {
            model: r,
            layout: i,
            disabled: o,
            labelAlign: a,
            labelColProps: s,
            wrapperColProps: l,
            labelColStyle: c,
            wrapperColStyle: d,
            size: h,
            rules: p,
          } = tt(e),
          { mergedSize: v } = Vr(h),
          g = C(() => e.layout === 'horizontal' && e.autoLabelWidth),
          _ = [],
          b = [],
          y = Je({}),
          M = C(() => Math.max(...Object.values(y))),
          x = (I) => {
            I && I.field && _.push(I)
          },
          w = (I) => {
            I && I.field && _.splice(_.indexOf(I), 1)
          },
          E = (I) => {
            _.forEach((B) => {
              I[B.field] && B.setField(I[B.field])
            })
          },
          P = (I, B) => {
            B && y[B] !== I && (y[B] = I)
          },
          A = (I) => {
            I && delete y[I]
          },
          F = (I) => {
            const B = I ? [].concat(I) : []
            _.forEach((V) => {
              ;(B.length === 0 || B.includes(V.field)) && V.resetField()
            })
          },
          T = (I) => {
            const B = I ? [].concat(I) : []
            _.forEach((V) => {
              ;(B.length === 0 || B.includes(V.field)) && V.clearValidate()
            })
          },
          k = (I) => {
            const B = []
            return (
              _.forEach((V) => {
                B.push(V.validate())
              }),
              Promise.all(B).then((V) => {
                const L = {}
                let W = !1
                return (
                  V.forEach((Y) => {
                    Y && ((W = !0), (L[Y.field] = Y))
                  }),
                  xt(I) && I(W ? L : void 0),
                  W ? L : void 0
                )
              })
            )
          },
          R = (I, B) => {
            const V = []
            for (const L of _)
              ((Ft(I) && I.includes(L.field)) || I === L.field) &&
                V.push(L.validate())
            return Promise.all(V).then((L) => {
              const W = {}
              let Y = !1
              return (
                L.forEach((U) => {
                  U && ((Y = !0), (W[U.field] = U))
                }),
                xt(B) && B(Y ? W : void 0),
                Y ? W : void 0
              )
            })
          },
          j = (I) => {
            const B = []
            _.forEach((V) => {
              B.push(V.validate())
            }),
              Promise.all(B).then((V) => {
                const L = {}
                let W = !1
                V.forEach((Y) => {
                  Y && ((W = !0), (L[Y.field] = Y))
                }),
                  W
                    ? t('submitFailed', { values: r.value, errors: L }, I)
                    : t('submitSuccess', r.value, I),
                  t('submit', { values: r.value, errors: W ? L : void 0 }, I)
              })
          }
        return (
          sn(
            D_,
            Je({
              layout: i,
              disabled: o,
              labelAlign: a,
              labelColProps: s,
              wrapperColProps: l,
              labelColStyle: c,
              wrapperColStyle: d,
              model: r,
              size: v,
              rules: p,
              fields: _,
              touchedFields: b,
              addField: x,
              removeField: w,
              validateField: R,
              setLabelWidth: P,
              removeLabelWidth: A,
              maxLabelWidth: M,
              autoLabelWidth: g,
            })
          ),
          {
            cls: C(() => [
              n,
              `${n}-layout-${e.layout}`,
              `${n}-size-${v.value}`,
              { [`${n}-auto-label-width`]: e.autoLabelWidth },
            ]),
            handleSubmit: j,
            innerValidate: k,
            innerValidateField: R,
            innerResetFields: F,
            innerClearValidate: T,
            innerSetFields: E,
          }
        )
      },
      methods: {
        validate(e) {
          return this.innerValidate(e)
        },
        validateField(e, t) {
          return this.innerValidateField(e, t)
        },
        resetFields(e) {
          return this.innerResetFields(e)
        },
        clearValidate(e) {
          return this.innerClearValidate(e)
        },
        setFields(e) {
          return this.innerSetFields(e)
        },
      },
    })
  function nK(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'form',
        {
          class: H(e.cls),
          onSubmit:
            t[0] ||
            (t[0] = io(
              (...a) => e.handleSubmit && e.handleSubmit(...a),
              ['prevent']
            )),
        },
        [ve(e.$slots, 'default')],
        34
      )
    )
  }
  var G0 = Te(tK, [['render', nK]]),
    lc = Object.prototype.toString
  function nm(e) {
    return lc.call(e) === '[object Array]'
  }
  function Na(e) {
    return lc.call(e) === '[object Object]'
  }
  function Pb(e) {
    return lc.call(e) === '[object String]'
  }
  function rK(e) {
    return lc.call(e) === '[object Number]' && e === e
  }
  function iK(e) {
    return lc.call(e) === '[object Boolean]'
  }
  function Tb(e) {
    return lc.call(e) === '[object Function]'
  }
  function oK(e) {
    return Na(e) && Object.keys(e).length === 0
  }
  function nl(e) {
    return e == null || e === ''
  }
  function Yk(e) {
    return nm(e) && !e.length
  }
  var iS = function (e, t) {
      if (typeof e != 'object' || typeof t != 'object') return e === t
      if (Tb(e) && Tb(t)) return e === t || e.toString() === t.toString()
      if (Object.keys(e).length !== Object.keys(t).length) return !1
      for (var n in e) {
        var r = iS(e[n], t[n])
        if (!r) return !1
      }
      return !0
    },
    oS = function (e, t) {
      var n = Object.assign({}, e)
      return (
        Object.keys(t || {}).forEach(function (r) {
          var i = n[r],
            o = t == null ? void 0 : t[r]
          n[r] = Na(i) ? Object.assign(Object.assign({}, i), o) : o || i
        }),
        n
      )
    },
    aK = function (e, t) {
      for (var n = t.split('.'), r = e, i = 0; i < n.length; i++)
        if (((r = r && r[n[i]]), r === void 0)) return r
      return r
    },
    us = '#{field} is not a #{type} type',
    sK = {
      required: '#{field} is required',
      type: {
        ip: us,
        email: us,
        url: us,
        string: us,
        number: us,
        array: us,
        object: us,
        boolean: us,
      },
      number: {
        min: '`#{value}` is not greater than `#{min}`',
        max: '`#{value}` is not less than `#{max}`',
        equal: '`#{value}` is not equal to `#{equal}`',
        range: '`#{value}` is not in range `#{min} ~ #{max}`',
        positive: '`#{value}` is not a positive number',
        negative: '`#{value}` is not a negative number',
      },
      string: {
        maxLength: '#{field} cannot be longer than #{maxLength} characters',
        minLength: '#{field} must be at least #{minLength} characters',
        length: '#{field} must be exactly #{length} characters',
        match: '`#{value}` does not match pattern #{pattern}',
        uppercase: '`#{value}` must be all uppercase',
        lowercase: '`#{value}` must be all lowercased',
      },
      array: {
        length: '#{field} must be exactly #{length} in length',
        minLength: '#{field} cannot be less than #{minLength} in length',
        maxLength: '#{field} cannot be greater than #{maxLength} in length',
        includes: '#{field} is not includes #{includes}',
        deepEqual: '#{field} is not deep equal with #{deepEqual}',
        empty: '#{field} is not an empty array',
      },
      object: {
        deepEqual: '#{field} is not deep equal to expected value',
        hasKeys: '#{field} does not contain required fields',
        empty: '#{field} is not an empty object',
      },
      boolean: {
        true: 'Expect true but got `#{value}`',
        false: 'Expect false but got `#{value}`',
      },
    },
    Bo = function (t, n) {
      var r = this
      ;(this.getValidateMsg = function (i, o) {
        o === void 0 && (o = {})
        var a = Object.assign(Object.assign({}, o), {
            value: r.obj,
            field: r.field,
            type: r.type,
          }),
          s = aK(r.validateMessages, i)
        return Tb(s)
          ? s(a)
          : Pb(s)
          ? s.replace(/\#\{.+?\}/g, function (l) {
              var c = l.slice(2, -1)
              if (c in a) {
                if (Na(a[c]) || nm(a[c]))
                  try {
                    return JSON.stringify(a[c])
                  } catch {
                    return a[c]
                  }
                return String(a[c])
              }
              return l
            })
          : s
      }),
        Na(n) && Pb(t) && n.trim
          ? (this.obj = t.trim())
          : Na(n) && n.ignoreEmptyString && t === ''
          ? (this.obj = void 0)
          : (this.obj = t),
        (this.message = n.message),
        (this.type = n.type),
        (this.error = null),
        (this.field = n.field || n.type),
        (this.validateMessages = oS(sK, n.validateMessages))
    },
    rm = {
      not: { configurable: !0 },
      isRequired: { configurable: !0 },
      end: { configurable: !0 },
    }
  rm.not.get = function () {
    return (this._not = !this._not), this
  }
  rm.isRequired.get = function () {
    if (nl(this.obj) || Yk(this.obj)) {
      var e = this.getValidateMsg('required')
      this.error = {
        value: this.obj,
        type: this.type,
        requiredError: !0,
        message:
          this.message || (Na(e) ? e : (this._not ? '[NOT MODE]:' : '') + e),
      }
    }
    return this
  }
  rm.end.get = function () {
    return this.error
  }
  Bo.prototype.addError = function (t) {
    !this.error &&
      t &&
      (this.error = {
        value: this.obj,
        type: this.type,
        message:
          this.message || (Na(t) ? t : (this._not ? '[NOT MODE]:' : '') + t),
      })
  }
  Bo.prototype.validate = function (t, n) {
    var r = this._not ? t : !t
    return r && this.addError(n), this
  }
  Bo.prototype.collect = function (t) {
    t && t(this.error)
  }
  Object.defineProperties(Bo.prototype, rm)
  var lK = (function (e) {
      function t(r, i) {
        e.call(
          this,
          r,
          Object.assign(Object.assign({}, i), { type: 'string' })
        ),
          this.validate(
            i && i.strict ? Pb(this.obj) : !0,
            this.getValidateMsg('type.string')
          )
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = {
        uppercase: { configurable: !0 },
        lowercase: { configurable: !0 },
      }
      return (
        (t.prototype.maxLength = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length <= i,
                this.getValidateMsg('string.maxLength', { maxLength: i })
              )
            : this
        }),
        (t.prototype.minLength = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length >= i,
                this.getValidateMsg('string.minLength', { minLength: i })
              )
            : this
        }),
        (t.prototype.length = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length === i,
                this.getValidateMsg('string.length', { length: i })
              )
            : this
        }),
        (t.prototype.match = function (i) {
          var o = i instanceof RegExp
          return (
            o && (i.lastIndex = 0),
            this.validate(
              this.obj === void 0 || (o && i.test(this.obj)),
              this.getValidateMsg('string.match', { pattern: i })
            )
          )
        }),
        (n.uppercase.get = function () {
          return this.obj
            ? this.validate(
                this.obj.toUpperCase() === this.obj,
                this.getValidateMsg('string.uppercase')
              )
            : this
        }),
        (n.lowercase.get = function () {
          return this.obj
            ? this.validate(
                this.obj.toLowerCase() === this.obj,
                this.getValidateMsg('string.lowercase')
              )
            : this
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    uK = (function (e) {
      function t(r, i) {
        e.call(
          this,
          r,
          Object.assign(Object.assign({}, i), { type: 'number' })
        ),
          this.validate(
            i && i.strict ? rK(this.obj) : !0,
            this.getValidateMsg('type.number')
          )
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = { positive: { configurable: !0 }, negative: { configurable: !0 } }
      return (
        (t.prototype.min = function (i) {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj >= i,
                this.getValidateMsg('number.min', { min: i })
              )
        }),
        (t.prototype.max = function (i) {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj <= i,
                this.getValidateMsg('number.max', { max: i })
              )
        }),
        (t.prototype.equal = function (i) {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj === i,
                this.getValidateMsg('number.equal', { equal: i })
              )
        }),
        (t.prototype.range = function (i, o) {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj >= i && this.obj <= o,
                this.getValidateMsg('number.range', { min: i, max: o })
              )
        }),
        (n.positive.get = function () {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj > 0,
                this.getValidateMsg('number.positive')
              )
        }),
        (n.negative.get = function () {
          return nl(this.obj)
            ? this
            : this.validate(
                this.obj < 0,
                this.getValidateMsg('number.negative')
              )
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    cK = (function (e) {
      function t(r, i) {
        e.call(this, r, Object.assign(Object.assign({}, i), { type: 'array' })),
          this.validate(
            i && i.strict ? nm(this.obj) : !0,
            this.getValidateMsg('type.array', {
              value: this.obj,
              type: this.type,
            })
          )
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = { empty: { configurable: !0 } }
      return (
        (t.prototype.length = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length === i,
                this.getValidateMsg('array.length', {
                  value: this.obj,
                  length: i,
                })
              )
            : this
        }),
        (t.prototype.minLength = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length >= i,
                this.getValidateMsg('array.minLength', {
                  value: this.obj,
                  minLength: i,
                })
              )
            : this
        }),
        (t.prototype.maxLength = function (i) {
          return this.obj
            ? this.validate(
                this.obj.length <= i,
                this.getValidateMsg('array.maxLength', {
                  value: this.obj,
                  maxLength: i,
                })
              )
            : this
        }),
        (t.prototype.includes = function (i) {
          var o = this
          return this.obj
            ? this.validate(
                i.every(function (a) {
                  return o.obj.indexOf(a) !== -1
                }),
                this.getValidateMsg('array.includes', {
                  value: this.obj,
                  includes: i,
                })
              )
            : this
        }),
        (t.prototype.deepEqual = function (i) {
          return this.obj
            ? this.validate(
                iS(this.obj, i),
                this.getValidateMsg('array.deepEqual', {
                  value: this.obj,
                  deepEqual: i,
                })
              )
            : this
        }),
        (n.empty.get = function () {
          return this.validate(
            Yk(this.obj),
            this.getValidateMsg('array.empty', { value: this.obj })
          )
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    dK = (function (e) {
      function t(r, i) {
        e.call(
          this,
          r,
          Object.assign(Object.assign({}, i), { type: 'object' })
        ),
          this.validate(
            i && i.strict ? Na(this.obj) : !0,
            this.getValidateMsg('type.object')
          )
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = { empty: { configurable: !0 } }
      return (
        (t.prototype.deepEqual = function (i) {
          return this.obj
            ? this.validate(
                iS(this.obj, i),
                this.getValidateMsg('object.deepEqual', { deepEqual: i })
              )
            : this
        }),
        (t.prototype.hasKeys = function (i) {
          var o = this
          return this.obj
            ? this.validate(
                i.every(function (a) {
                  return o.obj[a]
                }),
                this.getValidateMsg('object.hasKeys', { keys: i })
              )
            : this
        }),
        (n.empty.get = function () {
          return this.validate(
            oK(this.obj),
            this.getValidateMsg('object.empty')
          )
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    fK = (function (e) {
      function t(r, i) {
        e.call(
          this,
          r,
          Object.assign(Object.assign({}, i), { type: 'boolean' })
        ),
          this.validate(
            i && i.strict ? iK(this.obj) : !0,
            this.getValidateMsg('type.boolean')
          )
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = { true: { configurable: !0 }, false: { configurable: !0 } }
      return (
        (n.true.get = function () {
          return this.validate(
            this.obj === !0,
            this.getValidateMsg('boolean.true')
          )
        }),
        (n.false.get = function () {
          return this.validate(
            this.obj === !1,
            this.getValidateMsg('boolean.false')
          )
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    hK =
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    pK = new RegExp(
      '^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      'i'
    ),
    vK =
      /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/,
    mK = (function (e) {
      function t(r, i) {
        e.call(this, r, Object.assign(Object.assign({}, i), { type: 'type' }))
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = {
        email: { configurable: !0 },
        url: { configurable: !0 },
        ip: { configurable: !0 },
      }
      return (
        (n.email.get = function () {
          return (
            (this.type = 'email'),
            this.validate(
              this.obj === void 0 || hK.test(this.obj),
              this.getValidateMsg('type.email')
            )
          )
        }),
        (n.url.get = function () {
          return (
            (this.type = 'url'),
            this.validate(
              this.obj === void 0 || pK.test(this.obj),
              this.getValidateMsg('type.url')
            )
          )
        }),
        (n.ip.get = function () {
          return (
            (this.type = 'ip'),
            this.validate(
              this.obj === void 0 || vK.test(this.obj),
              this.getValidateMsg('type.ip')
            )
          )
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    gK = (function (e) {
      function t(r, i) {
        e.call(this, r, Object.assign(Object.assign({}, i), { type: 'custom' }))
      }
      e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t)
      var n = { validate: { configurable: !0 } }
      return (
        (n.validate.get = function () {
          var r = this
          return function (i, o) {
            var a
            if (i)
              return (
                (a = i(r.obj, r.addError.bind(r))),
                a && a.then
                  ? (o &&
                      a.then(
                        function () {
                          o && o(r.error)
                        },
                        function (s) {
                          console.error(s)
                        }
                      ),
                    [a, r])
                  : (o && o(r.error), r.error)
              )
          }
        }),
        Object.defineProperties(t.prototype, n),
        t
      )
    })(Bo),
    gv = function (e, t) {
      return new Zk(e, Object.assign({ field: 'value' }, t))
    }
  gv.globalConfig = {}
  gv.setGlobalConfig = function (e) {
    gv.globalConfig = e || {}
  }
  var Zk = function (t, n) {
      var r = gv.globalConfig,
        i = Object.assign(Object.assign(Object.assign({}, r), n), {
          validateMessages: oS(r.validateMessages, n.validateMessages),
        })
      ;(this.string = new lK(t, i)),
        (this.number = new uK(t, i)),
        (this.array = new cK(t, i)),
        (this.object = new dK(t, i)),
        (this.boolean = new fK(t, i)),
        (this.type = new mK(t, i)),
        (this.custom = new gK(t, i))
    },
    aS = function (t, n) {
      n === void 0 && (n = {}), (this.schema = t), (this.options = n)
    }
  aS.prototype.messages = function (t) {
    this.options = Object.assign(Object.assign({}, this.options), {
      validateMessages: oS(this.options.validateMessages, t),
    })
  }
  aS.prototype.validate = function (t, n) {
    var r = this
    if (!Na(t)) return
    var i = [],
      o = null
    function a(s, l) {
      o || (o = {}), (!o[s] || l.requiredError) && (o[s] = l)
    }
    this.schema &&
      Object.keys(this.schema).forEach(function (s) {
        if (nm(r.schema[s]))
          for (
            var l = function (h) {
                var p = r.schema[s][h],
                  v = p.type,
                  g = p.message
                if (!v && !p.validator)
                  throw 'You must specify a type to field ' + s + '!'
                var _ = Object.assign(Object.assign({}, r.options), {
                  message: g,
                  field: s,
                })
                ;('ignoreEmptyString' in p) &&
                  (_.ignoreEmptyString = p.ignoreEmptyString),
                  ('strict' in p) && (_.strict = p.strict)
                var b = new Zk(t[s], _),
                  y = b.type[v] || null
                if (!y)
                  if (p.validator) {
                    ;(y = b.custom.validate(p.validator)),
                      Object.prototype.toString.call(y) === '[object Array]' &&
                      y[0].then
                        ? i.push({ function: y[0], _this: y[1], key: s })
                        : y && a(s, y)
                    return
                  } else y = b[v]
                if (
                  (Object.keys(p).forEach(function (M) {
                    p.required && (y = y.isRequired),
                      M !== 'message' &&
                        y[M] &&
                        p[M] &&
                        typeof y[M] == 'object' &&
                        (y = y[M]),
                      y[M] &&
                        p[M] !== void 0 &&
                        typeof y[M] == 'function' &&
                        (y = y[M](p[M]))
                  }),
                  y.collect(function (M) {
                    M && a(s, M)
                  }),
                  o)
                )
                  return 'break'
              },
              c = 0;
            c < r.schema[s].length;
            c++
          ) {
            var d = l(c)
            if (d === 'break') break
          }
      }),
      i.length > 0
        ? Promise.all(
            i.map(function (s) {
              return s.function
            })
          ).then(function () {
            i.forEach(function (s) {
              s._this.error && a(s.key, s._this.error)
            }),
              n && n(o)
          })
        : n && n(o)
  }
  const Jk = Symbol('RowContextInjectionKey'),
    Qk = Symbol('GridContextInjectionKey'),
    eA = Symbol('GridDataCollectorInjectionKey'),
    yK = ce({
      name: 'Row',
      props: {
        gutter: { type: [Number, Object, Array], default: 0 },
        justify: { type: String, default: 'start' },
        align: { type: String, default: 'start' },
        div: { type: Boolean },
        wrap: { type: Boolean, default: !0 },
      },
      setup(e) {
        const { gutter: t, align: n, justify: r, div: i, wrap: o } = tt(e),
          a = ye('row'),
          s = C(() => ({
            [`${a}`]: !i.value,
            [`${a}-nowrap`]: !o.value,
            [`${a}-align-${n.value}`]: n.value,
            [`${a}-justify-${r.value}`]: r.value,
          })),
          l = C(() => (Array.isArray(t.value) ? t.value[0] : t.value)),
          c = C(() => (Array.isArray(t.value) ? t.value[1] : 0)),
          d = Da(l, 0),
          h = Da(c, 0),
          p = C(() => {
            const g = {}
            if ((d.value || h.value) && !i.value) {
              const _ = -d.value / 2,
                b = -h.value / 2
              _ && ((g.marginLeft = `${_}px`), (g.marginRight = `${_}px`)),
                b && ((g.marginTop = `${b}px`), (g.marginBottom = `${b}px`))
            }
            return g
          }),
          v = C(() => [d.value, h.value])
        return sn(Jk, Je({ gutter: v, div: i })), { classNames: s, styles: p }
      },
    })
  function bK(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames), style: at(e.styles) },
        [ve(e.$slots, 'default')],
        6
      )
    )
  }
  var dd = Te(yK, [['render', bK]])
  function _K(e) {
    return C(() => {
      const {
        val: n,
        key: r,
        xs: i,
        sm: o,
        md: a,
        lg: s,
        xl: l,
        xxl: c,
      } = e.value
      if (!i && !o && !a && !s && !l && !c) return n
      const d = {}
      return (
        vv.forEach((h) => {
          const p = e.value[h]
          it(p) ? (d[h] = p) : Ht(p) && it(p[r]) && (d[h] = p[r])
        }),
        d
      )
    })
  }
  var SK = Object.defineProperty,
    wM = Object.getOwnPropertySymbols,
    CK = Object.prototype.hasOwnProperty,
    wK = Object.prototype.propertyIsEnumerable,
    xM = (e, t, n) =>
      t in e
        ? SK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    K0 = (e, t) => {
      for (var n in t || (t = {})) CK.call(t, n) && xM(e, n, t[n])
      if (wM) for (var n of wM(t)) wK.call(t, n) && xM(e, n, t[n])
      return e
    }
  function xK(e) {
    if (
      (ir(e) && (['initial', 'auto', 'none'].includes(e) || /^\d+$/.test(e))) ||
      it(e)
    )
      return e
    if (ir(e) && /^\d+(px|em|rem|%)$/.test(e)) return `0 0 ${e}`
  }
  const MK = ce({
    name: 'Col',
    props: {
      span: { type: Number, default: 24 },
      offset: { type: Number },
      order: { type: Number },
      xs: { type: [Number, Object] },
      sm: { type: [Number, Object] },
      md: { type: [Number, Object] },
      lg: { type: [Number, Object] },
      xl: { type: [Number, Object] },
      xxl: { type: [Number, Object] },
      flex: { type: [Number, String] },
    },
    setup(e) {
      const t = ye('col'),
        n = zt(Jk, {}),
        r = C(() => xK(e.flex)),
        i = C(() => {
          const { div: h } = n,
            {
              span: p,
              offset: v,
              order: g,
              xs: _,
              sm: b,
              md: y,
              lg: M,
              xl: x,
              xxl: w,
            } = e,
            E = {
              [`${t}`]: !h,
              [`${t}-order-${g}`]: g,
              [`${t}-${p}`]: !h && !_ && !b && !y && !M && !x && !w,
              [`${t}-offset-${v}`]: v && v > 0,
            },
            P = { xs: _, sm: b, md: y, lg: M, xl: x, xxl: w }
          return (
            Object.keys(P).forEach((A) => {
              const F = P[A]
              F && it(F)
                ? (E[`${t}-${A}-${F}`] = !0)
                : F &&
                  Ht(F) &&
                  ((E[`${t}-${A}-${F.span}`] = F.span),
                  (E[`${t}-${A}-offset-${F.offset}`] = F.offset),
                  (E[`${t}-${A}-order-${F.order}`] = F.order))
            }),
            E
          )
        }),
        o = C(() => (r.value ? t : i.value)),
        a = C(() => {
          const { gutter: h, div: p } = n,
            v = {}
          if (Array.isArray(h) && !p) {
            const g = (h[0] && h[0] / 2) || 0,
              _ = (h[1] && h[1] / 2) || 0
            g && ((v.paddingLeft = `${g}px`), (v.paddingRight = `${g}px`)),
              _ && ((v.paddingTop = `${_}px`), (v.paddingBottom = `${_}px`))
          }
          return v
        }),
        s = C(() => (r.value ? { flex: r.value } : {})),
        l = C(() => ra(e, vv)),
        c = _K(C(() => K0({ val: e.span, key: 'span' }, l.value))),
        d = Da(c, 24, !0)
      return {
        visible: C(() => !!d.value),
        classNames: o,
        styles: C(() => K0(K0({}, a.value), s.value)),
      }
    },
  })
  function EK(e, t, n, r, i, o) {
    return e.visible
      ? (O(),
        Z(
          'div',
          { key: 0, class: H(e.classNames), style: at(e.styles) },
          [ve(e.$slots, 'default')],
          6
        ))
      : Ce('v-if', !0)
  }
  var fd = Te(MK, [['render', EK]])
  function PK(e, t) {
    var n, r
    const i = (n = t.span) != null ? n : 1,
      o = (r = t.offset) != null ? r : 0,
      a = Math.min(o, e)
    return {
      span: Math.min(a > 0 ? i + o : i, e),
      offset: a,
      suffix: 'suffix' in t ? t.suffix !== !1 : !1,
    }
  }
  function TK({ cols: e, collapsed: t, collapsedRows: n, itemDataList: r }) {
    let i = !1,
      o = []
    function a(s) {
      return Math.ceil(s / e) > n
    }
    if (t) {
      let s = 0
      for (let l = 0; l < r.length; l++)
        r[l].suffix && ((s += r[l].span), o.push(l))
      if (!a(s)) {
        let l = 0
        for (; l < r.length; ) {
          const c = r[l]
          if (!c.suffix) {
            if (((s += c.span), a(s))) break
            o.push(l)
          }
          l++
        }
      }
      i = r.some((l, c) => !l.suffix && !o.includes(c))
    } else o = r.map((s, l) => l)
    return { overflow: i, displayIndexList: o }
  }
  const kK = ce({
    name: 'Grid',
    props: {
      cols: { type: [Number, Object], default: 24 },
      rowGap: { type: [Number, Object], default: 0 },
      colGap: { type: [Number, Object], default: 0 },
      collapsed: { type: Boolean, default: !1 },
      collapsedRows: { type: Number, default: 1 },
    },
    setup(e) {
      const {
          cols: t,
          rowGap: n,
          colGap: r,
          collapsedRows: i,
          collapsed: o,
        } = tt(e),
        a = Da(t, 24),
        s = Da(r, 0),
        l = Da(n, 0),
        c = ye('grid'),
        d = C(() => [c]),
        h = C(() => [
          {
            gap: `${l.value}px ${s.value}px`,
            'grid-template-columns': `repeat(${a.value}, minmax(0px, 1fr))`,
          },
        ]),
        p = Je(new Map()),
        v = C(() => {
          const _ = []
          for (const [b, y] of p.entries()) _[b] = y
          return _
        }),
        g = Je({
          overflow: !1,
          displayIndexList: [],
          cols: a.value,
          colGap: s.value,
        })
      return (
        pr(() => {
          ;(g.cols = a.value), (g.colGap = s.value)
        }),
        pr(() => {
          const _ = TK({
            cols: a.value,
            collapsed: o.value,
            collapsedRows: i.value,
            itemDataList: v.value,
          })
          ;(g.overflow = _.overflow), (g.displayIndexList = _.displayIndexList)
        }),
        sn(Qk, g),
        sn(eA, {
          collectItemData(_, b) {
            p.set(_, b)
          },
          removeItemData(_) {
            p.delete(_)
          },
        }),
        { classNames: d, style: h }
      )
    },
  })
  function AK(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames), style: at(e.style) },
        [ve(e.$slots, 'default')],
        6
      )
    )
  }
  var q0 = Te(kK, [['render', AK]]),
    $K = Object.defineProperty,
    OK = Object.defineProperties,
    LK = Object.getOwnPropertyDescriptors,
    MM = Object.getOwnPropertySymbols,
    IK = Object.prototype.hasOwnProperty,
    RK = Object.prototype.propertyIsEnumerable,
    EM = (e, t, n) =>
      t in e
        ? $K(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    DK = (e, t) => {
      for (var n in t || (t = {})) IK.call(t, n) && EM(e, n, t[n])
      if (MM) for (var n of MM(t)) RK.call(t, n) && EM(e, n, t[n])
      return e
    },
    NK = (e, t) => OK(e, LK(t))
  const BK = ce({
    name: 'GridItem',
    props: {
      span: { type: [Number, Object], default: 1 },
      offset: { type: [Number, Object], default: 0 },
      suffix: { type: Boolean, default: !1 },
    },
    setup(e) {
      const t = ye('grid-item'),
        n = J(),
        { computedIndex: r } = Zv({ itemRef: n, selector: `.${t}` }),
        i = zt(Qk, { overflow: !1, displayIndexList: [], cols: 24, colGap: 0 }),
        o = zt(eA),
        a = C(() => {
          var b
          return (b = i == null ? void 0 : i.displayIndexList) == null
            ? void 0
            : b.includes(r.value)
        }),
        { span: s, offset: l } = tt(e),
        c = Da(s, 1),
        d = Da(l, 0),
        h = C(() =>
          PK(i.cols, NK(DK({}, e), { span: c.value, offset: d.value }))
        ),
        p = C(() => [t]),
        v = C(() => {
          const { offset: b, span: y } = h.value,
            { colGap: M } = i
          return b > 0
            ? {
                'margin-left': `calc((${`(100% - ${
                  M * (y - 1)
                }px) / ${y}`} * ${b}) + ${M * b}px)`,
              }
            : {}
        }),
        g = C(() => {
          const { suffix: b, span: y } = h.value,
            { cols: M } = i
          return b ? `${M - y + 1}` : `span ${y}`
        }),
        _ = C(() => {
          const { span: b } = h.value
          return [
            { 'grid-column': `${g.value} / span ${b}` },
            v.value,
            !a.value || b === 0 ? { display: 'none' } : {},
          ]
        })
      return (
        pr(() => {
          r.value !== -1 && (o == null || o.collectItemData(r.value, h.value))
        }),
        wr(() => {
          r.value !== -1 && (o == null || o.removeItemData(r.value))
        }),
        { classNames: p, style: _, domRef: n, overflow: C(() => i.overflow) }
      )
    },
  })
  function FK(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { ref: 'domRef', class: H(e.classNames), style: at(e.style) },
        [ve(e.$slots, 'default', { overflow: e.overflow })],
        6
      )
    )
  }
  var wp = Te(BK, [['render', FK]])
  const td = Object.assign(q0, {
    Row: dd,
    Col: fd,
    Item: wp,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + dd.name, dd),
        e.component(n + fd.name, fd),
        e.component(n + q0.name, q0),
        e.component(n + wp.name, wp)
    },
  })
  var zK = Object.defineProperty,
    PM = Object.getOwnPropertySymbols,
    VK = Object.prototype.hasOwnProperty,
    UK = Object.prototype.propertyIsEnumerable,
    TM = (e, t, n) =>
      t in e
        ? zK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    kM = (e, t) => {
      for (var n in t || (t = {})) VK.call(t, n) && TM(e, n, t[n])
      if (PM) for (var n of PM(t)) UK.call(t, n) && TM(e, n, t[n])
      return e
    }
  const HK = ce({
    name: 'Tooltip',
    components: { Trigger: Mr },
    props: {
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      content: String,
      position: { type: String, default: 'top' },
      mini: { type: Boolean, default: !1 },
      backgroundColor: { type: String },
      contentClass: { type: [String, Array, Object] },
      contentStyle: { type: Object },
      arrowClass: { type: [String, Array, Object] },
      arrowStyle: { type: Object },
      popupContainer: { type: [String, Object] },
    },
    emits: { 'update:popupVisible': (e) => !0, popupVisibleChange: (e) => !0 },
    setup(e, { emit: t }) {
      const n = ye('tooltip'),
        r = J(e.defaultPopupVisible),
        i = C(() => {
          var d
          return (d = e.popupVisible) != null ? d : r.value
        }),
        o = (d) => {
          ;(r.value = d),
            t('update:popupVisible', d),
            t('popupVisibleChange', d)
        },
        a = C(() => [
          `${n}-content`,
          e.contentClass,
          { [`${n}-mini`]: e.mini },
        ]),
        s = C(() => {
          if (e.backgroundColor || e.contentStyle)
            return kM({ backgroundColor: e.backgroundColor }, e.contentStyle)
        }),
        l = C(() => [`${n}-popup-arrow`, e.arrowClass]),
        c = C(() => {
          if (e.backgroundColor || e.arrowStyle)
            return kM({ backgroundColor: e.backgroundColor }, e.arrowStyle)
        })
      return {
        prefixCls: n,
        computedPopupVisible: i,
        contentCls: a,
        computedContentStyle: s,
        arrowCls: l,
        computedArrowStyle: c,
        handlePopupVisibleChange: o,
      }
    },
  })
  function WK(e, t, n, r, i, o) {
    const a = ge('Trigger')
    return (
      O(),
      Ee(
        a,
        {
          class: H(e.prefixCls),
          trigger: 'hover',
          position: e.position,
          'popup-visible': e.computedPopupVisible,
          'popup-offset': 10,
          'show-arrow': '',
          'content-class': e.contentCls,
          'content-style': e.computedContentStyle,
          'arrow-class': e.arrowCls,
          'arrow-style': e.computedArrowStyle,
          'popup-container': e.popupContainer,
          'animation-name': 'zoom-in-fade-out',
          'auto-fit-transform-origin': '',
          role: 'tooltip',
          onPopupVisibleChange: e.handlePopupVisibleChange,
        },
        {
          content: ze(() => [
            ve(e.$slots, 'content', {}, () => [Lt(mt(e.content), 1)]),
          ]),
          default: ze(() => [ve(e.$slots, 'default')]),
          _: 3,
        },
        8,
        [
          'class',
          'position',
          'popup-visible',
          'content-class',
          'content-style',
          'arrow-class',
          'arrow-style',
          'popup-container',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var X0 = Te(HK, [['render', WK]])
  const uo = Object.assign(X0, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + X0.name, X0)
      },
    }),
    jK = ce({
      name: 'IconQuestionCircle',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-question-circle`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    GK = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    KK = Se(
      'path',
      {
        d: 'M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z',
      },
      null,
      -1
    ),
    qK = Se(
      'path',
      {
        d: 'M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465',
      },
      null,
      -1
    ),
    XK = [KK, qK]
  function YK(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        XK,
        14,
        GK
      )
    )
  }
  var Y0 = Te(jK, [['render', YK]])
  const ZK = Object.assign(Y0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Y0.name, Y0)
      },
    }),
    JK = ce({
      name: 'FormItemLabel',
      components: { ResizeObserver: ks, Tooltip: uo, IconQuestionCircle: ZK },
      props: {
        required: { type: Boolean, default: !1 },
        showColon: { type: Boolean, default: !1 },
        component: { type: String, default: 'label' },
        asteriskPosition: { type: String, default: 'start' },
        tooltip: { type: String },
        attrs: Object,
      },
      setup() {
        const e = ye('form-item-label'),
          t = zt(D_, void 0),
          n = Jr(),
          r = J(),
          i = () => {
            r.value &&
              it(r.value.offsetWidth) &&
              (t == null ||
                t.setLabelWidth(
                  r.value.offsetWidth,
                  n == null ? void 0 : n.uid
                ))
          }
        return (
          Wt(() => {
            r.value &&
              it(r.value.offsetWidth) &&
              (t == null ||
                t.setLabelWidth(
                  r.value.offsetWidth,
                  n == null ? void 0 : n.uid
                ))
          }),
          Pr(() => {
            t == null || t.removeLabelWidth(n == null ? void 0 : n.uid)
          }),
          { prefixCls: e, labelRef: r, handleResize: i }
        )
      },
    }),
    QK = Se(
      'svg',
      {
        fill: 'currentColor',
        viewBox: '0 0 1024 1024',
        width: '1em',
        height: '1em',
      },
      [
        Se('path', {
          d: 'M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z',
        }),
      ],
      -1
    ),
    eq = [QK],
    tq = Se(
      'svg',
      {
        fill: 'currentColor',
        viewBox: '0 0 1024 1024',
        width: '1em',
        height: '1em',
      },
      [
        Se('path', {
          d: 'M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z',
        }),
      ],
      -1
    ),
    nq = [tq]
  function rq(e, t, n, r, i, o) {
    const a = ge('icon-question-circle'),
      s = ge('Tooltip'),
      l = ge('ResizeObserver')
    return (
      O(),
      Ee(
        l,
        { onResize: e.handleResize },
        {
          default: ze(() => [
            (O(),
            Ee(
              xi(e.component),
              Fe({ ref: 'labelRef', class: e.prefixCls }, e.attrs),
              {
                default: ze(() => [
                  e.required && e.asteriskPosition === 'start'
                    ? (O(),
                      Z(
                        'strong',
                        { key: 0, class: H(`${e.prefixCls}-required-symbol`) },
                        eq,
                        2
                      ))
                    : Ce('v-if', !0),
                  ve(e.$slots, 'default'),
                  e.tooltip
                    ? (O(),
                      Ee(
                        s,
                        { key: 1, content: e.tooltip },
                        {
                          default: ze(() => [
                            m(
                              a,
                              { class: H(`${e.prefixCls}-tooltip`) },
                              null,
                              8,
                              ['class']
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['content']
                      ))
                    : Ce('v-if', !0),
                  e.required && e.asteriskPosition === 'end'
                    ? (O(),
                      Z(
                        'strong',
                        { key: 2, class: H(`${e.prefixCls}-required-symbol`) },
                        nq,
                        2
                      ))
                    : Ce('v-if', !0),
                  Lt(' ' + mt(e.showColon ? ':' : ''), 1),
                ]),
                _: 3,
              },
              16,
              ['class']
            )),
          ]),
          _: 3,
        },
        8,
        ['onResize']
      )
    )
  }
  var iq = Te(JK, [['render', rq]])
  const oq = ce({
    name: 'FormItemMessage',
    props: { error: Array, help: String },
    setup() {
      return { prefixCls: ye('form-item-message') }
    },
  })
  function aq(e, t, n, r, i, o) {
    return e.help || e.$slots.help
      ? (O(),
        Ee(
          Fr,
          { key: 0, name: 'form-blink', appear: '' },
          {
            default: ze(() => [
              Se(
                'div',
                { class: H([e.prefixCls, `${e.prefixCls}-help`]) },
                [ve(e.$slots, 'help', {}, () => [Lt(mt(e.help), 1)])],
                2
              ),
            ]),
            _: 3,
          }
        ))
      : (O(!0),
        Z(
          yt,
          { key: 1 },
          Yn(
            e.error,
            (a) => (
              O(),
              Ee(
                Fr,
                { key: a, name: 'form-blink', appear: '' },
                {
                  default: ze(() => [
                    Se(
                      'div',
                      { role: 'alert', class: H([e.prefixCls]) },
                      mt(a),
                      3
                    ),
                  ]),
                  _: 2,
                },
                1024
              )
            )
          ),
          128
        ))
  }
  var sq = Te(oq, [['render', aq]])
  const AM = ['success', 'warning', 'error', 'validating'],
    lq = (e) => {
      let t = ''
      for (const n of Object.keys(e)) {
        const r = e[n]
        r && (!t || AM.indexOf(r) > AM.indexOf(t)) && (t = e[n])
      }
      return t
    },
    uq = (e) => {
      const t = []
      for (const n of Object.keys(e)) {
        const r = e[n]
        r && t.push(r)
      }
      return t
    }
  var cq = Object.defineProperty,
    yv = Object.getOwnPropertySymbols,
    tA = Object.prototype.hasOwnProperty,
    nA = Object.prototype.propertyIsEnumerable,
    $M = (e, t, n) =>
      t in e
        ? cq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    OM = (e, t) => {
      for (var n in t || (t = {})) tA.call(t, n) && $M(e, n, t[n])
      if (yv) for (var n of yv(t)) nA.call(t, n) && $M(e, n, t[n])
      return e
    },
    dq = (e, t) => {
      var n = {}
      for (var r in e) tA.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
      if (e != null && yv)
        for (var r of yv(e)) t.indexOf(r) < 0 && nA.call(e, r) && (n[r] = e[r])
      return n
    }
  const fq = ce({
    name: 'FormItem',
    components: {
      ArcoRow: dd,
      ArcoCol: fd,
      FormItemLabel: iq,
      FormItemMessage: sq,
    },
    props: {
      field: { type: String, default: '' },
      label: String,
      tooltip: { type: String },
      showColon: { type: Boolean, default: !1 },
      noStyle: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: void 0 },
      help: String,
      extra: String,
      required: { type: Boolean, default: !1 },
      asteriskPosition: { type: String, default: 'start' },
      rules: { type: [Object, Array] },
      validateStatus: { type: String },
      validateTrigger: { type: [String, Array], default: 'change' },
      labelColProps: Object,
      wrapperColProps: Object,
      hideLabel: { type: Boolean, default: !1 },
      hideAsterisk: { type: Boolean, default: !1 },
      labelColStyle: Object,
      wrapperColStyle: Object,
      rowProps: Object,
      rowClass: [String, Array, Object],
      contentClass: [String, Array, Object],
      contentFlex: { type: Boolean, default: !0 },
      mergeProps: { type: [Boolean, Function], default: !0 },
      labelColFlex: { type: [Number, String] },
      feedback: { type: Boolean, default: !1 },
      labelComponent: { type: String, default: 'label' },
      labelAttrs: Object,
    },
    setup(e) {
      const t = ye('form-item'),
        { field: n } = tt(e),
        r = zt(D_, {}),
        { autoLabelWidth: i, layout: o } = tt(r),
        { i18nMessage: a } = Vn(),
        s = C(() => {
          var U
          const le = OM({}, (U = e.labelColProps) != null ? U : r.labelColProps)
          return (
            e.labelColFlex
              ? (le.flex = e.labelColFlex)
              : r.autoLabelWidth && (le.flex = `${r.maxLabelWidth}px`),
            le
          )
        }),
        l = C(() => {
          var U
          const le = OM(
            {},
            (U = e.wrapperColProps) != null ? U : r.wrapperColProps
          )
          return (e.labelColFlex || r.autoLabelWidth) && (le.flex = 'auto'), le
        }),
        c = C(() => {
          var U
          return (U = e.labelColStyle) != null ? U : r.labelColStyle
        }),
        d = C(() => {
          var U
          return (U = e.wrapperColStyle) != null ? U : r.wrapperColStyle
        }),
        h = ml(r.model, e.field),
        p = Je({}),
        v = Je({}),
        g = C(() => lq(p)),
        _ = C(() => uq(v)),
        b = J(!1),
        y = C(() => ml(r.model, e.field)),
        M = C(() => {
          var U
          return !!((U = e.disabled) != null ? U : r != null && r.disabled)
        }),
        x = C(() => {
          var U
          return (U = e.validateStatus) != null ? U : g.value
        }),
        w = C(() => x.value === 'error'),
        E = C(() => {
          var U, le, q
          const oe = [].concat(
              (q =
                (le = e.rules) != null
                  ? le
                  : (U = r == null ? void 0 : r.rules) == null
                  ? void 0
                  : U[e.field]) != null
                ? q
                : []
            ),
            te = oe.some((ue) => ue.required)
          return e.required && !te ? [{ required: !0 }].concat(oe) : oe
        }),
        P = C(() => E.value.some((U) => U.required)),
        A = e.noStyle ? zt(yb, void 0) : void 0,
        F = (U, { status: le, message: q }) => {
          ;(p[U] = le),
            (v[U] = q),
            e.noStyle &&
              (A == null ||
                A.updateValidateState(U, { status: le, message: q }))
        },
        T = C(() => (e.feedback && x.value ? x.value : void 0)),
        k = () => {
          var U
          if (b.value) return Promise.resolve()
          const le = E.value
          if (!n.value || le.length === 0)
            return g.value && N(), Promise.resolve()
          const q = n.value,
            oe = y.value
          F(q, { status: '', message: '' })
          const te = new aS(
            {
              [q]: le.map((ue) => {
                var me = dq(ue, [])
                return !me.type && !me.validator && (me.type = 'string'), me
              }),
            },
            {
              ignoreEmptyString: !0,
              validateMessages:
                (U = a.value.form) == null ? void 0 : U.validateMessages,
            }
          )
          return new Promise((ue) => {
            te.validate({ [q]: oe }, (me) => {
              var Re
              const qe = !!(me != null && me[q])
              F(q, {
                status: qe ? 'error' : '',
                message:
                  (Re = me == null ? void 0 : me[q].message) != null ? Re : '',
              })
              const Ve = qe
                ? {
                    label: e.label,
                    field: n.value,
                    value: me[q].value,
                    type: me[q].type,
                    isRequiredError: !!me[q].requiredError,
                    message: me[q].message,
                  }
                : void 0
              ue(Ve)
            })
          })
        },
        R = C(() => [].concat(e.validateTrigger)),
        j = C(() =>
          R.value.reduce((U, le) => {
            switch (le) {
              case 'change':
                return (
                  (U.onChange = () => {
                    k()
                  }),
                  U
                )
              case 'input':
                return (
                  (U.onInput = () => {
                    hn(() => {
                      k()
                    })
                  }),
                  U
                )
              case 'focus':
                return (
                  (U.onFocus = () => {
                    k()
                  }),
                  U
                )
              case 'blur':
                return (
                  (U.onBlur = () => {
                    k()
                  }),
                  U
                )
              default:
                return U
            }
          }, {})
        )
      sn(
        yb,
        Je({
          eventHandlers: j,
          size: r && Vi(r, 'size'),
          disabled: M,
          error: w,
          feedback: T,
          updateValidateState: F,
        })
      )
      const N = () => {
          n.value && F(n.value, { status: '', message: '' })
        },
        V = Je({
          field: n,
          disabled: M,
          error: w,
          validate: k,
          clearValidate: N,
          resetField: () => {
            N(),
              (b.value = !0),
              r != null && r.model && n.value && fv(r.model, n.value, h),
              hn(() => {
                b.value = !1
              })
          },
          setField: (U) => {
            var le, q
            n.value &&
              ((b.value = !0),
              'value' in U &&
                r != null &&
                r.model &&
                n.value &&
                fv(r.model, n.value, U.value),
              (U.status || U.message) &&
                F(n.value, {
                  status: (le = U.status) != null ? le : '',
                  message: (q = U.message) != null ? q : '',
                }),
              hn(() => {
                b.value = !1
              }))
          },
        })
      Wt(() => {
        var U
        V.field && ((U = r.addField) == null || U.call(r, V))
      }),
        Pr(() => {
          var U
          V.field && ((U = r.removeField) == null || U.call(r, V))
        })
      const L = C(() => [
          t,
          `${t}-layout-${r.layout}`,
          { [`${t}-error`]: w.value, [`${t}-status-${x.value}`]: !!x.value },
          e.rowClass,
        ]),
        W = C(() => [
          `${t}-label-col`,
          {
            [`${t}-label-col-left`]: r.labelAlign === 'left',
            [`${t}-label-col-flex`]: r.autoLabelWidth || e.labelColFlex,
          },
        ]),
        Y = C(() => [
          `${t}-wrapper-col`,
          { [`${t}-wrapper-col-flex`]: !l.value },
        ])
      return {
        prefixCls: t,
        cls: L,
        isRequired: P,
        isError: w,
        finalMessage: _,
        mergedLabelCol: s,
        mergedWrapperCol: l,
        labelColCls: W,
        autoLabelWidth: i,
        layout: o,
        mergedLabelStyle: c,
        wrapperColCls: Y,
        mergedWrapperStyle: d,
      }
    },
  })
  function hq(e, t, n, r, i, o) {
    var a
    const s = ge('FormItemLabel'),
      l = ge('ArcoCol'),
      c = ge('FormItemMessage'),
      d = ge('ArcoRow')
    return e.noStyle
      ? ve(e.$slots, 'default', { key: 0 })
      : (O(),
        Ee(
          d,
          Fe(
            {
              key: 1,
              class: [
                e.cls,
                {
                  [`${e.prefixCls}-has-help`]: !!((a = e.$slots.help) != null
                    ? a
                    : e.help),
                },
              ],
              wrap: !(e.labelColFlex || e.autoLabelWidth),
              div: e.layout !== 'horizontal' || e.hideLabel,
            },
            e.rowProps
          ),
          {
            default: ze(() => [
              e.hideLabel
                ? Ce('v-if', !0)
                : (O(),
                  Ee(
                    l,
                    Fe(
                      {
                        key: 0,
                        class: e.labelColCls,
                        style: e.mergedLabelStyle,
                      },
                      e.mergedLabelCol
                    ),
                    {
                      default: ze(() => [
                        m(
                          s,
                          {
                            required: e.hideAsterisk ? !1 : e.isRequired,
                            'show-colon': e.showColon,
                            'asterisk-position': e.asteriskPosition,
                            component: e.labelComponent,
                            attrs: e.labelAttrs,
                            tooltip: e.tooltip,
                          },
                          {
                            default: ze(() => [
                              e.$slots.label || e.label
                                ? ve(e.$slots, 'label', { key: 0 }, () => [
                                    Lt(mt(e.label), 1),
                                  ])
                                : Ce('v-if', !0),
                            ]),
                            _: 3,
                          },
                          8,
                          [
                            'required',
                            'show-colon',
                            'asterisk-position',
                            'component',
                            'attrs',
                            'tooltip',
                          ]
                        ),
                      ]),
                      _: 3,
                    },
                    16,
                    ['class', 'style']
                  )),
              m(
                l,
                Fe(
                  { class: e.wrapperColCls, style: e.mergedWrapperStyle },
                  e.mergedWrapperCol
                ),
                {
                  default: ze(() => [
                    Se(
                      'div',
                      { class: H(`${e.prefixCls}-content-wrapper`) },
                      [
                        Se(
                          'div',
                          {
                            class: H([
                              `${e.prefixCls}-content`,
                              {
                                [`${e.prefixCls}-content-flex`]: e.contentFlex,
                              },
                              e.contentClass,
                            ]),
                          },
                          [ve(e.$slots, 'default')],
                          2
                        ),
                      ],
                      2
                    ),
                    e.isError || e.$slots.help || e.help
                      ? (O(),
                        Ee(
                          c,
                          { key: 0, error: e.finalMessage, help: e.help },
                          Nn({ _: 2 }, [
                            e.$slots.help
                              ? {
                                  name: 'help',
                                  fn: ze(() => [ve(e.$slots, 'help')]),
                                }
                              : void 0,
                          ]),
                          1032,
                          ['error', 'help']
                        ))
                      : Ce('v-if', !0),
                    e.$slots.extra || e.extra
                      ? (O(),
                        Z(
                          'div',
                          { key: 1, class: H(`${e.prefixCls}-extra`) },
                          [
                            ve(e.$slots, 'extra', {}, () => [
                              Lt(mt(e.extra), 1),
                            ]),
                          ],
                          2
                        ))
                      : Ce('v-if', !0),
                  ]),
                  _: 3,
                },
                16,
                ['class', 'style']
              ),
            ]),
            _: 3,
          },
          16,
          ['class', 'wrap', 'div']
        ))
  }
  var xp = Te(fq, [['render', hq]])
  const pq = Object.assign(G0, {
      Item: xp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + G0.name, G0), e.component(n + xp.name, xp)
      },
    }),
    vq = ce({
      name: 'Icon',
      props: {
        type: String,
        size: [Number, String],
        rotate: Number,
        spin: Boolean,
      },
      setup(e) {
        const t = ye('icon'),
          n = C(() => {
            const i = {}
            return (
              e.size && (i.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (i.transform = `rotate(${e.rotate}deg)`),
              i
            )
          })
        return {
          cls: C(() => [t, { [`${t}-loading`]: e.spin }, e.type]),
          innerStyle: n,
        }
      },
    })
  function mq(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        { class: H(e.cls), style: at(e.innerStyle), fill: 'currentColor' },
        [ve(e.$slots, 'default')],
        6
      )
    )
  }
  var Mp = Te(vq, [['render', mq]])
  function gq(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  const LM = [],
    yq = (e) => {
      const { src: t, extraProps: n = {} } = e
      if (!Kd && t != null && t.length && !LM.includes(t)) {
        const r = document.createElement('script')
        r.setAttribute('src', t),
          r.setAttribute('data-namespace', t),
          LM.push(t),
          document.body.appendChild(r)
      }
      return ce({
        name: 'IconFont',
        props: {
          type: String,
          size: [Number, String],
          rotate: Number,
          spin: Boolean,
        },
        setup(r, { slots: i }) {
          return () => {
            var o
            const a = r.type
              ? m('use', { 'xlink:href': `#${r.type}` }, null)
              : (o = i.default) == null
              ? void 0
              : o.call(i)
            return m(Mp, Fe(r, n), gq(a) ? a : { default: () => [a] })
          }
        },
      })
    },
    bq = Object.assign(Mp, {
      addFromIconFontCn: yq,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Mp.name, Mp)
      },
    }),
    _q = ce({
      name: 'ImageFooter',
      props: { title: { type: String }, description: { type: String } },
      setup() {
        return { prefixCls: ye('image-footer') }
      },
    }),
    Sq = ['title'],
    Cq = ['title']
  function wq(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          e.title || e.description
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-caption`) },
                [
                  e.title
                    ? (O(),
                      Z(
                        'div',
                        {
                          key: 0,
                          class: H(`${e.prefixCls}-caption-title`),
                          title: e.title,
                        },
                        mt(e.title),
                        11,
                        Sq
                      ))
                    : Ce('v-if', !0),
                  e.description
                    ? (O(),
                      Z(
                        'div',
                        {
                          key: 1,
                          class: H(`${e.prefixCls}-caption-description`),
                          title: e.description,
                        },
                        mt(e.description),
                        11,
                        Cq
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ))
            : Ce('v-if', !0),
          e.$slots.extra
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-extra`) },
                [ve(e.$slots, 'extra')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var xq = Te(_q, [['render', wq]])
  const Mq = ce({
    name: 'ImagePreviewArrow',
    components: { IconLeft: ja, IconRight: No },
    props: { onPrev: { type: Function }, onNext: { type: Function } },
    setup() {
      return { prefixCls: ye('image-preview-arrow') }
    },
  })
  function Eq(e, t, n, r, i, o) {
    const a = ge('icon-left'),
      s = ge('icon-right')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            {
              class: H([
                `${e.prefixCls}-left`,
                { [`${e.prefixCls}-disabled`]: !e.onPrev },
              ]),
              onClick:
                t[0] ||
                (t[0] = (l) => {
                  l.preventDefault(), e.onPrev && e.onPrev()
                }),
            },
            [m(a)],
            2
          ),
          Se(
            'div',
            {
              class: H([
                `${e.prefixCls}-right`,
                { [`${e.prefixCls}-disabled`]: !e.onNext },
              ]),
              onClick:
                t[1] ||
                (t[1] = (l) => {
                  l.preventDefault(), e.onNext && e.onNext()
                }),
            },
            [m(s)],
            2
          ),
        ],
        2
      )
    )
  }
  var Pq = Te(Mq, [['render', Eq]])
  function Tq(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var kb = ce({
      name: 'ImagePreviewAction',
      components: { Tooltip: uo },
      inheritAttrs: !1,
      props: { name: { type: String }, disabled: { type: Boolean } },
      setup(e, { slots: t, attrs: n }) {
        const r = ye('image-preview-toolbar-action')
        return () => {
          var i
          const { name: o, disabled: a } = e,
            s = (i = t.default) == null ? void 0 : i.call(t)
          if (!s || !s.length) return null
          const l = m(
            'div',
            Fe(
              {
                class: [`${r}`, { [`${r}-disabled`]: a }],
                onMousedown: (c) => {
                  c.preventDefault()
                },
              },
              n
            ),
            [m('span', { class: `${r}-content` }, [s])]
          )
          return o
            ? m(
                uo,
                { class: `${r}-tooltip`, content: o },
                Tq(l) ? l : { default: () => [l] }
              )
            : l
        }
      },
    }),
    kq = ce({
      name: 'ImagePreviewToolbar',
      components: { RenderFunction: Ga, PreviewAction: kb },
      props: {
        actions: { type: Array, default: () => [] },
        actionsLayout: { type: Array, default: () => [] },
      },
      setup(e) {
        const { actions: t, actionsLayout: n } = tt(e),
          r = ye('image-preview-toolbar'),
          i = C(() => {
            const o = new Set(n.value),
              a = (l) => o.has(l.key)
            return t.value.filter(a).sort((l, c) => {
              const d = n.value.indexOf(l.key),
                h = n.value.indexOf(c.key)
              return d > h ? 1 : -1
            })
          })
        return { prefixCls: r, resultActions: i }
      },
    })
  function Aq(e, t, n, r, i, o) {
    const a = ge('RenderFunction'),
      s = ge('PreviewAction')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.resultActions,
              (l) => (
                O(),
                Ee(
                  s,
                  {
                    key: l.key,
                    name: l.name,
                    disabled: l.disabled,
                    onClick: l.onClick,
                  },
                  {
                    default: ze(() => [
                      m(a, { 'render-func': l.content }, null, 8, [
                        'render-func',
                      ]),
                    ]),
                    _: 2,
                  },
                  1032,
                  ['name', 'disabled', 'onClick']
                )
              )
            ),
            128
          )),
          ve(e.$slots, 'default'),
        ],
        2
      )
    )
  }
  var $q = Te(kq, [['render', Aq]])
  function rA(e) {
    const t = J(e || 'beforeLoad'),
      n = C(() => t.value === 'beforeLoad'),
      r = C(() => t.value === 'loading'),
      i = C(() => t.value === 'error'),
      o = C(() => t.value === 'loaded')
    return {
      status: t,
      isBeforeLoad: n,
      isLoading: r,
      isError: i,
      isLoaded: o,
      setLoadStatus: (a) => {
        t.value = a
      },
    }
  }
  function Oq(e, t, n, r, i) {
    let o = n,
      a = r
    return (
      n &&
        (e.width > t.width
          ? (o = 0)
          : (t.left > e.left && (o -= Math.abs(e.left - t.left) / i),
            t.right < e.right && (o += Math.abs(e.right - t.right) / i))),
      r &&
        (e.height > t.height
          ? (a = 0)
          : (t.top > e.top && (a -= Math.abs(e.top - t.top) / i),
            t.bottom < e.bottom && (a += Math.abs(e.bottom - t.bottom) / i))),
      [o, a]
    )
  }
  function Lq(e) {
    const { wrapperEl: t, imageEl: n, scale: r } = tt(e),
      i = J([0, 0]),
      o = J(!1)
    let a = 0,
      s = 0,
      l = [0, 0]
    const c = () => {
        if (!t.value || !n.value) return
        const g = t.value.getBoundingClientRect(),
          _ = n.value.getBoundingClientRect(),
          [b, y] = Oq(g, _, i.value[0], i.value[1], r.value)
        ;(b !== i.value[0] || y !== i.value[1]) && (i.value = [b, y])
      },
      d = (g) => {
        g.preventDefault && g.preventDefault()
        const _ = l[0] + (g.pageX - a) / r.value,
          b = l[1] + (g.pageY - s) / r.value
        i.value = [_, b]
      },
      h = (g) => {
        g.preventDefault && g.preventDefault(), (o.value = !1), c(), v()
      },
      p = (g) => {
        g.target === g.currentTarget &&
          (g.preventDefault && g.preventDefault(),
          (o.value = !0),
          (a = g.pageX),
          (s = g.pageY),
          (l = [...i.value]),
          Cn(window, 'mousemove', d, !1),
          Cn(window, 'mouseup', h, !1))
      }
    function v() {
      kn(window, 'mousemove', d, !1), kn(window, 'mouseup', h, !1)
    }
    return (
      pr((g) => {
        n.value && Cn(n.value, 'mousedown', p),
          g(() => {
            n.value && kn(n.value, 'mousedown', p), v()
          })
      }),
      pt([r], () => {
        hn(() => c())
      }),
      {
        translate: i,
        moving: o,
        resetTranslate() {
          i.value = [0, 0]
        },
      }
    )
  }
  const Iq = ce({
      name: 'IconZoomOut',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-zoom-out`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Rq = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Dq = Se(
      'path',
      {
        d: 'M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15',
      },
      null,
      -1
    ),
    Nq = [Dq]
  function Bq(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Nq,
        14,
        Rq
      )
    )
  }
  var Z0 = Te(Iq, [['render', Bq]])
  const Fq = Object.assign(Z0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Z0.name, Z0)
      },
    }),
    zq = ce({
      name: 'IconZoomIn',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-zoom-in`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Vq = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Uq = Se(
      'path',
      {
        d: 'M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15m7 7V15',
      },
      null,
      -1
    ),
    Hq = [Uq]
  function Wq(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Hq,
        14,
        Vq
      )
    )
  }
  var J0 = Te(zq, [['render', Wq]])
  const jq = Object.assign(J0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + J0.name, J0)
      },
    }),
    Gq = ce({
      name: 'IconFullscreen',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-fullscreen`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Kq = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    qq = Se(
      'path',
      {
        d: 'M42 17V9a1 1 0 0 0-1-1h-8M6 17V9a1 1 0 0 1 1-1h8m27 23v8a1 1 0 0 1-1 1h-8M6 31v8a1 1 0 0 0 1 1h8',
      },
      null,
      -1
    ),
    Xq = [qq]
  function Yq(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Xq,
        14,
        Kq
      )
    )
  }
  var Q0 = Te(Gq, [['render', Yq]])
  const Zq = Object.assign(Q0, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Q0.name, Q0)
      },
    }),
    Jq = ce({
      name: 'IconRotateLeft',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-rotate-left`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Qq = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    eX = Se(
      'path',
      {
        d: 'M10 22a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V22ZM23 11h11a6 6 0 0 1 6 6v6M22.5 12.893 19.587 11 22.5 9.107v3.786Z',
      },
      null,
      -1
    ),
    tX = [eX]
  function nX(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        tX,
        14,
        Qq
      )
    )
  }
  var ey = Te(Jq, [['render', nX]])
  const rX = Object.assign(ey, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + ey.name, ey)
      },
    }),
    iX = ce({
      name: 'IconRotateRight',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-rotate-right`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    oX = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    aX = Se(
      'path',
      {
        d: 'M38 22a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V22ZM25 11H14a6 6 0 0 0-6 6v6M25.5 12.893 28.413 11 25.5 9.107v3.786Z',
      },
      null,
      -1
    ),
    sX = [aX]
  function lX(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        sX,
        14,
        oX
      )
    )
  }
  var ty = Te(iX, [['render', lX]])
  const uX = Object.assign(ty, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + ty.name, ty)
      },
    }),
    cX = ce({
      name: 'IconOriginalSize',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-original-size`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    dX = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    fX = Se('path', { d: 'm5.5 11.5 5-2.5h1v32M34 11.5 39 9h1v32' }, null, -1),
    hX = Se(
      'path',
      {
        d: 'M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    pX = Se('path', { d: 'M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z' }, null, -1),
    vX = [fX, hX, pX]
  function mX(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        vX,
        14,
        dX
      )
    )
  }
  var ny = Te(cX, [['render', mX]])
  const gX = Object.assign(ny, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + ny.name, ny)
    },
  })
  function yX(e) {
    const { container: t, hidden: n } = tt(e)
    let r = !1,
      i = {}
    const o = (l) =>
        l.tagName === 'BODY'
          ? window.innerWidth -
            (document.body.clientWidth || document.documentElement.clientWidth)
          : l.offsetWidth - l.clientWidth,
      a = () => {
        if (t.value && t.value.style.overflow !== 'hidden') {
          const l = t.value.style
          r = !0
          const c = o(t.value)
          c &&
            ((i.width = l.width),
            (t.value.style.width = `calc(${
              t.value.style.width || '100%'
            } - ${c}px)`)),
            (i.overflow = l.overflow),
            (t.value.style.overflow = 'hidden')
        }
      },
      s = () => {
        if (t.value && r) {
          const l = i
          Object.keys(l).forEach((c) => {
            t.value.style[c] = l[c]
          })
        }
        ;(r = !1), (i = {})
      }
    return (
      pr((l) => {
        n.value ? a() : s(),
          l(() => {
            s()
          })
      }),
      [s, a]
    )
  }
  function bX(e, t) {
    const { popupContainer: n } = tt(t)
    return C(() => (ir(n.value) ? N4(n.value) : n.value) || e)
  }
  const $o = [
      25, 33, 50, 67, 75, 80, 90, 100, 110, 125, 150, 175, 200, 250, 300, 400,
      500,
    ].map((e) => +(e / 100).toFixed(2)),
    _X = $o[0],
    SX = $o[$o.length - 1]
  function IM(e = 1, t = 'zoomIn') {
    let n = $o.indexOf(e)
    return (
      n === -1 && (n = CX(e)),
      t === 'zoomIn'
        ? n === $o.length - 1
          ? e
          : $o[n + 1]
        : n === 0
        ? e
        : $o[n - 1]
    )
  }
  function CX(e) {
    let t = $o.length - 1
    for (let n = 0; n < $o.length; n++) {
      const r = $o[n]
      if (e === r) {
        t = n
        break
      }
      if (e < r) {
        const i = $o[n - 1]
        t = i === void 0 || Math.abs(i - e) <= Math.abs(r - e) ? n - 1 : n
        break
      }
    }
    return t
  }
  var wX = Object.defineProperty,
    RM = Object.getOwnPropertySymbols,
    xX = Object.prototype.hasOwnProperty,
    MX = Object.prototype.propertyIsEnumerable,
    DM = (e, t, n) =>
      t in e
        ? wX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    EX = (e, t) => {
      for (var n in t || (t = {})) xX.call(t, n) && DM(e, n, t[n])
      if (RM) for (var n of RM(t)) MX.call(t, n) && DM(e, n, t[n])
      return e
    }
  const ry = 90
  var PX = ce({
    name: 'ImagePreview',
    components: {
      PreviewArrow: Pq,
      PreviewToolbar: $q,
      IconLoading: Xr,
      IconClose: zr,
    },
    props: {
      renderToBody: { type: Boolean, default: !0 },
      src: { type: String },
      visible: { type: Boolean, default: void 0 },
      defaultVisible: { type: Boolean, default: !1 },
      maskClosable: { type: Boolean, default: !0 },
      closable: { type: Boolean, default: !0 },
      actionsLayout: {
        type: Array,
        default: () => [
          'fullScreen',
          'rotateRight',
          'rotateLeft',
          'zoomIn',
          'zoomOut',
          'originalSize',
        ],
      },
      popupContainer: { type: [Object, String] },
      inGroup: { type: Boolean, default: !1 },
      groupArrowProps: { type: Object, default: () => ({}) },
    },
    emits: ['close', 'update:visible'],
    setup(e, { emit: t }) {
      const { t: n } = Vn(),
        {
          src: r,
          popupContainer: i,
          visible: o,
          defaultVisible: a,
          maskClosable: s,
        } = tt(e),
        l = J(),
        c = J(),
        d = ye('image-preview'),
        [h, p] = Er(a.value, Je({ value: o })),
        v = C(() => [d, { [`${d}-hide`]: !h.value }]),
        g = bX(document.body, Je({ popupContainer: i })),
        _ = C(() => g.value === document.body),
        { zIndex: b } = oc('dialog', { visible: h }),
        y = C(() => {
          const L = _.value
            ? { zIndex: b.value, position: 'fixed' }
            : { zIndex: 'inherit', position: 'absolute' }
          return EX({}, L)
        }),
        { isLoading: M, isLoaded: x, setLoadStatus: w } = rA(),
        E = J(0),
        P = J(1),
        {
          translate: A,
          moving: F,
          resetTranslate: T,
        } = Lq(Je({ wrapperEl: l, imageEl: c, visible: h, scale: P })),
        k = J(!1)
      let R = null
      const j = () => {
        !k.value && (k.value = !0),
          R && clearTimeout(R),
          (R = setTimeout(() => {
            k.value = !1
          }, 1e3))
      }
      yX(Je({ container: g, hidden: h }))
      function N() {
        ;(E.value = 0), (P.value = 1), T()
      }
      pt([r, h], () => {
        h.value && (N(), w('loading'))
      })
      function I() {
        h.value && (t('close'), t('update:visible', !1), p(!1))
      }
      function B(L) {
        s.value && L.target === L.currentTarget && I()
      }
      function V(L) {
        P.value !== L && ((P.value = L), j())
      }
      return {
        prefixCls: d,
        classNames: v,
        container: g,
        wrapperStyles: y,
        scale: P,
        translate: A,
        rotate: E,
        moving: F,
        mergedVisible: h,
        isLoading: M,
        isLoaded: x,
        scaleValueVisible: k,
        refWrapper: l,
        refImage: c,
        onMaskClick: B,
        onCloseClick: I,
        onImgLoad() {
          w('loaded')
        },
        onImgError() {
          w('error')
        },
        actions: C(() => [
          {
            key: 'fullScreen',
            name: n('imagePreview.fullScreen'),
            content: () => _i(Zq),
            onClick: () => {
              const L = l.value.getBoundingClientRect(),
                W = c.value.getBoundingClientRect(),
                Y = L.height / (W.height / P.value),
                U = L.width / (W.width / P.value),
                le = Math.max(Y, U)
              V(le)
            },
          },
          {
            key: 'rotateRight',
            name: n('imagePreview.rotateRight'),
            content: () => _i(uX),
            onClick: () => {
              E.value = (E.value + ry) % 360
            },
          },
          {
            key: 'rotateLeft',
            name: n('imagePreview.rotateLeft'),
            content: () => _i(rX),
            onClick: () => {
              E.value = E.value === 0 ? 360 - ry : E.value - ry
            },
          },
          {
            key: 'zoomIn',
            name: n('imagePreview.zoomIn'),
            content: () => _i(jq),
            onClick: () => {
              const L = IM(P.value, 'zoomIn')
              V(L)
            },
            disabled: P.value === SX,
          },
          {
            key: 'zoomOut',
            name: n('imagePreview.zoomOut'),
            content: () => _i(Fq),
            onClick: () => {
              const L = IM(P.value, 'zoomOut')
              V(L)
            },
            disabled: P.value === _X,
          },
          {
            key: 'originalSize',
            name: n('imagePreview.originalSize'),
            content: () => _i(gX),
            onClick: () => {
              V(1)
            },
          },
        ]),
      }
    },
  })
  const TX = ['src']
  function kX(e, t, n, r, i, o) {
    const a = ge('IconLoading'),
      s = ge('PreviewToolbar'),
      l = ge('IconClose'),
      c = ge('PreviewArrow')
    return (
      O(),
      Ee(
        Dv,
        { to: e.container, disabled: !e.renderToBody },
        [
          Se(
            'div',
            { class: H(e.classNames), style: at(e.wrapperStyles) },
            [
              m(
                Fr,
                {
                  name: 'image-fade',
                  onBeforeEnter:
                    t[0] ||
                    (t[0] = (d) => {
                      d.parentNode.style.display = 'block'
                    }),
                  onAfterLeave:
                    t[1] ||
                    (t[1] = (d) => {
                      d.parentNode.style.display = ''
                    }),
                },
                {
                  default: ze(() => [
                    ro(
                      Se('div', { class: H(`${e.prefixCls}-mask`) }, null, 2),
                      [[oo, e.mergedVisible]]
                    ),
                  ]),
                  _: 1,
                }
              ),
              e.mergedVisible
                ? (O(),
                  Z(
                    'div',
                    {
                      key: 0,
                      ref: 'refWrapper',
                      class: H(`${e.prefixCls}-wrapper`),
                      onClick:
                        t[6] ||
                        (t[6] = (...d) => e.onMaskClick && e.onMaskClick(...d)),
                    },
                    [
                      Ce(' img '),
                      Se(
                        'div',
                        {
                          class: H(`${e.prefixCls}-img-container`),
                          style: at({
                            transform: `scale(${e.scale}, ${e.scale})`,
                          }),
                          onClick:
                            t[4] ||
                            (t[4] = (...d) =>
                              e.onMaskClick && e.onMaskClick(...d)),
                        },
                        [
                          (O(),
                          Z(
                            'img',
                            {
                              ref: 'refImage',
                              key: e.src,
                              src: e.src,
                              class: H([
                                `${e.prefixCls}-img`,
                                { [`${e.prefixCls}-img-moving`]: e.moving },
                              ]),
                              style: at({
                                transform: `translate(${e.translate[0]}px, ${e.translate[1]}px) rotate(${e.rotate}deg)`,
                              }),
                              onLoad:
                                t[2] ||
                                (t[2] = (...d) =>
                                  e.onImgLoad && e.onImgLoad(...d)),
                              onError:
                                t[3] ||
                                (t[3] = (...d) =>
                                  e.onImgError && e.onImgError(...d)),
                            },
                            null,
                            46,
                            TX
                          )),
                        ],
                        6
                      ),
                      Ce(' loading '),
                      e.isLoading
                        ? (O(),
                          Z(
                            'div',
                            { key: 0, class: H(`${e.prefixCls}-loading`) },
                            [m(a)],
                            2
                          ))
                        : Ce('v-if', !0),
                      Ce(' scale value '),
                      m(
                        Fr,
                        { name: 'image-fade' },
                        {
                          default: ze(() => [
                            e.scaleValueVisible
                              ? (O(),
                                Z(
                                  'div',
                                  {
                                    key: 0,
                                    class: H(`${e.prefixCls}-scale-value`),
                                  },
                                  mt((e.scale * 100).toFixed(0)) + '% ',
                                  3
                                ))
                              : Ce('v-if', !0),
                          ]),
                          _: 1,
                        }
                      ),
                      Ce(' toolbar '),
                      e.isLoaded && e.actionsLayout.length
                        ? (O(),
                          Ee(
                            s,
                            {
                              key: 1,
                              actions: e.actions,
                              'actions-layout': e.actionsLayout,
                            },
                            {
                              default: ze(() => [ve(e.$slots, 'actions')]),
                              _: 3,
                            },
                            8,
                            ['actions', 'actions-layout']
                          ))
                        : Ce('v-if', !0),
                      Ce(' close btn '),
                      e.closable
                        ? (O(),
                          Z(
                            'div',
                            {
                              key: 2,
                              class: H(`${e.prefixCls}-close-btn`),
                              onClick:
                                t[5] ||
                                (t[5] = (...d) =>
                                  e.onCloseClick && e.onCloseClick(...d)),
                            },
                            [m(l)],
                            2
                          ))
                        : Ce('v-if', !0),
                      Ce(' group arrow '),
                      e.inGroup
                        ? (O(),
                          Ee(
                            c,
                            En(Fe({ key: 3 }, e.groupArrowProps)),
                            null,
                            16
                          ))
                        : Ce('v-if', !0),
                    ],
                    2
                  ))
                : Ce('v-if', !0),
            ],
            6
          ),
        ],
        8,
        ['to', 'disabled']
      )
    )
  }
  var Nu = Te(PX, [['render', kX]])
  function NM(e) {
    if (Mt(e)) return
    if (!it(e) && /^\d+(%)$/.test(e)) return e
    const t = parseInt(e, 10)
    return it(t) ? `${t}px` : void 0
  }
  const iA = Symbol('PreviewGroupInjectionKey')
  var AX = Object.defineProperty,
    BM = Object.getOwnPropertySymbols,
    $X = Object.prototype.hasOwnProperty,
    OX = Object.prototype.propertyIsEnumerable,
    FM = (e, t, n) =>
      t in e
        ? AX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    zM = (e, t) => {
      for (var n in t || (t = {})) $X.call(t, n) && FM(e, n, t[n])
      if (BM) for (var n of BM(t)) OX.call(t, n) && FM(e, n, t[n])
      return e
    }
  let LX = 0
  const IX = ce({
      name: 'Image',
      components: {
        IconImageClose: U_,
        IconLoading: Xr,
        ImageFooter: xq,
        ImagePreview: Nu,
      },
      inheritAttrs: !1,
      props: {
        renderToBody: { type: Boolean, default: !0 },
        src: { type: String },
        width: { type: [String, Number] },
        height: { type: [String, Number] },
        title: { type: String },
        description: { type: String },
        fit: { type: String },
        alt: { type: String },
        hideFooter: { type: [Boolean, String], default: !1 },
        footerPosition: { type: String, default: 'inner' },
        showLoader: { type: Boolean, default: !1 },
        preview: { type: Boolean, default: !0 },
        previewVisible: { type: Boolean, default: void 0 },
        defaultPreviewVisible: { type: Boolean, default: !1 },
        previewProps: { type: Object },
        footerClass: { type: [String, Array, Object] },
      },
      emits: ['preview-visible-change', 'update:previewVisible'],
      setup(e, { attrs: t, slots: n, emit: r }) {
        const { t: i } = Vn(),
          {
            height: o,
            width: a,
            hideFooter: s,
            title: l,
            description: c,
            src: d,
            footerPosition: h,
            defaultPreviewVisible: p,
            previewVisible: v,
            preview: g,
            previewProps: _,
          } = tt(e),
          b = zt(iA, void 0),
          y = ye('image'),
          M = J(),
          { isLoaded: x, isError: w, isLoading: E, setLoadStatus: P } = rA(),
          A = C(() => ({
            width: NM(a == null ? void 0 : a.value),
            height: NM(o == null ? void 0 : o.value),
          })),
          F = C(() => (e.fit ? { objectFit: e.fit } : {})),
          T = C(() => [
            `${y}`,
            {
              [`${y}-loading`]: E.value,
              [`${y}-loading-error`]: w.value,
              [`${y}-with-footer-inner`]: x && R && h.value === 'inner',
              [`${y}-with-footer-outer`]: x && R && h.value === 'outer',
            },
            t.class,
          ]),
          k = C(() => [A.value, t.style]),
          R = C(() =>
            (l != null && l.value) || (c != null && c.value) || n.extra
              ? Ui(s.value)
                ? !s.value && x.value
                : s.value === 'never'
              : !1
          ),
          j = C(() => xr(t, ['class', 'style'])),
          [N, I] = Er(p.value, Je({ value: v })),
          B = C(() => !(b != null && b.preview) && g.value)
        pr(() => {
          Kd ||
            !M.value ||
            ((M.value.src = d == null ? void 0 : d.value), P('loading'))
        })
        const V = LX++
        pr((le) => {
          var q, oe, te
          const ue =
            (te = b == null ? void 0 : b.registerImageUrl) == null
              ? void 0
              : te.call(
                  b,
                  V,
                  ((oe =
                    (q = _ == null ? void 0 : _.value) == null
                      ? void 0
                      : q.src) != null
                    ? oe
                    : d == null
                    ? void 0
                    : d.value) || '',
                  g.value
                )
          le(() => {
            ue == null || ue()
          })
        })
        function L() {
          P('loaded')
        }
        function W() {
          P('error')
        }
        function Y() {
          g.value &&
            (b != null && b.preview
              ? b.preview(V)
              : (r('preview-visible-change', !0), I(!0)))
        }
        function U() {
          r('preview-visible-change', !1), I(!1)
        }
        return {
          t: i,
          refImg: M,
          prefixCls: y,
          wrapperClassNames: T,
          wrapperStyles: k,
          showFooter: R,
          imgProps: j,
          imgStyle: A,
          isLoaded: x,
          isError: w,
          isLoading: E,
          mergedPreviewVisible: N,
          mergePreview: B,
          onImgLoaded: L,
          onImgLoadError: W,
          onImgClick: Y,
          onPreviewClose: U,
          fitStyle: F,
        }
      },
    }),
    RX = ['title', 'alt']
  function DX(e, t, n, r, i, o) {
    const a = ge('IconImageClose'),
      s = ge('IconLoading'),
      l = ge('ImageFooter'),
      c = ge('ImagePreview')
    return (
      O(),
      Z(
        'div',
        { class: H(e.wrapperClassNames), style: at(e.wrapperStyles) },
        [
          Se(
            'img',
            Fe({ ref: 'refImg', class: `${e.prefixCls}-img` }, e.imgProps, {
              style: zM(zM({}, e.imgStyle), e.fitStyle),
              title: e.title,
              alt: e.alt,
              onLoad:
                t[0] || (t[0] = (...d) => e.onImgLoaded && e.onImgLoaded(...d)),
              onError:
                t[1] ||
                (t[1] = (...d) => e.onImgLoadError && e.onImgLoadError(...d)),
              onClick:
                t[2] || (t[2] = (...d) => e.onImgClick && e.onImgClick(...d)),
            }),
            null,
            16,
            RX
          ),
          e.isLoaded
            ? Ce('v-if', !0)
            : (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-overlay`) },
                [
                  e.isError
                    ? ve(e.$slots, 'error', { key: 0 }, () => [
                        Se(
                          'div',
                          { class: H(`${e.prefixCls}-error`) },
                          [
                            Se(
                              'div',
                              { class: H(`${e.prefixCls}-error-icon`) },
                              [ve(e.$slots, 'error-icon', {}, () => [m(a)])],
                              2
                            ),
                            Se(
                              'div',
                              { class: H(`${e.prefixCls}-error-alt`) },
                              mt(e.alt || e.description),
                              3
                            ),
                          ],
                          2
                        ),
                      ])
                    : Ce('v-if', !0),
                  e.isLoading && (e.showLoader || e.$slots.loader)
                    ? ve(e.$slots, 'loader', { key: 1 }, () => [
                        Se(
                          'div',
                          { class: H([`${e.prefixCls}-loader`]) },
                          [
                            Se(
                              'div',
                              { class: H(`${e.prefixCls}-loader-spin`) },
                              [
                                m(s),
                                Se(
                                  'div',
                                  {
                                    class: H(`${e.prefixCls}-loader-spin-text`),
                                  },
                                  mt(e.t('image.loading')),
                                  3
                                ),
                              ],
                              2
                            ),
                          ],
                          2
                        ),
                      ])
                    : Ce('v-if', !0),
                ],
                2
              )),
          e.showFooter
            ? (O(),
              Ee(
                l,
                {
                  key: 1,
                  class: H(e.footerClass),
                  'prefix-cls': e.prefixCls,
                  title: e.title,
                  description: e.description,
                },
                Nn({ _: 2 }, [
                  e.$slots.extra
                    ? { name: 'extra', fn: ze(() => [ve(e.$slots, 'extra')]) }
                    : void 0,
                ]),
                1032,
                ['class', 'prefix-cls', 'title', 'description']
              ))
            : Ce('v-if', !0),
          e.isLoaded && e.mergePreview
            ? (O(),
              Ee(
                c,
                Fe({ key: 2, src: e.src }, e.previewProps, {
                  visible: e.mergedPreviewVisible,
                  'render-to-body': e.renderToBody,
                  onClose: e.onPreviewClose,
                }),
                { actions: ze(() => [ve(e.$slots, 'preview-actions')]), _: 3 },
                16,
                ['src', 'visible', 'render-to-body', 'onClose']
              ))
            : Ce('v-if', !0),
        ],
        6
      )
    )
  }
  var iy = Te(IX, [['render', DX]]),
    NX = ce({
      name: 'ImagePreviewGroup',
      components: { ImagePreview: Nu },
      inheritAttrs: !1,
      props: {
        renderToBody: { type: Boolean, default: !0 },
        srcList: { type: Array },
        current: { type: Number },
        defaultCurrent: { type: Number, default: 0 },
        infinite: { type: Boolean, default: !1 },
        visible: { type: Boolean, default: void 0 },
        defaultVisible: { type: Boolean, default: !1 },
        maskClosable: { type: Boolean, default: !0 },
        closable: { type: Boolean, default: !0 },
        actionsLayout: {
          type: Array,
          default: () => [
            'fullScreen',
            'rotateRight',
            'rotateLeft',
            'zoomIn',
            'zoomOut',
            'originalSize',
          ],
        },
        popupContainer: { type: [Object, String] },
      },
      emits: ['change', 'update:current', 'visible-change', 'update:visible'],
      setup(e, { emit: t }) {
        const {
            srcList: n,
            visible: r,
            defaultVisible: i,
            current: o,
            defaultCurrent: a,
            infinite: s,
          } = tt(e),
          [l, c] = Er(i.value, Je({ value: r })),
          d = (k) => {
            k !== l.value &&
              (t('visible-change', k), t('update:visible', k), c(k))
          },
          h = C(
            () =>
              new Map(
                Ft(n == null ? void 0 : n.value)
                  ? n == null
                    ? void 0
                    : n.value.map((k, R) => [R, { url: k, canPreview: !0 }])
                  : []
              )
          ),
          p = J(new Map(h.value || [])),
          v = C(() => Array.from(p.value.keys())),
          g = C(() => v.value.length)
        function _(k, R, j) {
          return (
            h.value.has(k) || p.value.set(k, { url: R, canPreview: j }),
            function () {
              h.value.has(k) || p.value.delete(k)
            }
          )
        }
        pt(h, () => {
          p.value = new Map(h.value || [])
        })
        const [b, y] = Er(a.value, Je({ value: o })),
          M = (k) => {
            k !== b.value && (t('change', k), t('update:current', k), y(k))
          },
          x = C(() => v.value[b.value]),
          w = (k) => {
            const R = v.value.indexOf(k)
            R !== b.value && M(R)
          },
          E = C(() => {
            var k
            return (k = p.value.get(x.value)) == null ? void 0 : k.url
          })
        sn(
          iA,
          Je({
            registerImageUrl: _,
            preview: (k) => {
              d(!0), w(k)
            },
          })
        )
        const P = C(() => {
            const k = (j, N) => {
                var I
                for (let B = j; B <= N; B++) {
                  const V = v.value[B]
                  if ((I = p.value.get(V)) != null && I.canPreview) return B
                }
              },
              R = k(b.value + 1, g.value - 1)
            return Mt(R) && s.value ? k(0, b.value - 1) : R
          }),
          A = C(() => {
            const k = (j, N) => {
                var I
                for (let B = j; B >= N; B--) {
                  const V = v.value[B]
                  if ((I = p.value.get(V)) != null && I.canPreview) return B
                }
              },
              R = k(b.value - 1, 0)
            return Mt(R) && s.value ? k(g.value - 1, b.value + 1) : R
          }),
          F = C(() =>
            Mt(A.value)
              ? void 0
              : () => {
                  !Mt(A.value) && M(A.value)
                }
          ),
          T = C(() =>
            Mt(P.value)
              ? void 0
              : () => {
                  !Mt(P.value) && M(P.value)
                }
          )
        return {
          mergedVisible: l,
          currentUrl: E,
          prevIndex: A,
          nextIndex: P,
          onClose() {
            d(!1)
          },
          groupArrowProps: Je({ onPrev: F, onNext: T }),
        }
      },
    }),
    BX = Object.defineProperty,
    FX = Object.defineProperties,
    zX = Object.getOwnPropertyDescriptors,
    VM = Object.getOwnPropertySymbols,
    VX = Object.prototype.hasOwnProperty,
    UX = Object.prototype.propertyIsEnumerable,
    UM = (e, t, n) =>
      t in e
        ? BX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    HX = (e, t) => {
      for (var n in t || (t = {})) VX.call(t, n) && UM(e, n, t[n])
      if (VM) for (var n of VM(t)) UX.call(t, n) && UM(e, n, t[n])
      return e
    },
    WX = (e, t) => FX(e, zX(t))
  function jX(e, t, n, r, i, o) {
    const a = ge('ImagePreview')
    return (
      O(),
      Z(
        yt,
        null,
        [
          ve(e.$slots, 'default'),
          m(
            a,
            Fe(WX(HX({}, e.$attrs), { groupArrowProps: e.groupArrowProps }), {
              'in-group': '',
              src: e.currentUrl,
              visible: e.mergedVisible,
              'mask-closable': e.maskClosable,
              closable: e.closable,
              'actions-layout': e.actionsLayout,
              'popup-container': e.popupContainer,
              'render-to-body': e.renderToBody,
              onClose: e.onClose,
            }),
            Nn({ _: 2 }, [
              e.$slots.actions
                ? {
                    name: 'actions',
                    fn: ze(() => [
                      ve(e.$slots, 'actions', { url: e.currentUrl }),
                    ]),
                  }
                : void 0,
            ]),
            1040,
            [
              'src',
              'visible',
              'mask-closable',
              'closable',
              'actions-layout',
              'popup-container',
              'render-to-body',
              'onClose',
            ]
          ),
        ],
        64
      )
    )
  }
  var hd = Te(NX, [['render', jX]])
  const GX = Object.assign(iy, {
    Preview: Nu,
    PreviewGroup: hd,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + iy.name, iy),
        e.component(n + Nu.name, Nu),
        e.component(n + hd.name, hd),
        e.component(n + kb.name, kb)
    },
  })
  function sS(e, t) {
    return t === void 0 && (t = 15), +parseFloat(Number(e).toPrecision(t))
  }
  function oa(e) {
    var t = e.toString().split(/[eE]/),
      n = (t[0].split('.')[1] || '').length - +(t[1] || 0)
    return n > 0 ? n : 0
  }
  function Id(e) {
    if (e.toString().indexOf('e') === -1)
      return Number(e.toString().replace('.', ''))
    var t = oa(e)
    return t > 0 ? sS(Number(e) * Math.pow(10, t)) : Number(e)
  }
  function Ab(e) {
    aA &&
      (e > Number.MAX_SAFE_INTEGER || e < Number.MIN_SAFE_INTEGER) &&
      console.warn(
        e +
          ' is beyond boundary when transfer to integer, the results may not be accurate'
      )
  }
  function im(e) {
    return function () {
      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n]
      var r = t[0],
        i = t.slice(1)
      return i.reduce(function (o, a) {
        return e(o, a)
      }, r)
    }
  }
  var As = im(function (e, t) {
      var n = Id(e),
        r = Id(t),
        i = oa(e) + oa(t),
        o = n * r
      return Ab(o), o / Math.pow(10, i)
    }),
    KX = im(function (e, t) {
      var n = Math.pow(10, Math.max(oa(e), oa(t)))
      return (As(e, n) + As(t, n)) / n
    }),
    qX = im(function (e, t) {
      var n = Math.pow(10, Math.max(oa(e), oa(t)))
      return (As(e, n) - As(t, n)) / n
    }),
    oA = im(function (e, t) {
      var n = Id(e),
        r = Id(t)
      return Ab(n), Ab(r), As(n / r, sS(Math.pow(10, oa(t) - oa(e))))
    })
  function XX(e, t) {
    var n = Math.pow(10, t),
      r = oA(Math.round(Math.abs(As(e, n))), n)
    return e < 0 && r !== 0 && (r = As(r, -1)), r
  }
  var aA = !0
  function YX(e) {
    e === void 0 && (e = !0), (aA = e)
  }
  var ci = {
    strip: sS,
    plus: KX,
    minus: qX,
    times: As,
    divide: oA,
    round: XX,
    digitLength: oa,
    float2Fixed: Id,
    enableBoundaryChecking: YX,
  }
  const ZX = ce({
      name: 'IconPlus',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-plus`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    JX = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    QX = Se('path', { d: 'M5 24h38M24 5v38' }, null, -1),
    eY = [QX]
  function tY(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        eY,
        14,
        JX
      )
    )
  }
  var oy = Te(ZX, [['render', tY]])
  const Xu = Object.assign(oy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + oy.name, oy)
      },
    }),
    nY = ce({
      name: 'IconMinus',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-minus`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    rY = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    iY = Se('path', { d: 'M5 24h38' }, null, -1),
    oY = [iY]
  function aY(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        oY,
        14,
        rY
      )
    )
  }
  var ay = Te(nY, [['render', aY]])
  const lS = Object.assign(ay, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + ay.name, ay)
      },
    }),
    sY = 150
  ci.enableBoundaryChecking(!1)
  var sy = ce({
    name: 'InputNumber',
    props: {
      modelValue: Number,
      defaultValue: Number,
      mode: { type: String, default: 'embed' },
      precision: Number,
      step: { type: Number, default: 1 },
      disabled: { type: Boolean, default: !1 },
      error: { type: Boolean, default: !1 },
      max: { type: Number, default: 1 / 0 },
      min: { type: Number, default: -1 / 0 },
      formatter: { type: Function },
      parser: { type: Function },
      placeholder: String,
      hideButton: { type: Boolean, default: !1 },
      size: { type: String },
      allowClear: { type: Boolean, default: !1 },
      modelEvent: { type: String, default: 'change' },
      readOnly: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      change: (e, t) => !0,
      focus: (e) => !0,
      blur: (e) => !0,
      clear: (e) => !0,
      input: (e, t, n) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      var r
      const { size: i, disabled: o } = tt(e),
        a = ye('input-number'),
        s = J(),
        {
          mergedSize: l,
          mergedDisabled: c,
          eventHandlers: d,
        } = Rn({ size: i, disabled: o }),
        { mergedSize: h } = Vr(l),
        p = C(() => {
          if (it(e.precision)) {
            const U = `${e.step}`.split('.')[1],
              le = (U && U.length) || 0
            return Math.max(le, e.precision)
          }
        }),
        v = (U) => {
          var le, q
          if (!it(U)) return ''
          const oe = p.value ? U.toFixed(p.value) : String(U)
          return (q = (le = e.formatter) == null ? void 0 : le.call(e, oe)) !=
            null
            ? q
            : oe
        },
        g = J(v((r = e.modelValue) != null ? r : e.defaultValue)),
        _ = C(() => {
          var U, le
          if (!g.value) return
          const q = Number(
            (le = (U = e.parser) == null ? void 0 : U.call(e, g.value)) != null
              ? le
              : g.value
          )
          return Number.isNaN(q) ? void 0 : q
        }),
        b = J(it(_.value) && _.value <= e.min),
        y = J(it(_.value) && _.value >= e.max)
      let M = 0
      const x = () => {
          M && (window.clearTimeout(M), (M = 0))
        },
        w = (U) => {
          if (!Mt(U))
            return (
              it(e.min) && U < e.min && (U = e.min),
              it(e.max) && U > e.max && (U = e.max),
              it(p.value) ? ci.round(U, p.value) : U
            )
        },
        E = (U) => {
          let le = !1,
            q = !1
          it(U) && (U <= e.min && (le = !0), U >= e.max && (q = !0)),
            y.value !== q && (y.value = q),
            b.value !== le && (b.value = le)
        },
        P = () => {
          const U = w(_.value),
            le = v(U)
          ;(U !== _.value || g.value !== le) && (g.value = le),
            t('update:modelValue', U)
        }
      pt(
        () => e.min,
        (U) => {
          const le = it(_.value) && _.value <= U
          b.value !== le && (b.value = le), it(_.value) && _.value < U && P()
        }
      ),
        pt(
          () => e.max,
          (U) => {
            const le = it(_.value) && _.value >= U
            y.value !== le && (y.value = le), it(_.value) && _.value > U && P()
          }
        )
      const A = (U, le) => {
          if (
            c.value ||
            (U === 'plus' && y.value) ||
            (U === 'minus' && b.value)
          )
            return
          let q
          it(_.value)
            ? (q = w(ci[U](_.value, e.step)))
            : (q = e.min === -1 / 0 ? 0 : e.min),
            (g.value = v(q)),
            E(q),
            t('update:modelValue', q),
            t('change', q, le)
        },
        F = (U, le, q = !1) => {
          var oe
          U.preventDefault(),
            (oe = s.value) == null || oe.focus(),
            A(le, U),
            q && (M = window.setTimeout(() => U.target.dispatchEvent(U), sY))
        },
        T = (U, le) => {
          var q, oe, te, ue
          ;(U = U.trim().replace(//g, '.')),
            (U =
              (oe = (q = e.parser) == null ? void 0 : q.call(e, U)) != null
                ? oe
                : U),
            (it(Number(U)) || /^(\.|-)$/.test(U)) &&
              ((g.value =
                (ue = (te = e.formatter) == null ? void 0 : te.call(e, U)) !=
                null
                  ? ue
                  : U),
              E(_.value),
              e.modelEvent === 'input' && t('update:modelValue', _.value),
              t('input', _.value, g.value, le))
        },
        k = (U) => {
          t('focus', U)
        },
        R = (U, le) => {
          const q = w(_.value),
            oe = v(q)
          ;(q !== _.value || g.value !== oe) && ((g.value = oe), E(q)),
            hn(() => {
              it(e.modelValue) &&
                e.modelValue !== q &&
                ((g.value = v(e.modelValue)), E(e.modelValue))
            }),
            t('update:modelValue', q),
            t('change', q, le)
        },
        j = (U) => {
          t('blur', U)
        },
        N = (U) => {
          var le, q
          ;(g.value = ''),
            t('update:modelValue', void 0),
            t('change', void 0, U),
            (q = (le = d.value) == null ? void 0 : le.onChange) == null ||
              q.call(le, U),
            t('clear', U)
        },
        I = Yv(
          new Map([
            [
              fr.ARROW_UP,
              (U) => {
                U.preventDefault(), !e.readOnly && A('plus', U)
              },
            ],
            [
              fr.ARROW_DOWN,
              (U) => {
                U.preventDefault(), !e.readOnly && A('minus', U)
              },
            ],
          ])
        )
      pt(
        () => e.modelValue,
        (U) => {
          U !== _.value && ((g.value = v(U)), E(U))
        }
      )
      const B = () => {
          var U
          return e.readOnly
            ? null
            : m(yt, null, [
                (U = n.suffix) == null ? void 0 : U.call(n),
                m('div', { class: `${a}-step` }, [
                  m(
                    'button',
                    {
                      class: [
                        `${a}-step-button`,
                        { [`${a}-step-button-disabled`]: c.value || y.value },
                      ],
                      type: 'button',
                      tabindex: '-1',
                      disabled: c.value || y.value,
                      onMousedown: (le) => F(le, 'plus', !0),
                      onMouseup: x,
                      onMouseleave: x,
                    },
                    [m(Y_, null, null)]
                  ),
                  m(
                    'button',
                    {
                      class: [
                        `${a}-step-button`,
                        { [`${a}-step-button-disabled`]: c.value || b.value },
                      ],
                      type: 'button',
                      tabindex: '-1',
                      disabled: c.value || b.value,
                      onMousedown: (le) => F(le, 'minus', !0),
                      onMouseup: x,
                      onMouseleave: x,
                    },
                    [m(sc, null, null)]
                  ),
                ]),
              ])
        },
        V = C(() => [
          a,
          `${a}-mode-${e.mode}`,
          `${a}-size-${h.value}`,
          { [`${a}-readonly`]: e.readOnly },
        ]),
        L = () =>
          m(
            Yr,
            {
              size: h.value,
              tabindex: '-1',
              class: `${a}-step-button`,
              disabled: c.value || b.value,
              onMousedown: (U) => F(U, 'minus', !0),
              onMouseup: x,
              onMouseleave: x,
            },
            { icon: () => m(lS, null, null) }
          ),
        W = () =>
          m(
            Yr,
            {
              size: h.value,
              tabindex: '-1',
              class: `${a}-step-button`,
              disabled: c.value || y.value,
              onMousedown: (U) => F(U, 'plus', !0),
              onMouseup: x,
              onMouseleave: x,
            },
            { icon: () => m(Xu, null, null) }
          )
      return {
        inputRef: s,
        render: () => {
          const U =
            e.mode === 'embed'
              ? {
                  prepend: n.prepend,
                  prefix: n.prefix,
                  suffix: e.hideButton ? n.suffix : B,
                  append: n.append,
                }
              : {
                  prepend: e.hideButton ? n.prepend : L,
                  prefix: n.prefix,
                  suffix: n.suffix,
                  append: e.hideButton ? n.append : W,
                }
          return m(
            ic,
            {
              key: `__arco__${e.mode}`,
              ref: s,
              class: V.value,
              type: 'text',
              allowClear: e.allowClear,
              size: h.value,
              modelValue: g.value,
              placeholder: e.placeholder,
              disabled: c.value,
              readonly: e.readOnly,
              error: e.error,
              inputAttrs: {
                role: 'spinbutton',
                'aria-valuemax': e.max,
                'aria-valuemin': e.min,
                'aria-valuenow': g.value,
              },
              onInput: T,
              onFocus: k,
              onBlur: j,
              onClear: N,
              onChange: R,
              onKeydown: I,
            },
            U
          )
        },
      }
    },
    methods: {
      focus() {
        var e
        ;(e = this.inputRef) == null || e.focus()
      },
      blur() {
        var e
        ;(e = this.inputRef) == null || e.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const uS = Object.assign(sy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + sy.name, sy)
      },
    }),
    sA = Symbol('LayoutSiderInjectionKey'),
    lA = Symbol('SiderInjectionKey')
  var lY = ce({
    name: 'Layout',
    props: { hasSider: { type: Boolean } },
    setup(e) {
      const t = J([]),
        n = ye('layout'),
        r = C(() => [n, { [`${n}-has-sider`]: e.hasSider || t.value.length }])
      return (
        sn(sA, {
          onSiderMount: (i) => t.value.push(i),
          onSiderUnMount: (i) => {
            t.value = t.value.filter((o) => o !== i)
          },
        }),
        { classNames: r }
      )
    },
  })
  function uY(e, t, n, r, i, o) {
    return (
      O(),
      Z('section', { class: H(e.classNames) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var ly = Te(lY, [['render', uY]])
  const cY = ce({
    name: 'LayoutHeader',
    setup() {
      return { classNames: [ye('layout-header')] }
    },
  })
  function dY(e, t, n, r, i, o) {
    return (
      O(), Z('header', { class: H(e.classNames) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var Ep = Te(cY, [['render', dY]])
  const fY = ce({
    name: 'LayoutContent',
    setup() {
      return { classNames: [ye('layout-content')] }
    },
  })
  function hY(e, t, n, r, i, o) {
    return (
      O(), Z('main', { class: H(e.classNames) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var Pp = Te(fY, [['render', hY]])
  const pY = ce({
    name: 'LayoutFooter',
    setup() {
      return { classNames: [ye('layout-footer')] }
    },
  })
  function vY(e, t, n, r, i, o) {
    return (
      O(), Z('footer', { class: H(e.classNames) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var Tp = Te(pY, [['render', vY]])
  const mY = ce({
      name: 'IconDragDot',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-drag-dot`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    gY = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    yY = Se(
      'path',
      {
        d: 'M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    bY = Se(
      'path',
      {
        d: 'M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z',
      },
      null,
      -1
    ),
    _Y = [yY, bY]
  function SY(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        _Y,
        14,
        gY
      )
    )
  }
  var uy = Te(mY, [['render', SY]])
  const CY = Object.assign(uy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + uy.name, uy)
      },
    }),
    wY = ce({
      name: 'IconDragDotVertical',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-drag-dot-vertical`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    xY = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    MY = Se(
      'path',
      {
        d: 'M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    EY = Se(
      'path',
      {
        d: 'M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z',
      },
      null,
      -1
    ),
    PY = [MY, EY]
  function TY(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        PY,
        14,
        xY
      )
    )
  }
  var cy = Te(wY, [['render', TY]])
  const cS = Object.assign(cy, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + cy.name, cy)
    },
  })
  var kY = ce({
    name: 'ResizeTrigger',
    components: {
      ResizeObserver: Ro,
      IconDragDot: CY,
      IconDragDotVertical: cS,
    },
    props: {
      prefixCls: { type: String, required: !0 },
      direction: { type: String, default: 'horizontal' },
    },
    emits: ['resize'],
    setup(e, { emit: t }) {
      const { direction: n, prefixCls: r } = tt(e),
        i = C(() => (n == null ? void 0 : n.value) === 'horizontal')
      return {
        classNames: C(() => [
          r.value,
          {
            [`${r.value}-horizontal`]: i.value,
            [`${r.value}-vertical`]: !i.value,
          },
        ]),
        onResize: (s) => {
          t('resize', s)
        },
        isHorizontal: i,
      }
    },
  })
  function AY(e, t, n, r, i, o) {
    const a = ge('IconDragDot'),
      s = ge('IconDragDotVertical'),
      l = ge('ResizeObserver')
    return (
      O(),
      Ee(
        l,
        { onResize: e.onResize },
        {
          default: ze(() => [
            Se(
              'div',
              { class: H(e.classNames) },
              [
                Ce(' @slot  '),
                ve(e.$slots, 'default', {}, () => [
                  Se(
                    'div',
                    { class: H(`${e.prefixCls}-icon-wrapper`) },
                    [
                      Ce(' @slot  icon '),
                      ve(e.$slots, 'icon', {}, () => [
                        e.isHorizontal
                          ? (O(),
                            Ee(
                              a,
                              { key: 0, class: H(`${e.prefixCls}-icon`) },
                              null,
                              8,
                              ['class']
                            ))
                          : (O(),
                            Ee(
                              s,
                              { key: 1, class: H(`${e.prefixCls}-icon`) },
                              null,
                              8,
                              ['class']
                            )),
                      ]),
                    ],
                    2
                  ),
                ]),
              ],
              2
            ),
          ]),
          _: 3,
        },
        8,
        ['onResize']
      )
    )
  }
  var uA = Te(kY, [['render', AY]]),
    $Y = Object.defineProperty,
    HM = Object.getOwnPropertySymbols,
    OY = Object.prototype.hasOwnProperty,
    LY = Object.prototype.propertyIsEnumerable,
    WM = (e, t, n) =>
      t in e
        ? $Y(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    dy = (e, t) => {
      for (var n in t || (t = {})) OY.call(t, n) && WM(e, n, t[n])
      if (HM) for (var n of HM(t)) LY.call(t, n) && WM(e, n, t[n])
      return e
    }
  const cA = 'left',
    dA = 'right',
    dS = 'top',
    fS = 'bottom',
    IY = [cA, dA, dS, fS]
  function jM(e, t) {
    if (e === 0) return 0
    const n = e - t
    return n <= 0 ? 0 : n
  }
  function fy(e) {
    return [dS, fS].indexOf(e) > -1
  }
  const RY = ce({
    name: 'ResizeBox',
    components: { ResizeTrigger: uA },
    inheritAttrs: !1,
    props: {
      width: { type: Number },
      height: { type: Number },
      component: { type: String, default: 'div' },
      directions: { type: Array, default: () => ['right'] },
    },
    emits: {
      'update:width': (e) => !0,
      'update:height': (e) => !0,
      movingStart: (e) => !0,
      moving: (e, t) => !0,
      movingEnd: (e) => !0,
    },
    setup(e, { emit: t }) {
      const { height: n, width: r, directions: i } = tt(e),
        [o, a] = Er(null, Je({ value: r })),
        [s, l] = Er(null, Je({ value: n })),
        c = J(),
        d = Je({}),
        h = ye('resizebox'),
        p = C(() => [h]),
        v = C(() =>
          dy(
            dy(
              dy({}, it(o.value) ? { width: `${o.value}px` } : {}),
              it(s.value) ? { height: `${s.value}px` } : {}
            ),
            d
          )
        ),
        g = C(() => i.value.filter((w) => IY.includes(w))),
        _ = {
          direction: '',
          startPageX: 0,
          startPageY: 0,
          startWidth: 0,
          startHeight: 0,
          moving: !1,
          padding: { left: 0, right: 0, top: 0, bottom: 0 },
        }
      function b(w) {
        if (!_.moving) return
        const {
          startPageX: E,
          startPageY: P,
          startWidth: A,
          startHeight: F,
          direction: T,
        } = _
        let k = A,
          R = F
        const j = w.pageX - E,
          N = w.pageY - P
        switch (T) {
          case cA:
            ;(k = A - j), a(k), t('update:width', k)
            break
          case dA:
            ;(k = A + j), a(k), t('update:width', k)
            break
          case dS:
            ;(R = F - N), l(R), t('update:height', R)
            break
          case fS:
            ;(R = F + N), l(R), t('update:height', R)
            break
        }
        t('moving', { width: k, height: R }, w)
      }
      function y(w) {
        ;(_.moving = !1),
          kn(window, 'mousemove', b),
          kn(window, 'mouseup', y),
          kn(window, 'contextmenu', y),
          (document.body.style.cursor = 'default'),
          t('movingEnd', w)
      }
      function M(w, E) {
        var P, A
        t('movingStart', E),
          (_.moving = !0),
          (_.startPageX = E.pageX),
          (_.startPageY = E.pageY),
          (_.direction = w)
        const { top: F, left: T, right: k, bottom: R } = _.padding
        ;(_.startWidth = jM(
          ((P = c.value) == null ? void 0 : P.clientWidth) || 0,
          T + k
        )),
          (_.startHeight = jM(
            ((A = c.value) == null ? void 0 : A.clientHeight) || 0,
            F + R
          )),
          Cn(window, 'mousemove', b),
          Cn(window, 'mouseup', y),
          Cn(window, 'contextmenu', y),
          (document.body.style.cursor = fy(w) ? 'row-resize' : 'col-resize')
      }
      function x(w, E) {
        const { width: P, height: A } = E.contentRect,
          F = fy(w) ? A : P
        ;(_.padding[w] = F), (d[`padding-${w}`] = `${F}px`)
      }
      return {
        prefixCls: h,
        classNames: p,
        styles: v,
        wrapperRef: c,
        onMoveStart: M,
        isHorizontal: fy,
        allowDirections: g,
        onTiggerResize: x,
      }
    },
  })
  function DY(e, t, n, r, i, o) {
    const a = ge('ResizeTrigger')
    return (
      O(),
      Ee(
        xi(e.component),
        Fe({ ref: 'wrapperRef', class: e.classNames }, e.$attrs, {
          style: e.styles,
        }),
        {
          default: ze(() => [
            ve(e.$slots, 'default'),
            (O(!0),
            Z(
              yt,
              null,
              Yn(
                e.allowDirections,
                (s) => (
                  O(),
                  Ee(
                    a,
                    {
                      key: s,
                      'prefix-cls': `${e.prefixCls}-trigger`,
                      class: H(`${e.prefixCls}-direction-${s}`),
                      direction: e.isHorizontal(s) ? 'horizontal' : 'vertical',
                      onMousedown: (l) => {
                        e.onMoveStart(s, l)
                      },
                      onResize: (l) => {
                        e.onTiggerResize(s, l)
                      },
                    },
                    Nn(
                      {
                        default: ze(() => [
                          e.$slots['resize-trigger']
                            ? ve(e.$slots, 'resize-trigger', {
                                key: 0,
                                direction: s,
                              })
                            : Ce('v-if', !0),
                        ]),
                        _: 2,
                      },
                      [
                        e.$slots['resize-trigger-icon']
                          ? {
                              name: 'icon',
                              fn: ze(() => [
                                ve(e.$slots, 'resize-trigger-icon', {
                                  direction: s,
                                }),
                              ]),
                            }
                          : void 0,
                      ]
                    ),
                    1032,
                    [
                      'prefix-cls',
                      'class',
                      'direction',
                      'onMousedown',
                      'onResize',
                    ]
                  )
                )
              ),
              128
            )),
          ]),
          _: 3,
        },
        16,
        ['class', 'style']
      )
    )
  }
  var hy = Te(RY, [['render', DY]])
  const fA = Object.assign(hy, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + hy.name, hy)
    },
  })
  function hA(e, t) {
    const n = C(() => (lr(e) ? e.value : e))
    let r = ''
    Wt(() => {
      r = mv.subscribe((i, o) => {
        n.value && (!o || o === n.value) && t(!!i[n.value])
      })
    }),
      wr(() => {
        r && mv.unsubscribe(r)
      })
  }
  const NY = (() => {
    let e = 0
    return (t = '') => ((e += 1), `${t}${e}`)
  })()
  var BY = ce({
    name: 'LayoutSider',
    components: { IconLeft: ja, IconRight: No, ResizeBox: fA },
    props: {
      theme: { type: String, default: 'light' },
      collapsed: { type: Boolean, default: void 0 },
      defaultCollapsed: { type: Boolean },
      collapsible: { type: Boolean },
      width: { type: Number, default: 200 },
      collapsedWidth: { type: Number, default: 48 },
      reverseArrow: { type: Boolean },
      breakpoint: { type: String },
      resizeDirections: { type: Array, default: void 0 },
      hideTrigger: { type: Boolean },
    },
    emits: ['collapse', 'update:collapsed', 'breakpoint'],
    setup(e, { emit: t }) {
      const {
          theme: n,
          collapsed: r,
          defaultCollapsed: i,
          collapsible: o,
          hideTrigger: a,
          breakpoint: s,
          collapsedWidth: l,
          resizeDirections: c,
        } = tt(e),
        [d, h] = Er(i.value, Je({ value: r })),
        p = C(() => (c.value ? 'ResizeBox' : 'div')),
        v = C(() => o.value && !a.value),
        g = ye('layout-sider'),
        _ = C(() => [
          g,
          {
            [`${g}-light`]: n.value === 'light',
            [`${g}-has-trigger`]: v.value,
            [`${g}-collapsed`]: r.value,
          },
        ]),
        b = C(() => {
          const { width: E, collapsedWidth: P } = e,
            A = d.value ? P : E
          return it(A) ? `${A}px` : String(A)
        }),
        y = C(() => [
          `${g}-trigger`,
          { [`${g}-trigger-light`]: n.value === 'light' },
        ]),
        M = () => {
          const E = !d.value
          h(E), t('update:collapsed', E), t('collapse', E, 'clickTrigger')
        }
      hA(s, (E) => {
        const P = !E
        P !== d.value &&
          (h(P),
          t('update:collapsed', P),
          t('collapse', P, 'responsive'),
          t('breakpoint', P))
      })
      const x = NY('__arco_layout_sider'),
        w = zt(sA, void 0)
      return (
        Wt(() => {
          var E
          ;(E = w == null ? void 0 : w.onSiderMount) == null || E.call(w, x)
        }),
        wr(() => {
          var E
          ;(E = w == null ? void 0 : w.onSiderUnMount) == null || E.call(w, x)
        }),
        sn(lA, Je({ theme: n, collapsed: d, collapsedWidth: l })),
        {
          componentTag: p,
          prefixCls: g,
          classNames: _,
          triggerClassNames: y,
          localCollapsed: d,
          siderWidth: b,
          showTrigger: v,
          toggleTrigger: M,
        }
      )
    },
  })
  const FY = { key: 0 },
    zY = { key: 1 }
  function VY(e, t, n, r, i, o) {
    const a = ge('IconLeft'),
      s = ge('IconRight')
    return (
      O(),
      Ee(
        xi(e.componentTag),
        Fe(
          { class: e.classNames, style: { width: e.siderWidth } },
          e.resizeDirections ? { directions: e.resizeDirections } : {}
        ),
        {
          default: ze(() => [
            Se(
              'div',
              { class: H(`${e.prefixCls}-children`) },
              [ve(e.$slots, 'default')],
              2
            ),
            e.showTrigger
              ? (O(),
                Z(
                  'div',
                  {
                    key: 0,
                    class: H(e.triggerClassNames),
                    style: at({ width: e.siderWidth }),
                    onClick:
                      t[0] ||
                      (t[0] = (...l) =>
                        e.toggleTrigger && e.toggleTrigger(...l)),
                  },
                  [
                    ve(
                      e.$slots,
                      'trigger',
                      { collapsed: e.localCollapsed },
                      () => [
                        e.reverseArrow
                          ? (O(),
                            Z('div', zY, [
                              e.localCollapsed
                                ? (O(), Ee(a, { key: 0 }))
                                : (O(), Ee(s, { key: 1 })),
                            ]))
                          : (O(),
                            Z('div', FY, [
                              e.localCollapsed
                                ? (O(), Ee(s, { key: 1 }))
                                : (O(), Ee(a, { key: 0 })),
                            ])),
                      ]
                    ),
                  ],
                  6
                ))
              : Ce('v-if', !0),
          ]),
          _: 3,
        },
        16,
        ['class', 'style']
      )
    )
  }
  var kp = Te(BY, [['render', VY]])
  const UY = Object.assign(ly, {
      Header: Ep,
      Content: Pp,
      Footer: Tp,
      Sider: kp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + ly.name, ly),
          e.component(n + Ep.name, Ep),
          e.component(n + Pp.name, Pp),
          e.component(n + Tp.name, Tp),
          e.component(n + kp.name, kp)
      },
    }),
    HY = ce({
      name: 'Pager',
      props: {
        pageNumber: { type: Number },
        current: { type: Number },
        disabled: { type: Boolean, default: !1 },
        style: { type: Object },
        activeStyle: { type: Object },
      },
      emits: ['click'],
      setup(e, { emit: t }) {
        const n = ye('pagination-item'),
          r = C(() => e.current === e.pageNumber),
          i = (s) => {
            e.disabled || t('click', e.pageNumber, s)
          },
          o = C(() => [n, { [`${n}-active`]: r.value }]),
          a = C(() => (r.value ? e.activeStyle : e.style))
        return { prefixCls: n, cls: o, mergedStyle: a, handleClick: i }
      },
    })
  function WY(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'li',
        {
          class: H(e.cls),
          style: at(e.mergedStyle),
          onClick:
            t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a)),
        },
        [
          ve(e.$slots, 'default', { page: e.pageNumber }, () => [
            Lt(mt(e.pageNumber), 1),
          ]),
        ],
        6
      )
    )
  }
  var jY = Te(HY, [['render', WY]])
  const pA = (e, { min: t, max: n }) => (e < t ? t : e > n ? n : e),
    GY = ce({
      name: 'StepPager',
      components: { IconLeft: ja, IconRight: No },
      props: {
        pages: { type: Number, required: !0 },
        current: { type: Number, required: !0 },
        type: { type: String, required: !0 },
        disabled: { type: Boolean, default: !1 },
        simple: { type: Boolean, default: !1 },
      },
      emits: ['click'],
      setup(e, { emit: t }) {
        const n = ye('pagination-item'),
          r = e.type === 'next',
          i = C(() =>
            e.disabled
              ? e.disabled
              : !e.pages || (r && e.current === e.pages)
              ? !0
              : !r && e.current <= 1
          ),
          o = C(() => pA(e.current + (r ? 1 : -1), { min: 1, max: e.pages })),
          a = (l) => {
            i.value || t('click', o.value)
          },
          s = C(() => [n, `${n}-${e.type}`, { [`${n}-disabled`]: i.value }])
        return { prefixCls: n, cls: s, isNext: r, handleClick: a }
      },
    })
  function KY(e, t, n, r, i, o) {
    const a = ge('icon-right'),
      s = ge('icon-left')
    return (
      O(),
      Ee(
        xi(e.simple ? 'span' : 'li'),
        { class: H(e.cls), onClick: e.handleClick },
        {
          default: ze(() => [
            ve(
              e.$slots,
              'default',
              { type: e.isNext ? 'next' : 'previous' },
              () => [
                e.isNext ? (O(), Ee(a, { key: 0 })) : (O(), Ee(s, { key: 1 })),
              ]
            ),
          ]),
          _: 3,
        },
        8,
        ['class', 'onClick']
      )
    )
  }
  var GM = Te(GY, [['render', KY]])
  const qY = ce({
    name: 'EllipsisPager',
    components: { IconMore: W_ },
    props: {
      current: { type: Number, required: !0 },
      step: { type: Number, default: 5 },
      pages: { type: Number, required: !0 },
    },
    emits: ['click'],
    setup(e, { emit: t }) {
      const n = ye('pagination-item'),
        r = C(() => pA(e.current + e.step, { min: 1, max: e.pages })),
        i = (a) => {
          t('click', r.value)
        },
        o = C(() => [n, `${n}-ellipsis`])
      return { prefixCls: n, cls: o, handleClick: i }
    },
  })
  function XY(e, t, n, r, i, o) {
    const a = ge('icon-more')
    return (
      O(),
      Z(
        'li',
        {
          class: H(e.cls),
          onClick:
            t[0] || (t[0] = (...s) => e.handleClick && e.handleClick(...s)),
        },
        [ve(e.$slots, 'default', {}, () => [m(a)])],
        2
      )
    )
  }
  var YY = Te(qY, [['render', XY]])
  const ZY = ce({
    name: 'PageJumper',
    components: { InputNumber: uS },
    props: {
      current: { type: Number, required: !0 },
      simple: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      pages: { type: Number, required: !0 },
      size: { type: String },
      onChange: { type: Function },
    },
    emits: ['change'],
    setup(e, { emit: t }) {
      const n = ye('pagination-jumper'),
        { t: r } = Vn(),
        i = J(e.simple ? e.current : void 0),
        o = (l) => {
          const c = parseInt(l.toString(), 10)
          return Number.isNaN(c) ? void 0 : String(c)
        },
        a = (l) => {
          t('change', i.value),
            hn(() => {
              e.simple || (i.value = void 0)
            })
        }
      pt(
        () => e.current,
        (l) => {
          e.simple && l !== i.value && (i.value = l)
        }
      )
      const s = C(() => [n, { [`${n}-simple`]: e.simple }])
      return {
        prefixCls: n,
        cls: s,
        t: r,
        inputValue: i,
        handleChange: a,
        handleFormatter: o,
      }
    },
  })
  function JY(e, t, n, r, i, o) {
    const a = ge('input-number')
    return (
      O(),
      Z(
        'span',
        { class: H(e.cls) },
        [
          e.simple
            ? Ce('v-if', !0)
            : (O(),
              Z(
                'span',
                {
                  key: 0,
                  class: H([
                    `${e.prefixCls}-prepend`,
                    `${e.prefixCls}-text-goto`,
                  ]),
                },
                [
                  ve(e.$slots, 'jumper-prepend', {}, () => [
                    Lt(mt(e.t('pagination.goto')), 1),
                  ]),
                ],
                2
              )),
          m(
            a,
            {
              modelValue: e.inputValue,
              'onUpdate:modelValue': t[0] || (t[0] = (s) => (e.inputValue = s)),
              class: H(`${e.prefixCls}-input`),
              min: 1,
              max: e.pages,
              size: e.size,
              disabled: e.disabled,
              'hide-button': '',
              formatter: e.handleFormatter,
              onChange: e.handleChange,
            },
            null,
            8,
            [
              'modelValue',
              'class',
              'max',
              'size',
              'disabled',
              'formatter',
              'onChange',
            ]
          ),
          e.$slots['jumper-append']
            ? (O(),
              Z(
                'span',
                { key: 1, class: H(`${e.prefixCls}-append`) },
                [ve(e.$slots, 'jumper-append')],
                2
              ))
            : Ce('v-if', !0),
          e.simple
            ? (O(),
              Z(
                yt,
                { key: 2 },
                [
                  Se('span', { class: H(`${e.prefixCls}-separator`) }, '/', 2),
                  Se(
                    'span',
                    { class: H(`${e.prefixCls}-total-page`) },
                    mt(e.pages),
                    3
                  ),
                ],
                64
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var KM = Te(ZY, [['render', JY]])
  const QY = ce({
    name: 'PageOptions',
    components: { ArcoSelect: lv },
    props: {
      sizeOptions: { type: Array, required: !0 },
      pageSize: Number,
      disabled: Boolean,
      size: { type: String },
      onChange: { type: Function },
      selectProps: { type: Object },
    },
    emits: ['change'],
    setup(e, { emit: t }) {
      const n = ye('pagination-options'),
        { t: r } = Vn(),
        i = C(() =>
          e.sizeOptions.map((a) => ({
            value: a,
            label: `${a} ${r('pagination.countPerPage')}`,
          }))
        )
      return {
        prefixCls: n,
        options: i,
        handleChange: (a) => {
          t('change', a)
        },
      }
    },
  })
  function eZ(e, t, n, r, i, o) {
    const a = ge('arco-select')
    return (
      O(),
      Z(
        'span',
        { class: H(e.prefixCls) },
        [
          m(
            a,
            Fe(
              {
                'model-value': e.pageSize,
                options: e.options,
                size: e.size,
                disabled: e.disabled,
              },
              e.selectProps,
              { onChange: e.handleChange }
            ),
            null,
            16,
            ['model-value', 'options', 'size', 'disabled', 'onChange']
          ),
        ],
        2
      )
    )
  }
  var tZ = Te(QY, [['render', eZ]]),
    py = ce({
      name: 'Pagination',
      props: {
        total: { type: Number, required: !0 },
        current: Number,
        defaultCurrent: { type: Number, default: 1 },
        pageSize: Number,
        defaultPageSize: { type: Number, default: 10 },
        disabled: { type: Boolean, default: !1 },
        hideOnSinglePage: { type: Boolean, default: !1 },
        simple: { type: Boolean, default: !1 },
        showTotal: { type: Boolean, default: !1 },
        showMore: { type: Boolean, default: !1 },
        showJumper: { type: Boolean, default: !1 },
        showPageSize: { type: Boolean, default: !1 },
        pageSizeOptions: { type: Array, default: () => [10, 20, 30, 40, 50] },
        pageSizeProps: { type: Object },
        size: { type: String },
        pageItemStyle: { type: Object },
        activePageItemStyle: { type: Object },
        baseSize: { type: Number, default: 6 },
        bufferSize: { type: Number, default: 2 },
        autoAdjust: { type: Boolean, default: !0 },
      },
      emits: {
        'update:current': (e) => !0,
        'update:pageSize': (e) => !0,
        change: (e) => !0,
        pageSizeChange: (e) => !0,
      },
      setup(e, { emit: t, slots: n }) {
        const r = ye('pagination'),
          { t: i } = Vn(),
          {
            disabled: o,
            pageItemStyle: a,
            activePageItemStyle: s,
            size: l,
          } = tt(e),
          { mergedSize: c } = Vr(l),
          d = J(e.defaultCurrent),
          h = J(e.defaultPageSize),
          p = C(() => {
            var P
            return (P = e.current) != null ? P : d.value
          }),
          v = C(() => {
            var P
            return (P = e.pageSize) != null ? P : h.value
          }),
          g = C(() => Math.ceil(e.total / v.value)),
          _ = (P) => {
            P !== p.value &&
              it(P) &&
              !e.disabled &&
              ((d.value = P), t('update:current', P), t('change', P))
          },
          b = (P) => {
            ;(h.value = P), t('update:pageSize', P), t('pageSizeChange', P)
          },
          y = Je({
            current: p,
            pages: g,
            disabled: o,
            style: a,
            activeStyle: s,
            onClick: _,
          }),
          M = (P, A = {}) =>
            P === 'more'
              ? m(YY, Fe(A, y), { default: n['page-item-ellipsis'] })
              : P === 'previous'
              ? m(GM, Fe({ type: 'previous' }, A, y), {
                  default: n['page-item-step'],
                })
              : P === 'next'
              ? m(GM, Fe({ type: 'next' }, A, y), {
                  default: n['page-item-step'],
                })
              : m(jY, Fe(A, y), { default: n['page-item'] }),
          x = C(() => {
            const P = []
            if (g.value < e.baseSize + e.bufferSize * 2)
              for (let A = 1; A <= g.value; A++)
                P.push(M('page', { key: A, pageNumber: A }))
            else {
              let A = 1,
                F = g.value,
                T = !1,
                k = !1
              p.value > 2 + e.bufferSize &&
                ((T = !0),
                (A = Math.min(
                  p.value - e.bufferSize,
                  g.value - 2 * e.bufferSize
                ))),
                p.value < g.value - (e.bufferSize + 1) &&
                  ((k = !0),
                  (F = Math.max(p.value + e.bufferSize, 2 * e.bufferSize + 1))),
                T &&
                  (P.push(M('page', { key: 1, pageNumber: 1 })),
                  P.push(
                    M('more', {
                      key: 'left-ellipsis-pager',
                      step: -(e.bufferSize * 2 + 1),
                    })
                  ))
              for (let R = A; R <= F; R++)
                P.push(M('page', { key: R, pageNumber: R }))
              k &&
                (P.push(
                  M('more', {
                    key: 'right-ellipsis-pager',
                    step: e.bufferSize * 2 + 1,
                  })
                ),
                P.push(M('page', { key: g.value, pageNumber: g.value })))
            }
            return P
          }),
          w = () =>
            e.simple
              ? m('span', { class: `${r}-simple` }, [
                  M('previous', { simple: !0 }),
                  m(
                    KM,
                    {
                      disabled: e.disabled,
                      current: p.value,
                      size: c.value,
                      pages: g.value,
                      simple: !0,
                      onChange: _,
                    },
                    null
                  ),
                  M('next', { simple: !0 }),
                ])
              : m('ul', { class: `${r}-list` }, [
                  M('previous', { simple: !0 }),
                  x.value,
                  e.showMore &&
                    M('more', { key: 'more', step: e.bufferSize * 2 + 1 }),
                  M('next', { simple: !0 }),
                ])
        pt(v, (P, A) => {
          if (e.autoAdjust && P !== A && p.value > 1) {
            const F = A * (p.value - 1) + 1,
              T = Math.ceil(F / P)
            T !== p.value &&
              ((d.value = T), t('update:current', T), t('change', T))
          }
        }),
          pt(g, (P, A) => {
            e.autoAdjust &&
              P !== A &&
              p.value > 1 &&
              p.value > P &&
              ((d.value = P), t('update:current', P), t('change', P))
          })
        const E = C(() => [
          r,
          `${r}-size-${c.value}`,
          { [`${r}-simple`]: e.simple, [`${r}-disabled`]: e.disabled },
        ])
        return () => {
          var P, A
          return e.hideOnSinglePage && g.value <= 1
            ? null
            : m('div', { class: E.value }, [
                e.showTotal &&
                  m('span', { class: `${r}-total` }, [
                    (A =
                      (P = n.total) == null
                        ? void 0
                        : P.call(n, { total: e.total })) != null
                      ? A
                      : i('pagination.total', e.total),
                  ]),
                w(),
                e.showPageSize &&
                  m(
                    tZ,
                    {
                      disabled: e.disabled,
                      sizeOptions: e.pageSizeOptions,
                      pageSize: v.value,
                      size: c.value,
                      onChange: b,
                      selectProps: e.pageSizeProps,
                    },
                    null
                  ),
                !e.simple &&
                  e.showJumper &&
                  m(
                    KM,
                    {
                      disabled: e.disabled,
                      current: p.value,
                      pages: g.value,
                      size: c.value,
                      onChange: _,
                    },
                    {
                      'jumper-prepend': n['jumper-prepend'],
                      'jumper-append': n['jumper-append'],
                    }
                  ),
              ])
        }
      },
    })
  const hS = Object.assign(py, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + py.name, py)
      },
    }),
    nZ = (e, { emit: t }) => {
      var n, r
      const i = J(
          Ht(e.paginationProps) &&
            (n = e.paginationProps.defaultCurrent) != null
            ? n
            : 1
        ),
        o = J(
          Ht(e.paginationProps) &&
            (r = e.paginationProps.defaultPageSize) != null
            ? r
            : 10
        ),
        a = C(() => {
          var d
          return Ht(e.paginationProps) &&
            (d = e.paginationProps.current) != null
            ? d
            : i.value
        }),
        s = C(() => {
          var d
          return Ht(e.paginationProps) &&
            (d = e.paginationProps.pageSize) != null
            ? d
            : o.value
        })
      return {
        current: a,
        pageSize: s,
        handlePageChange: (d) => {
          ;(i.value = d), t('pageChange', d)
        },
        handlePageSizeChange: (d) => {
          ;(o.value = d), t('pageSizeChange', d)
        },
      }
    }
  function qM(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var vy = ce({
      name: 'List',
      props: {
        data: { type: Array },
        size: { type: String, default: 'medium' },
        bordered: { type: Boolean, default: !0 },
        split: { type: Boolean, default: !0 },
        loading: { type: Boolean, default: !1 },
        hoverable: { type: Boolean, default: !1 },
        paginationProps: { type: Object },
        gridProps: { type: Object },
        maxHeight: { type: Number, default: 0 },
        bottomOffset: { type: Number, default: 0 },
        virtualListProps: { type: Object },
        scrollbar: { type: [Object, Boolean], default: !0 },
      },
      emits: {
        scroll: () => !0,
        reachBottom: () => !0,
        pageChange: (e) => !0,
        pageSizeChange: (e) => !0,
      },
      setup(e, { emit: t, slots: n }) {
        const { scrollbar: r } = tt(e),
          i = ye('list'),
          o = zt(di, void 0),
          { componentRef: a, elementRef: s } = Mu('containerRef'),
          l = C(() => e.virtualListProps),
          { displayScrollbar: c, scrollbarProps: d } = qv(r)
        let h = 0
        const p = (I) => {
          const { scrollTop: B, scrollHeight: V, offsetHeight: L } = I.target,
            W = Math.floor(V - (B + L))
          B > h && W <= e.bottomOffset && t('reachBottom'), t('scroll'), (h = B)
        }
        Wt(() => {
          if (s.value) {
            const { scrollTop: I, scrollHeight: B, offsetHeight: V } = s.value
            B <= I + V && t('reachBottom')
          }
        })
        const {
            current: v,
            pageSize: g,
            handlePageChange: _,
            handlePageSizeChange: b,
          } = nZ(e, { emit: t }),
          y = (I) => {
            if (!e.paginationProps) return I
            if (e.paginationProps && I.length > g.value) {
              const B = (v.value - 1) * g.value
              return I.slice(B, B + g.value)
            }
            return I
          },
          M = (I) => {
            let B
            if (!e.gridProps) return null
            const V = y(I)
            if (e.gridProps.span) {
              const L = [],
                W = 24 / e.gridProps.span
              for (let Y = 0; Y < V.length; Y += W) {
                let U
                const le = Y + W,
                  q = Math.floor(Y / W)
                L.push(
                  m(
                    td.Row,
                    { key: q, class: `${i}-row`, gutter: e.gridProps.gutter },
                    qM(
                      (U = V.slice(Y, le).map((oe, te) => {
                        var ue
                        return m(
                          td.Col,
                          {
                            key: `${q}-${te}`,
                            class: `${i}-col`,
                            span: (ue = e.gridProps) == null ? void 0 : ue.span,
                          },
                          {
                            default: () => {
                              var me
                              return [
                                An(oe)
                                  ? oe
                                  : (me = n.item) == null
                                  ? void 0
                                  : me.call(n, { item: oe, index: te }),
                              ]
                            },
                          }
                        )
                      }))
                    )
                      ? U
                      : { default: () => [U] }
                  )
                )
              }
              return L
            }
            return m(
              td.Row,
              { class: `${i}-row`, gutter: e.gridProps.gutter },
              qM(
                (B = V.map((L, W) =>
                  m(
                    td.Col,
                    Fe(
                      { key: W, class: `${i}-col` },
                      xr(e.gridProps, ['gutter'])
                    ),
                    {
                      default: () => {
                        var Y
                        return [
                          An(L)
                            ? L
                            : (Y = n.item) == null
                            ? void 0
                            : Y.call(n, { item: L, index: W }),
                        ]
                      },
                    }
                  )
                ))
              )
                ? B
                : { default: () => [B] }
            )
          },
          x = (I) =>
            y(I).map((V, L) => {
              var W
              return An(V)
                ? V
                : (W = n.item) == null
                ? void 0
                : W.call(n, { item: V, index: L })
            }),
          w = () => {
            const I = n.default ? ea(n.default()) : e.data
            return I && I.length > 0 ? (e.gridProps ? M(I) : x(I)) : j()
          },
          E = () => {
            if (!e.paginationProps) return null
            const I = xr(e.paginationProps, [
              'current',
              'pageSize',
              'defaultCurrent',
              'defaultPageSize',
            ])
            return m(
              hS,
              Fe({ class: `${i}-pagination` }, I, {
                current: v.value,
                pageSize: g.value,
                onChange: _,
                onPageSizeChange: b,
              }),
              null
            )
          },
          P = C(() => [
            i,
            `${i}-${e.size}`,
            {
              [`${i}-bordered`]: e.bordered,
              [`${i}-split`]: e.split,
              [`${i}-hover`]: e.hoverable,
            },
          ]),
          A = C(() => {
            if (e.maxHeight > 0)
              return { maxHeight: `${e.maxHeight}px`, overflowY: 'auto' }
          }),
          F = C(() => [`${i}-content`, { [`${i}-virtual`]: l.value }]),
          T = J(),
          k = () => {
            var I
            const B = y((I = e.data) != null ? I : [])
            return B.length
              ? m(
                  Qv,
                  Fe({ ref: T, class: F.value, data: B }, e.virtualListProps, {
                    onScroll: p,
                  }),
                  {
                    item: ({ item: V, index: L }) => {
                      var W
                      return (W = n.item) == null
                        ? void 0
                        : W.call(n, { item: V, index: L })
                    },
                  }
                )
              : j()
          },
          R = () =>
            n['scroll-loading']
              ? m('div', { class: [`${i}-item`, `${i}-scroll-loading`] }, [
                  n['scroll-loading'](),
                ])
              : null,
          j = () => {
            var I, B, V, L, W
            return n['scroll-loading']
              ? null
              : (W =
                  (L = (I = n.empty) == null ? void 0 : I.call(n)) != null
                    ? L
                    : (V = o == null ? void 0 : (B = o.slots).empty) == null
                    ? void 0
                    : V.call(B, { component: 'list' })) != null
              ? W
              : m(Ls, null, null)
          }
        return {
          virtualListRef: T,
          render: () => {
            const I = c.value ? ia : 'div'
            return m('div', { class: `${i}-wrapper` }, [
              m(
                Do,
                { class: `${i}-spin`, loading: e.loading },
                {
                  default: () => [
                    m(
                      I,
                      Fe({ ref: a, class: P.value, style: A.value }, d.value, {
                        onScroll: p,
                      }),
                      {
                        default: () => [
                          m('div', { class: `${i}-content-wrapper` }, [
                            n.header &&
                              m('div', { class: `${i}-header` }, [n.header()]),
                            l.value && !e.gridProps
                              ? m(yt, null, [k(), R()])
                              : m('div', { role: 'list', class: F.value }, [
                                  w(),
                                  R(),
                                ]),
                            n.footer &&
                              m('div', { class: `${i}-footer` }, [n.footer()]),
                          ]),
                        ],
                      }
                    ),
                    E(),
                  ],
                }
              ),
            ])
          },
        }
      },
      methods: {
        scrollIntoView(e) {
          this.virtualListRef && this.virtualListRef.scrollTo(e)
        },
      },
      render() {
        return this.render()
      },
    }),
    Ap = ce({
      name: 'ListItem',
      props: { actionLayout: { type: String, default: 'horizontal' } },
      setup(e, { slots: t }) {
        const n = ye('list-item'),
          r = () => {
            var i
            const o = (i = t.actions) == null ? void 0 : i.call(t)
            return !o || !o.length
              ? null
              : m('ul', { class: `${n}-action` }, [
                  o.map((a, s) => m('li', { key: `${n}-action-${s}` }, [a])),
                ])
          }
        return () => {
          var i, o
          return m('div', { role: 'listitem', class: n }, [
            m('div', { class: `${n}-main` }, [
              (i = t.meta) == null ? void 0 : i.call(t),
              m('div', { class: `${n}-content` }, [
                (o = t.default) == null ? void 0 : o.call(t),
              ]),
              e.actionLayout === 'vertical' && r(),
            ]),
            e.actionLayout === 'horizontal' && r(),
            t.extra && m('div', { class: `${n}-extra` }, [t.extra()]),
          ])
        }
      },
    })
  const rZ = ce({
    name: 'ListItemMeta',
    props: { title: String, description: String },
    setup(e, { slots: t }) {
      const n = ye('list-item-meta'),
        r = !!(e.title || e.description || t.title || t.description)
      return { prefixCls: n, hasContent: r }
    },
  })
  function iZ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          e.$slots.avatar
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-avatar`) },
                [ve(e.$slots, 'avatar')],
                2
              ))
            : Ce('v-if', !0),
          e.hasContent
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-content`) },
                [
                  e.$slots.title || e.title
                    ? (O(),
                      Z(
                        'div',
                        { key: 0, class: H(`${e.prefixCls}-title`) },
                        [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                        2
                      ))
                    : Ce('v-if', !0),
                  e.$slots.description || e.description
                    ? (O(),
                      Z(
                        'div',
                        { key: 1, class: H(`${e.prefixCls}-description`) },
                        [
                          ve(e.$slots, 'description', {}, () => [
                            Lt(mt(e.description), 1),
                          ]),
                        ],
                        2
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var $p = Te(rZ, [['render', iZ]])
  const vA = Object.assign(vy, {
      Item: Object.assign(Ap, { Meta: $p }),
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + vy.name, vy),
          e.component(n + Ap.name, Ap),
          e.component(n + $p.name, $p)
      },
    }),
    oZ = [
      'border-width',
      'box-sizing',
      'font-family',
      'font-weight',
      'font-size',
      'font-variant',
      'letter-spacing',
      'line-height',
      'padding-top',
      'padding-bottom',
      'padding-left',
      'padding-right',
      'text-indent',
      'text-rendering',
      'text-transform',
      'white-space',
      'overflow-wrap',
      'width',
    ],
    $b = (e) => {
      const t = {}
      return (
        oZ.forEach((n) => {
          t[n] = e.getPropertyValue(n)
        }),
        t
      )
    },
    aZ = ce({
      name: 'Textarea',
      components: { ResizeObserver: Ro, IconHover: In, IconClose: zr },
      inheritAttrs: !1,
      props: {
        modelValue: String,
        defaultValue: { type: String, default: '' },
        placeholder: String,
        disabled: { type: Boolean, default: !1 },
        error: { type: Boolean, default: !1 },
        maxLength: { type: [Number, Object], default: 0 },
        showWordLimit: { type: Boolean, default: !1 },
        allowClear: { type: Boolean, default: !1 },
        autoSize: { type: [Boolean, Object], default: !1 },
        wordLength: { type: Function },
        wordSlice: { type: Function },
      },
      emits: {
        'update:modelValue': (e) => !0,
        input: (e, t) => !0,
        change: (e, t) => !0,
        clear: (e) => !0,
        focus: (e) => !0,
        blur: (e) => !0,
      },
      setup(e, { emit: t, attrs: n }) {
        const { disabled: r, error: i, modelValue: o } = tt(e),
          a = ye('textarea'),
          {
            mergedDisabled: s,
            mergedError: l,
            eventHandlers: c,
          } = Rn({ disabled: r, error: i }),
          d = J(),
          h = J(),
          p = J(),
          v = J(),
          g = J(e.defaultValue),
          _ = C(() => {
            var G
            return (G = o.value) != null ? G : g.value
          }),
          [b, y] = z4(d)
        pt(o, (G) => {
          ;(Mt(G) || fi(G)) && (g.value = '')
        })
        const M = C(() => Ht(e.maxLength) && !!e.maxLength.errorOnly),
          x = C(() => (Ht(e.maxLength) ? e.maxLength.length : e.maxLength)),
          w = (G) => {
            var z
            return xt(e.wordLength)
              ? e.wordLength(G)
              : (z = G.length) != null
              ? z
              : 0
          },
          E = C(() => w(_.value)),
          P = C(() => l.value || !!(x.value && M.value && E.value > x.value)),
          A = J(!1),
          F = J(!1),
          T = C(() => e.allowClear && !s.value && _.value),
          k = J(!1),
          R = J(''),
          j = () => {
            b(),
              hn(() => {
                d.value &&
                  _.value !== d.value.value &&
                  ((d.value.value = _.value), y())
              })
          },
          N = (G, z = !0) => {
            var ie, ae
            x.value &&
              !M.value &&
              w(G) > x.value &&
              (G =
                (ae =
                  (ie = e.wordSlice) == null
                    ? void 0
                    : ie.call(e, G, x.value)) != null
                  ? ae
                  : G.slice(0, x.value)),
              (g.value = G),
              z && t('update:modelValue', G),
              j()
          }
        let I = _.value
        const B = (G, z) => {
            var ie, ae
            G !== I &&
              ((I = G),
              t('change', G, z),
              (ae = (ie = c.value) == null ? void 0 : ie.onChange) == null ||
                ae.call(ie, z))
          },
          V = (G) => {
            var z, ie
            ;(F.value = !0),
              (I = _.value),
              t('focus', G),
              (ie = (z = c.value) == null ? void 0 : z.onFocus) == null ||
                ie.call(z, G)
          },
          L = (G) => {
            var z, ie
            ;(F.value = !1),
              t('blur', G),
              (ie = (z = c.value) == null ? void 0 : z.onBlur) == null ||
                ie.call(z, G),
              B(_.value, G)
          },
          W = (G) => {
            var z, ie
            const { value: ae } = G.target
            if (G.type === 'compositionend') {
              if (
                ((k.value = !1),
                (R.value = ''),
                x.value &&
                  !M.value &&
                  _.value.length >= x.value &&
                  w(ae) > x.value)
              ) {
                j()
                return
              }
              t('input', ae, G),
                N(ae),
                (ie = (z = c.value) == null ? void 0 : z.onInput) == null ||
                  ie.call(z, G)
            } else k.value = !0
          },
          Y = (G) => {
            var z, ie
            const { value: ae } = G.target
            if (k.value) R.value = ae
            else {
              if (
                x.value &&
                !M.value &&
                _.value.length >= x.value &&
                w(ae) > x.value &&
                G.inputType === 'insertText'
              ) {
                j()
                return
              }
              t('input', ae, G),
                N(ae),
                (ie = (z = c.value) == null ? void 0 : z.onInput) == null ||
                  ie.call(z, G)
            }
          },
          U = (G) => {
            N(''), B('', G), t('clear', G)
          }
        pt(o, (G) => {
          G !== _.value && N(G ?? '', !1)
        })
        const le = (G) => xr(n, Ts),
          q = (G) => ra(n, Ts),
          oe = C(() => [
            `${a}-wrapper`,
            {
              [`${a}-focus`]: F.value,
              [`${a}-disabled`]: s.value,
              [`${a}-error`]: P.value,
              [`${a}-scroll`]: A.value,
            },
          ])
        let te
        const ue = J(0),
          me = J(0),
          Re = C(() =>
            !Ht(e.autoSize) || !e.autoSize.minRows
              ? 0
              : e.autoSize.minRows * ue.value + me.value
          ),
          qe = C(() =>
            !Ht(e.autoSize) || !e.autoSize.maxRows
              ? 0
              : e.autoSize.maxRows * ue.value + me.value
          ),
          Ve = () => {
            const G = $b(te)
            ;(ue.value = Number.parseInt(G['line-height'] || 0, 10)),
              (me.value =
                Number.parseInt(G['border-width'] || 0, 10) * 2 +
                Number.parseInt(G['padding-top'] || 0, 10) +
                Number.parseInt(G['padding-bottom'] || 0, 10)),
              (v.value = G),
              hn(() => {
                var z
                const ie = (z = p.value) == null ? void 0 : z.offsetHeight
                let ae = ie ?? 0,
                  re = 'hidden'
                Re.value && ae < Re.value && (ae = Re.value),
                  qe.value && ae > qe.value && ((ae = qe.value), (re = 'auto')),
                  (h.value = {
                    height: `${ae}px`,
                    resize: 'none',
                    overflow: re,
                  })
              })
          }
        Wt(() => {
          d.value &&
            ((te = window.getComputedStyle(d.value)), e.autoSize && Ve()),
            D()
        })
        const nt = () => {
            e.autoSize && p.value && Ve(), D()
          },
          We = (G) => {
            d.value &&
              G.target !== d.value &&
              (G.preventDefault(), d.value.focus())
          },
          D = () => {
            d.value &&
              (d.value.scrollHeight > d.value.offsetHeight
                ? A.value || (A.value = !0)
                : A.value && (A.value = !1))
          }
        return (
          pt(_, () => {
            e.autoSize && p.value && Ve(), D()
          }),
          {
            prefixCls: a,
            wrapperCls: oe,
            textareaRef: d,
            textareaStyle: h,
            mirrorRef: p,
            mirrorStyle: v,
            computedValue: _,
            showClearBtn: T,
            valueLength: E,
            computedMaxLength: x,
            mergedDisabled: s,
            getWrapperAttrs: le,
            getTextareaAttrs: q,
            handleInput: Y,
            handleFocus: V,
            handleBlur: L,
            handleComposition: W,
            handleClear: U,
            handleResize: nt,
            handleMousedown: We,
          }
        )
      },
      methods: {
        focus() {
          var e
          ;(e = this.$refs.textareaRef) == null || e.focus()
        },
        blur() {
          var e
          ;(e = this.$refs.textareaRef) == null || e.blur()
        },
      },
    }),
    sZ = ['disabled', 'value', 'placeholder']
  function lZ(e, t, n, r, i, o) {
    const a = ge('resize-observer'),
      s = ge('icon-close'),
      l = ge('icon-hover')
    return (
      O(),
      Z(
        'div',
        Fe(e.getWrapperAttrs(e.$attrs), {
          class: e.wrapperCls,
          onMousedown:
            t[7] ||
            (t[7] = (...c) => e.handleMousedown && e.handleMousedown(...c)),
        }),
        [
          e.autoSize
            ? (O(),
              Z(
                'div',
                {
                  key: 0,
                  ref: 'mirrorRef',
                  class: H(`${e.prefixCls}-mirror`),
                  style: at(e.mirrorStyle),
                },
                mt(`${e.computedValue}
`),
                7
              ))
            : Ce('v-if', !0),
          m(
            a,
            { onResize: e.handleResize },
            {
              default: ze(() => [
                Se(
                  'textarea',
                  Fe({ ref: 'textareaRef' }, e.getTextareaAttrs(e.$attrs), {
                    disabled: e.mergedDisabled,
                    class: e.prefixCls,
                    style: e.textareaStyle,
                    value: e.computedValue,
                    placeholder: e.placeholder,
                    onInput:
                      t[0] ||
                      (t[0] = (...c) => e.handleInput && e.handleInput(...c)),
                    onFocus:
                      t[1] ||
                      (t[1] = (...c) => e.handleFocus && e.handleFocus(...c)),
                    onBlur:
                      t[2] ||
                      (t[2] = (...c) => e.handleBlur && e.handleBlur(...c)),
                    onCompositionstart:
                      t[3] ||
                      (t[3] = (...c) =>
                        e.handleComposition && e.handleComposition(...c)),
                    onCompositionupdate:
                      t[4] ||
                      (t[4] = (...c) =>
                        e.handleComposition && e.handleComposition(...c)),
                    onCompositionend:
                      t[5] ||
                      (t[5] = (...c) =>
                        e.handleComposition && e.handleComposition(...c)),
                  }),
                  null,
                  16,
                  sZ
                ),
              ]),
              _: 1,
            },
            8,
            ['onResize']
          ),
          ve(e.$slots, 'suffix'),
          e.computedMaxLength && e.showWordLimit
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-word-limit`) },
                mt(e.valueLength) + '/' + mt(e.computedMaxLength),
                3
              ))
            : Ce('v-if', !0),
          e.showClearBtn
            ? (O(),
              Z(
                'div',
                {
                  key: 2,
                  class: H(`${e.prefixCls}-clear-btn`),
                  onClick:
                    t[6] ||
                    (t[6] = (...c) => e.handleClear && e.handleClear(...c)),
                },
                [m(l, null, { default: ze(() => [m(s)]), _: 1 })],
                2
              ))
            : Ce('v-if', !0),
        ],
        16
      )
    )
  }
  var my = Te(aZ, [['render', lZ]])
  const mA = Object.assign(my, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + my.name, my)
      },
    }),
    uZ = (e) => {
      const { value: t, selectionStart: n } = e
      return t.slice(0, n)
    },
    cZ = (e, t) =>
      [].concat(t).reduce(
        (r, i) => {
          const o = e.lastIndexOf(i)
          return o > r.location ? { location: o, prefix: i } : r
        },
        { location: -1, prefix: '' }
      ),
    dZ = (e, t) => !t || !e.includes(t)
  var fZ = Object.defineProperty,
    XM = Object.getOwnPropertySymbols,
    hZ = Object.prototype.hasOwnProperty,
    pZ = Object.prototype.propertyIsEnumerable,
    YM = (e, t, n) =>
      t in e
        ? fZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    vZ = (e, t) => {
      for (var n in t || (t = {})) hZ.call(t, n) && YM(e, n, t[n])
      if (XM) for (var n of XM(t)) pZ.call(t, n) && YM(e, n, t[n])
      return e
    }
  function mZ(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var gy = ce({
    name: 'Mention',
    inheritAttrs: !1,
    props: {
      modelValue: String,
      defaultValue: { type: String, default: '' },
      data: { type: Array, default: () => [] },
      prefix: { type: [String, Array], default: '@' },
      split: { type: String, default: ' ' },
      type: { type: String, default: 'input' },
      disabled: { type: Boolean, default: !1 },
      allowClear: { type: Boolean, default: !1 },
    },
    emits: {
      'update:modelValue': (e) => !0,
      change: (e) => !0,
      search: (e, t) => !0,
      select: (e) => !0,
      clear: (e) => !0,
      focus: (e) => !0,
      blur: (e) => !0,
    },
    setup(e, { emit: t, attrs: n, slots: r }) {
      const i = ye('mention')
      let o
      const { mergedDisabled: a, eventHandlers: s } = Rn({
          disabled: Vi(e, 'disabled'),
        }),
        { data: l, modelValue: c } = tt(e),
        d = J(),
        h = J({}),
        p = J(e.defaultValue),
        v = C(() => {
          var oe
          return (oe = e.modelValue) != null ? oe : p.value
        })
      pt(c, (oe) => {
        ;(Mt(oe) || fi(oe)) && (p.value = '')
      })
      const g = C(() => (v.value ? [Ml(v.value)] : [])),
        _ = J({ measuring: !1, location: -1, prefix: '', text: '' }),
        b = () => {
          _.value = { measuring: !1, location: -1, prefix: '', text: '' }
        },
        y = J(),
        M = C(() => _.value.text),
        x = J(!0),
        w = (oe, te) => {
          var ue, me
          const Re = uZ(te.target),
            qe = cZ(Re, e.prefix)
          if (qe.location > -1) {
            const Ve = Re.slice(qe.location + qe.prefix.length)
            dZ(Ve, e.split)
              ? ((P.value = !0),
                (_.value = vZ({ measuring: !0, text: Ve }, qe)),
                t('search', Ve, qe.prefix))
              : _.value.location > -1 && b()
          } else _.value.location > -1 && b()
          ;(p.value = oe),
            t('update:modelValue', oe),
            t('change', oe),
            (me = (ue = s.value) == null ? void 0 : ue.onChange) == null ||
              me.call(ue)
        },
        E = (oe) => {
          var te, ue
          ;(p.value = ''),
            t('update:modelValue', ''),
            t('change', ''),
            (ue = (te = s.value) == null ? void 0 : te.onChange) == null ||
              ue.call(te),
            t('clear', oe)
        },
        P = J(!1),
        A = C(() => P.value && _.value.measuring && N.value.length > 0),
        F = () => {
          B.value = $b(o)
        },
        T = (oe) => {
          P.value = oe
        },
        k = (oe, te) => {
          var ue, me, Re
          const { value: qe } = (ue = j.get(oe)) != null ? ue : {},
            Ve = _.value.location,
            nt = _.value.location + _.value.text.length
          let We = p.value.slice(0, Ve),
            D = p.value.slice(nt + 1)
          ;(We +=
            !We ||
            We.endsWith(e.split) ||
            We.endsWith(`
`)
              ? ''
              : e.split),
            (D =
              (!D ||
              D.startsWith(e.split) ||
              D.startsWith(`
`)
                ? ''
                : e.split) + D)
          const G = `${_.value.prefix}${qe}`,
            z = `${We}${G}${D}`
          ;(p.value = z),
            t('select', qe),
            t('update:modelValue', z),
            t('change', z),
            b(),
            (Re = (me = s.value) == null ? void 0 : me.onChange) == null ||
              Re.call(me)
        },
        {
          validOptions: R,
          optionInfoMap: j,
          validOptionInfos: N,
          handleKeyDown: I,
        } = V_({
          options: l,
          inputValue: M,
          filterOption: x,
          popupVisible: A,
          valueKeys: g,
          dropdownRef: d,
          optionRefs: h,
          onSelect: k,
          onPopupVisibleChange: T,
          enterToOpen: !1,
        }),
        B = J()
      Wt(() => {
        var oe
        e.type === 'textarea' &&
          (oe = y.value) != null &&
          oe.textareaRef &&
          ((o = window.getComputedStyle(y.value.textareaRef)),
          (B.value = $b(o)))
      })
      const V = (oe) => {
          if (xt(r.option) && oe.value) {
            const te = j.get(oe.key),
              ue = r.option
            return () => ue({ data: te })
          }
          return () => oe.label
        },
        L = (oe) =>
          m(
            pl,
            {
              ref: (te) => {
                te != null && te.$el && (h.value[oe.key] = te.$el)
              },
              key: oe.key,
              value: oe.value,
              disabled: oe.disabled,
              internal: !0,
            },
            { default: V(oe) }
          ),
        W = () => {
          let oe
          return m(
            F_,
            { ref: d },
            mZ((oe = R.value.map((te) => L(te)))) ? oe : { default: () => [oe] }
          )
        },
        Y = J()
      pt(A, (oe) => {
        e.type === 'textarea' &&
          oe &&
          hn(() => {
            var te, ue
            ;(te = y.value) != null &&
              te.textareaRef &&
              y.value.textareaRef.scrollTop > 0 &&
              ((ue = Y.value) == null ||
                ue.scrollTo(0, y.value.textareaRef.scrollTop))
          })
      })
      const U = (oe) => {
          t('focus', oe)
        },
        le = (oe) => {
          t('blur', oe)
        }
      return {
        inputRef: y,
        render: () => {
          var oe
          return e.type === 'textarea'
            ? m('div', { class: i }, [
                m(
                  Ro,
                  { onResize: F },
                  {
                    default: () => [
                      m(
                        mA,
                        Fe(n, {
                          ref: y,
                          allowClear: e.allowClear,
                          modelValue: v.value,
                          onInput: w,
                          onClear: E,
                          onFocus: U,
                          onBlur: le,
                          onKeydown: I,
                        }),
                        null
                      ),
                    ],
                  }
                ),
                _.value.measuring &&
                  N.value.length > 0 &&
                  m('div', { ref: Y, style: B.value, class: `${i}-measure` }, [
                    (oe = v.value) == null
                      ? void 0
                      : oe.slice(0, _.value.location),
                    m(
                      Mr,
                      {
                        trigger: 'focus',
                        position: 'bl',
                        popupOffset: 4,
                        preventFocus: !0,
                        popupVisible: A.value,
                        clickToClose: !1,
                        onPopupVisibleChange: T,
                      },
                      {
                        default: () => [m('span', null, [Lt('@')])],
                        content: W,
                      }
                    ),
                  ]),
              ])
            : m(
                Mr,
                {
                  trigger: 'focus',
                  position: 'bl',
                  animationName: 'slide-dynamic-origin',
                  popupOffset: 4,
                  preventFocus: !0,
                  popupVisible: A.value,
                  clickToClose: !1,
                  autoFitPopupWidth: !0,
                  autoFitTransformOrigin: !0,
                  disabled: a.value,
                  onPopupVisibleChange: T,
                },
                {
                  default: () => [
                    m(
                      ic,
                      Fe(n, {
                        ref: y,
                        allowClear: e.allowClear,
                        modelValue: v.value,
                        disabled: a.value,
                        onInput: w,
                        onClear: E,
                        onFocus: U,
                        onBlur: le,
                        onKeydown: I,
                      }),
                      r
                    ),
                  ],
                  content: W,
                }
              )
        },
      }
    },
    methods: {
      focus() {
        var e
        ;(e = this.inputRef) == null || e.focus()
      },
      blur() {
        var e
        ;(e = this.inputRef) == null || e.blur()
      },
    },
    render() {
      return this.render()
    },
  })
  const gZ = Object.assign(gy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + gy.name, gy)
      },
    }),
    pS = Symbol('MenuInjectionKey'),
    vS = Symbol('LevelInjectionKey'),
    gA = Symbol('DataCollectorInjectionKey'),
    yZ = ce({
      name: 'IconMenuFold',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-menu-fold`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    bZ = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    _Z = Se(
      'path',
      {
        d: 'M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z',
      },
      null,
      -1
    ),
    SZ = [_Z]
  function CZ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        SZ,
        14,
        bZ
      )
    )
  }
  var yy = Te(yZ, [['render', CZ]])
  const wZ = Object.assign(yy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + yy.name, yy)
      },
    }),
    xZ = ce({
      name: 'IconMenuUnfold',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-menu-unfold`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    MZ = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    EZ = Se(
      'path',
      { d: 'M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z' },
      null,
      -1
    ),
    PZ = [EZ]
  function TZ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        PZ,
        14,
        MZ
      )
    )
  }
  var by = Te(xZ, [['render', TZ]])
  const kZ = Object.assign(by, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + by.name, by)
    },
  })
  function mS(e) {
    const t = C(() => (lr(e) ? e.value : e))
    sn(vS, Je({ level: t }))
  }
  function tf(e) {
    const { provideNextLevel: t } = e || {},
      n = zt(vS),
      r = C(() => (n == null ? void 0 : n.level) || 1)
    if (t) {
      const i = C(() => r.value + 1)
      mS(i)
    }
    return { level: r }
  }
  function ZM(e, t) {
    const n = [],
      r = (i) => {
        i.forEach((o) => {
          t(o) && n.push(o.key), o.children && r(o.children)
        })
      }
    return r(e), n
  }
  function yA(e = !1) {
    return e ? void 0 : zt(gA)
  }
  function bA(e) {
    const { key: t, type: n } = e,
      r = J([]),
      i = yA(n === 'menu')
    return (
      sn(gA, {
        collectSubMenu(a, s, l = !1) {
          const c = { key: a, children: s }
          if (l) {
            const d = r.value.find((h) => h.key === a)
            d ? (d.children = s) : r.value.push(c)
          } else r.value = [...r.value, c]
          l &&
            (n === 'popupMenu'
              ? i == null || i.reportMenuData(r.value)
              : n === 'subMenu' &&
                !Mt(a) &&
                (i == null || i.collectSubMenu(a, r.value, !0)))
        },
        removeSubMenu(a) {
          r.value = r.value.filter((s) => s.key !== a)
        },
        collectMenuItem(a) {
          r.value.push({ key: a })
        },
        removeMenuItem(a) {
          r.value = r.value.filter((s) => s.key !== a)
        },
        reportMenuData(a) {
          ;(r.value = a),
            n === 'subMenu' &&
              !Mt(t) &&
              (i == null || i.collectSubMenu(t, r.value, !0))
        },
      }),
      n === 'subMenu' && !Mt(t)
        ? (Wt(() => {
            i == null || i.collectSubMenu(t, r.value)
          }),
          wr(() => {
            i == null || i.removeSubMenu(t)
          }))
        : n === 'popupMenu' &&
          Wt(() => {
            i == null || i.reportMenuData(r.value)
          }),
      {
        menuData: r,
        subMenuKeys: C(() => ZM(r.value, (a) => !!a.children)),
        menuItemKeys: C(() => ZM(r.value, (a) => !a.children)),
      }
    )
  }
  function AZ(e, t) {
    const n = [],
      r = (i) => {
        for (let o = 0; o < i.length; o++) {
          const a = i[o]
          if (a.key === t) return !0
          if (a.children) {
            if ((n.push(a.key), r(a.children))) return !0
            n.pop()
          }
        }
        return !1
      }
    return r(e), n
  }
  function $Z(e, t) {
    return e.length !== t.length ? !1 : e.toString() === t.toString()
  }
  function OZ(e) {
    const {
        modelValue: t,
        defaultValue: n,
        autoOpen: r,
        autoOpenSelected: i,
        subMenuKeys: o,
        selectedKeys: a,
        menuData: s,
        accordion: l,
      } = tt(e),
      c = J(Mt(t.value) ? (Mt(n.value) ? [] : n.value) : t.value),
      d = (g) => {
        c.value = g
      }
    pt(t, () => {
      Mt(t.value) && d([])
    })
    let h = []
    Wt(() => {
      h = [...o.value]
      let g = []
      if (
        (r.value && (g = l.value ? o.value.slice(0, 1) : [...o.value]), i.value)
      ) {
        const _ = a.value.map((b) => AZ(s.value, b))
        _.length &&
          (!r.value || l.value) &&
          (g = l.value ? _[0] : [...new Set([].concat(..._))])
      }
      g.length && d(g)
    })
    let p = !1
    pt(o, (g, _ = []) => {
      if (p || !$Z(g, h)) {
        const b = v.value.filter((y) => g.includes(y))
        if (r.value) {
          const y = g.filter((M) => !_.includes(M))
          b.push(...y)
        }
        d(l.value ? b.slice(0, 1) : b)
      }
      p = !0
    })
    const v = C(() => t.value || c.value)
    return {
      openKeys: v,
      localOpenKeys: c,
      setOpenKeys: d,
      open(g, _) {
        let b = []
        return (
          v.value.indexOf(g) > -1
            ? l.value && _ === 1
              ? (b = [])
              : (b = v.value.filter((y) => y !== g))
            : l.value && _ === 1
            ? (b = [g])
            : (b = v.value.concat([g])),
          d(b),
          b
        )
      },
    }
  }
  const LZ = ce({
    name: 'BaseMenu',
    components: { IconMenuFold: wZ, IconMenuUnfold: kZ },
    inheritAttrs: !1,
    props: {
      style: { type: Object },
      theme: { type: String, default: 'light' },
      mode: { type: String, default: 'vertical' },
      levelIndent: { type: Number },
      autoOpen: { type: Boolean },
      collapsed: { type: Boolean, default: void 0 },
      defaultCollapsed: { type: Boolean },
      collapsedWidth: { type: Number },
      accordion: { type: Boolean },
      autoScrollIntoView: { type: Boolean },
      showCollapseButton: { type: Boolean },
      selectedKeys: { type: Array },
      defaultSelectedKeys: { type: Array, default: () => [] },
      openKeys: { type: Array },
      defaultOpenKeys: { type: Array, default: () => [] },
      scrollConfig: { type: Object },
      triggerProps: { type: Object },
      tooltipProps: { type: Object },
      autoOpenSelected: { type: Boolean },
      breakpoint: { type: String },
      popupMaxHeight: { type: [Boolean, Number], default: !0 },
      prefixCls: { type: String },
      inTrigger: { type: Boolean },
      siderCollapsed: { type: Boolean },
      isRoot: { type: Boolean },
    },
    emits: [
      'update:collapsed',
      'update:selectedKeys',
      'update:openKeys',
      'collapse',
      'menu-item-click',
      'sub-menu-click',
    ],
    setup(e, { emit: t, slots: n }) {
      const {
          style: r,
          mode: i,
          theme: o,
          levelIndent: a,
          accordion: s,
          showCollapseButton: l,
          scrollConfig: c,
          autoScrollIntoView: d,
          collapsedWidth: h,
          autoOpen: p,
          collapsed: v,
          defaultCollapsed: g,
          selectedKeys: _,
          defaultSelectedKeys: b,
          openKeys: y,
          defaultOpenKeys: M,
          triggerProps: x,
          tooltipProps: w,
          autoOpenSelected: E,
          breakpoint: P,
          popupMaxHeight: A,
          prefixCls: F,
          inTrigger: T,
          siderCollapsed: k,
          isRoot: R,
        } = tt(e),
        { subMenuKeys: j, menuData: N } = bA({
          type: R.value ? 'menu' : 'popupMenu',
        }),
        [I, B] = Er(b.value, Je({ value: _ })),
        {
          openKeys: V,
          setOpenKeys: L,
          open: W,
        } = OZ(
          Je({
            modelValue: y,
            defaultValue: M,
            autoOpen: p,
            autoOpenSelected: E,
            selectedKeys: I,
            subMenuKeys: j,
            menuData: N,
            accordion: s,
          })
        ),
        [Y, U] = Er(g.value, Je({ value: v })),
        le = C(() => k.value || Y.value || i.value === 'popButton'),
        q = C(
          () =>
            ['horizontal', 'popButton'].indexOf(i.value) < 0 &&
            !T.value &&
            l.value
        ),
        oe = (We, D) => {
          We !== Y.value &&
            (U(We), t('update:collapsed', We), t('collapse', We, D))
        },
        te = () => {
          oe(!Y.value, 'clickTrigger')
        }
      hA(P, (We) => {
        oe(!We, 'responsive')
      })
      const ue = C(() => (F == null ? void 0 : F.value) || ye('menu')),
        me = C(() => [
          ue.value,
          `${ue.value}-${o == null ? void 0 : o.value}`,
          {
            [`${ue.value}-horizontal`]: i.value === 'horizontal',
            [`${ue.value}-vertical`]: i.value !== 'horizontal',
            [`${ue.value}-collapsed`]: le.value,
            [`${ue.value}-pop`]: i.value === 'pop' || le.value,
            [`${ue.value}-pop-button`]: i.value === 'popButton',
          },
        ]),
        Re = C(() => {
          const We = it(h.value) ? `${h.value}px` : void 0,
            D = Ht(r.value) ? r.value : void 0,
            G = le.value ? We : D == null ? void 0 : D.width
          return [D ? xr(D, ['width']) : r.value, { width: G }]
        }),
        qe = Mo(n, 'expand-icon-down'),
        Ve = Mo(n, 'expand-icon-right'),
        nt = Je({
          theme: o,
          mode: i,
          levelIndent: a,
          autoScrollIntoView: d,
          selectedKeys: I,
          openKeys: V,
          prefixCls: ue,
          scrollConfig: c,
          inTrigger: T,
          collapsed: le,
          triggerProps: x,
          tooltipProps: w,
          popupMaxHeight: A,
          expandIconDown: qe,
          expandIconRight: Ve,
          onMenuItemClick: (We) => {
            B([We]), t('update:selectedKeys', [We]), t('menu-item-click', We)
          },
          onSubMenuClick: (We, D) => {
            const G = W(We, D)
            L(G), t('update:openKeys', G), t('sub-menu-click', We, G)
          },
        })
      return (
        sn(pS, nt),
        mS(1),
        {
          computedPrefixCls: ue,
          classNames: me,
          computedStyle: Re,
          computedCollapsed: le,
          computedHasCollapseButton: q,
          onCollapseBtnClick: te,
        }
      )
    },
  })
  function IZ(e, t, n, r, i, o) {
    const a = ge('IconMenuUnfold'),
      s = ge('IconMenuFold')
    return (
      O(),
      Z(
        'div',
        Fe({ class: e.classNames }, e.$attrs, { style: e.computedStyle }),
        [
          Se(
            'div',
            { class: H(`${e.computedPrefixCls}-inner`) },
            [ve(e.$slots, 'default')],
            2
          ),
          e.computedHasCollapseButton
            ? (O(),
              Z(
                'div',
                {
                  key: 0,
                  class: H(`${e.computedPrefixCls}-collapse-button`),
                  onClick:
                    t[0] ||
                    (t[0] = (...l) =>
                      e.onCollapseBtnClick && e.onCollapseBtnClick(...l)),
                },
                [
                  ve(
                    e.$slots,
                    'collapse-icon',
                    { collapsed: e.computedCollapsed },
                    () => [
                      e.computedCollapsed
                        ? (O(), Ee(a, { key: 0 }))
                        : (O(), Ee(s, { key: 1 })),
                    ]
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        16
      )
    )
  }
  var Ob = Te(LZ, [['render', IZ]])
  function JM(e, t) {
    if (!e || !t) return null
    let n = t
    n === 'float' && (n = 'cssFloat')
    try {
      if (document.defaultView) {
        const r = document.defaultView.getComputedStyle(e, '')
        return e.style[n] || r ? r[n] : ''
      }
    } catch {
      return e.style[n]
    }
    return null
  }
  function Il() {
    return zt(pS) || {}
  }
  const RZ = (() => {
    let e = 0
    return (t = '') => ((e += 1), `${t}${e}`)
  })()
  function om() {
    const e = Jr()
    return {
      key: C(() => (e == null ? void 0 : e.vnode.key) || RZ('__arco_menu')),
    }
  }
  const DZ = ce({
    name: 'MenuIndent',
    props: { level: { type: Number, default: 1 } },
    setup() {
      const e = ye('menu'),
        t = Il()
      return { prefixCls: e, levelIndent: Vi(t, 'levelIndent') }
    },
  })
  function NZ(e, t, n, r, i, o) {
    return e.level > 1
      ? (O(),
        Z(
          'span',
          { key: 0, class: H(`${e.prefixCls}-indent-list`) },
          [
            (O(!0),
            Z(
              yt,
              null,
              Yn(
                e.level - 1,
                (a) => (
                  O(),
                  Z(
                    'span',
                    {
                      key: a,
                      class: H(`${e.prefixCls}-indent`),
                      style: at(`width: ${e.levelIndent}px`),
                    },
                    null,
                    6
                  )
                )
              ),
              128
            )),
          ],
          2
        ))
      : Ce('v-if', !0)
  }
  var am = Te(DZ, [['render', NZ]])
  const BZ = ce({
    name: 'ExpandTransition',
    setup() {
      return {
        onBeforeEnter(e) {
          e.style.height = '0'
        },
        onEnter(e) {
          e.style.height = `${e.scrollHeight}px`
        },
        onAfterEnter(e) {
          e.style.height = ''
        },
        onBeforeLeave(e) {
          e.style.height = `${e.scrollHeight}px`
        },
        onLeave(e) {
          e.style.height = '0'
        },
        onAfterLeave(e) {
          e.style.height = ''
        },
      }
    },
  })
  function FZ(e, t, n, r, i, o) {
    return (
      O(),
      Ee(
        Fr,
        {
          onBeforeEnter: e.onBeforeEnter,
          onEnter: e.onEnter,
          onAfterEnter: e.onAfterEnter,
          onBeforeLeave: e.onBeforeLeave,
          onLeave: e.onLeave,
          onAfterLeave: e.onAfterLeave,
        },
        { default: ze(() => [ve(e.$slots, 'default')]), _: 3 },
        8,
        [
          'onBeforeEnter',
          'onEnter',
          'onAfterEnter',
          'onBeforeLeave',
          'onLeave',
          'onAfterLeave',
        ]
      )
    )
  }
  var zZ = Te(BZ, [['render', FZ]])
  const VZ = ce({
    name: 'SubMenuInline',
    components: { MenuIndent: am, ExpandTransition: zZ },
    props: { title: { type: String }, isChildrenSelected: { type: Boolean } },
    setup(e) {
      const { key: t } = om(),
        { level: n } = tf({ provideNextLevel: !0 }),
        r = Il(),
        i = C(() => r.prefixCls),
        o = C(() => `${i.value}-inline`),
        a = C(() => [o.value]),
        s = C(() => e.isChildrenSelected),
        l = C(() => (r.openKeys || []).indexOf(t.value) > -1)
      return {
        prefixCls: o,
        menuPrefixCls: i,
        classNames: a,
        level: n,
        isSelected: s,
        isOpen: l,
        onHeaderClick: () => {
          r.onSubMenuClick && r.onSubMenuClick(t.value, n.value)
        },
      }
    },
  })
  function UZ(e, t, n, r, i, o) {
    const a = ge('MenuIndent'),
      s = ge('ExpandTransition')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          Se(
            'div',
            {
              class: H([
                `${e.prefixCls}-header`,
                {
                  [`${e.menuPrefixCls}-selected`]: e.isSelected,
                  [`${e.menuPrefixCls}-has-icon`]: e.$slots.icon,
                },
              ]),
              onClick:
                t[0] ||
                (t[0] = (...l) => e.onHeaderClick && e.onHeaderClick(...l)),
            },
            [
              m(a, { level: e.level }, null, 8, ['level']),
              e.$slots.icon
                ? (O(),
                  Z(
                    yt,
                    { key: 0 },
                    [
                      Se(
                        'span',
                        { class: H(`${e.menuPrefixCls}-icon`) },
                        [ve(e.$slots, 'icon')],
                        2
                      ),
                      Se(
                        'span',
                        { class: H(`${e.menuPrefixCls}-title`) },
                        [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                        2
                      ),
                    ],
                    64
                  ))
                : ve(e.$slots, 'title', { key: 1 }, () => [Lt(mt(e.title), 1)]),
              Se(
                'span',
                {
                  class: H([
                    `${e.menuPrefixCls}-icon-suffix`,
                    { ['is-open']: e.isOpen },
                  ]),
                },
                [ve(e.$slots, 'expand-icon-down')],
                2
              ),
            ],
            2
          ),
          m(s, null, {
            default: ze(() => [
              ro(
                Se(
                  'div',
                  { class: H(`${e.prefixCls}-content`) },
                  [ve(e.$slots, 'default')],
                  2
                ),
                [[oo, e.isOpen]]
              ),
            ]),
            _: 3,
          }),
        ],
        2
      )
    )
  }
  var HZ = Te(VZ, [['render', UZ]])
  const WZ = ce({
    name: 'SubMenuPop',
    components: { Menu: Ob, Trigger: Mr, MenuIndent: am, RenderFunction: Ga },
    inheritAttrs: !1,
    props: {
      title: { type: String },
      selectable: { type: Boolean },
      isChildrenSelected: { type: Boolean },
      popupMaxHeight: { type: [Boolean, Number], default: void 0 },
    },
    setup(e) {
      const { key: t } = om(),
        { level: n } = tf(),
        { selectable: r, isChildrenSelected: i, popupMaxHeight: o } = tt(e),
        a = Il(),
        { onSubMenuClick: s, onMenuItemClick: l } = a,
        c = C(() => a.prefixCls),
        d = C(() => a.mode),
        h = C(() => a.selectedKeys || []),
        p = C(() => `${c.value}-pop`),
        v = C(() => (r.value && h.value.includes(t.value)) || i.value),
        g = C(() => [
          `${p.value}`,
          `${p.value}-header`,
          { [`${c.value}-selected`]: v.value },
        ]),
        _ = C(() => d.value === 'horizontal' && !a.inTrigger),
        b = J(!1),
        y = (E) => {
          b.value = E
        },
        M = ye('trigger'),
        x = C(() => {
          var E
          return [
            `${p.value}-trigger`,
            { [`${p.value}-trigger-dark`]: a.theme === 'dark' },
            (E = a.triggerProps) == null ? void 0 : E.class,
          ]
        }),
        w = C(() => xr(a.triggerProps || {}, ['class']))
      return {
        menuPrefixCls: c,
        mode: d,
        level: n,
        classNames: g,
        isSelected: v,
        selectedKeys: h,
        needPopOnBottom: _,
        popVisible: b,
        triggerPrefixCls: M,
        triggerClassNames: x,
        triggerProps: w,
        menuContext: a,
        popupMenuStyles: C(() => {
          var E
          const P = (E = o.value) != null ? E : a.popupMaxHeight
          return it(P)
            ? { maxHeight: `${P}px` }
            : P
            ? {}
            : { maxHeight: 'unset' }
        }),
        onClick: () => {
          s && s(t.value, n.value), r.value && l && l(t.value)
        },
        onMenuItemClick: (E) => {
          l && l(E), y(!1)
        },
        onVisibleChange: (E) => {
          y(E)
        },
      }
    },
  })
  function jZ(e, t, n, r, i, o) {
    const a = ge('MenuIndent'),
      s = ge('RenderFunction'),
      l = ge('Menu'),
      c = ge('Trigger')
    return (
      O(),
      Ee(
        c,
        Fe(
          {
            trigger: 'hover',
            class: e.triggerClassNames,
            position: e.needPopOnBottom ? 'bl' : 'rt',
            'show-arrow': '',
            'animation-class': 'fade-in',
            'mouse-enter-delay': 50,
            'mouse-leave-delay': 50,
            'popup-offset': 4,
            'auto-fit-popup-min-width': !0,
            duration: 100,
          },
          e.triggerProps,
          {
            'unmount-on-close': !1,
            'popup-visible': e.popVisible,
            onPopupVisibleChange: e.onVisibleChange,
          }
        ),
        {
          content: ze(() => [
            m(
              l,
              {
                'in-trigger': '',
                'prefix-cls': `${e.triggerPrefixCls}-menu`,
                'selected-keys': e.selectedKeys,
                theme: e.menuContext.theme,
                'trigger-props': e.menuContext.triggerProps,
                style: at(e.popupMenuStyles),
                onMenuItemClick: e.onMenuItemClick,
              },
              Nn({ default: ze(() => [ve(e.$slots, 'default')]), _: 2 }, [
                e.menuContext.expandIconDown
                  ? {
                      name: 'expand-icon-down',
                      fn: ze(() => [
                        m(
                          s,
                          { 'render-func': e.menuContext.expandIconDown },
                          null,
                          8,
                          ['render-func']
                        ),
                      ]),
                    }
                  : void 0,
                e.menuContext.expandIconRight
                  ? {
                      name: 'expand-icon-right',
                      fn: ze(() => [
                        m(
                          s,
                          { 'render-func': e.menuContext.expandIconRight },
                          null,
                          8,
                          ['render-func']
                        ),
                      ]),
                    }
                  : void 0,
              ]),
              1032,
              [
                'prefix-cls',
                'selected-keys',
                'theme',
                'trigger-props',
                'style',
                'onMenuItemClick',
              ]
            ),
          ]),
          default: ze(() => [
            Se(
              'div',
              Fe(
                {
                  class: [
                    e.classNames,
                    { [`${e.menuPrefixCls}-has-icon`]: e.$slots.icon },
                  ],
                  'aria-haspopup': 'true',
                },
                e.$attrs,
                {
                  onClick:
                    t[0] || (t[0] = (...d) => e.onClick && e.onClick(...d)),
                }
              ),
              [
                Ce(' header '),
                m(a, { level: e.level }, null, 8, ['level']),
                e.$slots.icon
                  ? (O(),
                    Z(
                      yt,
                      { key: 0 },
                      [
                        Se(
                          'span',
                          { class: H(`${e.menuPrefixCls}-icon`) },
                          [ve(e.$slots, 'icon')],
                          2
                        ),
                        Se(
                          'span',
                          { class: H(`${e.menuPrefixCls}-title`) },
                          [
                            ve(e.$slots, 'title', {}, () => [
                              Lt(mt(e.title), 1),
                            ]),
                          ],
                          2
                        ),
                      ],
                      64
                    ))
                  : ve(e.$slots, 'title', { key: 1 }, () => [
                      Lt(mt(e.title), 1),
                    ]),
                Ce(' suffix '),
                Se(
                  'span',
                  { class: H(`${e.menuPrefixCls}-icon-suffix`) },
                  [
                    e.needPopOnBottom
                      ? ve(e.$slots, 'expand-icon-down', { key: 0 })
                      : ve(e.$slots, 'expand-icon-right', { key: 1 }),
                  ],
                  2
                ),
                e.isSelected && e.mode === 'horizontal'
                  ? (O(),
                    Z(
                      'div',
                      { key: 2, class: H(`${e.menuPrefixCls}-selected-label`) },
                      null,
                      2
                    ))
                  : Ce('v-if', !0),
              ],
              16
            ),
          ]),
          _: 3,
        },
        16,
        ['class', 'position', 'popup-visible', 'onPopupVisibleChange']
      )
    )
  }
  var GZ = Te(WZ, [['render', jZ]]),
    KZ = Object.defineProperty,
    qZ = Object.defineProperties,
    XZ = Object.getOwnPropertyDescriptors,
    QM = Object.getOwnPropertySymbols,
    YZ = Object.prototype.hasOwnProperty,
    ZZ = Object.prototype.propertyIsEnumerable,
    eE = (e, t, n) =>
      t in e
        ? KZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    JZ = (e, t) => {
      for (var n in t || (t = {})) YZ.call(t, n) && eE(e, n, t[n])
      if (QM) for (var n of QM(t)) ZZ.call(t, n) && eE(e, n, t[n])
      return e
    },
    QZ = (e, t) => qZ(e, XZ(t)),
    pd = ce({
      name: 'SubMenu',
      props: {
        key: { type: String },
        title: { type: String },
        selectable: { type: Boolean },
        popup: { type: [Boolean, Function], default: !1 },
        popupMaxHeight: { type: [Boolean, Number], default: void 0 },
      },
      setup(e, { attrs: t }) {
        const { key: n } = om(),
          { level: r } = tf(),
          { popup: i } = tt(e),
          o = Il(),
          a = C(() => {
            const { mode: d, collapsed: h, inTrigger: p } = o
            return (
              !!(typeof i.value == 'function' ? i.value(r.value) : i.value) ||
              h ||
              p ||
              d !== 'vertical'
            )
          }),
          { subMenuKeys: s, menuItemKeys: l } = bA({
            key: n.value,
            type: 'subMenu',
          }),
          c = C(() => {
            const d = o.selectedKeys || [],
              h = (p) => {
                for (let v = 0; v < d.length; v++) {
                  const g = d[v]
                  if (p.includes(g)) return !0
                }
                return !1
              }
            return h(s.value) || h(l.value)
          })
        return {
          subMenuKeys: s,
          menuItemKeys: l,
          isChildrenSelected: c,
          props: e,
          attrs: t,
          computedKey: n,
          computedPopup: a,
          expandIconDown: Vi(o, 'expandIconDown'),
          expandIconRight: Vi(o, 'expandIconRight'),
        }
      },
      render() {
        const {
            props: e,
            attrs: t,
            computedKey: n,
            computedPopup: r,
            expandIconDown: i,
            expandIconRight: o,
            isChildrenSelected: a,
          } = this,
          s = QZ(JZ({}, this.$slots), {
            'expand-icon-down':
              this.$slots['expand-icon-down'] ||
              i ||
              (() => [m(sc, null, null)]),
            'expand-icon-right':
              this.$slots['expand-icon-right'] ||
              o ||
              (() => [m(No, null, null)]),
          })
        return r
          ? m(
              GZ,
              Fe(
                {
                  key: n,
                  title: e.title,
                  selectable: e.selectable,
                  isChildrenSelected: a,
                  popupMaxHeight: e.popupMaxHeight,
                },
                t
              ),
              s
            )
          : m(HZ, Fe({ key: n, title: e.title, isChildrenSelected: a }, t), s)
      },
    })
  const eJ = 10
  function tE(e) {
    return e && +e.getBoundingClientRect().width.toFixed(2)
  }
  function nE(e) {
    const t = Number(e.replace('px', ''))
    return Number.isNaN(t) ? 0 : t
  }
  var tJ = ce({
      name: 'MenuOverflowWrap',
      setup(e, { slots: t }) {
        const r = `${Il().prefixCls}-overflow`,
          i = `${r}-sub-menu`,
          o = `${r}-hidden-menu-item`,
          a = `${r}-sub-menu-mirror`,
          s = J(),
          l = J(null),
          c = J()
        function d() {
          const h = s.value,
            p = tE(h),
            v = [].slice.call(h.children)
          let g = 0,
            _ = 0,
            b = 0
          for (let y = 0; y < v.length; y++) {
            const M = v[y],
              x = M.className.split(' '),
              w = x.indexOf(i) > -1,
              E = x.indexOf(a) > -1
            if (w) continue
            const P = tE(M) + nE(JM(M, 'marginLeft')) + nE(JM(M, 'marginRight'))
            if (E) {
              b = P
              continue
            }
            if (((_ += P), _ + b + eJ > p)) {
              l.value = g - 1
              return
            }
            g++
          }
          l.value = null
        }
        return (
          Wt(() => {
            d(),
              (c.value = new Vv((h) => {
                h.forEach(d)
              })),
              s.value && c.value.observe(s.value)
          }),
          wr(() => {
            c.value && c.value.disconnect()
          }),
          () => {
            const h = (v, g) => {
                const { isMirror: _ = !1, props: b = {} } = g || {}
                return m(
                  pd,
                  Fe(
                    {
                      key: `__arco-menu-overflow-sub-menu${_ ? '-mirror' : ''}`,
                      class: _ ? a : i,
                    },
                    b
                  ),
                  {
                    title: () => m('span', null, [Lt('...')]),
                    default: () => v,
                  }
                )
              },
              p = () => {
                var v
                const g = ((v = t.default) == null ? void 0 : v.call(t)) || [],
                  _ = WB(g)
                let b = null
                const y = h(null, { isMirror: !0 }),
                  M = _.map((x, w) => {
                    const E = Ti(
                      x,
                      l.value !== null && w > l.value
                        ? { class: o }
                        : { class: '' }
                    )
                    if (l.value !== null && w === l.value + 1) {
                      const P = _.slice(w).map((A) => Ti(A))
                      b = h(P)
                    }
                    return E
                  })
                return [y, ...M, b]
              }
            return m('div', { class: `${r}-wrap`, ref: s }, [p()])
          }
        )
      },
    }),
    nJ = Object.defineProperty,
    rJ = Object.defineProperties,
    iJ = Object.getOwnPropertyDescriptors,
    rE = Object.getOwnPropertySymbols,
    oJ = Object.prototype.hasOwnProperty,
    aJ = Object.prototype.propertyIsEnumerable,
    iE = (e, t, n) =>
      t in e
        ? nJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    sJ = (e, t) => {
      for (var n in t || (t = {})) oJ.call(t, n) && iE(e, n, t[n])
      if (rE) for (var n of rE(t)) aJ.call(t, n) && iE(e, n, t[n])
      return e
    },
    lJ = (e, t) => rJ(e, iJ(t)),
    _y = ce({
      name: 'Menu',
      components: { BaseMenu: Ob },
      inheritAttrs: !1,
      props: {
        theme: { type: String },
        mode: { type: String, default: 'vertical' },
      },
      setup(e, { attrs: t, slots: n }) {
        const { theme: r, mode: i } = tt(e),
          o = zt(lA, void 0),
          a = C(() => (o == null ? void 0 : o.collapsed) || !1),
          s = C(
            () =>
              (r == null ? void 0 : r.value) ||
              (o == null ? void 0 : o.theme) ||
              'light'
          )
        return (
          sn(pS, void 0),
          sn(vS, void 0),
          () =>
            m(
              Ob,
              Fe(e, t, {
                theme: s.value,
                inTrigger: !1,
                siderCollapsed: a.value,
                isRoot: !0,
              }),
              lJ(sJ({}, n), {
                default:
                  i.value === 'horizontal' && n.default
                    ? () =>
                        m(tJ, null, {
                          default: () => {
                            var l
                            return [
                              (l = n.default) == null ? void 0 : l.call(n),
                            ]
                          },
                        })
                    : n.default,
              })
            )
        )
      },
    })
  function _A(e) {
    return e === Object(e) && Object.keys(e).length !== 0
  }
  function uJ(e, t) {
    t === void 0 && (t = 'auto')
    var n = 'scrollBehavior' in document.body.style
    e.forEach(function (r) {
      var i = r.el,
        o = r.top,
        a = r.left
      i.scroll && n
        ? i.scroll({ top: o, left: a, behavior: t })
        : ((i.scrollTop = o), (i.scrollLeft = a))
    })
  }
  function cJ(e) {
    return e === !1
      ? { block: 'end', inline: 'nearest' }
      : _A(e)
      ? e
      : { block: 'start', inline: 'nearest' }
  }
  function dJ(e, t) {
    var n = e.isConnected || e.ownerDocument.documentElement.contains(e)
    if (_A(t) && typeof t.behavior == 'function')
      return t.behavior(n ? gb(e, t) : [])
    if (n) {
      var r = cJ(t)
      return uJ(gb(e, r), r.behavior)
    }
  }
  var fJ = Object.defineProperty,
    oE = Object.getOwnPropertySymbols,
    hJ = Object.prototype.hasOwnProperty,
    pJ = Object.prototype.propertyIsEnumerable,
    aE = (e, t, n) =>
      t in e
        ? fJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    vJ = (e, t) => {
      for (var n in t || (t = {})) hJ.call(t, n) && aE(e, n, t[n])
      if (oE) for (var n of oE(t)) pJ.call(t, n) && aE(e, n, t[n])
      return e
    },
    Op = ce({
      name: 'MenuItem',
      inheritAttrs: !1,
      props: {
        key: { type: String },
        disabled: { type: Boolean, default: !1 },
      },
      emits: ['click'],
      setup(e, { emit: t }) {
        const { key: n } = om(),
          { level: r } = tf(),
          i = Il(),
          o = J(),
          a = C(() => (i.selectedKeys || []).indexOf(n.value) > -1),
          s = yA()
        Wt(() => {
          s == null || s.collectMenuItem(n.value)
        }),
          wr(() => {
            s == null || s.removeMenuItem(n.value)
          })
        function l() {
          i.autoScrollIntoView &&
            o.value &&
            a.value &&
            dJ(
              o.value,
              vJ(
                {
                  behavior: 'smooth',
                  block: 'nearest',
                  scrollMode: 'if-needed',
                  boundary: document.documentElement,
                },
                i.scrollConfig || {}
              )
            )
        }
        let c
        return (
          Wt(() => {
            c = setTimeout(() => {
              l()
            }, 500)
          }),
          wr(() => {
            clearTimeout(c)
          }),
          pt([a], () => {
            l()
          }),
          {
            menuContext: i,
            level: r,
            isSelected: a,
            refItemElement: o,
            onClick(d) {
              e.disabled ||
                (i.onMenuItemClick && i.onMenuItemClick(n.value), t('click', d))
            },
          }
        )
      },
      render() {
        var e, t
        const {
            level: n,
            menuContext: r,
            disabled: i,
            isSelected: o,
            onClick: a,
          } = this,
          {
            prefixCls: s,
            collapsed: l,
            inTrigger: c,
            mode: d,
            tooltipProps: h,
          } = r,
          p = l && !c && n === 1,
          v = d === 'vertical' && n > 1,
          g =
            ((t = (e = this.$slots).default) == null ? void 0 : t.call(e)) ||
            [],
          _ = v && !c && !l,
          b = this.$slots.icon && this.$slots.icon(),
          y = [
            _ && m(am, { level: n }, null),
            b && m('span', { class: `${s}-icon` }, [b]),
            _ || b
              ? m(
                  'span',
                  { class: [`${s}-item-inner`, { [`${s}-title`]: b }] },
                  [g]
                )
              : g,
          ].filter(Boolean),
          M = m(
            'div',
            Fe(
              {
                ref: 'refItemElement',
                class: [
                  `${s}-item`,
                  {
                    [`${s}-disabled`]: i,
                    [`${s}-selected`]: o,
                    [`${s}-has-icon`]: b,
                  },
                ],
              },
              this.$attrs,
              { onClick: a }
            ),
            [
              y,
              o &&
                d === 'horizontal' &&
                m('div', { class: `${s}-selected-label` }, null),
            ]
          )
        if (p) {
          const x = [`${s}-item-tooltip`, h == null ? void 0 : h.class]
          return m(
            uo,
            Fe(
              { trigger: 'hover', position: 'right', class: x },
              xr(h || {}, ['class'])
            ),
            { default: () => M, content: () => g }
          )
        }
        return M
      },
    })
  const mJ = ce({
    name: 'MenuItemGroup',
    components: { MenuIndent: am },
    props: { title: { type: String } },
    setup() {
      const { level: e } = tf(),
        t = C(() => (e.value === 1 ? e.value + 1 : e.value))
      mS(t)
      const n = Il(),
        r = C(() => n.prefixCls),
        i = C(() => [`${r.value}-group`])
      return { prefixCls: r, classNames: i, level: e }
    },
  })
  function gJ(e, t, n, r, i, o) {
    const a = ge('MenuIndent')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-group-title`) },
            [
              m(a, { level: e.level }, null, 8, ['level']),
              ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)]),
            ],
            2
          ),
          ve(e.$slots, 'default'),
        ],
        2
      )
    )
  }
  var Lp = Te(mJ, [['render', gJ]])
  const yJ = Object.assign(_y, {
      Item: Op,
      ItemGroup: Lp,
      SubMenu: pd,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + _y.name, _y),
          e.component(n + Op.name, Op),
          e.component(n + Lp.name, Lp),
          e.component(n + pd.name, pd)
      },
    }),
    bJ = ce({
      name: 'Message',
      components: {
        AIconHover: In,
        IconInfoCircleFill: qd,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
        IconClose: zr,
        IconLoading: Xr,
      },
      props: {
        type: { type: String, default: 'info' },
        closable: { type: Boolean, default: !1 },
        showIcon: { type: Boolean, default: !0 },
        duration: { type: Number, default: 3e3 },
        resetOnUpdate: { type: Boolean, default: !1 },
        resetOnHover: { type: Boolean, default: !1 },
      },
      emits: ['close'],
      setup(e, { emit: t }) {
        const n = ye('message')
        let r = 0
        const i = () => {
            t('close')
          },
          o = () => {
            e.duration > 0 && (r = window.setTimeout(i, e.duration))
          },
          a = () => {
            r && (window.clearTimeout(r), (r = 0))
          }
        return (
          Wt(() => {
            o()
          }),
          Zr(() => {
            e.resetOnUpdate && (a(), o())
          }),
          wr(() => {
            a()
          }),
          {
            handleMouseEnter: () => {
              e.resetOnHover && a()
            },
            handleMouseLeave: () => {
              e.resetOnHover && o()
            },
            prefixCls: n,
            handleClose: i,
          }
        )
      },
    })
  function _J(e, t, n, r, i, o) {
    const a = ge('icon-info-circle-fill'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill'),
      d = ge('icon-loading'),
      h = ge('icon-close'),
      p = ge('a-icon-hover')
    return (
      O(),
      Z(
        'li',
        {
          role: 'alert',
          class: H([
            e.prefixCls,
            `${e.prefixCls}-${e.type}`,
            { [`${e.prefixCls}-closable`]: e.closable },
          ]),
          onMouseenter:
            t[1] ||
            (t[1] = (...v) => e.handleMouseEnter && e.handleMouseEnter(...v)),
          onMouseleave:
            t[2] ||
            (t[2] = (...v) => e.handleMouseLeave && e.handleMouseLeave(...v)),
        },
        [
          e.showIcon && !(e.type === 'normal' && !e.$slots.icon)
            ? (O(),
              Z(
                'span',
                { key: 0, class: H(`${e.prefixCls}-icon`) },
                [
                  ve(e.$slots, 'icon', {}, () => [
                    e.type === 'info'
                      ? (O(), Ee(a, { key: 0 }))
                      : e.type === 'success'
                      ? (O(), Ee(s, { key: 1 }))
                      : e.type === 'warning'
                      ? (O(), Ee(l, { key: 2 }))
                      : e.type === 'error'
                      ? (O(), Ee(c, { key: 3 }))
                      : e.type === 'loading'
                      ? (O(), Ee(d, { key: 4 }))
                      : Ce('v-if', !0),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'span',
            { class: H(`${e.prefixCls}-content`) },
            [ve(e.$slots, 'default')],
            2
          ),
          e.closable
            ? (O(),
              Z(
                'span',
                {
                  key: 1,
                  class: H(`${e.prefixCls}-close-btn`),
                  onClick:
                    t[0] ||
                    (t[0] = (...v) => e.handleClose && e.handleClose(...v)),
                },
                [m(p, null, { default: ze(() => [m(h)]), _: 1 })],
                2
              ))
            : Ce('v-if', !0),
        ],
        34
      )
    )
  }
  var SJ = Te(bJ, [['render', _J]])
  function CJ(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var wJ = ce({
      name: 'MessageList',
      props: {
        messages: { type: Array, default: () => [] },
        position: { type: String, default: 'top' },
      },
      emits: ['close', 'afterClose'],
      setup(e, t) {
        const n = ye('message-list'),
          { zIndex: r } = oc('message', { runOnMounted: !0 })
        return () => {
          let i
          return m(
            jd,
            {
              class: [n, `${n}-${e.position}`],
              name: 'fade-message',
              tag: 'ul',
              style: { zIndex: r.value },
              onAfterLeave: () => t.emit('afterClose'),
            },
            CJ(
              (i = e.messages.map((o) => {
                const a = { default: ui(o.content), icon: ui(o.icon) }
                return m(
                  SJ,
                  {
                    key: o.id,
                    type: o.type,
                    duration: o.duration,
                    closable: o.closable,
                    resetOnUpdate: o.resetOnUpdate,
                    resetOnHover: o.resetOnHover,
                    onClose: () => t.emit('close', o.id),
                  },
                  a
                )
              }))
            )
              ? i
              : { default: () => [i] }
          )
        }
      },
    }),
    xJ = Object.defineProperty,
    MJ = Object.defineProperties,
    EJ = Object.getOwnPropertyDescriptors,
    sE = Object.getOwnPropertySymbols,
    PJ = Object.prototype.hasOwnProperty,
    TJ = Object.prototype.propertyIsEnumerable,
    lE = (e, t, n) =>
      t in e
        ? xJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    bv = (e, t) => {
      for (var n in t || (t = {})) PJ.call(t, n) && lE(e, n, t[n])
      if (sE) for (var n of sE(t)) TJ.call(t, n) && lE(e, n, t[n])
      return e
    },
    SA = (e, t) => MJ(e, EJ(t))
  class kJ {
    constructor(t, n) {
      ;(this.messageCount = 0),
        (this.add = (o) => {
          var a
          this.messageCount++
          const s =
            (a = o.id) != null ? a : `__arco_message_${this.messageCount}`
          if (this.messageIds.has(s)) return this.update(s, o)
          const l = Je(bv({ id: s }, o))
          return (
            this.messages.value.push(l),
            this.messageIds.add(s),
            { close: () => this.remove(s) }
          )
        }),
        (this.update = (o, a) => {
          for (let s = 0; s < this.messages.value.length; s++)
            if (this.messages.value[s].id === o) {
              const l = !Mt(a.duration)
              Object.assign(
                this.messages.value[s],
                SA(bv({}, a), { id: o, resetOnUpdate: l })
              )
              break
            }
          return { close: () => this.remove(o) }
        }),
        (this.remove = (o) => {
          for (let a = 0; a < this.messages.value.length; a++) {
            const s = this.messages.value[a]
            if (s.id === o) {
              xt(s.onClose) && s.onClose(o),
                this.messages.value.splice(a, 1),
                this.messageIds.delete(o)
              break
            }
          }
        }),
        (this.clear = () => {
          this.messages.value.splice(0)
        }),
        (this.destroy = () => {
          this.messages.value.length === 0 &&
            this.container &&
            (Ua(null, this.container),
            document.body.removeChild(this.container),
            (this.container = null),
            (Bu[this.position] = void 0))
        })
      const { position: r = 'top' } = t
      ;(this.container = jv('message')),
        (this.messageIds = new Set()),
        (this.messages = J([])),
        (this.position = r)
      const i = m(wJ, {
        messages: this.messages.value,
        position: r,
        onClose: this.remove,
        onAfterClose: this.destroy,
      })
      ;(n ?? Lb._context) && (i.appContext = n ?? Lb._context),
        Ua(i, this.container),
        document.body.appendChild(this.container)
    }
  }
  const Bu = {},
    CA = [...Kv, 'loading', 'normal'],
    Ip = CA.reduce(
      (e, t) => (
        (e[t] = (n, r) => {
          ir(n) && (n = { content: n })
          const i = bv({ type: t }, n),
            { position: o = 'top' } = i
          return Bu[o] || (Bu[o] = new kJ(i, r)), Bu[o].add(i)
        }),
        e
      ),
      {}
    )
  Ip.clear = (e) => {
    var t
    e
      ? (t = Bu[e]) == null || t.clear()
      : Object.values(Bu).forEach((n) => (n == null ? void 0 : n.clear()))
  }
  const Lb = SA(bv({}, Ip), {
      install: (e) => {
        const t = { clear: Ip.clear }
        for (const n of CA) t[n] = (r, i = e._context) => Ip[n](r, i)
        e.config.globalProperties.$message = t
      },
      _context: null,
    }),
    AJ = ({ modalRef: e, wrapperRef: t, draggable: n, alignCenter: r }) => {
      const i = J(!1),
        o = J([0, 0]),
        a = J([0, 0]),
        s = J(),
        l = J([0, 0]),
        c = J([0, 0]),
        d = () => {
          var g, _, b
          if (t.value && e.value) {
            const { top: y, left: M } = t.value.getBoundingClientRect(),
              { clientWidth: x, clientHeight: w } = t.value,
              {
                top: E,
                left: P,
                width: A,
                height: F,
              } = e.value.getBoundingClientRect(),
              T = r.value ? 0 : (g = e.value) == null ? void 0 : g.offsetTop,
              k = P - M,
              R = E - y - T
            ;(k !== ((_ = a.value) == null ? void 0 : _[0]) ||
              R !== ((b = a.value) == null ? void 0 : b[1])) &&
              (a.value = [k, R])
            const j = x > A ? x - A : 0,
              N = w > F ? w - F - T : 0
            ;(j !== c.value[0] || N !== c.value[1]) && (c.value = [j, N]),
              T && (l.value = [0, 0 - T])
          }
        },
        h = (g) => {
          n.value &&
            (g.preventDefault(),
            (i.value = !0),
            d(),
            (o.value = [g.x, g.y]),
            Cn(window, 'mousemove', p),
            Cn(window, 'mouseup', v),
            Cn(window, 'contextmenu', v))
        },
        p = (g) => {
          if (i.value) {
            const _ = g.x - o.value[0],
              b = g.y - o.value[1]
            let y = a.value[0] + _,
              M = a.value[1] + b
            y < l.value[0] && (y = l.value[0]),
              y > c.value[0] && (y = c.value[0]),
              M < l.value[1] && (M = l.value[1]),
              M > c.value[1] && (M = c.value[1]),
              (s.value = [y, M])
          }
        },
        v = () => {
          ;(i.value = !1), kn(window, 'mousemove', p), kn(window, 'mouseup', v)
        }
      return { position: s, handleMoveDown: h }
    }
  var $J = Object.defineProperty,
    uE = Object.getOwnPropertySymbols,
    OJ = Object.prototype.hasOwnProperty,
    LJ = Object.prototype.propertyIsEnumerable,
    cE = (e, t, n) =>
      t in e
        ? $J(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    IJ = (e, t) => {
      for (var n in t || (t = {})) OJ.call(t, n) && cE(e, n, t[n])
      if (uE) for (var n of uE(t)) LJ.call(t, n) && cE(e, n, t[n])
      return e
    },
    RJ = ce({
      name: 'Modal',
      components: {
        ClientOnly: N_,
        ArcoButton: Yr,
        IconHover: In,
        IconClose: zr,
        IconInfoCircleFill: qd,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
      },
      inheritAttrs: !1,
      props: {
        visible: { type: Boolean, default: void 0 },
        defaultVisible: { type: Boolean, default: !1 },
        width: { type: [Number, String] },
        top: { type: [Number, String] },
        mask: { type: Boolean, default: !0 },
        title: { type: String },
        titleAlign: { type: String, default: 'center' },
        alignCenter: { type: Boolean, default: !0 },
        unmountOnClose: Boolean,
        maskClosable: { type: Boolean, default: !0 },
        hideCancel: { type: Boolean, default: !1 },
        simple: { type: Boolean, default: (e) => e.notice },
        closable: { type: Boolean, default: !0 },
        okText: String,
        cancelText: String,
        okLoading: { type: Boolean, default: !1 },
        okButtonProps: { type: Object },
        cancelButtonProps: { type: Object },
        footer: { type: Boolean, default: !0 },
        renderToBody: { type: Boolean, default: !0 },
        popupContainer: { type: [String, Object], default: 'body' },
        maskStyle: { type: Object },
        modalClass: { type: [String, Array] },
        modalStyle: { type: Object },
        onBeforeOk: { type: Function },
        onBeforeCancel: { type: Function },
        escToClose: { type: Boolean, default: !0 },
        draggable: { type: Boolean, default: !1 },
        fullscreen: { type: Boolean, default: !1 },
        maskAnimationName: {
          type: String,
          default: (e) => (e.fullscreen ? 'fade-in-standard' : 'fade-modal'),
        },
        modalAnimationName: {
          type: String,
          default: (e) => (e.fullscreen ? 'zoom-in' : 'zoom-modal'),
        },
        bodyClass: { type: [String, Array] },
        bodyStyle: { type: [String, Object, Array] },
        messageType: { type: String },
      },
      emits: {
        'update:visible': (e) => !0,
        ok: (e) => !0,
        cancel: (e) => !0,
        open: () => !0,
        close: () => !0,
        beforeOpen: () => !0,
        beforeClose: () => !0,
      },
      setup(e, { emit: t }) {
        const { fullscreen: n, popupContainer: r, alignCenter: i } = tt(e),
          o = ye('modal'),
          { t: a } = Vn(),
          s = J(),
          l = J(),
          c = J(e.defaultVisible),
          d = C(() => {
            var ue
            return (ue = e.visible) != null ? ue : c.value
          }),
          h = J(!1),
          p = C(() => e.okLoading || h.value),
          v = C(() => e.draggable && !e.fullscreen),
          { teleportContainer: g, containerRef: _ } = B_({
            popupContainer: r,
            visible: d,
          }),
          b = J(d.value),
          y = C(() => e.okText || a('modal.okText')),
          M = C(() => e.cancelText || a('modal.cancelText')),
          { zIndex: x, isLastDialog: w } = oc('dialog', { visible: d })
        let E = !1
        const P = (ue) => {
            e.escToClose && ue.key === fr.ESC && w() && I(ue)
          },
          A = () => {
            e.escToClose &&
              !E &&
              ((E = !0), Cn(document.documentElement, 'keydown', P))
          },
          F = () => {
            ;(E = !1), kn(document.documentElement, 'keydown', P)
          }
        let T = 0
        const { position: k, handleMoveDown: R } = AJ({
            wrapperRef: s,
            modalRef: l,
            draggable: v,
            alignCenter: i,
          }),
          j = () => {
            T++,
              h.value && (h.value = !1),
              (c.value = !1),
              t('update:visible', !1)
          },
          N = async (ue) => {
            const me = T,
              Re = await new Promise(async (qe) => {
                var Ve
                if (xt(e.onBeforeOk)) {
                  let nt = e.onBeforeOk((We = !0) => qe(We))
                  if (((xl(nt) || !Ui(nt)) && (h.value = !0), xl(nt)))
                    try {
                      nt = (Ve = await nt) != null ? Ve : !0
                    } catch {
                      nt = !1
                    }
                  Ui(nt) && qe(nt)
                } else qe(!0)
              })
            me === T && (Re ? (t('ok', ue), j()) : h.value && (h.value = !1))
          },
          I = (ue) => {
            var me
            let Re = !0
            xt(e.onBeforeCancel) &&
              (Re = (me = e.onBeforeCancel()) != null ? me : !1),
              Re && (t('cancel', ue), j())
          },
          B = J(!1),
          V = (ue) => {
            ue.target === s.value && (B.value = !0)
          },
          L = (ue) => {
            e.mask && e.maskClosable && B.value && I(ue)
          },
          W = () => {
            d.value &&
              (!jB(s.value, document.activeElement) &&
                document.activeElement instanceof HTMLElement &&
                document.activeElement.blur(),
              t('open'))
          },
          Y = () => {
            d.value ||
              (v.value && (k.value = void 0), (b.value = !1), le(), t('close'))
          },
          { setOverflowHidden: U, resetOverflow: le } = Xk(_)
        Wt(() => {
          ;(_.value = Yo(e.popupContainer)),
            d.value && (U(), e.escToClose && A())
        }),
          Pr(() => {
            le(), F()
          }),
          pt(d, (ue) => {
            c.value !== ue && (c.value = ue),
              ue
                ? (t('beforeOpen'), (b.value = !0), (B.value = !1), U(), A())
                : (t('beforeClose'), F())
          }),
          pt(n, () => {
            k.value && (k.value = void 0)
          })
        const q = C(() => [
            `${o}-wrapper`,
            {
              [`${o}-wrapper-align-center`]: e.alignCenter && !e.fullscreen,
              [`${o}-wrapper-moved`]: !!k.value,
            },
          ]),
          oe = C(() => [
            `${o}`,
            e.modalClass,
            {
              [`${o}-simple`]: e.simple,
              [`${o}-draggable`]: v.value,
              [`${o}-fullscreen`]: e.fullscreen,
            },
          ]),
          te = C(() => {
            var ue
            const me = IJ({}, (ue = e.modalStyle) != null ? ue : {})
            return (
              e.width &&
                !e.fullscreen &&
                (me.width = it(e.width) ? `${e.width}px` : e.width),
              !e.alignCenter &&
                e.top &&
                (me.top = it(e.top) ? `${e.top}px` : e.top),
              k.value &&
                (me.transform = `translate(${k.value[0]}px, ${k.value[1]}px)`),
              me
            )
          })
        return {
          prefixCls: o,
          mounted: b,
          computedVisible: d,
          containerRef: _,
          wrapperRef: s,
          mergedModalStyle: te,
          okDisplayText: y,
          cancelDisplayText: M,
          zIndex: x,
          handleOk: N,
          handleCancel: I,
          handleMaskClick: L,
          handleMaskMouseDown: V,
          handleOpen: W,
          handleClose: Y,
          mergedOkLoading: p,
          modalRef: l,
          wrapperCls: q,
          modalCls: oe,
          teleportContainer: g,
          handleMoveDown: R,
        }
      },
    })
  function DJ(e, t, n, r, i, o) {
    const a = ge('icon-info-circle-fill'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill'),
      d = ge('icon-close'),
      h = ge('icon-hover'),
      p = ge('arco-button'),
      v = ge('client-only')
    return (
      O(),
      Ee(v, null, {
        default: ze(() => [
          (O(),
          Ee(
            Dv,
            { to: e.teleportContainer, disabled: !e.renderToBody },
            [
              !e.unmountOnClose || e.computedVisible || e.mounted
                ? ro(
                    (O(),
                    Z(
                      'div',
                      Fe(
                        {
                          key: 0,
                          class: `${e.prefixCls}-container`,
                          style: { zIndex: e.zIndex },
                        },
                        e.$attrs
                      ),
                      [
                        m(
                          Fr,
                          { name: e.maskAnimationName, appear: '' },
                          {
                            default: ze(() => [
                              e.mask
                                ? ro(
                                    (O(),
                                    Z(
                                      'div',
                                      {
                                        key: 0,
                                        ref: 'maskRef',
                                        class: H(`${e.prefixCls}-mask`),
                                        style: at(e.maskStyle),
                                      },
                                      null,
                                      6
                                    )),
                                    [[oo, e.computedVisible]]
                                  )
                                : Ce('v-if', !0),
                            ]),
                            _: 1,
                          },
                          8,
                          ['name']
                        ),
                        Se(
                          'div',
                          {
                            ref: 'wrapperRef',
                            class: H(e.wrapperCls),
                            onClick:
                              t[2] ||
                              (t[2] = io(
                                (...g) =>
                                  e.handleMaskClick && e.handleMaskClick(...g),
                                ['self']
                              )),
                            onMousedown:
                              t[3] ||
                              (t[3] = io(
                                (...g) =>
                                  e.handleMaskMouseDown &&
                                  e.handleMaskMouseDown(...g),
                                ['self']
                              )),
                          },
                          [
                            m(
                              Fr,
                              {
                                name: e.modalAnimationName,
                                appear: '',
                                onAfterEnter: e.handleOpen,
                                onAfterLeave: e.handleClose,
                              },
                              {
                                default: ze(() => [
                                  ro(
                                    Se(
                                      'div',
                                      {
                                        ref: 'modalRef',
                                        class: H(e.modalCls),
                                        style: at(e.mergedModalStyle),
                                      },
                                      [
                                        e.$slots.title || e.title || e.closable
                                          ? (O(),
                                            Z(
                                              'div',
                                              {
                                                key: 0,
                                                class: H(
                                                  `${e.prefixCls}-header`
                                                ),
                                                onMousedown:
                                                  t[1] ||
                                                  (t[1] = (...g) =>
                                                    e.handleMoveDown &&
                                                    e.handleMoveDown(...g)),
                                              },
                                              [
                                                e.$slots.title || e.title
                                                  ? (O(),
                                                    Z(
                                                      'div',
                                                      {
                                                        key: 0,
                                                        class: H([
                                                          `${e.prefixCls}-title`,
                                                          `${e.prefixCls}-title-align-${e.titleAlign}`,
                                                        ]),
                                                      },
                                                      [
                                                        e.messageType
                                                          ? (O(),
                                                            Z(
                                                              'div',
                                                              {
                                                                key: 0,
                                                                class: H(
                                                                  `${e.prefixCls}-title-icon`
                                                                ),
                                                              },
                                                              [
                                                                e.messageType ===
                                                                'info'
                                                                  ? (O(),
                                                                    Ee(a, {
                                                                      key: 0,
                                                                    }))
                                                                  : Ce(
                                                                      'v-if',
                                                                      !0
                                                                    ),
                                                                e.messageType ===
                                                                'success'
                                                                  ? (O(),
                                                                    Ee(s, {
                                                                      key: 1,
                                                                    }))
                                                                  : Ce(
                                                                      'v-if',
                                                                      !0
                                                                    ),
                                                                e.messageType ===
                                                                'warning'
                                                                  ? (O(),
                                                                    Ee(l, {
                                                                      key: 2,
                                                                    }))
                                                                  : Ce(
                                                                      'v-if',
                                                                      !0
                                                                    ),
                                                                e.messageType ===
                                                                'error'
                                                                  ? (O(),
                                                                    Ee(c, {
                                                                      key: 3,
                                                                    }))
                                                                  : Ce(
                                                                      'v-if',
                                                                      !0
                                                                    ),
                                                              ],
                                                              2
                                                            ))
                                                          : Ce('v-if', !0),
                                                        ve(
                                                          e.$slots,
                                                          'title',
                                                          {},
                                                          () => [
                                                            Lt(mt(e.title), 1),
                                                          ]
                                                        ),
                                                      ],
                                                      2
                                                    ))
                                                  : Ce('v-if', !0),
                                                !e.simple && e.closable
                                                  ? (O(),
                                                    Z(
                                                      'div',
                                                      {
                                                        key: 1,
                                                        tabindex: '-1',
                                                        role: 'button',
                                                        'aria-label': 'Close',
                                                        class: H(
                                                          `${e.prefixCls}-close-btn`
                                                        ),
                                                        onClick:
                                                          t[0] ||
                                                          (t[0] = (...g) =>
                                                            e.handleCancel &&
                                                            e.handleCancel(
                                                              ...g
                                                            )),
                                                      },
                                                      [
                                                        m(h, null, {
                                                          default: ze(() => [
                                                            m(d),
                                                          ]),
                                                          _: 1,
                                                        }),
                                                      ],
                                                      2
                                                    ))
                                                  : Ce('v-if', !0),
                                              ],
                                              34
                                            ))
                                          : Ce('v-if', !0),
                                        Se(
                                          'div',
                                          {
                                            class: H([
                                              `${e.prefixCls}-body`,
                                              e.bodyClass,
                                            ]),
                                            style: at(e.bodyStyle),
                                          },
                                          [ve(e.$slots, 'default')],
                                          6
                                        ),
                                        e.footer
                                          ? (O(),
                                            Z(
                                              'div',
                                              {
                                                key: 1,
                                                class: H(
                                                  `${e.prefixCls}-footer`
                                                ),
                                              },
                                              [
                                                ve(
                                                  e.$slots,
                                                  'footer',
                                                  {},
                                                  () => [
                                                    e.hideCancel
                                                      ? Ce('v-if', !0)
                                                      : (O(),
                                                        Ee(
                                                          p,
                                                          Fe(
                                                            { key: 0 },
                                                            e.cancelButtonProps,
                                                            {
                                                              onClick:
                                                                e.handleCancel,
                                                            }
                                                          ),
                                                          {
                                                            default: ze(() => [
                                                              Lt(
                                                                mt(
                                                                  e.cancelDisplayText
                                                                ),
                                                                1
                                                              ),
                                                            ]),
                                                            _: 1,
                                                          },
                                                          16,
                                                          ['onClick']
                                                        )),
                                                    m(
                                                      p,
                                                      Fe(
                                                        { type: 'primary' },
                                                        e.okButtonProps,
                                                        {
                                                          loading:
                                                            e.mergedOkLoading,
                                                          onClick: e.handleOk,
                                                        }
                                                      ),
                                                      {
                                                        default: ze(() => [
                                                          Lt(
                                                            mt(e.okDisplayText),
                                                            1
                                                          ),
                                                        ]),
                                                        _: 1,
                                                      },
                                                      16,
                                                      ['loading', 'onClick']
                                                    ),
                                                  ]
                                                ),
                                              ],
                                              2
                                            ))
                                          : Ce('v-if', !0),
                                      ],
                                      6
                                    ),
                                    [[oo, e.computedVisible]]
                                  ),
                                ]),
                                _: 3,
                              },
                              8,
                              ['name', 'onAfterEnter', 'onAfterLeave']
                            ),
                          ],
                          34
                        ),
                      ],
                      16
                    )),
                    [[oo, e.computedVisible || e.mounted]]
                  )
                : Ce('v-if', !0),
            ],
            8,
            ['to', 'disabled']
          )),
        ]),
        _: 3,
      })
    )
  }
  var Rp = Te(RJ, [['render', DJ]]),
    NJ = Object.defineProperty,
    BJ = Object.defineProperties,
    FJ = Object.getOwnPropertyDescriptors,
    dE = Object.getOwnPropertySymbols,
    zJ = Object.prototype.hasOwnProperty,
    VJ = Object.prototype.propertyIsEnumerable,
    fE = (e, t, n) =>
      t in e
        ? NJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    gl = (e, t) => {
      for (var n in t || (t = {})) zJ.call(t, n) && fE(e, n, t[n])
      if (dE) for (var n of dE(t)) VJ.call(t, n) && fE(e, n, t[n])
      return e
    },
    UJ = (e, t) => BJ(e, FJ(t))
  const Sy = (e, t) => {
      let n = jv('modal')
      const r = () => {
          c.component && (c.component.props.visible = !1),
            xt(e.onOk) && e.onOk()
        },
        i = () => {
          c.component && (c.component.props.visible = !1),
            xt(e.onCancel) && e.onCancel()
        },
        o = async () => {
          await hn(),
            n && (Ua(null, n), document.body.removeChild(n)),
            (n = null),
            xt(e.onClose) && e.onClose()
        },
        a = () => {
          c.component && (c.component.props.visible = !1)
        },
        s = (d) => {
          c.component &&
            Object.entries(d).forEach(([h, p]) => {
              c.component.props[h] = p
            })
        },
        c = m(
          Rp,
          gl(
            gl(
              gl(
                {},
                {
                  visible: !0,
                  renderToBody: !1,
                  unmountOnClose: !0,
                  onOk: r,
                  onCancel: i,
                  onClose: o,
                }
              ),
              xr(e, [
                'content',
                'title',
                'footer',
                'visible',
                'unmountOnClose',
                'onOk',
                'onCancel',
                'onClose',
              ])
            ),
            { footer: typeof e.footer == 'boolean' ? e.footer : void 0 }
          ),
          {
            default: ui(e.content),
            title: ui(e.title),
            footer: typeof e.footer != 'boolean' ? ui(e.footer) : void 0,
          }
        )
      return (
        (t ?? Ib._context) && (c.appContext = t ?? Ib._context),
        Ua(c, n),
        document.body.appendChild(n),
        { close: a, update: s }
      )
    },
    Cy = gl(
      {
        open: Sy,
        confirm: (e, t) => {
          const n = gl({ simple: !0, messageType: 'warning' }, e)
          return Sy(n, t)
        },
      },
      Kv.reduce(
        (e, t) => (
          (e[t] = (n, r) => {
            const i = gl({ simple: !0, hideCancel: !0, messageType: t }, n)
            return Sy(i, r)
          }),
          e
        ),
        {}
      )
    ),
    Ib = Object.assign(
      Rp,
      UJ(gl({}, Cy), {
        install: (e, t) => {
          Rt(e, t)
          const n = It(t)
          e.component(n + Rp.name, Rp)
          const r = {}
          for (const i of Object.keys(Cy))
            r[i] = (o, a = e._context) => Cy[i](o, a)
          e.config.globalProperties.$modal = r
        },
        _context: null,
      })
    ),
    HJ = (e) => e.replace(/\B([A-Z])/g, '-$1').toLowerCase(),
    WJ = ce({
      name: 'Notification',
      components: {
        AIconHover: In,
        IconInfoCircleFill: qd,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
        IconClose: zr,
      },
      props: {
        type: { type: String, default: 'info' },
        showIcon: { type: Boolean, default: !0 },
        closable: { type: Boolean, default: !1 },
        duration: { type: Number, default: 3e3 },
        resetOnUpdate: { type: Boolean, default: !1 },
      },
      emits: ['close'],
      setup(e, t) {
        const n = ye('notification')
        let r = 0
        const i = () => {
          t.emit('close')
        }
        return (
          Wt(() => {
            e.duration > 0 && (r = window.setTimeout(i, e.duration))
          }),
          Zr(() => {
            e.resetOnUpdate &&
              (r && (window.clearTimeout(r), (r = 0)),
              e.duration > 0 && (r = window.setTimeout(i, e.duration)))
          }),
          wr(() => {
            r && window.clearTimeout(r)
          }),
          { prefixCls: n, handleClose: i }
        )
      },
    })
  function jJ(e, t, n, r, i, o) {
    const a = ge('icon-info-circle-fill'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill'),
      d = ge('icon-close'),
      h = ge('a-icon-hover')
    return (
      O(),
      Z(
        'li',
        {
          role: 'alert',
          class: H([
            e.prefixCls,
            `${e.prefixCls}-${e.type}`,
            { [`${e.prefixCls}-closable`]: e.closable },
          ]),
        },
        [
          e.showIcon
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-left`) },
                [
                  Se(
                    'div',
                    { class: H(`${e.prefixCls}-icon`) },
                    [
                      ve(e.$slots, 'icon', {}, () => [
                        e.type === 'info'
                          ? (O(), Ee(a, { key: 0 }))
                          : e.type === 'success'
                          ? (O(), Ee(s, { key: 1 }))
                          : e.type === 'warning'
                          ? (O(), Ee(l, { key: 2 }))
                          : e.type === 'error'
                          ? (O(), Ee(c, { key: 3 }))
                          : Ce('v-if', !0),
                      ]),
                    ],
                    2
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-right`) },
            [
              e.$slots.default
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-title`) },
                    [ve(e.$slots, 'default')],
                    2
                  ))
                : Ce('v-if', !0),
              e.$slots.content
                ? (O(),
                  Z(
                    'div',
                    { key: 1, class: H(`${e.prefixCls}-content`) },
                    [ve(e.$slots, 'content')],
                    2
                  ))
                : Ce('v-if', !0),
              e.$slots.footer
                ? (O(),
                  Z(
                    'div',
                    { key: 2, class: H(`${e.prefixCls}-footer`) },
                    [ve(e.$slots, 'footer')],
                    2
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          e.closable
            ? (O(),
              Z(
                'div',
                {
                  key: 1,
                  class: H(`${e.prefixCls}-close-btn`),
                  onClick:
                    t[0] ||
                    (t[0] = (...p) => e.handleClose && e.handleClose(...p)),
                },
                [
                  ve(e.$slots, 'closeIconElement', {}, () => [
                    m(h, null, {
                      default: ze(() => [
                        ve(e.$slots, 'closeIcon', {}, () => [m(d)]),
                      ]),
                      _: 3,
                    }),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var GJ = Te(WJ, [['render', jJ]])
  const KJ = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']
  function qJ(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var XJ = ce({
      name: 'NotificationList',
      props: {
        notifications: { type: Array, default: () => [] },
        position: {
          type: String,
          default: 'topRight',
          validator: (e) => KJ.includes(e),
        },
      },
      emits: ['close', 'afterClose'],
      setup(e, t) {
        const n = ye('notification-list'),
          r = HJ(e.position),
          { zIndex: i } = oc('message', { runOnMounted: !0 }),
          o = e.position.includes('Right')
        return () => {
          let a
          return m(
            jd,
            {
              class: [n, `${n}-${r}`],
              style: { zIndex: i.value },
              name: `slide-${o ? 'right' : 'left'}-notification`,
              onAfterLeave: () => t.emit('afterClose'),
              tag: 'ul',
            },
            qJ(
              (a = e.notifications.map((s) => {
                const l = {
                  default: ui(s.title),
                  content: ui(s.content),
                  icon: ui(s.icon),
                  footer: ui(s.footer),
                  closeIcon: ui(s.closeIcon),
                  closeIconElement: ui(s.closeIconElement),
                }
                return m(
                  GJ,
                  {
                    key: s.id,
                    type: s.type,
                    style: s.style,
                    class: s.class,
                    duration: s.duration,
                    closable: s.closable,
                    showIcon: s.showIcon,
                    resetOnUpdate: s.resetOnUpdate,
                    onClose: () => t.emit('close', s.id),
                  },
                  l
                )
              }))
            )
              ? a
              : { default: () => [a] }
          )
        }
      },
    }),
    YJ = Object.defineProperty,
    ZJ = Object.defineProperties,
    JJ = Object.getOwnPropertyDescriptors,
    hE = Object.getOwnPropertySymbols,
    QJ = Object.prototype.hasOwnProperty,
    eQ = Object.prototype.propertyIsEnumerable,
    pE = (e, t, n) =>
      t in e
        ? YJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    _v = (e, t) => {
      for (var n in t || (t = {})) QJ.call(t, n) && pE(e, n, t[n])
      if (hE) for (var n of hE(t)) eQ.call(t, n) && pE(e, n, t[n])
      return e
    },
    wA = (e, t) => ZJ(e, JJ(t))
  class tQ {
    constructor(t, n) {
      ;(this.notificationCount = 0),
        (this.add = (o) => {
          var a
          this.notificationCount++
          const s =
            (a = o.id) != null
              ? a
              : `__arco_notification_${this.notificationCount}`
          if (this.notificationIds.has(s)) return this.update(s, o)
          const l = Je(_v({ id: s }, o))
          return (
            this.notifications.value.push(l),
            this.notificationIds.add(s),
            { close: () => this.remove(s) }
          )
        }),
        (this.update = (o, a) => {
          for (let s = 0; s < this.notifications.value.length; s++)
            if (this.notifications.value[s].id === o) {
              const l = !Mt(a.duration)
              Object.assign(
                this.notifications.value[s],
                wA(_v({}, a), { id: o, resetOnUpdate: l })
              )
              break
            }
          return { close: () => this.remove(o) }
        }),
        (this.remove = (o) => {
          for (let a = 0; a < this.notifications.value.length; a++) {
            const s = this.notifications.value[a]
            if (s.id === o) {
              xt(s.onClose) && s.onClose(o),
                this.notifications.value.splice(a, 1),
                this.notificationIds.delete(o)
              break
            }
          }
        }),
        (this.clear = () => {
          this.notifications.value.splice(0)
        }),
        (this.destroy = () => {
          this.notifications.value.length === 0 &&
            this.container &&
            (Ua(null, this.container),
            document.body.removeChild(this.container),
            (this.container = null),
            (yl[this.position] = void 0))
        })
      const { position: r = 'topRight' } = t
      ;(this.container = jv('notification')),
        (this.notificationIds = new Set()),
        (this.notifications = J([])),
        (this.position = r)
      const i = m(XJ, {
        notifications: this.notifications.value,
        position: r,
        onClose: this.remove,
        onAfterClose: this.destroy,
      })
      ;(n ?? Rb._context) && (i.appContext = n ?? Rb._context),
        Ua(i, this.container),
        document.body.appendChild(this.container)
    }
  }
  const yl = {},
    vd = Kv.reduce(
      (e, t) => (
        (e[t] = (n, r) => {
          ir(n) && (n = { content: n })
          const i = _v({ type: t }, n),
            { position: o = 'topRight' } = i
          return yl[o] || (yl[o] = new tQ(i, r)), yl[o].add(i)
        }),
        e
      ),
      {}
    )
  vd.remove = (e) => {
    e && Object.values(yl).forEach((t) => (t == null ? void 0 : t.remove(e)))
  }
  vd.clear = (e) => {
    var t
    e
      ? (t = yl[e]) == null || t.clear()
      : Object.values(yl).forEach((n) => (n == null ? void 0 : n.clear()))
  }
  const Rb = wA(_v({}, vd), {
      install: (e) => {
        const t = { clear: vd.clear }
        for (const n of Kv) t[n] = (r, i = e._context) => vd[n](r, i)
        e.config.globalProperties.$notification = t
      },
      _context: null,
    }),
    nQ = ce({
      name: 'PageHeader',
      components: { AIconHover: In, IconLeft: ja },
      props: {
        title: String,
        subtitle: String,
        showBack: { type: Boolean, default: !0 },
      },
      emits: ['back'],
      setup(e, { emit: t, slots: n }) {
        const r = ye('page-header'),
          i = (a) => {
            t('back', a)
          },
          o = C(() => [
            r,
            {
              [`${r}-with-breadcrumb`]: !!n.breadcrumb,
              [`${r}-with-content`]: !!n.default,
            },
          ])
        return { prefixCls: r, cls: o, handleBack: i }
      },
    })
  function rQ(e, t, n, r, i, o) {
    const a = ge('icon-left'),
      s = ge('a-icon-hover')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-wrapper`) },
            [
              e.$slots.breadcrumb
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-breadcrumb`) },
                    [ve(e.$slots, 'breadcrumb')],
                    2
                  ))
                : Ce('v-if', !0),
              Se(
                'div',
                { class: H(`${e.prefixCls}-header`) },
                [
                  Se(
                    'span',
                    { class: H(`${e.prefixCls}-main`) },
                    [
                      e.showBack
                        ? (O(),
                          Ee(
                            s,
                            {
                              key: 0,
                              class: H(`${e.prefixCls}-back-btn`),
                              prefix: e.prefixCls,
                              onClick: e.handleBack,
                            },
                            {
                              default: ze(() => [
                                ve(e.$slots, 'back-icon', {}, () => [m(a)]),
                              ]),
                              _: 3,
                            },
                            8,
                            ['class', 'prefix', 'onClick']
                          ))
                        : Ce('v-if', !0),
                      Se(
                        'span',
                        { class: H(`${e.prefixCls}-title`) },
                        [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                        2
                      ),
                      e.$slots.subtitle || e.subtitle
                        ? (O(),
                          Z(
                            'span',
                            { key: 1, class: H(`${e.prefixCls}-divider`) },
                            null,
                            2
                          ))
                        : Ce('v-if', !0),
                      e.$slots.subtitle || e.subtitle
                        ? (O(),
                          Z(
                            'span',
                            { key: 2, class: H(`${e.prefixCls}-subtitle`) },
                            [
                              ve(e.$slots, 'subtitle', {}, () => [
                                Lt(mt(e.subtitle), 1),
                              ]),
                            ],
                            2
                          ))
                        : Ce('v-if', !0),
                    ],
                    2
                  ),
                  e.$slots.extra
                    ? (O(),
                      Z(
                        'span',
                        { key: 0, class: H(`${e.prefixCls}-extra`) },
                        [ve(e.$slots, 'extra')],
                        2
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ),
            ],
            2
          ),
          e.$slots.default
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-content`) },
                [ve(e.$slots, 'default')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var wy = Te(nQ, [['render', rQ]])
  const iQ = Object.assign(wy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + wy.name, wy)
      },
    }),
    oQ = ce({
      name: 'Popconfirm',
      components: {
        ArcoButton: Yr,
        Trigger: Mr,
        IconInfoCircleFill: qd,
        IconCheckCircleFill: $l,
        IconExclamationCircleFill: Wa,
        IconCloseCircleFill: rc,
      },
      props: {
        content: String,
        position: { type: String, default: 'top' },
        popupVisible: { type: Boolean, default: void 0 },
        defaultPopupVisible: { type: Boolean, default: !1 },
        type: { type: String, default: 'info' },
        okText: String,
        cancelText: String,
        okLoading: { type: Boolean, default: !1 },
        okButtonProps: { type: Object },
        cancelButtonProps: { type: Object },
        contentClass: { type: [String, Array, Object] },
        contentStyle: { type: Object },
        arrowClass: { type: [String, Array, Object] },
        arrowStyle: { type: Object },
        popupContainer: { type: [String, Object] },
        onBeforeOk: { type: Function },
        onBeforeCancel: { type: Function },
      },
      emits: {
        'update:popupVisible': (e) => !0,
        popupVisibleChange: (e) => !0,
        ok: () => !0,
        cancel: () => !0,
      },
      setup(e, { emit: t }) {
        const n = ye('popconfirm'),
          { t: r } = Vn(),
          i = J(e.defaultPopupVisible),
          o = C(() => {
            var _
            return (_ = e.popupVisible) != null ? _ : i.value
          }),
          a = J(!1),
          s = C(() => e.okLoading || a.value)
        let l = 0
        const c = () => {
            l++,
              a.value && (a.value = !1),
              (i.value = !1),
              t('update:popupVisible', !1),
              t('popupVisibleChange', !1)
          },
          d = (_) => {
            _
              ? ((i.value = _),
                t('update:popupVisible', _),
                t('popupVisibleChange', _))
              : c()
          },
          h = async () => {
            const _ = l,
              b = await new Promise(async (y) => {
                var M
                if (xt(e.onBeforeOk)) {
                  let x = e.onBeforeOk((w = !0) => y(w))
                  if (((xl(x) || !Ui(x)) && (a.value = !0), xl(x)))
                    try {
                      x = (M = await x) != null ? M : !0
                    } catch {
                      x = !1
                    }
                  Ui(x) && y(x)
                } else y(!0)
              })
            _ === l && (b ? (t('ok'), c()) : a.value && (a.value = !1))
          },
          p = () => {
            var _
            let b = !0
            xt(e.onBeforeCancel) &&
              (b = (_ = e.onBeforeCancel()) != null ? _ : !1),
              b && (t('cancel'), c())
          },
          v = C(() => [`${n}-popup-content`, e.contentClass]),
          g = C(() => [`${n}-popup-arrow`, e.arrowClass])
        return {
          prefixCls: n,
          contentCls: v,
          arrowCls: g,
          computedPopupVisible: o,
          mergedOkLoading: s,
          handlePopupVisibleChange: d,
          handleOk: h,
          handleCancel: p,
          t: r,
        }
      },
    })
  function aQ(e, t, n, r, i, o) {
    const a = ge('icon-info-circle-fill'),
      s = ge('icon-check-circle-fill'),
      l = ge('icon-exclamation-circle-fill'),
      c = ge('icon-close-circle-fill'),
      d = ge('arco-button'),
      h = ge('trigger')
    return (
      O(),
      Ee(
        h,
        {
          class: H(e.prefixCls),
          trigger: 'click',
          position: e.position,
          'show-arrow': '',
          'popup-visible': e.computedPopupVisible,
          'popup-offset': 10,
          'popup-container': e.popupContainer,
          'content-class': e.contentCls,
          'content-style': e.contentStyle,
          'arrow-class': e.arrowCls,
          'arrow-style': e.arrowStyle,
          'animation-name': 'zoom-in-fade-out',
          'auto-fit-transform-origin': '',
          onPopupVisibleChange: e.handlePopupVisibleChange,
        },
        {
          content: ze(() => [
            Se(
              'div',
              { class: H(`${e.prefixCls}-body`) },
              [
                Se(
                  'span',
                  { class: H(`${e.prefixCls}-icon`) },
                  [
                    ve(e.$slots, 'icon', {}, () => [
                      e.type === 'info'
                        ? (O(), Ee(a, { key: 0 }))
                        : e.type === 'success'
                        ? (O(), Ee(s, { key: 1 }))
                        : e.type === 'warning'
                        ? (O(), Ee(l, { key: 2 }))
                        : e.type === 'error'
                        ? (O(), Ee(c, { key: 3 }))
                        : Ce('v-if', !0),
                    ]),
                  ],
                  2
                ),
                Se(
                  'span',
                  { class: H(`${e.prefixCls}-content`) },
                  [ve(e.$slots, 'content', {}, () => [Lt(mt(e.content), 1)])],
                  2
                ),
              ],
              2
            ),
            Se(
              'div',
              { class: H(`${e.prefixCls}-footer`) },
              [
                m(
                  d,
                  Fe({ size: 'mini' }, e.cancelButtonProps, {
                    onClick: e.handleCancel,
                  }),
                  {
                    default: ze(() => [
                      Lt(mt(e.cancelText || e.t('popconfirm.cancelText')), 1),
                    ]),
                    _: 1,
                  },
                  16,
                  ['onClick']
                ),
                m(
                  d,
                  Fe({ type: 'primary', size: 'mini' }, e.okButtonProps, {
                    loading: e.mergedOkLoading,
                    onClick: e.handleOk,
                  }),
                  {
                    default: ze(() => [
                      Lt(mt(e.okText || e.t('popconfirm.okText')), 1),
                    ]),
                    _: 1,
                  },
                  16,
                  ['loading', 'onClick']
                ),
              ],
              2
            ),
          ]),
          default: ze(() => [ve(e.$slots, 'default')]),
          _: 3,
        },
        8,
        [
          'class',
          'position',
          'popup-visible',
          'popup-container',
          'content-class',
          'content-style',
          'arrow-class',
          'arrow-style',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var xy = Te(oQ, [['render', aQ]])
  const sQ = Object.assign(xy, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + xy.name, xy)
    },
  })
  var lQ = Object.defineProperty,
    vE = Object.getOwnPropertySymbols,
    uQ = Object.prototype.hasOwnProperty,
    cQ = Object.prototype.propertyIsEnumerable,
    mE = (e, t, n) =>
      t in e
        ? lQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (e[t] = n),
    dQ = (e, t) => {
      for (var n in t || (t = {})) uQ.call(t, n) && mE(e, n, t[n])
      if (vE) for (var n of vE(t)) cQ.call(t, n) && mE(e, n, t[n])
      return e
    }
  const fQ = { small: 3, medium: 4, large: 8 },
    hQ = (e) => {
      if (e)
        return Ht(e)
          ? {
              backgroundImage: `linear-gradient(to right, ${Object.keys(e)
                .map((n) => `${e[n]} ${n}`)
                .join(',')})`,
            }
          : { backgroundColor: e }
    },
    pQ = ce({
      name: 'ProgressLine',
      components: { IconExclamationCircleFill: Wa },
      props: {
        percent: { type: Number, default: 0 },
        animation: { type: Boolean, default: !1 },
        size: { type: String, default: 'medium' },
        strokeWidth: { type: Number, default: 4 },
        width: { type: [Number, String], default: '100%' },
        color: { type: [String, Object], default: void 0 },
        trackColor: String,
        formatText: { type: Function, default: void 0 },
        status: { type: String },
        showText: Boolean,
      },
      setup(e) {
        const t = ye('progress-line'),
          n = C(() => (e.strokeWidth !== 4 ? e.strokeWidth : fQ[e.size])),
          r = C(() => `${ci.times(e.percent, 100)}%`),
          i = C(() => ({
            width: e.width,
            height: `${n.value}px`,
            backgroundColor: e.trackColor,
          })),
          o = C(() => dQ({ width: `${e.percent * 100}%` }, hQ(e.color)))
        return { prefixCls: t, style: i, barStyle: o, text: r }
      },
    }),
    vQ = ['aria-valuenow']
  function mQ(e, t, n, r, i, o) {
    const a = ge('icon-exclamation-circle-fill')
    return (
      O(),
      Z(
        'div',
        {
          role: 'progressbar',
          'aria-valuemin': '0',
          'aria-valuemax': '100',
          'aria-valuenow': e.percent,
          class: H(`${e.prefixCls}-wrapper`),
        },
        [
          Se(
            'div',
            { class: H(e.prefixCls), style: at(e.style) },
            [
              Se('div', { class: H(`${e.prefixCls}-bar-buffer`) }, null, 2),
              Se(
                'div',
                { class: H([`${e.prefixCls}-bar`]), style: at(e.barStyle) },
                null,
                6
              ),
            ],
            6
          ),
          e.showText
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-text`) },
                [
                  ve(e.$slots, 'text', { percent: e.percent }, () => [
                    Lt(mt(e.text) + ' ', 1),
                    e.status === 'danger'
                      ? (O(), Ee(a, { key: 0 }))
                      : Ce('v-if', !0),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        10,
        vQ
      )
    )
  }
  var gQ = Te(pQ, [['render', mQ]])
  const yQ = ce({
      name: 'IconExclamation',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-exclamation`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    bQ = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    _Q = Se('path', { d: 'M23 9h2v21h-2z' }, null, -1),
    SQ = Se(
      'path',
      { fill: 'currentColor', stroke: 'none', d: 'M23 9h2v21h-2z' },
      null,
      -1
    ),
    CQ = Se('path', { d: 'M23 37h2v2h-2z' }, null, -1),
    wQ = Se(
      'path',
      { fill: 'currentColor', stroke: 'none', d: 'M23 37h2v2h-2z' },
      null,
      -1
    ),
    xQ = [_Q, SQ, CQ, wQ]
  function MQ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        xQ,
        14,
        bQ
      )
    )
  }
  var My = Te(yQ, [['render', MQ]])
  const xA = Object.assign(My, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + My.name, My)
      },
    }),
    EQ = ce({
      name: 'IconCheck',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-check`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    PQ = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    TQ = Se('path', { d: 'M41.678 11.05 19.05 33.678 6.322 20.95' }, null, -1),
    kQ = [TQ]
  function AQ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        kQ,
        14,
        PQ
      )
    )
  }
  var Ey = Te(EQ, [['render', AQ]])
  const sm = Object.assign(Ey, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + Ey.name, Ey)
    },
  })
  let gE = 0
  const $Q = { mini: 16, small: 48, medium: 64, large: 80 },
    OQ = { mini: 4, small: 3, medium: 4, large: 4 },
    LQ = ce({
      name: 'ProgressCircle',
      components: { IconExclamation: xA, IconCheck: sm },
      props: {
        percent: { type: Number, default: 0 },
        type: { type: String },
        size: { type: String, default: 'medium' },
        strokeWidth: { type: Number },
        width: { type: Number, default: void 0 },
        color: { type: [String, Object], default: void 0 },
        trackColor: String,
        status: { type: String, default: void 0 },
        showText: { type: Boolean, default: !0 },
        pathStrokeWidth: { type: Number },
      },
      setup(e) {
        const t = ye('progress-circle'),
          n = Ht(e.color),
          r = C(() => {
            var h
            return (h = e.width) != null ? h : $Q[e.size]
          }),
          i = C(() => {
            var h
            return (h = e.strokeWidth) != null
              ? h
              : e.size === 'mini'
              ? r.value / 2
              : OQ[e.size]
          }),
          o = C(() => {
            var h
            return (h = e.pathStrokeWidth) != null
              ? h
              : e.size === 'mini'
              ? i.value
              : Math.max(2, i.value - 2)
          }),
          a = C(() => (r.value - i.value) / 2),
          s = C(() => Math.PI * 2 * a.value),
          l = C(() => r.value / 2),
          c = C(() => ((gE += 1), `${t}-linear-gradient-${gE}`)),
          d = C(() => `${ci.times(e.percent, 100)}%`)
        return {
          prefixCls: t,
          isLinearGradient: n,
          radius: a,
          text: d,
          perimeter: s,
          center: l,
          mergedWidth: r,
          mergedStrokeWidth: i,
          mergedPathStrokeWidth: o,
          linearGradientId: c,
        }
      },
    }),
    IQ = ['aria-valuenow'],
    RQ = ['viewBox'],
    DQ = { key: 0 },
    NQ = ['id'],
    BQ = ['offset', 'stop-color'],
    FQ = ['cx', 'cy', 'r', 'stroke-width'],
    zQ = ['cx', 'cy', 'r', 'stroke-width']
  function VQ(e, t, n, r, i, o) {
    const a = ge('icon-check'),
      s = ge('icon-exclamation')
    return (
      O(),
      Z(
        'div',
        {
          role: 'progressbar',
          'aria-valuemin': '0',
          'aria-valuemax': '100',
          'aria-valuenow': e.percent,
          class: H(`${e.prefixCls}-wrapper`),
          style: at({
            width: `${e.mergedWidth}px`,
            height: `${e.mergedWidth}px`,
          }),
        },
        [
          e.type === 'circle' && e.size === 'mini' && e.status === 'success'
            ? (O(),
              Ee(
                a,
                {
                  key: 0,
                  style: at({ fontSize: e.mergedWidth - 2, color: e.color }),
                },
                null,
                8,
                ['style']
              ))
            : (O(),
              Z(
                'svg',
                {
                  key: 1,
                  viewBox: `0 0 ${e.mergedWidth} ${e.mergedWidth}`,
                  class: H(`${e.prefixCls}-svg`),
                },
                [
                  e.isLinearGradient
                    ? (O(),
                      Z('defs', DQ, [
                        Se(
                          'linearGradient',
                          {
                            id: e.linearGradientId,
                            x1: '0',
                            y1: '1',
                            x2: '0',
                            y2: '0',
                          },
                          [
                            (O(!0),
                            Z(
                              yt,
                              null,
                              Yn(
                                Object.keys(e.color),
                                (l) => (
                                  O(),
                                  Z(
                                    'stop',
                                    {
                                      key: l,
                                      offset: l,
                                      'stop-color': e.color[l],
                                    },
                                    null,
                                    8,
                                    BQ
                                  )
                                )
                              ),
                              128
                            )),
                          ],
                          8,
                          NQ
                        ),
                      ]))
                    : Ce('v-if', !0),
                  Se(
                    'circle',
                    {
                      class: H(`${e.prefixCls}-bg`),
                      fill: 'none',
                      cx: e.center,
                      cy: e.center,
                      r: e.radius,
                      'stroke-width': e.mergedPathStrokeWidth,
                      style: at({ stroke: e.trackColor }),
                    },
                    null,
                    14,
                    FQ
                  ),
                  Se(
                    'circle',
                    {
                      class: H(`${e.prefixCls}-bar`),
                      fill: 'none',
                      cx: e.center,
                      cy: e.center,
                      r: e.radius,
                      'stroke-width': e.mergedStrokeWidth,
                      style: at({
                        stroke: e.isLinearGradient
                          ? `url(#${e.linearGradientId})`
                          : e.color,
                        strokeDasharray: e.perimeter,
                        strokeDashoffset:
                          (e.percent >= 1 ? 0 : 1 - e.percent) * e.perimeter,
                      }),
                    },
                    null,
                    14,
                    zQ
                  ),
                ],
                10,
                RQ
              )),
          e.showText && e.size !== 'mini'
            ? (O(),
              Z(
                'div',
                { key: 2, class: H(`${e.prefixCls}-text`) },
                [
                  ve(e.$slots, 'text', { percent: e.percent }, () => [
                    e.status === 'danger'
                      ? (O(), Ee(s, { key: 0 }))
                      : e.status === 'success'
                      ? (O(), Ee(a, { key: 1 }))
                      : (O(), Z(yt, { key: 2 }, [Lt(mt(e.text), 1)], 2112)),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        14,
        IQ
      )
    )
  }
  var UQ = Te(LQ, [['render', VQ]])
  const HQ = ce({
      name: 'ProgressSteps',
      components: { IconExclamationCircleFill: Wa },
      props: {
        steps: { type: Number, default: 0 },
        percent: { type: Number, default: 0 },
        size: { type: String },
        color: { type: [String, Object], default: void 0 },
        trackColor: String,
        strokeWidth: { type: Number },
        status: { type: String, default: void 0 },
        showText: { type: Boolean, default: !0 },
      },
      setup(e) {
        const t = ye('progress-steps'),
          n = C(() => {
            var o
            return ((o = e.strokeWidth) != null ? o : e.size === 'small')
              ? 8
              : 4
          }),
          r = C(() =>
            [...Array(e.steps)].map(
              (o, a) => e.percent > 0 && e.percent > (1 / e.steps) * a
            )
          ),
          i = C(() => `${ci.times(e.percent, 100)}%`)
        return { prefixCls: t, stepList: r, mergedStrokeWidth: n, text: i }
      },
    }),
    WQ = ['aria-valuenow']
  function jQ(e, t, n, r, i, o) {
    const a = ge('icon-exclamation-circle-fill')
    return (
      O(),
      Z(
        'div',
        {
          role: 'progressbar',
          'aria-valuemin': '0',
          'aria-valuemax': '100',
          'aria-valuenow': e.percent,
          class: H(`${e.prefixCls}-wrapper`),
        },
        [
          Se(
            'div',
            {
              class: H(e.prefixCls),
              style: at({ height: `${e.mergedStrokeWidth}px` }),
            },
            [
              (O(!0),
              Z(
                yt,
                null,
                Yn(
                  e.stepList,
                  (s, l) => (
                    O(),
                    Z(
                      'div',
                      {
                        key: l,
                        class: H([
                          `${e.prefixCls}-item`,
                          { [`${e.prefixCls}-item-active`]: s },
                        ]),
                        style: at({
                          backgroundColor: s ? e.color : e.trackColor,
                        }),
                      },
                      null,
                      6
                    )
                  )
                ),
                128
              )),
            ],
            6
          ),
          e.showText
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-text`) },
                [
                  ve(e.$slots, 'text', { percent: e.percent }, () => [
                    Lt(mt(e.text) + ' ', 1),
                    e.status === 'danger'
                      ? (O(), Ee(a, { key: 0 }))
                      : Ce('v-if', !0),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        10,
        WQ
      )
    )
  }
  var GQ = Te(HQ, [['render', jQ]])
  const KQ = ce({
    name: 'Progress',
    components: { ProgressLine: gQ, ProgressCircle: UQ, ProgressSteps: GQ },
    props: {
      type: { type: String, default: 'line' },
      size: { type: String },
      percent: { type: Number, default: 0 },
      steps: { type: Number, default: 0 },
      animation: { type: Boolean, default: !1 },
      strokeWidth: { type: Number },
      width: { type: [Number, String] },
      color: { type: [String, Object] },
      trackColor: String,
      bufferColor: { type: [String, Object] },
      showText: { type: Boolean, default: !0 },
      status: { type: String },
    },
    setup(e) {
      const t = ye('progress'),
        { size: n } = tt(e),
        r = C(() => (e.steps > 0 ? 'steps' : e.type)),
        i = C(() => e.status || (e.percent >= 1 ? 'success' : 'normal')),
        { mergedSize: o } = Vr(n)
      return {
        cls: C(() => [
          t,
          `${t}-type-${r.value}`,
          `${t}-size-${o.value}`,
          `${t}-status-${i.value}`,
        ]),
        computedStatus: i,
        mergedSize: o,
      }
    },
  })
  function qQ(e, t, n, r, i, o) {
    const a = ge('progress-steps'),
      s = ge('progress-line'),
      l = ge('progress-circle')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          e.steps > 0
            ? (O(),
              Ee(
                a,
                {
                  key: 0,
                  'stroke-width': e.strokeWidth,
                  percent: e.percent,
                  color: e.color,
                  'track-color': e.trackColor,
                  width: e.width,
                  steps: e.steps,
                  size: e.mergedSize,
                  'show-text': e.showText,
                },
                Nn({ _: 2 }, [
                  e.$slots.text
                    ? {
                        name: 'text',
                        fn: ze((c) => [ve(e.$slots, 'text', En(Rr(c)))]),
                      }
                    : void 0,
                ]),
                1032,
                [
                  'stroke-width',
                  'percent',
                  'color',
                  'track-color',
                  'width',
                  'steps',
                  'size',
                  'show-text',
                ]
              ))
            : e.type === 'line' && e.mergedSize !== 'mini'
            ? (O(),
              Ee(
                s,
                {
                  key: 1,
                  'stroke-width': e.strokeWidth,
                  animation: e.animation,
                  percent: e.percent,
                  color: e.color,
                  'track-color': e.trackColor,
                  size: e.mergedSize,
                  'buffer-color': e.bufferColor,
                  width: e.width,
                  'show-text': e.showText,
                  status: e.computedStatus,
                },
                Nn({ _: 2 }, [
                  e.$slots.text
                    ? {
                        name: 'text',
                        fn: ze((c) => [ve(e.$slots, 'text', En(Rr(c)))]),
                      }
                    : void 0,
                ]),
                1032,
                [
                  'stroke-width',
                  'animation',
                  'percent',
                  'color',
                  'track-color',
                  'size',
                  'buffer-color',
                  'width',
                  'show-text',
                  'status',
                ]
              ))
            : (O(),
              Ee(
                l,
                {
                  key: 2,
                  type: e.type,
                  'stroke-width':
                    e.type === 'line' ? e.strokeWidth || 4 : e.strokeWidth,
                  'path-stroke-width':
                    e.type === 'line' ? e.strokeWidth || 4 : e.strokeWidth,
                  width: e.width,
                  percent: e.percent,
                  color: e.color,
                  'track-color': e.trackColor,
                  size: e.mergedSize,
                  'show-text': e.showText,
                  status: e.computedStatus,
                },
                Nn({ _: 2 }, [
                  e.$slots.text
                    ? {
                        name: 'text',
                        fn: ze((c) => [ve(e.$slots, 'text', En(Rr(c)))]),
                      }
                    : void 0,
                ]),
                1032,
                [
                  'type',
                  'stroke-width',
                  'path-stroke-width',
                  'width',
                  'percent',
                  'color',
                  'track-color',
                  'size',
                  'show-text',
                  'status',
                ]
              )),
        ],
        2
      )
    )
  }
  var Py = Te(KQ, [['render', qQ]])
  const MA = Object.assign(Py, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Py.name, Py)
      },
    }),
    XQ = ce({
      name: 'IconStarFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-star-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    YQ = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    ZQ = Se(
      'path',
      {
        d: 'M22.683 5.415c.568-1.043 2.065-1.043 2.634 0l5.507 10.098a1.5 1.5 0 0 0 1.04.756l11.306 2.117c1.168.219 1.63 1.642.814 2.505l-7.902 8.359a1.5 1.5 0 0 0-.397 1.223l1.48 11.407c.153 1.177-1.058 2.057-2.131 1.548l-10.391-4.933a1.5 1.5 0 0 0-1.287 0l-10.39 4.933c-1.073.51-2.284-.37-2.131-1.548l1.48-11.407a1.5 1.5 0 0 0-.398-1.223L4.015 20.89c-.816-.863-.353-2.286.814-2.505l11.306-2.117a1.5 1.5 0 0 0 1.04-.756l5.508-10.098Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    JQ = [ZQ]
  function QQ(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        JQ,
        14,
        YQ
      )
    )
  }
  var Ty = Te(XQ, [['render', QQ]])
  const eee = Object.assign(Ty, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Ty.name, Ty)
      },
    }),
    tee = ce({
      name: 'IconFaceMehFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-face-meh-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    nee = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    ree = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM15.999 30a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H18a2 2 0 0 1-2-2Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    iee = [ree]
  function oee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        iee,
        14,
        nee
      )
    )
  }
  var ky = Te(tee, [['render', oee]])
  const yE = Object.assign(ky, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + ky.name, ky)
      },
    }),
    aee = ce({
      name: 'IconFaceSmileFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-face-smile-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    see = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    lee = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-.355 9.953a1.91 1.91 0 0 1 2.694.177 6.66 6.66 0 0 0 5.026 2.279c1.918 0 3.7-.81 4.961-2.206a1.91 1.91 0 0 1 2.834 2.558 10.476 10.476 0 0 1-7.795 3.466 10.477 10.477 0 0 1-7.897-3.58 1.91 1.91 0 0 1 .177-2.694Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    uee = [lee]
  function cee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        uee,
        14,
        see
      )
    )
  }
  var Ay = Te(aee, [['render', cee]])
  const dee = Object.assign(Ay, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Ay.name, Ay)
      },
    }),
    fee = ce({
      name: 'IconFaceFrownFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-face-frown-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    hee = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    pee = Se(
      'path',
      {
        'fill-rule': 'evenodd',
        'clip-rule': 'evenodd',
        d: 'M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.322-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM31.68 32.88a1.91 1.91 0 0 1-2.694-.176 6.66 6.66 0 0 0-5.026-2.28c-1.918 0-3.701.81-4.962 2.207a1.91 1.91 0 0 1-2.834-2.559 10.476 10.476 0 0 1 7.796-3.465c3.063 0 5.916 1.321 7.896 3.58a1.909 1.909 0 0 1-.176 2.693Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    vee = [pee]
  function mee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        vee,
        14,
        hee
      )
    )
  }
  var $y = Te(fee, [['render', mee]])
  const gee = Object.assign($y, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + $y.name, $y)
    },
  })
  var Oy = ce({
    name: 'Rate',
    props: {
      count: { type: Number, default: 5 },
      modelValue: { type: Number, default: void 0 },
      defaultValue: { type: Number, default: 0 },
      allowHalf: { type: Boolean, default: !1 },
      allowClear: { type: Boolean, default: !1 },
      grading: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      color: { type: [String, Object] },
    },
    emits: {
      'update:modelValue': (e) => !0,
      change: (e) => !0,
      hoverChange: (e) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const { modelValue: r } = tt(e),
        i = ye('rate'),
        { mergedDisabled: o, eventHandlers: a } = Rn({
          disabled: Vi(e, 'disabled'),
        }),
        s = J(e.defaultValue),
        l = J(!1)
      pt(r, (A) => {
        ;(Mt(A) || fi(A)) && (s.value = 0)
      })
      const c = J(0),
        d = C(() => {
          var A
          return (A = e.modelValue) != null ? A : s.value
        }),
        h = C(() => {
          const A = e.allowHalf
            ? ci.times(ci.round(ci.divide(d.value, 0.5), 0), 0.5)
            : Math.round(d.value)
          return c.value || A
        }),
        p = C(() => o.value || e.readonly),
        v = C(() => [...Array(e.grading ? 5 : e.count)]),
        g = C(() => {
          var A
          if (ir(e.color)) return v.value.map(() => e.color)
          if (Ht(e.color)) {
            const F = Object.keys(e.color)
              .map((k) => Number(k))
              .sort((k, R) => R - k)
            let T = (A = F.pop()) != null ? A : v.value.length
            return v.value.map((k, R) => {
              var j
              return (
                R + 1 > T && (T = (j = F.pop()) != null ? j : T),
                e.color[String(T)]
              )
            })
          }
        }),
        _ = () => {
          c.value && ((c.value = 0), t('hoverChange', 0))
        },
        b = (A, F) => {
          const T = F && e.allowHalf ? A + 0.5 : A + 1
          T !== c.value && ((c.value = T), t('hoverChange', T))
        },
        y = (A, F) => {
          var T, k, R, j
          const N = F && e.allowHalf ? A + 0.5 : A + 1
          ;(l.value = !0),
            N !== d.value
              ? ((s.value = N),
                t('update:modelValue', N),
                t('change', N),
                (k = (T = a.value) == null ? void 0 : T.onChange) == null ||
                  k.call(T))
              : e.allowClear &&
                ((s.value = 0),
                t('update:modelValue', 0),
                t('change', 0),
                (j = (R = a.value) == null ? void 0 : R.onChange) == null ||
                  j.call(R))
        },
        M = (A) => {
          l.value && A + 1 >= d.value - 1 && (l.value = !1)
        },
        x = (A, F) =>
          A > F
            ? m(yE, null, null)
            : F <= 2
            ? m(gee, null, null)
            : F <= 3
            ? m(yE, null, null)
            : m(dee, null, null),
        w = (A, F = !1) => ({
          role: 'radio',
          'aria-checked': A + (F ? 0.5 : 1) <= d.value,
          'aria-setsize': v.value.length,
          'aria-posinset': A + (F ? 0.5 : 1),
        }),
        E = (A) => {
          var F, T
          const k = e.grading
              ? x(A, h.value)
              : (T =
                  (F = n.character) == null
                    ? void 0
                    : F.call(n, { index: A })) != null
              ? T
              : m(eee, null, null),
            R = p.value
              ? {}
              : { onMouseenter: () => b(A, !0), onClick: () => y(A, !0) },
            j = p.value
              ? {}
              : { onMouseenter: () => b(A, !1), onClick: () => y(A, !1) },
            N = l.value ? { animationDelay: `${50 * A}ms` } : void 0,
            I = Math.ceil(h.value) - 1,
            B =
              g.value && e.allowHalf && A + 0.5 === h.value
                ? { color: g.value[I] }
                : void 0,
            V = g.value && A + 1 <= h.value ? { color: g.value[I] } : void 0,
            L = [
              `${i}-character`,
              {
                [`${i}-character-half`]: e.allowHalf && A + 0.5 === h.value,
                [`${i}-character-full`]: A + 1 <= h.value,
                [`${i}-character-scale`]: l.value && A + 1 < d.value,
              },
            ]
          return m(
            'div',
            Fe({ class: L, style: N }, e.allowHalf ? void 0 : w(A), {
              onAnimationend: () => M(A),
            }),
            [
              m(
                'div',
                Fe(
                  { class: `${i}-character-left`, style: B },
                  R,
                  e.allowHalf ? w(A, !0) : void 0
                ),
                [k]
              ),
              m(
                'div',
                Fe(
                  { class: `${i}-character-right`, style: V },
                  j,
                  e.allowHalf ? w(A) : void 0
                ),
                [k]
              ),
            ]
          )
        },
        P = C(() => [
          i,
          { [`${i}-readonly`]: e.readonly, [`${i}-disabled`]: o.value },
        ])
      return () =>
        m('div', { class: P.value, onMouseleave: _ }, [
          v.value.map((A, F) => E(F)),
        ])
    },
  })
  const yee = Object.assign(Oy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Oy.name, Oy)
      },
    }),
    bee = ce({
      name: 'IconInfo',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-info`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    _ee = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    See = Se('path', { d: 'M25 39h-2V18h2z' }, null, -1),
    Cee = Se(
      'path',
      { fill: 'currentColor', stroke: 'none', d: 'M25 39h-2V18h2z' },
      null,
      -1
    ),
    wee = Se('path', { d: 'M25 11h-2V9h2z' }, null, -1),
    xee = Se(
      'path',
      { fill: 'currentColor', stroke: 'none', d: 'M25 11h-2V9h2z' },
      null,
      -1
    ),
    Mee = [See, Cee, wee, xee]
  function Eee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Mee,
        14,
        _ee
      )
    )
  }
  var Ly = Te(bee, [['render', Eee]])
  const Pee = Object.assign(Ly, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + Ly.name, Ly)
    },
  })
  var Tee = ce({
      name: 'ResultForbidden',
      render() {
        return m(
          'svg',
          {
            viewBox: '0 0 213 213',
            height: '100%',
            width: '100%',
            style: {
              fillRule: 'evenodd',
              clipRule: 'evenodd',
              strokeLinejoin: 'round',
              strokeMiterlimit: 2,
            },
          },
          [
            m('g', { transform: 'matrix(1,0,0,1,-871.485,-445.62)' }, [
              m('g', null, [
                m('g', { transform: 'matrix(1,0,0,1,-75.2684,-87.3801)' }, [
                  m(
                    'circle',
                    {
                      cx: '1053.23',
                      cy: '639.477',
                      r: '106.477',
                      style: { fill: 'rgb(235, 238, 246)' },
                    },
                    null
                  ),
                ]),
                m('g', { transform: 'matrix(1,0,0,1,246.523,295.575)' }, [
                  m(
                    'g',
                    {
                      transform:
                        'matrix(0.316667,0,0,0.316667,277.545,71.0298)',
                    },
                    [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(202, 174, 136)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(102, 102, 102)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)',
                        },
                        [
                          m('g', { transform: 'matrix(1,0,0,1,-6,-6)' }, [
                            m(
                              'path',
                              {
                                d: 'M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z',
                                style: { fill: 'white' },
                              },
                              null
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1663.92',
                              y: '-407.511',
                              width: '143.183',
                              height: '118.292',
                              style: { fill: 'rgb(240, 218, 183)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1748.87',
                              y: '1226.67',
                              width: '10.895',
                              height: '13.378',
                              style: { fill: 'rgb(132, 97, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]
                  ),
                  m(
                    'g',
                    {
                      transform:
                        'matrix(0.182997,0.105653,-0.494902,0.285732,814.161,66.3087)',
                    },
                    [
                      m(
                        'rect',
                        {
                          x: '657.012',
                          y: '404.643',
                          width: '198.586',
                          height: '145.08',
                          style: { fillOpacity: 0.1 },
                        },
                        null
                      ),
                    ]
                  ),
                  m(
                    'g',
                    {
                      transform:
                        'matrix(0.316667,0,0,0.316667,237.301,94.2647)',
                    },
                    [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(202, 174, 136)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(102, 102, 102)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)',
                        },
                        [
                          m('g', { transform: 'matrix(1,0,0,1,-6,-6)' }, [
                            m(
                              'path',
                              {
                                d: 'M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z',
                                style: { fill: 'white' },
                              },
                              null
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1663.92',
                              y: '-407.511',
                              width: '143.183',
                              height: '118.292',
                              style: { fill: 'rgb(240, 218, 183)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1748.87',
                              y: '1226.67',
                              width: '10.895',
                              height: '13.378',
                              style: { fill: 'rgb(132, 97, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]
                  ),
                  m(
                    'g',
                    {
                      transform:
                        'matrix(0.474953,0,0,0.474953,538.938,8.95289)',
                    },
                    [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.180615,0.104278,-0.973879,0.562269,790.347,286.159)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '657.012',
                              y: '404.643',
                              width: '198.586',
                              height: '145.08',
                              style: { fillOpacity: 0.1 },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.473356,0,0,0.473356,294.481,129.741)',
                        },
                        [
                          m('g', null, [
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '202.62',
                                    y: '575.419',
                                    width: '124.002',
                                    height: '259.402',
                                    style: { fill: 'rgb(235, 235, 235)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '657.012',
                                    y: '404.643',
                                    width: '198.586',
                                    height: '145.08',
                                    style: { fill: 'rgb(34, 34, 34)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '202.62',
                                    y: '575.419',
                                    width: '124.002',
                                    height: '259.402',
                                    style: { fill: 'rgb(51, 51, 51)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '657.012',
                                    y: '404.643',
                                    width: '198.586',
                                    height: '145.08',
                                    style: { fill: 'rgb(102, 102, 102)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.473356,0,0,0.473356,192.621,188.549)',
                        },
                        [
                          m('g', null, [
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '202.62',
                                    y: '575.419',
                                    width: '124.002',
                                    height: '259.402',
                                    style: { fill: 'rgb(235, 235, 235)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '657.012',
                                    y: '404.643',
                                    width: '198.586',
                                    height: '145.08',
                                    style: { fill: 'rgb(34, 34, 34)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '202.62',
                                    y: '575.419',
                                    width: '124.002',
                                    height: '259.402',
                                    style: { fill: 'rgb(51, 51, 51)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '657.012',
                                    y: '404.643',
                                    width: '198.586',
                                    height: '145.08',
                                    style: { fill: 'rgb(102, 102, 102)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.668111,0,0,0.668111,-123.979,-49.2109)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(235, 235, 235)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(235, 235, 235)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(102, 102, 102)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(51, 51, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(34, 34, 34)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.668111,0,0,0.668111,-123.979,-91.97)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(235, 235, 235)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(235, 235, 235)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(102, 102, 102)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(51, 51, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '657.012',
                                  y: '404.643',
                                  width: '198.586',
                                  height: '145.08',
                                  style: { fill: 'rgb(34, 34, 34)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '831',
                                  y: '1023.79',
                                  width: '89.214',
                                  height: '89.214',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.701585,5.16096e-35,-5.16096e-35,0.701585,-546.219,-21.3487)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.558202,-0.322278,0,0.882275,1033.27,615.815)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z',
                                  style: { fill: 'white' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.558202,-0.322278,0,0.882275,1035.25,616.977)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z',
                                  style: { fill: 'white' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            { transform: 'matrix(1,0,0,1,418.673,507.243)' },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1088.34,192.063C1089.79,191.209 1090.78,191.821 1090.78,191.821L1092.71,192.944C1092.71,192.944 1092.29,192.721 1091.7,192.763C1090.99,192.813 1090.34,193.215 1090.34,193.215C1090.34,193.215 1088.85,192.362 1088.34,192.063Z',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            { transform: 'matrix(1,0,0,1,235.984,-39.1315)' },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1164.02,805.247C1164.05,802.517 1165.64,799.379 1167.67,798.118L1169.67,799.272C1167.58,800.648 1166.09,803.702 1166.02,806.402L1164.02,805.247Z',
                                  style: { fill: 'url(#_Linear1)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.396683,0,0,0.396683,1000.22,516.921)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1011.2,933.14C1009.31,932.075 1008.05,929.696 1007.83,926.324L1012.87,929.235C1012.87,929.235 1012.96,930.191 1013.04,930.698C1013.16,931.427 1013.42,932.344 1013.62,932.845C1013.79,933.255 1014.59,935.155 1016.22,936.046C1015.83,935.781 1011.19,933.139 1011.19,933.139L1011.2,933.14Z',
                                  style: { fill: 'rgb(238, 238, 238)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.253614,-0.146424,4.87691e-17,0.338152,1209.98,830.02)',
                            },
                            [
                              m(
                                'circle',
                                {
                                  cx: '975.681',
                                  cy: '316.681',
                                  r: '113.681',
                                  style: { fill: 'rgb(245, 63, 63)' },
                                },
                                null
                              ),
                              m(
                                'g',
                                {
                                  transform:
                                    'matrix(1.08844,0,0,0.61677,-99.9184,125.436)',
                                },
                                [
                                  m(
                                    'path',
                                    {
                                      d: 'M1062,297.556C1062,296.697 1061.61,296 1061.12,296L915.882,296C915.395,296 915,296.697 915,297.556L915,333.356C915,334.215 915.395,334.912 915.882,334.912L1061.12,334.912C1061.61,334.912 1062,334.215 1062,333.356L1062,297.556Z',
                                      style: { fill: 'white' },
                                    },
                                    null
                                  ),
                                ]
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(5.57947,-3.22131,0.306277,0.176829,-6260.71,4938.32)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1335.54',
                                  y: '694.688',
                                  width: '18.525',
                                  height: '6.511',
                                  style: { fill: 'rgb(248, 248, 248)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.10726,0.0619268,-1.83335e-14,18.1609,1256.76,-11932.8)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1335.54',
                                  y: '694.688',
                                  width: '18.525',
                                  height: '6.511',
                                  style: { fill: 'rgb(238, 238, 238)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                    ]
                  ),
                  m(
                    'g',
                    {
                      transform:
                        'matrix(0.316667,0,0,0.316667,269.139,37.8829)',
                    },
                    [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(202, 174, 136)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(102, 102, 102)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)',
                        },
                        [
                          m('g', { transform: 'matrix(1,0,0,1,-6,-6)' }, [
                            m(
                              'path',
                              {
                                d: 'M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z',
                                style: { fill: 'white' },
                              },
                              null
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1663.92',
                              y: '-407.511',
                              width: '143.183',
                              height: '118.292',
                              style: { fill: 'rgb(240, 218, 183)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1748.87',
                              y: '1226.67',
                              width: '10.895',
                              height: '13.378',
                              style: { fill: 'rgb(132, 97, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]
                  ),
                ]),
              ]),
            ]),
            m('defs', null, [
              m(
                'linearGradient',
                {
                  id: '_Linear1',
                  x1: '0',
                  y1: '0',
                  x2: '1',
                  y2: '0',
                  gradientUnits: 'userSpaceOnUse',
                  gradientTransform:
                    'matrix(-2.64571,4.04098,-4.04098,-2.64571,1167.67,799.269)',
                },
                [
                  m(
                    'stop',
                    {
                      offset: '0',
                      style: {
                        stopColor: 'rgb(248, 248, 248)',
                        stopOpacity: 1,
                      },
                    },
                    null
                  ),
                  m(
                    'stop',
                    {
                      offset: '1',
                      style: {
                        stopColor: 'rgb(248, 248, 248)',
                        stopOpacity: 1,
                      },
                    },
                    null
                  ),
                ]
              ),
            ]),
          ]
        )
      },
    }),
    kee = ce({
      name: 'ResultNotFound',
      render() {
        return m(
          'svg',
          {
            width: '100%',
            height: '100%',
            viewBox: '0 0 213 213',
            style: {
              fillRule: 'evenodd',
              clipRule: 'evenodd',
              strokeLinejoin: 'round',
              strokeMiterlimit: 2,
            },
          },
          [
            m('g', { transform: 'matrix(1,0,0,1,-1241.95,-445.62)' }, [
              m('g', null, [
                m('g', { transform: 'matrix(1,0,0,1,295.2,-87.3801)' }, [
                  m(
                    'circle',
                    {
                      cx: '1053.23',
                      cy: '639.477',
                      r: '106.477',
                      style: { fill: 'rgb(235, 238, 246)' },
                    },
                    null
                  ),
                ]),
                m(
                  'g',
                  { transform: 'matrix(0.38223,0,0,0.38223,1126.12,238.549)' },
                  [
                    m(
                      'g',
                      {
                        transform:
                          'matrix(0.566536,0.327089,-1.28774,0.74348,763.4,317.171)',
                      },
                      [
                        m(
                          'rect',
                          {
                            x: '657.012',
                            y: '404.643',
                            width: '198.586',
                            height: '145.08',
                            style: { fillOpacity: 0.1 },
                          },
                          null
                        ),
                      ]
                    ),
                    m(
                      'g',
                      {
                        transform:
                          'matrix(0.29595,0.170867,-0.91077,0.525833,873.797,588.624)',
                      },
                      [
                        m(
                          'rect',
                          {
                            x: '657.012',
                            y: '404.643',
                            width: '198.586',
                            height: '145.08',
                            style: { fillOpacity: 0.1 },
                          },
                          null
                        ),
                      ]
                    ),
                    m('g', { transform: 'matrix(1,0,0,1,275,-15)' }, [
                      m(
                        'path',
                        {
                          d: 'M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z',
                          style: { fill: 'rgb(196, 173, 142)' },
                        },
                        null
                      ),
                      m(
                        'g',
                        { transform: 'matrix(0.866025,-0.5,1,0.57735,0,-45)' },
                        [
                          m(
                            'ellipse',
                            {
                              cx: '-848.416',
                              cy: '1004.25',
                              rx: '6.062',
                              ry: '5.25',
                              style: { fill: 'rgb(255, 125, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                    m('g', { transform: 'matrix(1,0,0,1,183.952,-67.5665)' }, [
                      m(
                        'path',
                        {
                          d: 'M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z',
                          style: { fill: 'rgb(196, 173, 142)' },
                        },
                        null
                      ),
                      m(
                        'g',
                        { transform: 'matrix(0.866025,-0.5,1,0.57735,0,-45)' },
                        [
                          m(
                            'ellipse',
                            {
                              cx: '-848.416',
                              cy: '1004.25',
                              rx: '6.062',
                              ry: '5.25',
                              style: { fill: 'rgb(255, 125, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                    m('g', { transform: 'matrix(1,0,0,1,414,-95.2517)' }, [
                      m(
                        'path',
                        {
                          d: 'M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z',
                          style: { fill: 'rgb(196, 173, 142)' },
                        },
                        null
                      ),
                      m(
                        'g',
                        { transform: 'matrix(0.866025,-0.5,1,0.57735,0,-45)' },
                        [
                          m(
                            'ellipse',
                            {
                              cx: '-848.416',
                              cy: '1004.25',
                              rx: '6.062',
                              ry: '5.25',
                              style: { fill: 'rgb(255, 125, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                    m('g', { transform: 'matrix(1,0,0,1,322.952,-147.818)' }, [
                      m(
                        'path',
                        {
                          d: 'M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z',
                          style: { fill: 'rgb(196, 173, 142)' },
                        },
                        null
                      ),
                      m(
                        'g',
                        { transform: 'matrix(0.866025,-0.5,1,0.57735,0,-45)' },
                        [
                          m(
                            'ellipse',
                            {
                              cx: '-848.416',
                              cy: '1004.25',
                              rx: '6.062',
                              ry: '5.25',
                              style: { fill: 'rgb(255, 125, 0)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                    m('g', null, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.42334,-0.821763,1.11271,0.642426,-1439.64,459.621)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.40786,-0.812831,6.60237e-16,1.99081,-2052.17,-84.7286)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.26159,-0.728382,5.91642e-16,1.78397,-1774.67,11.2303)',
                        },
                        [
                          m(
                            'path',
                            {
                              d: 'M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z',
                              style: { fill: 'rgb(132, 97, 51)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.2198,-0.704254,5.72043e-16,1.72488,-1697.6,37.2103)',
                        },
                        [
                          m(
                            'path',
                            {
                              d: 'M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.707187,0.408295,9.06119e-17,1.54833,-733.949,683.612)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1663.92',
                              y: '-407.511',
                              width: '143.183',
                              height: '118.292',
                              style: { fill: 'rgb(240, 218, 183)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.74666,0.431085,2.3583e-17,0.135259,-816.63,57.1397)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1663.92',
                              y: '-407.511',
                              width: '143.183',
                              height: '118.292',
                              style: { fill: 'rgb(240, 218, 183)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '495.52',
                              y: '1057.87',
                              width: '105.078',
                              height: '91',
                              style: { fill: 'rgb(253, 243, 228)' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.750082,0,0,0.750082,163.491,354.191)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(132, 97, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(246, 220, 185)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1663.92',
                                  y: '-407.511',
                                  width: '143.183',
                                  height: '118.292',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.750082,0,0,0.750082,163.491,309.191)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(132, 97, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(246, 220, 185)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1663.92',
                                  y: '-407.511',
                                  width: '143.183',
                                  height: '118.292',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.750082,0,0,0.750082,163.491,263.931)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(132, 97, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)',
                            },
                            [
                              m(
                                'path',
                                {
                                  d: 'M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                  style: { fill: 'rgb(246, 220, 185)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1663.92',
                                  y: '-407.511',
                                  width: '143.183',
                                  height: '118.292',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                        ]
                      ),
                      m(
                        'path',
                        {
                          d: 'M555.753,832.474L555.753,921.408L630.693,878.141L630.693,789.207L555.753,832.474Z',
                          style: { fillOpacity: 0.1 },
                        },
                        null
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.750082,0,0,0.750082,236.431,272.852)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.64553,-0.950049,1.14552,0.661368,-1606.78,467.933)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(253, 243, 228)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.54477,-0.891873,1.05847,0.611108,-1456.84,490.734)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(132, 97, 51)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.27607,-0.736739,0.751435,0.433841,-970.952,617.519)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '495.52',
                                  y: '1057.87',
                                  width: '105.078',
                                  height: '91',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.728038,0.420333,3.52595e-17,0.377589,-790.978,151.274)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1663.92',
                                  y: '-407.511',
                                  width: '143.183',
                                  height: '118.292',
                                  style: { fill: 'rgb(240, 218, 183)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2726.83,1873.38)',
                            },
                            [
                              m(
                                'rect',
                                {
                                  x: '1844.06',
                                  y: '1192.54',
                                  width: '106.232',
                                  height: '92',
                                  style: { fill: 'rgb(196, 173, 142)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m('g', null, [
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '1844.06',
                                    y: '1192.54',
                                    width: '106.232',
                                    height: '92',
                                    style: { fill: 'rgb(196, 173, 142)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)',
                              },
                              [
                                m(
                                  'path',
                                  {
                                    d: 'M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                    style: { fill: 'rgb(132, 97, 51)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)',
                              },
                              [
                                m(
                                  'path',
                                  {
                                    d: 'M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z',
                                    style: { fill: 'rgb(246, 220, 185)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '495.52',
                                    y: '1057.87',
                                    width: '105.078',
                                    height: '91',
                                    style: { fill: 'rgb(240, 218, 183)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                            m(
                              'g',
                              {
                                transform:
                                  'matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)',
                              },
                              [
                                m(
                                  'rect',
                                  {
                                    x: '1663.92',
                                    y: '-407.511',
                                    width: '143.183',
                                    height: '118.292',
                                    style: { fill: 'rgb(240, 218, 183)' },
                                  },
                                  null
                                ),
                              ]
                            ),
                          ]),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.62765,-0.939723,4.80984e-17,0.173913,-2468.81,2307.87)',
                        },
                        [
                          m(
                            'rect',
                            {
                              x: '1844.06',
                              y: '1192.54',
                              width: '106.232',
                              height: '92',
                              style: { fill: 'rgb(196, 173, 142)' },
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                    m('g', null, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(0.479077,0.276595,-0.564376,0.325843,598.357,-129.986)',
                        },
                        [
                          m(
                            'path',
                            {
                              d: 'M1776.14,1326C1776.14,1321.19 1772.15,1317.28 1767.24,1317.28L1684.37,1317.28C1679.46,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.46,1404.46 1684.37,1404.46L1767.24,1404.46C1772.15,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z',
                              style: { fill: 'white' },
                            },
                            null
                          ),
                        ]
                      ),
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.61622,0,0,2.61622,-2305.73,162.161)',
                        },
                        [
                          m(
                            'g',
                            {
                              transform:
                                'matrix(1.09915,-0.634597,1.26919,0.73277,-299.167,-62.4615)',
                            },
                            [
                              m(
                                'ellipse',
                                {
                                  cx: '412.719',
                                  cy: '770.575',
                                  rx: '6.303',
                                  ry: '5.459',
                                  style: { fill: 'rgb(255, 125, 0)' },
                                },
                                null
                              ),
                            ]
                          ),
                          m(
                            'g',
                            {
                              transform:
                                'matrix(0.238212,-0.137532,0.178659,0.103149,875.064,207.93)',
                            },
                            [
                              m(
                                'text',
                                {
                                  x: '413.474px',
                                  y: '892.067px',
                                  style: {
                                    fontFamily: 'NunitoSans-Bold, Nunito Sans',
                                    fontWeight: 700,
                                    fontSize: 41.569,
                                    fill: 'white',
                                  },
                                },
                                [Lt('?')]
                              ),
                            ]
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
              ]),
            ]),
          ]
        )
      },
    }),
    Aee = ce({
      name: 'ResultServerError',
      render() {
        return m(
          'svg',
          {
            width: '100%',
            height: '100%',
            viewBox: '0 0 213 213',
            style: {
              fillRule: 'evenodd',
              clipRule: 'evenodd',
              strokeLinejoin: 'round',
              strokeMiterlimit: 2,
            },
          },
          [
            m('g', { transform: 'matrix(1,0,0,1,-483.054,-445.448)' }, [
              m('g', null, [
                m('g', { transform: 'matrix(1,0,0,1,-463.699,-87.5516)' }, [
                  m(
                    'circle',
                    {
                      cx: '1053.23',
                      cy: '639.477',
                      r: '106.477',
                      style: { fill: 'rgb(235, 238, 246)' },
                    },
                    null
                  ),
                ]),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,260.021)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fillOpacity: 0.1 },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,218.845)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,238.807)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(0, 85, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,257.804)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(29, 105, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform: 'matrix(0.428916,0,0,0.428916,19.0588,329.956)',
                  },
                  [
                    m('clipPath', { id: '_clip1' }, [
                      m(
                        'path',
                        {
                          d: 'M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip1)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.33146,-0,-0,2.33146,1081.79,269.266)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image2',
                              x: '50.54',
                              y: '112.301',
                              width: '112.406px',
                              height: '46.365px',
                              transform: 'matrix(0.99474,0,0,0.98649,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,265.448)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,268.45)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,271.452)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,124.262)',
                  },
                  [
                    m(
                      'rect',
                      {
                        x: '1621.2',
                        y: '1370.57',
                        width: '57.735',
                        height: '5.947',
                        style: { fill: 'rgb(106, 161, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,420.796)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,419.062)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,417.329)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,415.595)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,413.862)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,196.542)',
                  },
                  [
                    m('clipPath', { id: '_clip3' }, [
                      m(
                        'path',
                        {
                          d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip3)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.30028,1.12608,-2.25216,1.95042,68.2716,1030.07)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image4',
                              x: '50.54',
                              y: '56.312',
                              width: '112.406px',
                              height: '64.897px',
                              transform: 'matrix(0.99474,0,0,0.998422,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,216.764)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(0, 85, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,235.762)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(29, 105, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform: 'matrix(0.428916,0,0,0.428916,19.0588,307.652)',
                  },
                  [
                    m('clipPath', { id: '_clip5' }, [
                      m(
                        'path',
                        {
                          d: 'M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip5)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.33146,-0,-0,2.33146,1081.79,321.266)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image2',
                              x: '50.54',
                              y: '89.692',
                              width: '112.406px',
                              height: '46.365px',
                              transform: 'matrix(0.99474,0,0,0.98649,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,243.144)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,246.146)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,249.149)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,101.958)',
                  },
                  [
                    m(
                      'rect',
                      {
                        x: '1621.2',
                        y: '1370.57',
                        width: '57.735',
                        height: '5.947',
                        style: { fill: 'rgb(106, 161, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,398.492)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,396.759)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,395.025)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,393.292)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,391.558)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,171.832)',
                  },
                  [
                    m('clipPath', { id: '_clip6' }, [
                      m(
                        'path',
                        {
                          d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip6)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.30028,1.12608,-2.25216,1.95042,12.6215,1078.27)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image7',
                              x: '50.54',
                              y: '31.563',
                              width: '112.406px',
                              height: '64.897px',
                              transform: 'matrix(0.99474,0,0,0.998422,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,192.055)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(0, 85, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,211.052)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'rgb(29, 105, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform: 'matrix(0.428916,0,0,0.428916,19.0588,282.943)',
                  },
                  [
                    m('clipPath', { id: '_clip8' }, [
                      m(
                        'path',
                        {
                          d: 'M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip8)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.33146,-0,-0,2.33146,1081.79,378.876)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image2',
                              x: '50.54',
                              y: '64.644',
                              width: '112.406px',
                              height: '46.365px',
                              transform: 'matrix(0.99474,0,0,0.98649,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,218.434)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,221.437)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,224.439)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,77.2484)',
                  },
                  [
                    m(
                      'rect',
                      {
                        x: '1621.2',
                        y: '1370.57',
                        width: '57.735',
                        height: '5.947',
                        style: { fill: 'rgb(106, 161, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,373.782)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'white' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,372.049)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,370.316)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,368.582)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,366.849)',
                  },
                  [
                    m(
                      'ellipse',
                      {
                        cx: '1566.31',
                        cy: '1372.3',
                        rx: '4',
                        ry: '3.464',
                        style: { fill: 'rgb(64, 128, 255)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,185.45)',
                  },
                  [
                    m('clipPath', { id: '_clip9' }, [
                      m(
                        'path',
                        {
                          d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip9)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(1.36821,1.1849,-2.36981,2.05231,5.46929,1071.93)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image10',
                              x: '53.151',
                              y: '30.14',
                              width: '106.825px',
                              height: '61.676px',
                              transform: 'matrix(0.998367,0,0,0.994768,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,183.729)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z',
                        style: { fill: 'url(#_Linear11)' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  { transform: 'matrix(0.407622,0,0,0.407622,47.38,278)' },
                  [
                    m('clipPath', { id: '_clip12' }, [
                      m(
                        'path',
                        {
                          d: 'M1461.07,554.317C1461.07,556.747 1459.6,559.067 1456.6,560.8L1342.04,626.943C1335.41,630.767 1323.83,630.287 1316.18,625.871L1205.33,561.871C1201.14,559.456 1199,556.361 1199,553.426L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,554.317Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip12)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.45325,-0,-0,2.45325,1068.82,410.793)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image13',
                              x: '53.151',
                              y: '58.978',
                              width: '106.825px',
                              height: '33.517px',
                              transform: 'matrix(0.998367,0,0,0.985808,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.371452,-0.214458,2.38096e-17,0.495269,-19.3677,248.256)',
                  },
                  [
                    m('clipPath', { id: '_clip14' }, [
                      m(
                        'path',
                        {
                          d: 'M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z',
                        },
                        null
                      ),
                    ]),
                    m('g', { clipPath: 'url(#_clip14)' }, [
                      m(
                        'g',
                        {
                          transform:
                            'matrix(2.69214,1.16573,-1.29422e-16,2.0191,1352.59,983.841)',
                        },
                        [
                          m(
                            'use',
                            {
                              href: '#_Image15',
                              x: '121.882',
                              y: '76.034',
                              width: '37.393px',
                              height: '61.803px',
                              transform: 'matrix(0.984021,0,0,0.996825,0,0)',
                            },
                            null
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.371452,-0.214458,2.38096e-17,0.495269,-15.0786,249.972)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z',
                        style: { fill: 'white', stopOpacity: 0.9 },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.220199,-0.127132,1.41145e-17,0.293599,339.708,327.53)',
                  },
                  [
                    m(
                      'path',
                      {
                        d: 'M1306.5,1286.73C1307.09,1285.72 1308.6,1285.48 1310.36,1286.12C1312.13,1286.76 1313.84,1288.16 1314.73,1289.7C1326.44,1309.98 1355.4,1360.15 1363.73,1374.57C1364.33,1375.61 1364.49,1376.61 1364.18,1377.35C1363.87,1378.09 1363.11,1378.5 1362.07,1378.5C1346.41,1378.5 1288.17,1378.5 1264.07,1378.5C1262.42,1378.5 1260.37,1377.48 1258.9,1375.94C1257.44,1374.41 1256.88,1372.67 1257.5,1371.6C1268.1,1353.25 1296.8,1303.53 1306.5,1286.73Z',
                        style: { fill: 'rgb(245, 63, 63) ;fill-opacity:0.9' },
                      },
                      null
                    ),
                  ]
                ),
                m(
                  'g',
                  {
                    transform:
                      'matrix(0.254264,-0.1468,1.22235e-17,0.254264,329.57,364.144)',
                  },
                  [
                    m(
                      'text',
                      {
                        x: '1170.88px',
                        y: '1451.42px',
                        style: {
                          fontFamily: 'NunitoSans-Bold, Nunito Sans',
                          fontWeight: 700,
                          fontSize: 41.569,
                          fill: 'white',
                          fillOpacity: 0.9,
                        },
                      },
                      [Lt('!')]
                    ),
                  ]
                ),
              ]),
            ]),
            m('defs', null, [
              m(
                'image',
                {
                  id: '_Image2',
                  width: '113px',
                  height: '47px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAAvCAYAAADU+iVXAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABVUlEQVR4nO2aQRKCMAxFxUN4O+9/DNw4CoiTliZN8vPfQlm00ykvP3aQ5fFc11sjy/L+/nx8r3ffm7Fn845jz+aJa23XOJvfs9Zh7NBawv3YrSGtdbj+x10egkFzpRrNt+SSxMgbqkiZJCJDiQDoSmSfdYFJ3JD18GMmcXhDTHUzNZIIXhA1JIJDib0MptqiKbhKzHqQiAaT6IlSFVIiAJQIACUGpLfLhpfIw49Ml8T2v4/JTPySyIJQI3w7JTIYEp2fong3FXWJ3huqCEYSNUlYhZRoyaSCoEQAKHESlqF0kZj9NBgNJhEASgSAEgNx9WfCTmLxpygzYRIBmCORsTIlXxJZED/kk0h+KC1x9E2FKG86qEkMsh8/HG9A6SSGYqAIKDEinUIpUSDDYXiqxAw3JCNMIgDXJTIWYdBJIvukK2ynARit4XASUZ6izCScRFWKCH0BfLM84oTw1Z8AAAAASUVORK5CYII=',
                },
                null
              ),
              m(
                'image',
                {
                  id: '_Image4',
                  width: '113px',
                  height: '65px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAASeElEQVR4nN2d6ZbcNpKFL5cs9UN1W5bntWxr6XmsWTzLQ7mSJDA/gh/iApWyLalUy+AcnypVJkEAsd24EaQn/T8Yb9+XKknrOuk4pOM4tCyLpkkqpWpZJu170TzPKqVoWWZJUq3Sbx+m6VkX/wjjVW/gH7/sdZ5nTacc5lkqJT6rtWqaJtVaVUrRNE26XGbd3+9alkW1Vi3LrFKq/uvj/KrP4dUu/t3HWkupmuepWVspIcjrddc8z1qWWcdRTusLwc3z3Cz1OA5dLouOo+o4Dv3vv15e5Xm8ukX//eetTtOkdV20bWFVkrQsk+ZZOo74Xq3SNMVPqXextYal1lq1rrNqlfb90LrGXP/5/nW52Fez2B8/1FpPiSxLLLsUaV2lfZdKiZiHkHCtuFWPj/73cvpfLDQseNJxvB43++IX+cOvR5WkZQkBbdsh4uCySNtWWkxEuLVKx1HOuLecFjdp3/NnWiYKUbSuAXiOIwR8HIf+55/riz+jF73Anz7VWkq4RSkEI+m0Fun+ftflsra/r+usfY/fATVY3DzP2ratCe3Nm7UhWawv3KzO69PtllJetDBf5MJ++hRHWWu4QCkOm1h4HH2agJuVpHme2ufHUXS5zLpeQ1B8Ns9zu2ZdU3gAJdwxFh3zxjUv0cW+qAX9+KFWhMV/Urg6kCUWcxzpRvlsmno3ehwBVhDKcWRMZQ6uQ4D7HsgI1MrcDIT/koT5IhaC28T17fuudV0bWAmhTJ0QpN56ti1cq4MXSR1wiWv6+ChJ12ukGpJaunG5rJpnad9rm+NyWVRKgqiXQhQ8+yI87pEicDQIRApAg3US60gvPPYhbBceqYTH17DEo8VLSVqWTFGmKdKOZVm0LDKlqIaEQ+GeO798tpu/fV/qPE+nCwwLiwNVi1FhCaUJIFxbury7uxAiwrled0k6Dz6F78J2FgcBk2qs66J9T/QrpRt2MoH7RX6ZXuO/Py3Pcp5PftMffj0qdBeHF4AlXJwU4ETSGavUMSsAD1AlqYDHvut1P61y6QRPMg/g2bbSudnJvCNCgmsFQKEE8Z2p+1x6Hi72SW/47mPk6/u+txwNa4vfpw4hYi3Lok7AHBiHCfjArTr6ZE4Sfr+W+aVAqQgVpUCJJBQq1kas7FFxAqTLZdK//fx0wnySG/3LP2sl1uEKU4uX9r1Siu7uliYwhHwctR0y1zmz4gwO80gp3OM4dHe3NqIAy3R36kjX4yvVj31P4OR0HYJluPVOk/Qfv35/YX7XG/z4IVSVQ8d11lp1ucydsNxlLsukbQth4zLnWQ8sA85zWZYm7LCiiFEp7J6O477rOul6TU5VUpdHjgJmL4QDKiGxzmSP3OqJ8d+Tj/0uE//w61EBI57jSWldUk+hxWc9OR1Wk+4WYWNNaD2jlNKsxdMOEnZJ7dC3bTcFmZpQSimNzXHl81ok7tndvAOlW8KXvl9u+eiTAlyoIozuB4DhrAt/w6qkdL3kb1Jymli0xzSH/Vi153QcLqmJX0t6c70erTqyrusfKhPEggOjmGvqANAIxNZ10r//8rhW+WiTkTI4iCDuOGAZ+U8osXWddH+/twMn5iEIeFEswasRkroir49l4cDVhM/Bcshc44LwCkcKZD6tfW75JHN6jRJlQnld+NzzOB4vJfnmSd59rHWMTwEkFh3HeDBxDVaIwB1JjlxofhZCj0pG7bQ9508rIH+bJq6JU/eaYsybaczd3dJVRXCZpajVLhEMua2j5VueIeZxAqNXnlrrNwvzqy/+6VP1s+6Sdnpd/LAYxJ1lWbTv+2mpc8ekeOz5XJINkPEknbSABN/dIfFrniddr9uZm65tPudsGS4gLyqzX9ZTSgIq9iipoWfQKyGm1qyDxn2+DcV+1YU/faqVxbEZL8Iy3AURV0Z2Bgjv8aPW2iyJgbDcejk4YiCQnwEH6gpGuuHxknV5GAApe+rhjBIM0Zs362dJAwTM2uNzNWAnPQRtX1Py+qILEJ4kXS6Tfv89ER6D2ITLjEPpSWjiCL8DXvhezrO0eIhuJILNQ6IqUUqS2lJAfikQKWi01tq5enJBXKQn/SiK57LO3XrvDvdxZgfSAC+xbXvjat3K2a+fyZe42L/0RfI94sO+H11S7ptzwDFCbQcKHuTTitVZhR+g/x13u+/HGaPWJtBucwZOGNQXmddjl9cYr9fjjIlzQ6EolO9vjIHM4Yo65o6+L1CuK76j2b+SlvzhF959rBWEySY9r/IWBxeapJsxgs9gP9y6cHlj99q+9zwow8tRzIFr4l4jqHJkPOaAzOFzOnjy3z3ZZw73HJwRQM/PZZzLz5bwdH+/6e7ucirDnxeiP/shqPN63U1rMo5J6nI/YgiaD9IbUahX19mwI1dHp+6SRvDgBzIWbaHvIu7VB4dIHCwly09es8TF46JZH6AJl4i18H2KyMuS83tbpSvXuk4nKs70ybGBnwWe4XPx8sEf//7zVtd17YAKNJgjPrSNSjqCy5bBjBmx+FyUC5IxghyPM1w75nMIxF0v6yVmjqzQmJT7YaKYYdUJtCQ1ZaKjwNMPZ4ig+dwlxv6mdi2CJm0ZvYafnYcg1jNWSto/3r4v9ZZms/HRlTjKQ0ggMQcCXhPctiwZObr0+7iC8D0npEHCgBuGu0f+/ebN2oTh1ZFQjhAUwvBiMMriB+kpTwi1z1P9++wF0OSAB4HggpkDz+WKFF6uV2z3fljm5IgTM0ZjRqQ2ukKPDSzO3aa7orHhyGONI8FsR8wD8Prfus5dh/donX4PDjYtZ+q8ixecHUl6l/jIf8LYcOC33Dnu2lOQEEAqsKPymPchNnDBj/2yDnwmmnK9h2WEzLhWhifcnvDimm5B5xH0eFwZEah/lw2wMdryuX6sMKTVBnrl87E7oFZ1uagDHPZIDuzC2/eoF+57368z5pPUTDGMUaHhjdnPSNXhacbvO4BrBoNWQEthUQ7NXSNCcHHQYSnxtzjgZFxG7eU+6S5n0856WmJfaOXacKHTef/ZWJ4ERB4BYv0xN4IJ96fu4CC5Y/299W7b3pRx33cdx9GUwKszpFnpVQL8ZQpTT4XILvTLJWuRtVZdLuvpcY4GchAg3wnsQdf7fLJiZ7nucoleTvpViEfRbLurlKJ9P0R9zjcQ2l5PTcxDpIgaLjc/QFvRqlLKqWW90gSY6asBbNoJ5/QYcd3lMneQnYNIIAQhjkLoTAVK21+eQWrF5bI2yO9rZB8BpNxT8GwITExt3kuKpmcPJft+nCEj8QHnOU2TLpelU7JQdhR60gzHSWCPw4kvRNse6Cpb58NNhN/3+MXNp4lmpfk8uIxzjiyzWiCt63JuPONcBPjpVCSaoJhrOQ+otPgUrj3dZ+ynnGWp0lkTQMsbo6KaklYFmYBFuXsOoKS2/rT+uSl74Ae8SQhynjPnDYusZwpVTmFmTJXCC4T7zHXFd0u754zv9aQ6hJDawE1i0nrGtNHNzp3Gx3dDMwJKT6ebqJ2WpSstLb5SPkLYcbhrs66Ma7W7p1sdG5+mqeV2d3f5eFsp0UcKp5nxWuf9lnbYXjCutbbQwz7dK3C4t/7tqBdwlLhj7lgkUheUi/RlXRMLtNDkQuDQ2EwejE6Txh0Gyrpe9xYj0MrrdWtaFDeSKcbcDrBPvp2P7BXBlQPrgtlY16nrYNu2ox22K1Ek7rV5m5hD5uZAxulmM16lN7hcLlpXd9mJavEarBe37fGbGOasUn/mx2mpkPJHM6DoWCgNaHEPSZoxSQIrpr8sKcTQjocVgiAFKPMEyPnb3y7NbXiciU7qkTlJITT/PmM5STaQNzn4Oo6qbStdyoOg2XgSErWzOD+MzHOnM/bXbn2wOl4uC1DUK7S7PI/5/MTL8W/iIvdGwblH/7SXt3hSgMjcc/7twzQFsKhnHOu7zxws3mIWvM/kONRATghy7jbM4XBAaDNaz+/ExQQ2vav0DjMs7+5ubRZfStWbN+tpFRmTwhVu56GGJUfYANpHQTs9TD1jYW3MET2trCNqolCEEXe3bX8Q23wsy3KS9tNZ2chqTICsuB8MkbNEefY6UfCUjA09oeR+TjPBRDhMJj/yZHesQLjvHvnDyHcOcz+525HKg3DgQBB23BNSvafFXPHCivdWe/T0BCKBkEDO5wfrMZ690k7iBLfv2+/Nnih3ZZqVzV6eQ2ca1VOfyAVlpYPuAXf6w69HRTDOSUJ1OUODK4VJyUCftUQqERRnnTz3p47CctON4Ipo9/BnIjzPQ3mc2+WQ6d9hH5DiHJz37XDIsf5UNhTTFQY35uuE4QqFedgoxVhX6f4+FS7z2KPjSsdaLGSF9Afc6Tho+B0tKm6Q7A6jTzN6rXRqzVGVL9gZDRTBm4wkDe0cbm09COO7zsZwyM6lIhj3QOMenT1yxiisI1MtUD50JHO612B/sz04RGbg/UCu3G6lnytJfVaIDIhxKUtPvmkHFH6QuLVbLfmOEhGCF0bd/2MJY/u+Wyqbj8/yIFAsn+9WYXp0b27NiQbVXR/INSx726L+xx5w3azLH/Rx78Y8biBO03nnwB/VFP9UiFI+N4/b+1wNzA8AV0Tux8K8y8sJdCeV4T1HlwPmwn07F+oCxI17DB3LQAyvdXa51/A01Gjld3fe/9P3lUaumUqO1/E+G+ZBuM6fEo+lv9Zw/JeEyHj7vtSE6KW5tlhYDwhwB+5SvGDsKYs3XAVK7J+7cMDi7i0P0d9Tk4/Lcf3Y+uCIGqGS81FZGEEE8SnnDJxwf7+1RN2TeI+3faGgXzfM0RiyvqRb/IuEyPAne/0gvGbn8XAM0qNFjMjSEaWDFag7Ns3fYo5wYR5fODzosh6mZ58se0iXP3VKABd8qyls7FCgQoM38aIwrvXubhXPjYT1hiAvl+WrWhe/SoiMdx9r3ba9FYcdsPATq0MLSV04SEeCoE93yxyAIzxHjMsy6XpNAQaAWdr3cYNYqb/ACEXyZzWSe+1flcKAfPBWjFt9SCPwGoGUdyIg/K99Q8c3CVFK4DPmiuNz8xRzqbGND7k4MMFyvJHJEWBel+4JZcLaoarI/WLusWUkrdJDgIMdVybAjyNp0iLQqgvM+2K5npqkM1ff+qDNNwuRwZNQkiO51OQR+IyFUM+r+mfk+2Ymb5kYXVm3MQMitxDo+HQVa/Jiredmjh79+35fqvUoknce4GkgSEopj/as/6MJkfH2faluhYAF75qT+ke66TDzxByXOLpD4qbnpWPq4vkWvUDjsxOOHhGw9w8FNTbdtGLefeO4AKtjnW6hxHvW+tiPhD+6EBkgWafi0NxMqLMxV1JzO/nSvRDMSGUx3NW5sBwZ8293Y2Mvq6PbsbKQCHlurNDIEI05rOefTliU8n3eTPXdhCipPXQDqPEOs/FgsB7i3mGMgLfCe46aaDIZfY9rntLwaJv0UHnGFAIheC+QP3rnDE78VKsNEoOdTqz1+76Q4bsKkfHjh3z8jYP2eIF78u4zb8N482bV/X0++CllY7ET0t7z6k1bWA6oOL4TPz2mpkt/yBG7O7/VsXeLbXqqF/w9iRAZvCk4qyL9YUk9HUZMcsAwHhYgyHNCrMU5Tql3dQjM06Jb77FhjZ97xM4JArzIND3tO1OfVIgM3tntVsWIikc0JXkJa3y2A+33vM+tydkbKd359Rrm+rlccryPs0kjIxPr7b2HpCd/KdGzCFGKlCRLTA9fTuSVhs/1nYIo/ZAdaY6v9fL6IDVLYh41O3JcrIoOB2I3aQgx1K99ited3BrPJkSGv0k/QU1SXaBIJwPGOOYpRyLTqfs+sdObgD1l8WqL1yoldUwQXgHhS8//xsVnFyLjxw+13mJn/O1Okk5O9eGrouuNup2/+MgRqZeaHAzxXQTtL2tAOUh7njru/dG40QHyPOO3D9ME6EGAPUUWLvH337cmJBJorwyEi0xrTlaIZuVDNCtfr4fot6EXKB9Xyw6+7FxLxXopApRekCX6ePexVtzc+MZhSc1KnEgAzUpZb/SHVp3IdvLZLXPsOhgrM4/Bc36P8eIW5IP/9wWW5+S354hSz6z4+25IJ2BzmCuuiZ+AFn9x4EiKv5QX1N4aL3ZhPqDwvN/H63vENqe6kgbrCXAHObcq+k504w1eovX5eNGL8/GPX4KJBpXi4oh/lLrGd7tRdIUsx7L89SjEv/EFuS9deIxXsUgf8LF9p3a+o3TsO3UOk1eQSLQY5iulqXpIz58yfOl4VYv14awPeZ0XpEnE+Y7Hwuw4ry33k16f8BivctE+/H8/5IBkfLmfv2Wf3NIF/ZKBy5+NV7twH2OVRPJH1fp3vsG0IMTnevn6Y47/AxX1K5XSf237AAAAAElFTkSuQmCC',
                },
                null
              ),
              m(
                'image',
                {
                  id: '_Image7',
                  width: '113px',
                  height: '65px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAMrklEQVR4nOVdW2LbNhAcUD5Xkl4scXqxpr0XiX7AQwwGu7Rj2RLV7o8lknjtc3YBygX/Afr2XOu2bQCAZVkAALVWlFJQClAr9mvLUrBt7R4A/Hp++fDA9NAL+PpjqwBQSkF9kVQkOBIFx2vLUlDr4wvyYSf/7blJghanglFLc9q2DZfLgnXddqvl9X/+vDwkPx5u0l9/bFWtTf+q8Hidwt22DaWUXYCtj3H5bPNolvkwk2Xc05hHcjep1yk8Fy4tksSmfH5ZCv768RjCPP0k3W3ysxKFtSwLaq0vAGYZXC2vtefHmKn9Lkv7TKt+BKs89QT/+FnrtnVECYwghuRukfcpOL1N4fgzrZ/umgHsbvfsVnnKiX35vlYFHUpMJQAMwMQtqpSCdV3x9HTBujbXSUUAZmVQa876A84ZL081oS/f1+qAQwGLusx+vz/rSNUtbk5FZvccpSuOdmut+PvnchrenWIidJvAKJRIaPpZY6B+Z/6nAlBrisjjp4KezKWfRZB3n8QfP2tlKuBWAHS0SMZqOFSAwu+R1QA9sVdhupA5riNapUjY946Xdxv823OtHnfIFGp+lv+pZSiaZH/e1gVIlmseCXRBk1SBFO26i6fA7xUvbz4oS2UABoaua699ZjFK25CJ/NzajukBgMmNerzUNuyD1Rw2U6XR/ihAzhu4D/C56YDM+QAMDMqScrUiYMzjiDjVmjT2aTLvlhtZLeOvI9RufWWyRCUt9906Xt5kIFpf5uaUKarlR0jUy2p+X2Nh62+2bi3faaxz1JoBInf1nr/WWm9Sj/3UAb7+2KrHo6hC4gJ0kAOMwMSf0RwwSgu8isNrDpSU1KIVBY9zX+Rz9xAaP3n/My3zUzrWOqdbhLpGPqMuFMhjkGu8pxZRKuE5H0ljYFaC0z60b8ZNutllAbatC1PdcxurPftZgvzwTnWDFuhJdSlzHFOozudGsHBsxeMYc5xiHxm6jdyx11mVojHVkt2zaJ/6+aOF+WGdffm+7hu0zrB9sCC2ULiRNUUF6fa5l9H0GjCX4nRsF9BRPsj2kVC8fyofx88KC5/lYq/uhPt7zni6FFoetZaCjQU2okPgWBBqtXrfXbczmP2qmz7a5oqAVwR6Mkv1Zz3eXpuWvLux7jBwog7bIyKTNaboEjQ+7ZMUl+RQnvdVYTKE6S48AiD6LOepwMmVTfs6Qsw+P1/XNVb5roaa7wFjzIqAgloHidaoRyUiVOruz9MOIE4ZpoVapcfben9ODpAyC9M+dc1UWmCuDGnb9wjztxqo65wXNqcNUVDXeBmdc4kWqsKLQBL78zIcx6U71aMZfa6xW86uOeKOarU6R3fZ6n2y3Bj4vcrPmx789lyrx7QsH9OFXC4F6xqnGBHo0aqJCihzpa+hV33OEWpk/ZGFkJWeh0YVI953ZSU+UIGyzeVSQDDvHgF4m2UePsAiNRmoNUXX9NcOIDkTyJhs0R782/PxZzLAtZ3XNYXxeKhMzRivfbW1XlKX/1oakn3XsVyxXtslSW+q61QNjayv1oqnp+VlMnGVxRnnwEKFQAaocFQx9BkHPWSIV1OyfUUfb2KQeRnPL13wJHWrkedyZY3auSfKrHK6mIEW7YyTd2txbVbw0vuL9/1GxvXPtG510W3xs6X4wtXyiJo9Trml6jo1vqqCaHvOVcd1AWdgz/FFBu6cTx4v9y9R3BsZO2uPCkM1Xl1vhvwi16j967PKKP0cxTMFFC4k9umxl8r2lvlmTPa4TXIBet+RG414wvbqrVhcL9xZ10Hcuo6OO0QD8/MoiNnqdIKZ4pB8AY4ql4VKNQ0zzU3XGrlgjdk6F80ds3VxHd6vto3G8fyTc4x2ftimlLYRXfx9Bg/+RxoRAYMIYUX3IxfdJz6fOHPGt+8Yis9jSjDHnAzRcj56cDg686NziEALKQNdLhQKg89oKVHvR25+2BPVCXECOvkuVGWyl7fmZF7jUCljfNB2nem8P277aIzhuG0BdJ0ag0bm6PEKlQX7dNR6uSwTCGLb7gEU0I0xMFJQzoHt13Xb16BEdE8Z1NpPOyiPW1/kbVOUJy6+MaUMGuaW1jvE3hlJNYptIhfZJ6CId0aL/XhEmdqy7yjuRrlnmz+ZU3amKVCJ5sO+lZlRESFCvbyuSuHgiXzkGN3tLnt7kuIN9zBPFIpqfktkL4NAI4TlVRXVDk6ScYBMIXEBbMt9RUd8ruVdaGXoT4Wsa1ENZ36nCkjk7IwZ4/Wcv+l1pVHZ66R4kZtuAtKxxudU4I7qSylYdHK8p9pNBvRFjh3rgtpkutvRwTtYKnJPraYrQ3OF82I5R3V1zlB3b02Rln1MjtUtYi4ucA0zSi7Wd//chD4K0EOClyL7sx2YqWA7Nhnz4a7kbdyFDSh9jxMx7MYuMHdZFAQnNrYru4A4MQBD+SqD8XroieMrc3Ujms9qfFXLJwP6urcpduv8KVi9766xucMYuLkSjC61DoqrMX/Mr0fF7Ir24k5ZBxy1I/bxbn1uGRHkBub9ui60Lnx+VjfJ/hXWKyR3N6fITZmpcZ9/+wszfc9ThcM41ePQnMwreFJBUYk0DXIBdtc5sGxYp7r+plTtu26PLb+eS9Fis1pes6hZc2gFZEhHq8s+GLWTWtMtaazAaL9kJEmhvgZ7R6M9PleJf8uLhVe48ilq1O+cqwqBHqqHmrIrjzJdleNy6crl6+acPZy4B+S6xnl2DzEAOH7gyywKWrzyoaiwI7h8OyY6/qBWM2rtnJvRerLjGGOs7Qm0H0T2Z9RiIytRiqzHrU7bRWiXbfnXT+dpH17A8KOd6g32io1PmoVvAFjX1VxbXAgYAUpvq2hQ6WhfLXc5M9DxcSOXFjGabfW6CjUqcGTz8XU3IY3u1wERkKc4vn72rWN6IXxWvRfSQngWrFWjfTG+aPZ2lFtFWsrJ6zjqLbQUxTFG1DimGmq97hK1LRALVj2HMz1atyuok3o8XU+0qZ5tFKdCJOm7EzqZyGqUGdGiIgaxjbpMzS3VYltfnEd3tRq7FOFqnOHzylivZWZzzcKB3su8hc5TQ4saQOQu3WCOdvpfFSLQD0VlKCsThPrvvtjxJRqPmd6nMydihraL4mAkkGynnVbrrjD6q3OLGD8x+6AvnyObv+W1uTcJkcSd/sjslZFR3Iqq+srQ6Liiotr2fY4vc/yMT75pm+hsaCk9pXDhZ3E5U+bIUx3FPi+8v2U3X+m3hEji9pW6uKOJRxpHxmg88A1gXfDR+ZouiDnuaLw8iu0TY4LrPjb78L5UOTxsRHxQPr3nDOq7hEjyHwaKDjpFsTJzJZGL3Cdaeo7Fw1fRM1FKQWUBxkIC73Hu0Y8zeExrfcRbVUcuNVN4Heu9h4ivEiLQUawDhkAOALRgsEzxTZ9xrScz94kbkFGA47sb6g5Lab+q0Sw9Pi7ZxxjzP68kqTVyHvxOPmTHULgPClz/YurVQiTpu/fDAAkQcMa6Fkcbq15XVQFGxwd53wGIx0udBxAXFzxdorJkz+kcVMBt7e3vR73r/2FCJPm7GRkgIJGpwJhAq9D8tJ3qicdHLbpHqNaF6CAt3hQe88kIWPn61KXrXwAf/uLphwuR5O/mAzEIUe1u17XwO8Y1t1rdQPb+dQwlzw0jhJmVHCNAlYGkTMCf8U7/pwkRGH+XDRhztAhgROhTBaUC8SqNWjzHygBTlgY4ZejV+1aX6aiT1x7uTWGn6PW3iMmkjBEeWzLk6y7TyWObu9YobrZ2CEt3fN7jfa23+TWNmwiRpL9dE0HwaOdbGeIC6e44P2LpVSG3IHePfiSQlBUAVNDX5nvvpZsKkURhZpYF5AXpKN3gcx6TFDkeKU0Elvg3eukGiBWOz9/6t2zuIkRgfFknQoJRhUaL4wo6nDKAEVWAvBzom9aRq492VIDrXhS9hu4mRJL+LKaDE1IE+9vz84azu9hIgBHAigCOWqgKj6+j8dr/9rfdnHzLi+Qul9eAectHD3rpfbf43maOi442gX5kg5vcFOZZfmUx/mXYO5AyRC3MXWP0mbLUE3BKUWrCds1ix+OPHLe3WXC5XNL53ptOMxElLaz7ybUsufadBY9/fu4mugZgf7vZx6SQz/hvF043ISX/Mdsoz9QYmCX8fMYL0hEqzXLWM1me02knpuRbXsC8tdM+x7vmWmrrQh/P7mgMVGU4A3B5jU49OaXX/i8Gy3N+iizKEbPKkVvsma1P6SEmqeRVH2U8CwGa/wHjXqG++KPWrHniGePeET3UZJX05VhgLouR/H526uxWdc7PoIectBJ/a8B3872yoxvHwHxu51EFCPwHhAjMv/gBzNUYIP5duEeJe0f0L+D749HrhKeLAAAAAElFTkSuQmCC',
                },
                null
              ),
              m(
                'image',
                {
                  id: '_Image10',
                  width: '107px',
                  height: '62px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAA+CAYAAAAs/OVIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nN2dWa8saXaWn5jnzMjMPZ5T1V3tsrGR+TNIvjAgC+y2uw22bIONzB/gBgkEAowZJbiBCyR+CzdIIHDX0Gfvs4fMjHmO+LhYEbGrrabdQw2nCKl0ztlDROQ3rPWu933XVxpf0+vn/0CpplEAeJ7G83MBQByHmCaczzVx7GEYMI7QtjAMA/f/1tK+yvf+Wa6v5Yt/4+8olWU5YRgCYJoawyATZxgargtVBZoGZVlhWRamaeJ5Gl0HRVFx/I/B1+6zf61e+Ju/o1TXDTw/P3N7e4NhQN8rbFujaUY0TSMMdU6nhjh2GUfoezBN+a/rIM9LLi8DHh8LNpuQj/+l9rUZg6/Fi17+eq00TaNpGjabDZ6noesyEY4jk2BZUBQKTdPQNIgiyHMYx4lpmnh+fiaKIq6vAz799MxmsyEMDboOlOJrMWnv9Au++s6gLMvgeDxzc7Pj+Tnn4iICIElqLMvCMAxcV2MYoOtGdF0HoOs6NhuH47HAMAw8z0PXIQyhruHx8cwHH+zo+2Wi4aN/8W5P2Dv7cq+/OyrL0jFNAQhl2RIEDtMEwzDRNA2GYWCaJrZtcDwm7PcxVdXQdR37/Ya2HTFNg7bt6LqOi4uQpoEggGGQnFYUA45jzvcdiWOD//GP3s1Je+de6uf/QKkkqXFdlzDUyLKR/d7g+bmfJ0Yjy+T7fd8DEAQ2AIYhIbGqGkzTpCxLttstcSwTrhSk6YjrGuS5THZZllxcxOg6uK6EzjiWifzv//DdmrR35mVuf6tXlmUyTYqqqthuAwxDBm0YBCBoGjw9CURXSrHbRUyT/P4wTLiujq5DWY4YhsHbt2/58MMbHh4KXr8OOZ8nlFJM04TnWVRVh67r6LqO7+u8fZsQxzGGAUVREwTeO5XL3okX+cU/VCpNe7quw3VdbNtgmmQnBAGkqYSq5+czV1e7dVeM40gQuOuEdV2P61r0vXzBsnSaRnZkVVVomkbXdWiaxmazwTDk44+jQinFOI64rkXXCbLUdZ0ggKendwPqf6Uv8Oo7gxrHkf3eJk0FHBiGhmVJ2Hp6EmBR1xPavMCTJMGyLDRNIwgC6rpmHEeUUmy3EXXdst87VBV4HhTFhOPo1PVAFJn0Pei63B9kxyoFeS45sW1Hmqbh/fcD2lZ28+Njxe2tT5Iovv+n+lc2Zl/Jg3e/lisAwzC4ufFmiK0wTY2qahnHEd/3sSxBba7rMk0Tr14FVJUMcF0LPO86uWffy78fH1s8z1mfVVWyC+PYommgrjtc10bXwbbh+bnC932qqsLzPDRNI0kSwjDEtk0sS+6tafJf3yt8X+N//ZMvPzx+qQ/8xt9RCgR1WZZBVTW4rouuQ123dF3H9XXE+dxydeXQdTIxaTphWfoKApJEQMfpNLLdSsh8fq4YxxHLstjvXepaQmieK6JIo65hGGRBLGiwaWQyHcdhGAa2W4tpetl1SVLiui5ZlrHb7VBKYRgamw0cjyN3/8b8UsdP/7IedPG3KrXdwjQp2ralLGvC0GW3g+0WqqqawxlomsbxOFCWE30vNVPT9HSdoq5hszE4HgeCwJjBwIRpmrx+HXFx4ZIkHY4jfGDXdYyj1FKGIbTU+TzO7MbIxYVLHGsMw0Cej+i6TFLfw/vvB2y3Bo7jEEl5R5YVvH3bSH77lUe1/Rup+rLG8AtfGX/p7yk1jpAkFWHoM00CsR1HcsfjY0UQ+KRpNoceHcOQHVUUijjWqCqYJil6o8jANOGTTxLeey+maaDrJrquw/Nc2rbDcWyKouT6OkDTIMvkPkmi2Gw0jsduDXv7vUNZQlEUbLchj49HXr8+rCVA27YEQYBpmozjOIdUeHrqmaYJy7IA2G71L7w++8Ju/kt/pFTfQ12P9H2PruvEsY1SMlF3dxWvXvlkGWw28uGVUvi+jWHA8SiDl+cVjiM5KAyNleuzrIVOGpkmgeS2bWOazPBdBvPyUn738VFyl6ZpuK5J3yssS8P3hfRdCuhpUniexjRBUXQz+2GsTMeSv2ybmd3vsW2ZsGGQ+PlFhcfPPQxef7tVv/zHStU1pGlNFBlEkQtInkjTjrKE/d7n/r7G8+D+vp4LXpthgKoaiaKQYVDouo6maWy3BgB13VPXik8+OdO2LUmSsNtZTJNwgAtpOwwDYejQNHA6DTPMt+j7nr5XpGmK5wlQUUrAjiwkYebbVhFFNk3ToJSE7+MxZxwnum7g/v5MVUEUWXRdTxDAdmuQ5znv/231hYTGz3WyXn93VI5j07ZwOiV4nkdZKrKsZr+3CUPwfZtxhDzvKYqC47HB9z0MQxJ/FMlAx7Hcs65r+r7n8bECIAyteSJCuk6K2rKUwfZ9naIYaBrwfY++l/DbdR1RFOA4cH3tsdlInfX01OD7EpYNQ547DLKDhmGgaRS+73M+SyE+DAOapnE4mDNDUtP3cHtr0XWQJAPvvy9F9eavJ+qD3/18J+1z2a7X324VgOMI7XM6nQHQdZ3NZoNlCYL63vdSXr3aUlUSMmzboGl6qqpis9lgmhpJkq/E636vkabQdVIUN00/k7fQNBJa27YlDP0VtpumCcjAWpZFGOqkac9mYzEMzEVuz25nUZbQNO2aj2zbRinZdZeX8VqTLXVf0wwYhuxw09RwHAmhris5tW0VYaiRJBLSlVJ4nkPTdDz8e+dnHuuf6Qa7X8vV9XWIZcFHHyVzYbrFdfWVfTif1YzIRnY7n7aVAQCJ/a4Lb9/mRFFEXdd4nkdVCejoup793sKy4HhU6LrIH6dTwqtXMVk24Lom4whFUc7PD9E0Zgguz7ZtG8PQqKqGvu85HCK6DsqyxDRNHMdZ0eMCfJoG+n7g6srk6UlykYANH5CclSQ1tm0TBAZv30qxHscBXSclwgI3TFNy3c/K6v/Uv3z567WKY3fl4ZqmIQhc6rrjcLDpe3h4SLm93a4F7MIqZJmiLEssS0Ka7/szoRry9JQTx4KTpwnqull3y7ID0jTl9es9b9+m2LaNZVl0XUcY+tR1y/W1gIqylHukqYSxzSZkHBXDMNC27TyJBpZlcDolXF7GaJrsEAmJA77vEYbyzn3fs9lImJ8m+bfr2uu7Sn6THRVFPmEoIGgYhIGxLA3DgP/9T3+6SfuJc1b0187qm7+j1OWly/lcs9sJlHYchywrVz2p72G/3zIM8nt5Ln+ezwNxrKGUwjRN4jjgcNB4770Qz4M4juYBG5gmNSNEk67r6Pue3c7A9/05pAXYto1tm/PPQRg6HI8jeS7vUNcdnucRxyF9/8L5tW3LdmvTdR2GARcXMVXVUxQdti1j+eqVx/Pzcf3sSikeHzMA0jRlu7Vpmo7n5xOmCRcXLlHkYZomeV5xOo0YhnCURVHg+/JOr74zqJvf7H7ifPZjz/B7vz0ppdScrF2Uku3dNPIhNE2jqiouLnzGUVZaWUrN07YdFxf2al4ZRzgeG4Zh4OYm5OGhJAwDxlF4vDR9get5nrPbCdooipKLi4Dz+QWGT9PEdmtTlhNBoK9C4kIPCZID3xdC+HAwub+v5h1lEQQ6SdLOSHSYw6KEsK57uUfbdrNtwMJx5BllKWHQ9405Cgzouo5t63TdRBjKwjVNuL8v8TyPpmnWksVxZPw++ZMfb6f9hTvrw99X6hf+rlJZlqFpGp7nkqYVVdXx9JSTpikguSeKfE6nBtuWiYoim74fmKaJuoaHh448Z4buAufrGrbbYKaREspSapv9XuqbwyGmKEpME3zfp2nkd7MsI45Ntlt7DrM6x2PFOC6c4Uhd9+i6TPLjY8luZ/LxxwkAlmWRpum8++p5UGWH6jo8PCSM40RZ1ozjRBjKLpSwquj7kcPBmxeMLEDPM2fKC8JQ5/4+pSwVaarYbAKqShbhQoVlWU/X9T821P+Rk/X6u6MaR6mPvvWtLbouRSSI4HdzExGGIaapMY4yQI7j8OmnCZqmEUWsVX8Uwc2NvSZw4flcum6kbUf6njnW27RtS9+/cHSO49A0I0GgMU2KcYT9fr8O0jAMdB3Ytk3XQZoKEnVdi6YZub2VcFmWsNvFXF0Jcbvb7ajrnutr2bmbjYZl6bQt3N7GGIbOxYXH4aBTliK1TJP8XF3XGIY8p+tk8ppmxLYtzueGuoY43hIEkqvO52z+2W7O5xVKKW5vLTQNfu73lFpQ9f/r+qHbz/qr9+rDD28YBkE8mqZxdeVyd1dwcRFi27K6hmHAcSzOZwESDw9iD3McDaUkPrvuwihIQnYcG8+TuibLFK6rkeeyC7tOVNokEUjteQ6nk8j1SskOCYIAXRdEeDjEKyNSVeJyenqS+s5xnJmyknDrui5RZFJVijzP2W43lGU112cOeV6x3/v0vYTMtoXHxwTf99ls7DXcPzw88OrVDUVRYds24zhS1zWHQzwvnhc5x/MEUCyFN8i96/olvC6k8v19MpcvOn3/w0niH/hC+KsntdvtZugrDPM4KrZbjTyXAZYQJ1SNhBjxN3zwQcgwvEB1WTUuZSmUU1EU7HbbFY3VdU0cb6iqBt93KQqB63kuyO2zxpcoivB9g2GQiX96+qym5dP3gmIOB5OyhCQRm5llQV1PxLHO42OzcodRZK8KdJIUKKUIw5BhGFZRU9O0dZJlMQitFcfCzJ9O9fw9bd79gnYXrWwcX+ist28rdjt//nvLdisLqSwlFwpQkXquqiRvRpF8/7NKtQbwwe8q5TiQpsJzaZo8XOCo1AwgyEoEQgPL0lY+7XxOuLqKSdMa3xcXkePA8VgzTRPX18G6A85ncRgdjx2bjXCFCwgYBlkMS6gcR7i/zzFNk7Zt8TyP16+FQioKIV89z8OyjHWVlqXcbwm/4ziuueLy0uajj8SGJpKIQ12rVb8KQ4u2lR0kphsHTRP+b7+3yHN5pmVZc8h2sW1517Zd0GdDXYvzStd1HMdhuzXWiWzbkTA0SFPR1dq2xzAM0jTl1asdZTlhmjrjqKjrGsdx1l2m/ZV/oFSWsdq08lyI1ft7QTq6rs+eBYHowj4M+L6JbcPp1BEENlUlrECWTUSRzt1dShxvGQZRgPu+ZxxHwtADpPa5vAxnmkaK4jiGLBPpQrg84Qo9j3kXy4TI7pYdGwQGeS6DWZby/U8/TbBtmzj2ybKGsizZ7/fzhLtkmTwvyzJev96QptOsWcV0nZhwltJCPBpwPqdcX285nSo2G5++V+tOdBydthXH1cWFT1lKydE0DTc3AooELcoY6LrOMAwcDj739xJql5C6eBkXt1YQyOe2bdAXo6Ss4oq6btcJCQKDYRjYbAzGcVFoayzLpK7HWSey6Hvh7N68STEMna4Tri7LcnRdRylFENhEkYemycDHcbjunu02IgzhdJrWWmgphA1DVm2ajmgavHmT8NFHKboutU6evyT+/V5W99VVjO/7KAW+73I4HCjLcg1pcRyhlMJxnBnF6ViWhW0LMXt5abHbCdAR24Di8nJLnvdcXvqcz1I0TtOEbctkmqbObuevoXu71TkcfO7uCqZJFGZRqxtcVxaSbcN778WM40iWZRiGweOj3PvqKp69IRIeTRP0slQUxTCHPmf2IahVCGya5geS7n7vMU0KxzE4nxsBJJaEy/1+S98PZFm91jGyKwUxDQNkWUWeN2voEGGx43zu15eWUKtTlt2cv8A0DYZhJIoibm+3WBYcDvsZTWmczx2nk8T2cZQoIQ0JPZoGFxfhCsuXLOB5Ds/PFedzRRAEPD1l1LWi70VLMwyDIBB4Lova4ulJgIXjaBwODsMgu2ah0IZBFnRdy9d3u5CybHFdjdOp5fXreJVXJMf3OI6DrutEkcyBUswLRyPLJpSSn9Vlpk08T1ZKkkiCD8OQtpU/01TY5b6XxBqGGk0zcHUl3ogXWM3skHWpqgrXdbm8NGYxUQrNqyufw8FlGCR+L+Kd48ifu91uDpkTrmtTVR1ZVmNZsNsJrVUUE3kOux3c3QmYsSwLz5OFs4Tn8znFdS2mSdgNIWtllSdJQt+PRJE/85Adt7cbgkCjKCRP931P2/Zst3A+J2ga3Nz4aJpGWfZzflQURTtrW6IMbLfbWcHuOR4z4tjh8VGose9//8zpVJGm/ZyrRYv7xjdC7u8lH55OCXUNd3fZLP0IwNEOf7NUC+sgtY7krDRlVVOXLg2ZWBddXxjnabV3Lbxd3/c0TUMcx0SRwfEoqElW3UCWZWw2G+LY4nwWVsC2rRni9mRZNsvoIUEgFb5hvDAiS/ja7eDP/uzFmqaU4vra4/m5m8OnQd/3DMMw+wJ9np6eME0TTdP45jdjigKyTJiFKNLpe1nBS+gRH7wiy7LZpxjT98PMZBjc3yfz38MZlhtomoyLMBmSb9++fSF8FyI7z8Woo2lSpvR9z8VFyPlcz5KRLOZpmnAcWYjaYlNumn71zJ1OJ25uLgHW9plFUZWXkUnbbGQwxxEeH4/s93tsW3ZQmopJMgjg7dty5vVi6loMKotnT9fh+VlI1CU0+v4LU11VkqzP5zOO43A4hOS5wF0pxGVAl8vztJmz9DidxEL25k1BEAT4vsbxWBFF/uqL3++1Wf4QdTkIRErx/UUsbZmmadbHBmzbZBgkVzXNsOZWXWeWbsY53ztUVTfbDTxc18B1hRsVf6KzSi+uK97EIPDRdXn2w0M1q+sueT4DE8PQGQaF686zp2lcXFzQNBLrP/nkiK7LRNV1MwuELuM4znWCmgFDPPsbsjlceLRtP/Nr2oy+cm5uXA4Hjb4fqev2MywFc64oSJKONFWzu0m6R0zTxHVdDEPYk9Oppm3VHIYbDEPD8zSSRMwsAqV7qkpCeRRpFMU452XZBV3XkSSyQNpWEQQWx2NOlhXzTh7nWs6b84hJ28rAdd1EURQ4juSoMISuU+vC6bppLTeapqHrFEky4jgmwzBg26xCZ9PA7a1ocraQ+Fxe+nPBrdjvLbZbV+imzUabfd6KoijQdY3NxqIoGl6/PpDn1Sp9C3qCKDJ4fj6jaRrPz+lniladp6eMqoI4lrpFaKBOaoa7isfHgSgy2G4lmb56FVOWzDkkpKoqTFOjrru5PnN49WqLpmmzaRMuLz0cR4jc3c7j6em4vuP1tWha2+2WPJe6pyjAsowZaUqxfH3tEMfw+Jiy2Whz2PJo23ZGlwKSzueUNE1xXbBtsQbYtr7SW+M48sknCXGsURTFHLrElp1l2Spquq4xRzB3DrkTRTFwPCYkiXCIadpxPIr14fY2mEsIyX9rdfxLf6RUUYjOdHkZkiQtUeTMiGrAssw11CxajoQRk/N5XF9sAQy7nb+WBOKulXadZcX7vkWaVtzc+PNASjhI08U2JtJ/HFsoBff36YzCHJqmYZomwjCc2fF+VYa3W5MkEfV5yVXDMHBxIS7d+fVoGoH+oiZL7ghDef5CChyPJZtNQBiymkvzfFhFUssyOZ3OxHFMWZa8ehXy8CAOYc/z8H2Dh4eE29uYtoWm6fA8e65XpUYUEfOFohJ0LX+vKvn5PBf79g/QTe/99qQ8TyPP+1WgE1len7sw1JwIhR5ZFFnPg48/lmTfdWrt/kiShIuLA1mWc3sbUVXC6d3cxNS18ILCM76Ic54nAzkMwp6/fSsTKsWyTHKSlPK+7wWzfCE5482bZGYWIjYbE8OA+/uCOA5n4CBq89L8YNs2fd/jeR5ZlnF1teV0KmeNzJpRsZhKNxuDspR8soAe8XgkXFzEFIV0W3adjIfY7xr2e5eqkp/b72NcVxbMxx9L4f76tc+bNxXTNHE4hLMFrub62qMsf1Bd/qFE7vW3W3VxYfPxx0LNyPaVVhmxNBe4rsswDFxfuzw8CL8nu47ZFqZxPhc4joPrWivddDxWbLc+VSXU1uKB2O8NkkTNZpiXnxeXVMnNTUCWiXVZdkU2W6xNsixnv49WC/WnnyazsBnSNOJxf3jIuLraoGmQJC23tw53d/Le0/RS4I6jLELDWDzwNZuNmG+macIw9BURGoZBXQuYEZpKJsX3fS4v7bWrsusk5IHoc9/85pb7e6lFw9CmbcX+JjRagW3bP9Sz8SNFL/dXHtXFxcUqyi3EbpIk3N7ueHrKORwimuZlGxuGwPrvfe8tH3xwQ1VJK87iim0aOJ/Pcy2i43mQJB2WZeE4Ur9EkbUW0GHoE8fw/Cwf1vd1hmGRRl6oLN+3aZqBvu8JAo9xlETvuhpFIQtjATFSZE6z1yOY/YUG9/fC9KephOyFXpP7QFGM+L6B5wlhLbltWkGI9IcpLi+liBZ7tlBISdICzKDE4fY2pCggzwt0Xef2VqLHjxIif6Se1fzXK+37f6prCyEq6rA228BEjxKI3X8GlS3o5oY8l0Q8lyFzp2GBaZr0fc/5nJDnQrhO08T5XHJxYVHXiq6bCAIfzxOzzOEgWlBRDKRpObMZxsyE27guM1vt0TQdbdtSVRVVNVKW5QyH09nvLjWk7/trC1CaCqMxjmr2lKjZONNiGHB3dyYM5et3dxVBoLHdujiOQxx7zAgeXdf45JNqNd90XUdVKaLImZVpcfem6UTX9VxdhbP/Uf2FivGPLevf/lavxnEkihzqesRxDLpOGOKlvgBmuf1Fspa6TAq9um6wLIu2bbm99TmdFh5Q53xOef16uxLBDw/CpARBgKaJ1CCrmzVESn0npGwQQJL0lGXJbhdTltXqbNrv/dVSIMy/7Ib9XuPTTyWnWZaE8PNZdvMwCPQW86m1cppZJnJHUfT0fc9+768O3cfHdmbahWfsOmZILwtFhFoBFVnWcnHhkKYTb/618WPNw0/ssvm531OqqiRUSfErjMF2a/P0VHB9HfL8XHN15VFVUFXtHJqCub5Y6jl4eCjm5jkhYpcicRzVGtocB56f61lM1ElTETiXGL+gvsUDcn29o20FvLx9K/1dWSbhCiCOPaZJNDEhdh1cV6Np1ErcfvjhjtNJ7h2GPlXVEIYuWVZxOPgUxThbD2TXAytRvKgLi3NqYdilTpTnOI5GXf/kXSg/tRXt6jcatds5ZNlAGJorKmuaht3OpW2XLvh+RjpCej495VxeRiRJQxRJu8/xWLDbhZzPBVEkMdOy4HyWMytAEr4UlQZl2a4OJSmUDYpCWArD0EnTjJubzbxYRNJYitRhGNjtIvJcdjvIbhP/vRhy7u7On+EoRzzPJQzh6amZuU/xMmZZtxpbF5/7QjjbtsEwCHBoW1G5bdvm+tr6qXuVf2aX6F/++0rJJEnyrSoRJIXYlGTq+xZdJ6v9fK7mVWYTRfDmjfzMxYXFRx+d125GOadCm3WrmosLj/NZtLOuU7MPQpiCpTkhihzKsl9lGYA4Nueww9pDLMYWKcLD0FgprbaVRSCuX52yrFYuse97osinqgRJns/LCTYiNEoXypY0TWeUKnLI5aXH83OzaoOf/quf3uj5udinf/mPpWPk6Unif5IUvP9+SJqKRLEgSduWvJAkFXHs0zQCl/v+Bbm1LatAB5Kg5XvCNhgGPD2p2e+3AB9h3S3LWOX052epa8TTCHd3+SxDBKv7Vu4riK8opEl8IV2X0LrbidD58HAmiiK6ruPmxl89KEFgzfodlKUYXZUS/tTz3PUZn0en5OfamvLeb09KQp5BnktCXpqzP2tpLsuSzSbkdEpm352P677UJGUpk1nXUowuRPLiUxgGGYAsm6jrmv0+4HgsOBzEzHN/L+1Ci1IQRUIoPz8LUfvmzRO6rnN9fZhbTyXnSDuQuy6WIDBWqJ9lEqIti1VvWkJ9WU6cz2cuLw+AfEbZ6Qb/8x9/fj1bX0gf0TJpfd8Thu6aH3xfEJthGGuN9fwsSXwcpZAWL4bi+fmZ/X6PruszMdtyOATkeT9bzPrZhLOjLKVoXgjZaRKJ4nQ68fr1AcuSfKfrOufzmffe2895pCaKPBwH8nyakZzk0JubkDwXXUuUXmHcXfflqIdPPz3yC79w4O5OdpGgYvHfT9Pnf8TQF9ZMd/UbjdpuRQZ4eKhm+O3N/cPdipSyLOP997eMI5zP3bqq+75fm+kuLvx1hy6QuG1lwNp2YrvV5w5IxX4vH0kpePtWlOzt1uXhQSxqfd/zjW9IiO77ic1G5/m54fLS5XTqubiw1ibyYZAdE8/9R8LMmPT9uDq0ttvt6nHf7Xy67sd32P6k1xfepvr6u6NaTCdNs8j0+io3RJGF6wqt1PfM9ZI0iKdpznYrTQrL15cmiO3W5XgsaNuWq6vDLOP0q74kjXVyFBC85MHbW4ePP5b7iggou35RbTVNI4417u7KuRbzSVOZvLIUoFOWi7G0WwXEsvziz8r40rrNlxNklILj8cirV4f1WATTlB2T5xO+r5PnPYeDWL/O5wTDMNhsIoZhXLs0tltr3lmsNdrzsyjbck9Rt4W81Wcm5AWJ1nWL4zgrk7H0MS8uX8mfPZ5n0bbjeqCKlCbe7NUQ0+oXtZP+/PWln+Xw4e8rlSQyQHVdz40A1mxFlhDXdf0s95ukqdRlZSmtPldX+zUkLpY1zxPTpijHclLNe+8Fs2AquXMxhcqgO6sBaJFFhkHAzCITXV+Hs/dBmPoFVb55I7LK0qZ0+k/hlzaGX8mhJT//B0qlabNyi0tH4vEo0FfafWRGgsBeqaCyHFe/uFILdA6wLI00FWu1uGuFSLVtGVzf9/E8a0Wjcp6FPnNzFlUFed4xTRP7vYvrwsODyDHLwsiyksMhIE2lFnv77+z/vw8t+fNX+Ksntd/vVmtY2/azVGHjujLgi4zuOA6bjRTJYfiieS1HNeS5eBjKUsBM0zR861s7zmcpxstSjKnzQWozky8F/HYr/vqlt3ix4rVtSxQFNE1HGNqUZf+VTNJyfWmHlvywq/gve+2TP9E0yQ8DRVGsO0aI4A7ft9ak//QkHpCPPz7PTW/Mztd+1paa+SxcjziOOZ/FmZTn3Xw24dLoPc4yy4jvC7sh8jucTvIOeZ6vB0q6rs3/+Wea9lVOFLwjp6It1y/+oTzw8moAAAHYSURBVFJl+cJOLBrZZmOQ52IWTVOxQ4vxJVhdUkqJoadtWyzL4nDw1zZWOWjEnk+gfhH6kkSOrNM0+V3fd9fifQE9bQvf++df/jlNP+x6J17is9f1t1slsNtc/eJRFK2+jEWUXPyMy0Eii31rYfhBmtsk1y07zqTr5J6CEB36fmS3M+beXykZyrKmbVvy/7x7p8bnnXqZz17f/B2lmqabpXRhuhf6yLZt8jxns9ng+8I6LKzC6TSujLznuSuh7Hketm3MLMo4d+2LMzjPO4ZhmPWp7Tt7Vu47+VKfvV59Z1B1Xa/Iz/etGVio9biE5aihpVuy7wWG17XkvcPB5u4un21rW5qmY7ezubtL567MkGmSXPlV56Ufdb2zL/bZ6+Y3O+W6FmXZrAJfFFkUxbDmryhyZxVYWAyhgnyaZlxNKLe3Huezms0uL4eN/CRN2F/l9c6/4GevX/ojpapKitMX1gPyXDjA5WyLxUMoNmWXzcbg8bFkuw3WBkA5zvXLPzPwZ7m+Ni/62Wv5/5Asx4W7rs3pJK2rV1fB3GB9nifKo22Fxlr8hVXV8vgf3K/dZ//avfBnr8tfr9UC1a+u/PXM9udnYc+zbPH+vfx/Sx4eHuj/2+3X8nP/X8+jjAy2QdiEAAAAAElFTkSuQmCC',
                },
                null
              ),
              m(
                'linearGradient',
                {
                  id: '_Linear11',
                  x1: '0',
                  y1: '0',
                  x2: '1',
                  y2: '0',
                  gradientUnits: 'userSpaceOnUse',
                  gradientTransform:
                    'matrix(-118.47,-106.79,210.785,-180.125,69.2121,1372.7)',
                },
                [
                  m(
                    'stop',
                    {
                      offset: '0',
                      style: { stopColor: 'rgb(64, 128, 255)', stopOpacity: 1 },
                    },
                    null
                  ),
                  m(
                    'stop',
                    {
                      offset: '1',
                      style: { stopColor: 'rgb(64, 128, 255)', stopOpacity: 1 },
                    },
                    null
                  ),
                ]
              ),
              m(
                'image',
                {
                  id: '_Image13',
                  width: '107px',
                  height: '34px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAiCAYAAABY6CeoAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABFElEQVRoge2aQRKDMAhFmx6it/P+x7Ab64xOmaAG8vnwFnWhiOGFOG3TPsu6vpS0djpuH61zXoz5F3s6r4rRxipiftddeUbp3t18QozEu3/JfdSzgCy5VWpTWcVYSlaPqcvDEUpZQPUdCqUsSAbMoJIViJIVCBNZrO+MHtbjrs4KRMkKBJUs9uXXTxZ7JR2g6ix27sly6BIxReIOHdpZWevoNe68y2DAmTVXFmDBAB9pJ29nBYRCln5jgkVyv1QUsrIAJyvtvg1F7iGykF/KlniPG66zKDCyWLI2IqwOJSsQz2URbqZEpTorEDCypn6xnciVYT+SlbS+08Zt01lJfv7xBmYZLPpgy6p/pA9gyxIArKMLXxexLNiBCThLAAAAAElFTkSuQmCC',
                },
                null
              ),
              m(
                'image',
                {
                  id: '_Image15',
                  width: '38px',
                  height: '62px',
                  href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAA+CAYAAABHuGlYAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGaElEQVRogcVZSWLjOAwsblIu+oD+/zZ/YC4di8sc7IKLsJzJdCdpXGxLXIACUADpgL8oIYR9jKG/wd/hL+m080uMEb33pwHpR9UBkFLaU7ptW0rBGAOKGgAsy/KjiO3Aw105Z4wx0FpDSgmtNVPqer0if7c2Oee91oqUEsYY5rZaK5ZlQYwRx3HY+J+IsSmOQghPqKhwTO8dIYRvU8yU0kzzEmPEGGNSiGO/Ovh3ABtwQ4UI5ZxRSjEFKBprYwyUUtB7v6H3hQqhlGIb1loRY0RKCcdxIKWE3rshUkqZYsvLHykWQthjjJZZGtwqpRS01ia3MaZCCKi1cj2MMZBS+n1XhhB2brKuK2qtj/hIyeJHkVEypft678g5I+c8uf53FNsBbLoJF6RwU800kirjinM18HXcpxULIewANi5KyDWT1nWd3KquXZbF5tGVmq2qXO/9UzG2f/SSyK3rivf395e1T5/TmBAClmXB+/u7AnBD+7NK5fwoEiE822OM7d7lnBFjtIwlmkSMga97hBBelqRdraTf1SIvnsm1/gEwVBgCfMfPpwQ6UWgj0XGQxgrfeUWJFIO7tYacs20WYzRDPbqkDcZs790U25dl2ai9xoKK+V+oQFEhspzvWZ4kC2DKTK6tCRBjjDtd4RVZlgVvb2/T4lqMj+Ow9yRaRU/Xi/E5nIkUjWLMpZSQxhibn8C6dhyHlRZa6Ru73jtKKbYgDeBmWor8PN2LLmf8JdyLrsKrlV7hp+XeRa01G+/jjaj4hGE49N6ngm/vVakQgqU1N9c2uPc+pTdLjyqpn7qOFz6PMU48RjBsVcaHr/hqPZVZ13XKMn3v+U4zmiWKhur6mpm994diDDwN2BDCxD80wD9TZWqttimfE1lPQYyndV2n32OMW4xp6jI7vGi80CqSr48PRZGGkttSShO/sV9b19XHcjSkmEWKmP5mcKsiipaXs/hjCFCUO1ncASDFGLdXmxJBjRFFk4VbfxNVpRi6h/F2tgfBoRdiaw3LshifeCGPsW3hQsCj/lER5T1SCN3nWd76rhehk0IIGxVQC7iAh3xZlmksUVQC1eMaS5gqRve/OoXXWm/Br0jwANFas3aFStFNuomlt7iZ2aeErUox8Espxp9U1GomgJ0WTec6l23+HcvIWWPIHoytkM7lfYWi7ue21hBZ/9TiUsqUPWcMT746U6rWOvVnOvdVJaAYjeScNwYorSeFeDL0LO838W5WQ/S7ZZ4klc/4eL1eLViZsrVW8z39f9a2eKR8u8Mg93NpZGsNx3FMBxTzEoDt7KCqCcFNtTNVK1+dK1trljxKEWyVfDfLLM05I7Fz1c191tVarbPwLlXOMjecKKWbMtEo/s6s945IjWutBq1apxbpUR94JAkX00Kv8aSuZDZynWVZTCltNs2VHikN/DP+okvOEsCHA68BPFLa3XoujZqFKlqctRx5BfQsSI7iHACWeeoySmvt6eDDsmaIeSF18PbPu5ZjtCroe7+mP01pS+T3tZM4G7uzWGCvpNZpdhExZqx2ptpRKPX47oJoszMG7j2/xoIqx8DU1oYLcxwTxbfkPl5jjFN4MAP53p8nIsmV15G+9yICXIyKcNHjOKY5KjqXY6kc6yzXbK0ZkjFGhFLKzoH2UG75xIIP6xzT3X8HHg3B2TGOzabe+/PiblOfn8UEn3MToqnI6R0GjfOJoOXNcx7r552CLmmMsem1NjdX7uGiSqa6IUWPa2eZzoOtntBVeu8XAP8AuF1D5ZytmKoVFH/0OpNX79St/lMo5uLnJdzvUzXwpk5SiFTpwlv9qnfXYm8F+jHPEPJiaUR21gzTf8fUytba1E2Qw/TcSdECzaS6U8sTShPS/MKOk27T9FXxqKirSBetNby9veHXr182XrL0Q4UokVdInnO0vj1Zc+ciJUV2HloVXON4+axSAJDJ2F4Bn+p6tD9rhbkGkZee//JR0rySlHPelLfOWhUqqH966gFFKYRz7p+fRuhJsRDCaWtNJf1JiJvqkf6E4y6999Ns+6xkbVtIE2enZ0XKX4VzPP5HDP2XGI8B81W5lhTlOZYiV3YuY4w/QshLVJeR/TVOBA0TF49fhpJKptXaT/mSoZlLRa/X67coRAkAdt+OnP2ZLvKtClEy8Bz4L5T6EYUoU2utqGm9+2mlAMz/vunfxHda+HGFKP8C6wW6ett+DK8AAAAASUVORK5CYII=',
                },
                null
              ),
            ]),
          ]
        )
      },
    })
  const $ee = [
      'info',
      'success',
      'warning',
      'error',
      '403',
      '404',
      '500',
      null,
    ],
    Oee = ce({
      name: 'Result',
      components: {
        IconInfo: Pee,
        IconCheck: sm,
        IconExclamation: xA,
        IconClose: zr,
        ResultForbidden: Tee,
        ResultNotFound: kee,
        ResultServerError: Aee,
      },
      props: {
        status: {
          type: String,
          default: 'info',
          validator: (e) => $ee.includes(e),
        },
        title: String,
        subtitle: String,
      },
      setup() {
        return { prefixCls: ye('result') }
      },
    })
  function Lee(e, t, n, r, i, o) {
    const a = ge('icon-info'),
      s = ge('icon-check'),
      l = ge('icon-exclamation'),
      c = ge('icon-close'),
      d = ge('result-forbidden'),
      h = ge('result-not-found'),
      p = ge('result-server-error')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            {
              class: H([
                `${e.prefixCls}-icon`,
                {
                  [`${e.prefixCls}-icon-${e.status}`]: e.status,
                  [`${e.prefixCls}-icon-custom`]: e.status === null,
                },
              ]),
            },
            [
              Se(
                'div',
                { class: H(`${e.prefixCls}-icon-tip`) },
                [
                  ve(e.$slots, 'icon', {}, () => [
                    e.status === 'info'
                      ? (O(), Ee(a, { key: 0 }))
                      : e.status === 'success'
                      ? (O(), Ee(s, { key: 1 }))
                      : e.status === 'warning'
                      ? (O(), Ee(l, { key: 2 }))
                      : e.status === 'error'
                      ? (O(), Ee(c, { key: 3 }))
                      : e.status === '403'
                      ? (O(), Ee(d, { key: 4 }))
                      : e.status === '404'
                      ? (O(), Ee(h, { key: 5 }))
                      : e.status === '500'
                      ? (O(), Ee(p, { key: 6 }))
                      : Ce('v-if', !0),
                  ]),
                ],
                2
              ),
            ],
            2
          ),
          e.title || e.$slots.title
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-title`) },
                [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                2
              ))
            : Ce('v-if', !0),
          e.subtitle || e.$slots.subtitle
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-subtitle`) },
                [ve(e.$slots, 'subtitle', {}, () => [Lt(mt(e.subtitle), 1)])],
                2
              ))
            : Ce('v-if', !0),
          e.$slots.extra
            ? (O(),
              Z(
                'div',
                { key: 2, class: H(`${e.prefixCls}-extra`) },
                [ve(e.$slots, 'extra')],
                2
              ))
            : Ce('v-if', !0),
          e.$slots.default
            ? (O(),
              Z(
                'div',
                { key: 3, class: H(`${e.prefixCls}-content`) },
                [ve(e.$slots, 'default')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Iy = Te(Oee, [['render', Lee]])
  const Iee = Object.assign(Iy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Iy.name, Iy)
      },
    }),
    Ree = ce({
      name: 'Skeleton',
      props: {
        loading: { type: Boolean, default: !0 },
        animation: { type: Boolean, default: !1 },
      },
      setup(e) {
        const t = ye('skeleton'),
          n = C(() => [t, { [`${t}-animation`]: e.animation }])
        return { prefixCls: t, cls: n }
      },
    })
  function Dee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          e.loading
            ? ve(e.$slots, 'default', { key: 0 })
            : ve(e.$slots, 'content', { key: 1 }),
        ],
        2
      )
    )
  }
  var Ry = Te(Ree, [['render', Dee]])
  const Nee = ce({
    name: 'SkeletonLine',
    props: {
      rows: { type: Number, default: 1 },
      widths: { type: Array, default: () => [] },
      lineHeight: { type: Number, default: 20 },
      lineSpacing: { type: Number, default: 15 },
    },
    setup(e) {
      const t = ye('skeleton-line'),
        n = []
      for (let r = 0; r < e.rows; r++) {
        const i = {}
        it(e.widths[r])
          ? (i.width = `${e.widths[r]}px`)
          : ir(e.widths[r]) && (i.width = String(e.widths[r])),
          (i.height = `${e.lineHeight}px`),
          r > 0 && (i.marginTop = `${e.lineSpacing}px`),
          n.push(i)
      }
      return { prefixCls: t, lines: n }
    },
  })
  function Bee(e, t, n, r, i, o) {
    return (
      O(!0),
      Z(
        yt,
        null,
        Yn(
          e.lines,
          (a, s) => (
            O(),
            Z(
              'ul',
              { key: s, class: H(e.prefixCls) },
              [
                Se(
                  'li',
                  { class: H(`${e.prefixCls}-row`), style: at(a) },
                  null,
                  6
                ),
              ],
              2
            )
          )
        ),
        128
      )
    )
  }
  var Dp = Te(Nee, [['render', Bee]])
  const Fee = ce({
    name: 'SkeletonShape',
    props: {
      shape: { type: String, default: 'square' },
      size: { type: String, default: 'medium' },
    },
    setup(e) {
      const t = ye('skeleton-shape'),
        n = C(() => [t, `${t}-${e.shape}`, `${t}-${e.size}`])
      return { prefixCls: t, cls: n }
    },
  })
  function zee(e, t, n, r, i, o) {
    return O(), Z('div', { class: H(e.cls) }, null, 2)
  }
  var Np = Te(Fee, [['render', zee]])
  const Vee = Object.assign(Ry, {
      Line: Dp,
      Shape: Np,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Ry.name, Ry),
          e.component(n + Dp.name, Dp),
          e.component(n + Np.name, Np)
      },
    }),
    Uee = ce({
      name: 'SliderButton',
      components: { Tooltip: uo },
      inheritAttrs: !1,
      props: {
        direction: { type: String, default: 'horizontal' },
        disabled: { type: Boolean, default: !1 },
        min: { type: Number, required: !0 },
        max: { type: Number, required: !0 },
        formatTooltip: { type: Function },
        value: [String, Number],
        tooltipPosition: { type: String },
        showTooltip: { type: Boolean, default: !0 },
      },
      emits: ['movestart', 'moving', 'moveend'],
      setup(e, { emit: t }) {
        const n = ye('slider-btn'),
          r = J(!1),
          i = (h) => {
            e.disabled ||
              (h.preventDefault(),
              (r.value = !0),
              Cn(window, 'mousemove', o),
              Cn(window, 'mouseup', a),
              Cn(window, 'contextmenu', a),
              t('movestart'))
          },
          o = (h) => {
            t('moving', h.clientX, h.clientY)
          },
          a = () => {
            ;(r.value = !1),
              kn(window, 'mousemove', o),
              kn(window, 'mouseup', a),
              t('moveend')
          },
          s = C(() => [n]),
          l = C(() => {
            var h
            return (
              (h = e.tooltipPosition) != null ? h : e.direction === 'vertical'
            )
              ? 'right'
              : 'top'
          }),
          c = C(() => {
            var h, p
            return (p =
              (h = e.formatTooltip) == null ? void 0 : h.call(e, e.value)) !=
              null
              ? p
              : `${e.value}`
          }),
          d = C(() => (e.showTooltip ? (r.value ? !0 : void 0) : !1))
        return {
          prefixCls: n,
          cls: s,
          tooltipContent: c,
          mergedTooltipPosition: l,
          popupVisible: d,
          handleMouseDown: i,
        }
      },
    }),
    Hee = [
      'aria-disabled',
      'aria-valuemax',
      'aria-valuemin',
      'aria-valuenow',
      'aria-valuetext',
    ]
  function Wee(e, t, n, r, i, o) {
    const a = ge('tooltip')
    return (
      O(),
      Ee(
        a,
        {
          'popup-visible': e.popupVisible,
          position: e.mergedTooltipPosition,
          content: e.tooltipContent,
        },
        {
          default: ze(() => [
            Se(
              'div',
              Fe(e.$attrs, {
                tabindex: '0',
                role: 'slider',
                'aria-disabled': e.disabled,
                'aria-valuemax': e.max,
                'aria-valuemin': e.min,
                'aria-valuenow': e.value,
                'aria-valuetext': e.tooltipContent,
                class: e.cls,
                onMousedown:
                  t[0] ||
                  (t[0] = (...s) =>
                    e.handleMouseDown && e.handleMouseDown(...s)),
                onClick: t[1] || (t[1] = io(() => {}, ['stop'])),
              }),
              null,
              16,
              Hee
            ),
          ]),
          _: 1,
        },
        8,
        ['popup-visible', 'position', 'content']
      )
    )
  }
  var jee = Te(Uee, [['render', Wee]])
  const ys = (e, [t, n]) => {
      const r = Math.max((e - t) / (n - t), 0)
      return `${ci.round(r * 100, 2)}%`
    },
    lm = (e, t) => (t === 'vertical' ? { bottom: e } : { left: e }),
    Gee = ce({
      name: 'SliderDots',
      props: {
        data: { type: Array, required: !0 },
        min: { type: Number, required: !0 },
        max: { type: Number, required: !0 },
        direction: { type: String, default: 'horizontal' },
      },
      setup(e) {
        return {
          prefixCls: ye('slider'),
          getStyle: (r) => lm(ys(r, [e.min, e.max]), e.direction),
        }
      },
    })
  function Kee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-dots`) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.data,
              (a, s) => (
                O(),
                Z(
                  'div',
                  {
                    key: s,
                    class: H(`${e.prefixCls}-dot-wrapper`),
                    style: at(e.getStyle(a.key)),
                  },
                  [
                    Se(
                      'div',
                      {
                        class: H([
                          `${e.prefixCls}-dot`,
                          { [`${e.prefixCls}-dot-active`]: a.isActive },
                        ]),
                      },
                      null,
                      2
                    ),
                  ],
                  6
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var qee = Te(Gee, [['render', Kee]])
  const Xee = ce({
    name: 'SliderMarks',
    props: {
      data: { type: Array, required: !0 },
      min: { type: Number, required: !0 },
      max: { type: Number, required: !0 },
      direction: { type: String, default: 'horizontal' },
    },
    setup(e) {
      return {
        prefixCls: ye('slider'),
        getStyle: (r) => lm(ys(r, [e.min, e.max]), e.direction),
      }
    },
  })
  function Yee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-marks`) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.data,
              (a, s) => (
                O(),
                Z(
                  'div',
                  {
                    key: s,
                    'aria-hidden': 'true',
                    class: H(`${e.prefixCls}-mark`),
                    style: at(e.getStyle(a.key)),
                  },
                  mt(a.content),
                  7
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var Zee = Te(Xee, [['render', Yee]])
  const Jee = ce({
    name: 'SliderTicks',
    props: {
      value: { type: Array, required: !0 },
      step: { type: Number, required: !0 },
      min: { type: Number, required: !0 },
      max: { type: Number, required: !0 },
      direction: { type: String, default: 'horizontal' },
    },
    setup(e) {
      const t = ye('slider'),
        n = C(() => {
          const i = [],
            o = Math.floor((e.max - e.min) / e.step)
          for (let a = 0; a <= o; a++) {
            const s = ci.plus(a * e.step, e.min)
            s <= e.min ||
              s >= e.max ||
              i.push({ key: s, isActive: s >= e.value[0] && s <= e.value[1] })
          }
          return i
        })
      return {
        prefixCls: t,
        steps: n,
        getStyle: (i) => lm(ys(i, [e.min, e.max]), e.direction),
      }
    },
  })
  function Qee(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-ticks`) },
        [
          (O(!0),
          Z(
            yt,
            null,
            Yn(
              e.steps,
              (a, s) => (
                O(),
                Z(
                  'div',
                  {
                    key: s,
                    class: H([
                      `${e.prefixCls}-tick`,
                      { [`${e.prefixCls}-tick-active`]: a.isActive },
                    ]),
                    style: at(e.getStyle(a.key)),
                  },
                  null,
                  6
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var ete = Te(Jee, [['render', Qee]])
  const tte = ce({
    name: 'SliderInput',
    components: { InputNumber: uS },
    props: {
      modelValue: { type: Array, required: !0 },
      min: { type: Number },
      max: { type: Number },
      step: { type: Number },
      disabled: { type: Boolean },
      range: { type: Boolean },
    },
    emits: ['startChange', 'endChange'],
    setup(e, { emit: t }) {
      return { prefixCls: ye('slider') }
    },
  })
  function nte(e, t, n, r, i, o) {
    const a = ge('input-number')
    return (
      O(),
      Z(
        'div',
        { class: H(`${e.prefixCls}-input`) },
        [
          e.range
            ? (O(),
              Z(
                yt,
                { key: 0 },
                [
                  m(
                    a,
                    {
                      min: e.min,
                      max: e.max,
                      step: e.step,
                      disabled: e.disabled,
                      'model-value': e.modelValue[0],
                      'hide-button': '',
                      onChange:
                        t[0] || (t[0] = (s) => e.$emit('startChange', s)),
                    },
                    null,
                    8,
                    ['min', 'max', 'step', 'disabled', 'model-value']
                  ),
                  Se(
                    'div',
                    { class: H(`${e.prefixCls}-input-hyphens`) },
                    null,
                    2
                  ),
                ],
                64
              ))
            : Ce('v-if', !0),
          m(
            a,
            {
              min: e.min,
              max: e.max,
              step: e.step,
              disabled: e.disabled,
              'model-value': e.modelValue[1],
              'hide-button': '',
              onChange: t[1] || (t[1] = (s) => e.$emit('endChange', s)),
            },
            null,
            8,
            ['min', 'max', 'step', 'disabled', 'model-value']
          ),
        ],
        2
      )
    )
  }
  var rte = Te(tte, [['render', nte]])
  const ite = ce({
    name: 'Slider',
    components: {
      SliderButton: jee,
      SliderDots: qee,
      SliderMarks: Zee,
      SliderTicks: ete,
      SliderInput: rte,
    },
    props: {
      modelValue: { type: [Number, Array], default: void 0 },
      defaultValue: { type: [Number, Array], default: 0 },
      step: { type: Number, default: 1 },
      min: { type: Number, default: 0 },
      marks: { type: Object },
      max: { type: Number, default: 100 },
      direction: { type: String, default: 'horizontal' },
      disabled: { type: Boolean, default: !1 },
      showTicks: { type: Boolean, default: !1 },
      showInput: { type: Boolean, default: !1 },
      range: { type: Boolean, default: !1 },
      formatTooltip: { type: Function },
      showTooltip: { type: Boolean, default: !0 },
    },
    emits: { 'update:modelValue': (e) => !0, change: (e) => !0 },
    setup(e, { emit: t }) {
      const { modelValue: n } = tt(e),
        r = ye('slider'),
        { mergedDisabled: i, eventHandlers: o } = Rn({
          disabled: Vi(e, 'disabled'),
        }),
        a = J(null),
        s = J(),
        l = e.modelValue ? e.modelValue : e.defaultValue,
        c = J(Ft(l) ? l[0] : 0),
        d = J(Ft(l) ? l[1] : l)
      pt(n, (R) => {
        var j, N, I, B, V
        Ft(R)
          ? ((c.value = (N = (j = R[0]) != null ? j : e.min) != null ? N : 0),
            (d.value = (B = (I = R[1]) != null ? I : e.min) != null ? B : 0))
          : (d.value = (V = R ?? e.min) != null ? V : 0)
      })
      const h = () => {
          var R, j
          e.range
            ? (t('update:modelValue', [c.value, d.value]),
              t('change', [c.value, d.value]))
            : (t('update:modelValue', d.value), t('change', d.value)),
            (j = (R = o.value) == null ? void 0 : R.onChange) == null ||
              j.call(R)
        },
        p = (R) => {
          ;(R = R ?? e.min), (c.value = R), h()
        },
        v = (R) => {
          ;(R = R ?? e.min), (d.value = R), h()
        },
        g = C(() => {
          var R, j, N
          return e.range
            ? Ft(e.modelValue)
              ? e.modelValue
              : [c.value, (R = e.modelValue) != null ? R : d.value]
            : Mt(e.modelValue)
            ? [c.value, d.value]
            : Ft(e.modelValue)
            ? [(j = e.min) != null ? j : 0, e.modelValue[1]]
            : [(N = e.min) != null ? N : 0, e.modelValue]
        }),
        _ = C(() =>
          Object.keys(e.marks || {}).map((R) => {
            var j
            const N = Number(R)
            return {
              key: N,
              content: (j = e.marks) == null ? void 0 : j[N],
              isActive: N >= g.value[0] && N <= g.value[1],
            }
          })
        ),
        b = (R) => lm(ys(R, [e.min, e.max]), e.direction),
        y = J(!1),
        M = () => {
          ;(y.value = !0),
            a.value && (s.value = a.value.getBoundingClientRect())
        }
      function x(R, j) {
        if (!s.value) return 0
        const { left: N, top: I, width: B, height: V } = s.value,
          L = e.direction === 'horizontal' ? B : V,
          W = (L * e.step) / (e.max - e.min)
        let Y = e.direction === 'horizontal' ? R - N : I + V - j
        Y < 0 && (Y = 0), Y > L && (Y = L)
        const U = Math.round(Y / W)
        return ci.plus(e.min, ci.times(U, e.step))
      }
      const w = (R, j) => {
          ;(d.value = x(R, j)), h()
        },
        E = (R) => {
          if (i.value) return
          const { clientX: j, clientY: N } = R
          a.value && (s.value = a.value.getBoundingClientRect()),
            (d.value = x(j, N)),
            h()
        }
      function P([R, j]) {
        return (
          R > j && ([R, j] = [j, R]),
          e.direction === 'vertical'
            ? {
                bottom: ys(R, [e.min, e.max]),
                top: ys(e.max + e.min - j, [e.min, e.max]),
              }
            : {
                left: ys(R, [e.min, e.max]),
                right: ys(e.max + e.min - j, [e.min, e.max]),
              }
        )
      }
      const A = (R, j) => {
          ;(c.value = x(R, j)), h()
        },
        F = () => {
          y.value = !1
        },
        T = C(() => [
          r,
          {
            [`${r}-vertical`]: e.direction === 'vertical',
            [`${r}-with-marks`]: !!e.marks,
          },
        ]),
        k = C(() => [
          `${r}-track`,
          {
            [`${r}-track-disabled`]: i.value,
            [`${r}-track-vertical`]: e.direction === 'vertical',
          },
        ])
      return {
        prefixCls: r,
        cls: T,
        trackCls: k,
        trackRef: a,
        computedValue: g,
        mergedDisabled: i,
        markList: _,
        getBtnStyle: b,
        getBarStyle: P,
        handleClick: E,
        handleMoveStart: M,
        handleEndMoving: w,
        handleMoveEnd: F,
        handleStartMoving: A,
        handleStartChange: p,
        handleEndChange: v,
      }
    },
  })
  function ote(e, t, n, r, i, o) {
    const a = ge('slider-ticks'),
      s = ge('slider-dots'),
      l = ge('slider-marks'),
      c = ge('slider-button'),
      d = ge('slider-input')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          Se(
            'div',
            {
              ref: 'trackRef',
              class: H(e.trackCls),
              onClick:
                t[0] || (t[0] = (...h) => e.handleClick && e.handleClick(...h)),
            },
            [
              Se(
                'div',
                {
                  class: H(`${e.prefixCls}-bar`),
                  style: at(e.getBarStyle(e.computedValue)),
                },
                null,
                6
              ),
              e.showTicks
                ? (O(),
                  Ee(
                    a,
                    {
                      key: 0,
                      value: e.computedValue,
                      step: e.step,
                      min: e.min,
                      max: e.max,
                      direction: e.direction,
                    },
                    null,
                    8,
                    ['value', 'step', 'min', 'max', 'direction']
                  ))
                : Ce('v-if', !0),
              e.marks
                ? (O(),
                  Ee(
                    s,
                    {
                      key: 1,
                      data: e.markList,
                      min: e.min,
                      max: e.max,
                      direction: e.direction,
                    },
                    null,
                    8,
                    ['data', 'min', 'max', 'direction']
                  ))
                : Ce('v-if', !0),
              e.marks
                ? (O(),
                  Ee(
                    l,
                    {
                      key: 2,
                      data: e.markList,
                      min: e.min,
                      max: e.max,
                      direction: e.direction,
                    },
                    null,
                    8,
                    ['data', 'min', 'max', 'direction']
                  ))
                : Ce('v-if', !0),
              e.range
                ? (O(),
                  Ee(
                    c,
                    {
                      key: 3,
                      style: at(e.getBtnStyle(e.computedValue[0])),
                      value: e.computedValue[0],
                      direction: e.direction,
                      disabled: e.mergedDisabled,
                      min: e.min,
                      max: e.max,
                      'format-tooltip': e.formatTooltip,
                      'show-tooltip': e.showTooltip,
                      onMovestart: e.handleMoveStart,
                      onMoving: e.handleStartMoving,
                      onMoveend: e.handleMoveEnd,
                    },
                    null,
                    8,
                    [
                      'style',
                      'value',
                      'direction',
                      'disabled',
                      'min',
                      'max',
                      'format-tooltip',
                      'show-tooltip',
                      'onMovestart',
                      'onMoving',
                      'onMoveend',
                    ]
                  ))
                : Ce('v-if', !0),
              m(
                c,
                {
                  style: at(e.getBtnStyle(e.computedValue[1])),
                  value: e.computedValue[1],
                  direction: e.direction,
                  disabled: e.mergedDisabled,
                  min: e.min,
                  max: e.max,
                  'format-tooltip': e.formatTooltip,
                  'show-tooltip': e.showTooltip,
                  onMovestart: e.handleMoveStart,
                  onMoving: e.handleEndMoving,
                  onMoveend: e.handleMoveEnd,
                },
                null,
                8,
                [
                  'style',
                  'value',
                  'direction',
                  'disabled',
                  'min',
                  'max',
                  'format-tooltip',
                  'show-tooltip',
                  'onMovestart',
                  'onMoving',
                  'onMoveend',
                ]
              ),
            ],
            2
          ),
          e.showInput
            ? (O(),
              Ee(
                d,
                {
                  key: 0,
                  'model-value': e.computedValue,
                  min: e.min,
                  max: e.max,
                  step: e.step,
                  range: e.range,
                  disabled: e.disabled,
                  onStartChange: e.handleStartChange,
                  onEndChange: e.handleEndChange,
                },
                null,
                8,
                [
                  'model-value',
                  'min',
                  'max',
                  'step',
                  'range',
                  'disabled',
                  'onStartChange',
                  'onEndChange',
                ]
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Dy = Te(ite, [['render', ote]])
  const ate = Object.assign(Dy, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + Dy.name, Dy)
    },
  })
  var Ny = ce({
    name: 'Space',
    props: {
      align: { type: String },
      direction: { type: String, default: 'horizontal' },
      size: { type: [Number, String, Array], default: 'small' },
      wrap: { type: Boolean },
      fill: { type: Boolean },
    },
    setup(e, { slots: t }) {
      const n = ye('space'),
        r = C(() => {
          var s
          return (s = e.align) != null
            ? s
            : e.direction === 'horizontal'
            ? 'center'
            : ''
        }),
        i = C(() => [
          n,
          {
            [`${n}-${e.direction}`]: e.direction,
            [`${n}-align-${r.value}`]: r.value,
            [`${n}-wrap`]: e.wrap,
            [`${n}-fill`]: e.fill,
          },
        ])
      function o(s) {
        if (it(s)) return s
        switch (s) {
          case 'mini':
            return 4
          case 'small':
            return 8
          case 'medium':
            return 16
          case 'large':
            return 24
          default:
            return 8
        }
      }
      const a = (s) => {
        const l = {},
          c = `${o(Ft(e.size) ? e.size[0] : e.size)}px`,
          d = `${o(Ft(e.size) ? e.size[1] : e.size)}px`
        return s
          ? e.wrap
            ? { marginBottom: d }
            : {}
          : (e.direction === 'horizontal' && (l.marginRight = c),
            (e.direction === 'vertical' || e.wrap) && (l.marginBottom = d),
            l)
      }
      return () => {
        var s
        const l = ea((s = t.default) == null ? void 0 : s.call(t), !0).filter(
          (c) => c.type !== Fi
        )
        return m('div', { class: i.value }, [
          l.map((c, d) => {
            var h, p
            const v = t.split && d > 0
            return m(yt, { key: (h = c.key) != null ? h : `item-${d}` }, [
              v &&
                m('div', { class: `${n}-item-split`, style: a(!1) }, [
                  (p = t.split) == null ? void 0 : p.call(t),
                ]),
              m('div', { class: `${n}-item`, style: a(d === l.length - 1) }, [
                c,
              ]),
            ])
          }),
        ])
      }
    },
  })
  const ste = Object.assign(Ny, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + Ny.name, Ny)
    },
  })
  function EA(e) {
    const t = ir(e) ? parseFloat(e) : e
    let n = ''
    return (
      it(e) || String(t) === e ? (n = t > 1 ? 'px' : '%') : (n = 'px'),
      { size: t, unit: n, isPx: n === 'px' }
    )
  }
  function vh({ size: e, defaultSize: t, containerSize: n }) {
    const r = EA(e ?? t)
    return r.isPx ? r.size : r.size * n
  }
  function lte(e, t) {
    return parseFloat(e) / parseFloat(t)
  }
  const ute = ce({
    name: 'Split',
    components: { ResizeTrigger: uA },
    props: {
      component: { type: String, default: 'div' },
      direction: { type: String, default: 'horizontal' },
      size: { type: [Number, String], default: void 0 },
      defaultSize: { type: [Number, String], default: 0.5 },
      min: { type: [Number, String] },
      max: { type: [Number, String] },
      disabled: { type: Boolean, default: !1 },
    },
    emits: {
      moveStart: (e) => !0,
      moving: (e) => !0,
      moveEnd: (e) => !0,
      'update:size': (e) => !0,
    },
    setup(e, { emit: t }) {
      const { direction: n, size: r, defaultSize: i, min: o, max: a } = tt(e),
        s = J(0),
        l = J(),
        c = ye('split'),
        [d, h] = Er(i.value, Je({ value: r })),
        p = C(() => EA(d.value)),
        v = C(() => n.value === 'horizontal'),
        g = C(() => [
          c,
          { [`${c}-horizontal`]: v.value, [`${c}-vertical`]: !v.value },
        ]),
        _ = C(() => {
          const { size: T, unit: k, isPx: R } = p.value
          return { flex: `0 0 calc(${R ? T : T * 100}${k} - ${s.value / 2}px)` }
        }),
        b = {
          startPageX: 0,
          startPageY: 0,
          startContainerSize: 0,
          startSize: 0,
        }
      async function y() {
        const T = () => {
          var k, R
          return v.value
            ? (k = l.value) == null
              ? void 0
              : k.clientWidth
            : ((R = l.value) == null ? void 0 : R.clientHeight) || 0
        }
        return (!l.value || T()) && (await hn()), T()
      }
      function M(T, k) {
        if (!k) return
        const R = p.value.isPx ? `${T}px` : lte(T, k)
        d.value !== R && (h(R), t('update:size', R))
      }
      function x(T, k) {
        const R = vh({ size: T, containerSize: k }),
          j = vh({ size: o.value, defaultSize: '0px', containerSize: k }),
          N = vh({ size: a.value, defaultSize: `${k}px`, containerSize: k })
        let I = R
        return (I = Math.max(I, j)), (I = Math.min(I, N)), I
      }
      function w({
        startContainerSize: T,
        startSize: k,
        startPosition: R,
        endPosition: j,
      }) {
        const N = vh({ size: k, containerSize: T })
        return x(`${N + (j - R)}px`, T)
      }
      function E(T) {
        t('moving', T)
        const k = v.value
          ? w({
              startContainerSize: b.startContainerSize,
              startSize: b.startSize,
              startPosition: b.startPageX,
              endPosition: T.pageX,
            })
          : w({
              startContainerSize: b.startContainerSize,
              startSize: b.startSize,
              startPosition: b.startPageY,
              endPosition: T.pageY,
            })
        M(k, b.startContainerSize)
      }
      function P(T) {
        kn(window, 'mousemove', E),
          kn(window, 'mouseup', P),
          kn(window, 'contextmenu', P),
          (document.body.style.cursor = 'default'),
          t('moveEnd', T)
      }
      async function A(T) {
        t('moveStart', T),
          (b.startPageX = T.pageX),
          (b.startPageY = T.pageY),
          (b.startContainerSize = await y()),
          (b.startSize = d.value),
          Cn(window, 'mousemove', E),
          Cn(window, 'mouseup', P),
          Cn(window, 'contextmenu', P),
          (document.body.style.cursor = v.value ? 'col-resize' : 'row-resize')
      }
      function F(T) {
        const { width: k, height: R } = T.contentRect
        s.value = v.value ? k : R
      }
      return (
        Wt(async () => {
          const T = await y(),
            k = x(d.value, T)
          M(k, T)
        }),
        {
          prefixCls: c,
          classNames: g,
          isHorizontal: v,
          wrapperRef: l,
          onMoveStart: A,
          onTriggerResize: F,
          firstPaneStyles: _,
        }
      )
    },
  })
  function cte(e, t, n, r, i, o) {
    const a = ge('ResizeTrigger')
    return (
      O(),
      Ee(
        xi(e.component),
        { ref: 'wrapperRef', class: H(e.classNames) },
        {
          default: ze(() => [
            Se(
              'div',
              {
                class: H([`${e.prefixCls}-pane`, `${e.prefixCls}-pane-first`]),
                style: at(e.firstPaneStyles),
              },
              [ve(e.$slots, 'first')],
              6
            ),
            e.disabled
              ? Ce('v-if', !0)
              : (O(),
                Ee(
                  a,
                  {
                    key: 0,
                    'prefix-cls': `${e.prefixCls}-trigger`,
                    direction: e.isHorizontal ? 'vertical' : 'horizontal',
                    onMousedown: e.onMoveStart,
                    onResize: e.onTriggerResize,
                  },
                  {
                    default: ze(() => [ve(e.$slots, 'resize-trigger')]),
                    icon: ze(() => [ve(e.$slots, 'resize-trigger-icon')]),
                    _: 3,
                  },
                  8,
                  ['prefix-cls', 'direction', 'onMousedown', 'onResize']
                )),
            Se(
              'div',
              {
                class: H([`${e.prefixCls}-pane`, `${e.prefixCls}-pane-second`]),
              },
              [ve(e.$slots, 'second')],
              2
            ),
          ]),
          _: 3,
        },
        8,
        ['class']
      )
    )
  }
  var By = Te(ute, [['render', cte]])
  const dte = Object.assign(By, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + By.name, By)
      },
    }),
    fte = ce({
      name: 'Statistic',
      props: {
        title: String,
        value: { type: [Number, Object] },
        format: { type: String, default: 'HH:mm:ss' },
        extra: String,
        start: { type: Boolean, default: !0 },
        precision: { type: Number, default: 0 },
        separator: String,
        showGroupSeparator: { type: Boolean, default: !1 },
        animation: { type: Boolean, default: !1 },
        animationDuration: { type: Number, default: 2e3 },
        valueFrom: { type: Number, default: void 0 },
        placeholder: { type: String },
        valueStyle: { type: Object },
      },
      setup(e) {
        var t
        const n = ye('statistic'),
          r = C(() => (it(e.value) ? e.value : 0)),
          i = J((t = e.valueFrom) != null ? t : e.value),
          o = J(null),
          { value: a } = tt(e),
          s = C(() => Mt(e.value)),
          l = (
            d = ((p) => ((p = e.valueFrom) != null ? p : 0))(),
            h = r.value
          ) => {
            var p
            d !== h &&
              ((o.value = new Ol({
                from: { value: d },
                to: { value: h },
                duration: e.animationDuration,
                easing: 'quartOut',
                onUpdate: (v) => {
                  i.value = v.value
                },
                onFinish: () => {
                  i.value = h
                },
              })),
              (p = o.value) == null || p.start())
          },
          c = C(() => {
            let d = i.value
            if (it(d)) {
              it(e.precision) &&
                (d = ci.round(d, e.precision).toFixed(e.precision))
              const h = String(d).split('.'),
                p = e.showGroupSeparator
                  ? Number(h[0]).toLocaleString('en-US')
                  : h[0],
                v = h[1]
              return { isNumber: !0, integer: p, decimal: v }
            }
            return (
              e.format && (d = Kr(d).format(e.format)),
              { isNumber: !1, value: d }
            )
          })
        return (
          Wt(() => {
            e.animation && e.start && l()
          }),
          pt(
            () => e.start,
            (d) => {
              d && e.animation && !o.value && l()
            }
          ),
          pt(a, (d) => {
            var h
            o.value && ((h = o.value) == null || h.stop(), (o.value = null)),
              (i.value = d),
              e.animation && e.start && l()
          }),
          { prefixCls: n, showPlaceholder: s, formatValue: c }
        )
      },
    }),
    hte = { key: 0 }
  function pte(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          e.title || e.$slots.title
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-title`) },
                [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-content`) },
            [
              Se(
                'div',
                { class: H(`${e.prefixCls}-value`), style: at(e.valueStyle) },
                [
                  e.showPlaceholder
                    ? (O(), Z('span', hte, mt(e.placeholder), 1))
                    : (O(),
                      Z(
                        yt,
                        { key: 1 },
                        [
                          e.$slots.prefix
                            ? (O(),
                              Z(
                                'span',
                                { key: 0, class: H(`${e.prefixCls}-prefix`) },
                                [ve(e.$slots, 'prefix')],
                                2
                              ))
                            : Ce('v-if', !0),
                          e.formatValue.isNumber
                            ? (O(),
                              Z(
                                yt,
                                { key: 1 },
                                [
                                  Se(
                                    'span',
                                    {
                                      class: H(`${e.prefixCls}-value-integer`),
                                    },
                                    mt(e.formatValue.integer),
                                    3
                                  ),
                                  e.formatValue.decimal
                                    ? (O(),
                                      Z(
                                        'span',
                                        {
                                          key: 0,
                                          class: H(
                                            `${e.prefixCls}-value-decimal`
                                          ),
                                        },
                                        ' .' + mt(e.formatValue.decimal),
                                        3
                                      ))
                                    : Ce('v-if', !0),
                                ],
                                64
                              ))
                            : (O(),
                              Z(
                                yt,
                                { key: 2 },
                                [Lt(mt(e.formatValue.value), 1)],
                                2112
                              )),
                          e.$slots.suffix
                            ? (O(),
                              Z(
                                'span',
                                { key: 3, class: H(`${e.prefixCls}-suffix`) },
                                [ve(e.$slots, 'suffix')],
                                2
                              ))
                            : Ce('v-if', !0),
                        ],
                        64
                      )),
                ],
                6
              ),
              e.extra || e.$slots.extra
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-extra`) },
                    [ve(e.$slots, 'extra', {}, () => [Lt(mt(e.extra), 1)])],
                    2
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Fy = Te(fte, [['render', pte]])
  const vte = [
    ['Y', 1e3 * 60 * 60 * 24 * 365],
    ['M', 1e3 * 60 * 60 * 24 * 30],
    ['D', 1e3 * 60 * 60 * 24],
    ['H', 1e3 * 60 * 60],
    ['m', 1e3 * 60],
    ['s', 1e3],
    ['S', 1],
  ]
  function zy(e, t) {
    let n = e
    return vte.reduce((r, [i, o]) => {
      if (r.indexOf(i) !== -1) {
        const a = Math.floor(n / o)
        return (
          (n -= a * o),
          r.replace(new RegExp(`${i}+`, 'g'), (s) => {
            const l = s.length
            return String(a).padStart(l, '0')
          })
        )
      }
      return r
    }, t)
  }
  const mte = ce({
    name: 'Countdown',
    props: {
      title: String,
      value: { type: Number, default: () => Date.now() + 3e5 },
      now: { type: Number, default: () => Date.now() },
      format: { type: String, default: 'HH:mm:ss' },
      start: { type: Boolean, default: !0 },
      valueStyle: { type: Object },
    },
    emits: { finish: () => !0 },
    setup(e, { emit: t }) {
      const n = ye('statistic'),
        { start: r, value: i, now: o, format: a } = tt(e),
        s = J(
          zy(Math.max(Kr(e.value).diff(Kr(e.now), 'millisecond'), 0), e.format)
        )
      pt([i, o, a], () => {
        const h = zy(
          Math.max(Kr(e.value).diff(Kr(e.now), 'millisecond'), 0),
          e.format
        )
        h !== s.value && (s.value = h)
      })
      const l = J(0),
        c = () => {
          l.value && (window.clearInterval(l.value), (l.value = 0))
        },
        d = () => {
          Kr(e.value).valueOf() < Date.now() ||
            (l.value = window.setInterval(() => {
              const h = Kr(e.value).diff(Kr(), 'millisecond')
              h <= 0 && (c(), t('finish')),
                (s.value = zy(Math.max(h, 0), e.format))
            }, 1e3 / 30))
        }
      return (
        Wt(() => {
          e.start && d()
        }),
        Pr(() => {
          c()
        }),
        pt(r, (h) => {
          h && !l.value && d()
        }),
        { prefixCls: n, displayValue: s }
      )
    },
  })
  function gte(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { class: H([`${e.prefixCls}`, `${e.prefixCls}-countdown`]) },
        [
          e.title || e.$slots.title
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-title`) },
                [ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)])],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-content`) },
            [
              Se(
                'div',
                { class: H(`${e.prefixCls}-value`), style: at(e.valueStyle) },
                mt(e.displayValue),
                7
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Bp = Te(mte, [['render', gte]])
  const yte = Object.assign(Fy, {
      Countdown: Bp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Fy.name, Fy), e.component(n + Bp.name, Bp)
      },
    }),
    PA = Symbol('ArcoSteps'),
    bte = ce({
      name: 'Steps',
      props: {
        type: { type: String, default: 'default' },
        direction: { type: String, default: 'horizontal' },
        labelPlacement: { type: String, default: 'horizontal' },
        current: { type: Number, default: void 0 },
        defaultCurrent: { type: Number, default: 1 },
        status: { type: String, default: 'process' },
        lineLess: { type: Boolean, default: !1 },
        small: { type: Boolean, default: !1 },
        changeable: { type: Boolean, default: !1 },
      },
      emits: { 'update:current': (e) => !0, change: (e, t) => !0 },
      setup(e, { emit: t, slots: n }) {
        const { type: r, lineLess: i } = tt(e),
          o = ye('steps'),
          a = J(e.defaultCurrent),
          s = C(() => {
            var y
            return (y = e.current) != null ? y : a.value
          }),
          l = C(() =>
            ['navigation', 'arrow'].includes(e.type)
              ? 'horizontal'
              : e.direction
          ),
          c = C(() =>
            e.type === 'dot'
              ? l.value === 'vertical'
                ? 'horizontal'
                : 'vertical'
              : e.type === 'navigation'
              ? 'horizontal'
              : e.labelPlacement
          ),
          d = (y) => (y < s.value ? 'finish' : y > s.value ? 'wait' : e.status),
          h = (y, M) => {
            e.changeable &&
              ((a.value = y), t('update:current', y), t('change', y, M))
          },
          p = Je(new Map()),
          v = C(() =>
            Array.from(p.values())
              .filter((y) => y.status === 'error')
              .map((y) => y.step)
          ),
          g = (y, M) => {
            p.set(y, M)
          },
          _ = (y) => {
            p.delete(y)
          },
          b = C(() => [
            o,
            `${o}-${l.value}`,
            `${o}-label-${c.value}`,
            `${o}-mode-${r.value}`,
            {
              [`${o}-changeable`]: e.changeable,
              [`${o}-size-small`]: e.small && e.type !== 'dot',
              [`${o}-line-less`]: i.value,
            },
          ])
        return (
          sn(
            PA,
            Je({
              type: r,
              direction: l,
              labelPlacement: c,
              lineLess: i,
              current: s,
              errorSteps: v,
              getStatus: d,
              addItem: g,
              removeItem: _,
              onClick: h,
              parentCls: o,
            })
          ),
          { cls: b }
        )
      },
    })
  function _te(e, t, n, r, i, o) {
    return O(), Z('div', { class: H(e.cls) }, [ve(e.$slots, 'default')], 2)
  }
  var Vy = Te(bte, [['render', _te]])
  const Ste = ce({
    name: 'Step',
    components: { IconCheck: sm, IconClose: zr },
    props: {
      title: String,
      description: String,
      status: { type: String },
      disabled: { type: Boolean, default: !1 },
    },
    setup(e) {
      const t = ye('steps-item'),
        n = Jr(),
        r = ye('steps-icon'),
        i = zt(PA, void 0),
        o = C(() => {
          var g
          return (g = i == null ? void 0 : i.type) != null ? g : 'default'
        }),
        a = J(),
        { computedIndex: s } = Zv({
          itemRef: a,
          selector: `.${t}`,
          parentClassName: i == null ? void 0 : i.parentCls,
        }),
        l = C(() => s.value + 1),
        c = C(() => {
          var g, _
          return (_ =
            (g = e.status) != null
              ? g
              : i == null
              ? void 0
              : i.getStatus(l.value)) != null
            ? _
            : 'process'
        }),
        d = C(() => {
          var g
          return (g =
            i == null ? void 0 : i.errorSteps.includes(l.value + 1)) != null
            ? g
            : !1
        })
      n && (i == null || i.addItem(n.uid, Je({ step: l, status: c }))),
        Pr(() => {
          n && (i == null || i.removeItem(n.uid))
        })
      const h = C(
          () =>
            !(i != null && i.lineLess) &&
            ((i == null ? void 0 : i.labelPlacement) === 'vertical' ||
              (i == null ? void 0 : i.direction) === 'vertical')
        ),
        p = (g) => {
          e.disabled || i == null || i.onClick(l.value, g)
        },
        v = C(() => [
          t,
          `${t}-${c.value}`,
          {
            [`${t}-active`]: l.value === (i == null ? void 0 : i.current),
            [`${t}-next-error`]: d.value,
            [`${t}-disabled`]: e.disabled,
          },
        ])
      return {
        prefixCls: t,
        iconCls: r,
        cls: v,
        itemRef: a,
        showTail: h,
        stepNumber: l,
        computedStatus: c,
        type: o,
        handleClick: p,
      }
    },
  })
  function Cte(e, t, n, r, i, o) {
    const a = ge('icon-check'),
      s = ge('icon-close')
    return (
      O(),
      Z(
        'div',
        {
          ref: 'itemRef',
          class: H(e.cls),
          onClick:
            t[0] || (t[0] = (...l) => e.handleClick && e.handleClick(...l)),
        },
        [
          e.showTail
            ? (O(),
              Z('div', { key: 0, class: H(`${e.prefixCls}-tail`) }, null, 2))
            : Ce('v-if', !0),
          e.type !== 'arrow'
            ? (O(),
              Z(
                'div',
                { key: 1, class: H(`${e.prefixCls}-node`) },
                [
                  ve(
                    e.$slots,
                    'node',
                    { step: e.stepNumber, status: e.computedStatus },
                    () => [
                      e.type !== 'dot'
                        ? (O(),
                          Z(
                            'div',
                            { key: 0, class: H(e.iconCls) },
                            [
                              ve(
                                e.$slots,
                                'icon',
                                {
                                  step: e.stepNumber,
                                  status: e.computedStatus,
                                },
                                () => [
                                  e.computedStatus === 'finish'
                                    ? (O(), Ee(a, { key: 0 }))
                                    : e.computedStatus === 'error'
                                    ? (O(), Ee(s, { key: 1 }))
                                    : (O(),
                                      Z(
                                        yt,
                                        { key: 2 },
                                        [Lt(mt(e.stepNumber), 1)],
                                        2112
                                      )),
                                ]
                              ),
                            ],
                            2
                          ))
                        : Ce('v-if', !0),
                    ]
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-content`) },
            [
              Se(
                'div',
                { class: H(`${e.prefixCls}-title`) },
                [ve(e.$slots, 'default', {}, () => [Lt(mt(e.title), 1)])],
                2
              ),
              e.description || e.$slots.description
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-description`) },
                    [
                      ve(e.$slots, 'description', {}, () => [
                        Lt(mt(e.description), 1),
                      ]),
                    ],
                    2
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Fp = Te(Ste, [['render', Cte]])
  const wte = Object.assign(Vy, {
      Step: Fp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Vy.name, Vy), e.component(n + Fp.name, Fp)
      },
    }),
    xte = ce({
      name: 'Switch',
      components: { IconLoading: Xr },
      props: {
        modelValue: { type: [String, Number, Boolean], default: void 0 },
        defaultChecked: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        loading: { type: Boolean, default: !1 },
        type: { type: String, default: 'circle' },
        size: { type: String },
        checkedValue: { type: [String, Number, Boolean], default: !0 },
        uncheckedValue: { type: [String, Number, Boolean], default: !1 },
        checkedColor: { type: String },
        uncheckedColor: { type: String },
        beforeChange: { type: Function },
        checkedText: { type: String },
        uncheckedText: { type: String },
      },
      emits: {
        'update:modelValue': (e) => !0,
        change: (e, t) => !0,
        focus: (e) => !0,
        blur: (e) => !0,
      },
      setup(e, { emit: t }) {
        const { disabled: n, size: r } = tt(e),
          i = ye('switch'),
          { mergedSize: o } = Vr(r),
          {
            mergedDisabled: a,
            mergedSize: s,
            eventHandlers: l,
          } = Rn({ disabled: n, size: o }),
          c = J(e.defaultChecked ? e.checkedValue : e.uncheckedValue),
          d = C(() => {
            var x
            return ((x = e.modelValue) != null ? x : c.value) === e.checkedValue
          }),
          h = J(e.loading),
          p = C(() => h.value || e.loading),
          v = (x, w) => {
            var E, P
            ;(c.value = x ? e.checkedValue : e.uncheckedValue),
              t('update:modelValue', c.value),
              t('change', c.value, w),
              (P = (E = l.value) == null ? void 0 : E.onChange) == null ||
                P.call(E, w)
          },
          g = async (x) => {
            if (p.value || a.value) return
            const w = !d.value,
              E = w ? e.checkedValue : e.uncheckedValue,
              P = e.beforeChange
            if (xt(P)) {
              h.value = !0
              try {
                const A = await P(E)
                ;(A ?? !0) && v(w, x)
              } finally {
                h.value = !1
              }
            } else v(w, x)
          },
          _ = (x) => {
            var w, E
            t('focus', x),
              (E = (w = l.value) == null ? void 0 : w.onFocus) == null ||
                E.call(w, x)
          },
          b = (x) => {
            var w, E
            t('blur', x),
              (E = (w = l.value) == null ? void 0 : w.onBlur) == null ||
                E.call(w, x)
          },
          y = C(() => [
            i,
            `${i}-type-${e.type}`,
            {
              [`${i}-small`]: s.value === 'small' || s.value === 'mini',
              [`${i}-checked`]: d.value,
              [`${i}-disabled`]: a.value,
              [`${i}-loading`]: p.value,
              [`${i}-custom-color`]:
                e.type === 'line' && (e.checkedColor || e.uncheckedColor),
            },
          ]),
          M = C(() => {
            if (d.value && e.checkedColor)
              return e.type === 'line'
                ? { '--custom-color': e.checkedColor }
                : { backgroundColor: e.checkedColor }
            if (!d.value && e.uncheckedColor)
              return e.type === 'line'
                ? { '--custom-color': e.uncheckedColor }
                : { backgroundColor: e.uncheckedColor }
          })
        return {
          prefixCls: i,
          cls: y,
          mergedDisabled: a,
          buttonStyle: M,
          computedCheck: d,
          computedLoading: p,
          handleClick: g,
          handleFocus: _,
          handleBlur: b,
        }
      },
    }),
    Mte = ['aria-checked', 'disabled']
  function Ete(e, t, n, r, i, o) {
    const a = ge('icon-loading')
    return (
      O(),
      Z(
        'button',
        {
          type: 'button',
          role: 'switch',
          'aria-checked': e.computedCheck,
          class: H(e.cls),
          style: at(e.buttonStyle),
          disabled: e.mergedDisabled,
          onClick:
            t[0] || (t[0] = (...s) => e.handleClick && e.handleClick(...s)),
          onFocus:
            t[1] || (t[1] = (...s) => e.handleFocus && e.handleFocus(...s)),
          onBlur: t[2] || (t[2] = (...s) => e.handleBlur && e.handleBlur(...s)),
        },
        [
          Se(
            'span',
            { class: H(`${e.prefixCls}-handle`) },
            [
              Se(
                'span',
                { class: H(`${e.prefixCls}-handle-icon`) },
                [
                  e.computedLoading
                    ? (O(), Ee(a, { key: 0 }))
                    : (O(),
                      Z(
                        yt,
                        { key: 1 },
                        [
                          e.computedCheck
                            ? ve(e.$slots, 'checked-icon', { key: 0 })
                            : ve(e.$slots, 'unchecked-icon', { key: 1 }),
                        ],
                        2112
                      )),
                ],
                2
              ),
            ],
            2
          ),
          Ce('  prettier-ignore  '),
          e.type !== 'line' &&
          e.size !== 'small' &&
          (e.$slots.checked ||
            e.checkedText ||
            e.$slots.unchecked ||
            e.uncheckedText)
            ? (O(),
              Z(
                yt,
                { key: 0 },
                [
                  Se(
                    'span',
                    { class: H(`${e.prefixCls}-text-holder`) },
                    [
                      e.computedCheck
                        ? ve(e.$slots, 'checked', { key: 0 }, () => [
                            Lt(mt(e.checkedText), 1),
                          ])
                        : ve(e.$slots, 'unchecked', { key: 1 }, () => [
                            Lt(mt(e.uncheckedText), 1),
                          ]),
                    ],
                    2
                  ),
                  Se(
                    'span',
                    { class: H(`${e.prefixCls}-text`) },
                    [
                      e.computedCheck
                        ? ve(e.$slots, 'checked', { key: 0 }, () => [
                            Lt(mt(e.checkedText), 1),
                          ])
                        : ve(e.$slots, 'unchecked', { key: 1 }, () => [
                            Lt(mt(e.uncheckedText), 1),
                          ]),
                    ],
                    2
                  ),
                ],
                64
              ))
            : Ce('v-if', !0),
        ],
        46,
        Mte
      )
    )
  }
  var Uy = Te(xte, [['render', Ete]])
  const Pte = Object.assign(Uy, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + Uy.name, Uy)
    },
  })
  var Tte = Object.defineProperty,
    kte = Object.defineProperties,
    Ate = Object.getOwnPropertyDescriptors,
    bE = Object.getOwnPropertySymbols,
    $te = Object.prototype.hasOwnProperty,
    Ote = Object.prototype.propertyIsEnumerable,
    _E = (e, t, n) =>
      t in e
        ? Tte(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Lte = (e, t) => {
      for (var n in t || (t = {})) $te.call(t, n) && _E(e, n, t[n])
      if (bE) for (var n of bE(t)) Ote.call(t, n) && _E(e, n, t[n])
      return e
    },
    Ite = (e, t) => kte(e, Ate(t))
  const Rte = (e) => {
      let t = 0
      const n = (r) => {
        if (Ft(r) && r.length > 0)
          for (const i of r) i.children ? n(i.children) : (t += 1)
      }
      return n(e), t
    },
    TA = (e) => {
      let t = 0
      if (Ft(e) && e.length > 0) {
        t = 1
        for (const n of e)
          if (n.children) {
            const r = TA(n.children)
            r > 0 && (t = Math.max(t, r + 1))
          }
      }
      return t
    },
    SE = (e, t) => {
      let { parent: n } = e
      for (; n; )
        n.fixed === t &&
          (t === 'left'
            ? (n.isLastLeftFixed = !0)
            : (n.isFirstRightFixed = !0)),
          (n = n.parent)
    },
    Dte = (e, t) => {
      const n = TA(e)
      t.clear()
      const r = [],
        i = [...Array(n)].map(() => [])
      let o, a
      const s = (l, { level: c = 0, parent: d, fixed: h } = {}) => {
        var p
        for (const v of l) {
          const g = Ite(Lte({}, v), { parent: d })
          if (Ft(g.children)) {
            const _ = Rte(g.children)
            _ > 1 && (g.colSpan = _),
              i[c].push(g),
              s(g.children, { level: c + 1, parent: g, fixed: g.fixed })
          } else {
            const _ = n - c
            _ > 1 && (g.rowSpan = _),
              (h || g.fixed) &&
                ((g.fixed = (p = g.fixed) != null ? p : h),
                g.fixed === 'left' ? (o = r.length) : Mt(a) && (a = r.length)),
              (Mt(g.dataIndex) || fi(g.dataIndex)) &&
                (g.dataIndex = `__arco_data_index_${r.length}`),
              t.set(g.dataIndex, g),
              r.push(g),
              i[c].push(g)
          }
        }
      }
      return (
        s(e),
        Mt(o) || ((r[o].isLastLeftFixed = !0), SE(r[o], 'left')),
        Mt(a) || ((r[a].isFirstRightFixed = !0), SE(r[a], 'right')),
        { dataColumns: r, groupColumns: i }
      )
    },
    Nte = (e, t) => {
      for (let n = 0; n < e.length; n++) if (e[n].name === t) return n
      return -1
    },
    Bte = (e, t) => {
      var n
      const r = Nte(t, e.name)
      if (r <= 0) return 0
      let i = 0
      const o = t.slice(0, r)
      for (const a of o) i += (n = a.width) != null ? n : 0
      return i
    },
    gS = (e) => (e.children && e.children.length > 0 ? gS(e.children[0]) : e),
    Fte = (e) =>
      e.children && e.children.length > 0
        ? gS(e.children[e.children.length - 1])
        : e,
    zte = (e, { dataColumns: t, operations: n }) => {
      var r, i
      let o = 0
      if (e.fixed === 'left') {
        for (const l of n) o += (r = l.width) != null ? r : 40
        const s = gS(e)
        for (const l of t) {
          if (s.dataIndex === l.dataIndex) break
          o += (i = l.width) != null ? i : 0
        }
        return o
      }
      const a = Fte(e)
      for (let s = t.length - 1; s > 0; s--) {
        const l = t[s]
        if (a.dataIndex === l.dataIndex) break
        l.fixed === 'right' && (o += l.width)
      }
      return o
    },
    kA = (e, t) =>
      t.fixed
        ? [
            `${e}-col-fixed-left`,
            { [`${e}-col-fixed-left-last`]: t.isLastLeftFixed },
          ]
        : [],
    AA = (e, t) =>
      t.fixed === 'left'
        ? [
            `${e}-col-fixed-left`,
            { [`${e}-col-fixed-left-last`]: t.isLastLeftFixed },
          ]
        : t.fixed === 'right'
        ? [
            `${e}-col-fixed-right`,
            { [`${e}-col-fixed-right-first`]: t.isFirstRightFixed },
          ]
        : [],
    $A = (e, { dataColumns: t, operations: n }) => {
      if (e.fixed) {
        const r = `${zte(e, { dataColumns: t, operations: n })}px`
        return e.fixed === 'left' ? { left: r } : { right: r }
      }
      return {}
    },
    OA = (e, t) => (e.fixed ? { left: `${Bte(e, t)}px` } : {}),
    CE = (e, t, n) => {
      var r
      let i = e
      for (let o = 0; o < t.length; o++) {
        const a = t[o]
        if (o >= t.length - 1)
          if (n) i.splice(a, 0, n)
          else return i.splice(a, 1)[0]
        i = (r = i[a].children) != null ? r : []
      }
    },
    yS = (e) => {
      const t = []
      if (e.children)
        for (const n of e.children) n.isLeaf ? t.push(n.key) : t.push(...yS(n))
      return t
    },
    Vte = (e, t) => {
      let n = !1,
        r = !1
      const i = t.filter((o) => e.includes(o))
      return (
        i.length > 0 && (i.length >= t.length ? (n = !0) : (r = !0)),
        { checked: n, indeterminate: r }
      )
    },
    Wc = (e, t, n = !1) =>
      n ? e.filter((r) => !t.includes(r)) : Array.from(new Set(e.concat(t))),
    Ute = (e) => {
      const t = []
      for (let n = 0; n < e.length; n++) t[n] = e[e.length - 1 - n]
      return t
    },
    Hte = ({
      selectedKeys: e,
      defaultSelectedKeys: t,
      rowSelection: n,
      currentAllRowKeys: r,
      currentAllEnabledRowKeys: i,
      emit: o,
    }) => {
      var a, s, l
      const c = C(() => {
          var x
          return ((x = n.value) == null ? void 0 : x.type) === 'radio'
        }),
        d = J(
          (l =
            (s = t.value) != null
              ? s
              : (a = n.value) == null
              ? void 0
              : a.defaultSelectedRowKeys) != null
            ? l
            : []
        ),
        h = C(() => {
          var x, w, E
          return (E =
            (w = e.value) != null
              ? w
              : (x = n.value) == null
              ? void 0
              : x.selectedRowKeys) != null
            ? E
            : d.value
        }),
        p = C(() => h.value.filter((x) => r.value.includes(x)))
      return {
        isRadio: c,
        selectedRowKeys: h,
        currentSelectedRowKeys: p,
        handleSelectAll: (x) => {
          const w = Wc(h.value, i.value, !x)
          ;(d.value = w),
            o('selectAll', x),
            o('selectionChange', w),
            o('update:selectedKeys', w)
        },
        handleSelect: (x, w) => {
          const E = c.value ? [w.key] : Wc(h.value, [w.key], !x)
          ;(d.value = E),
            o('select', E, w.key, w.raw),
            o('selectionChange', E),
            o('update:selectedKeys', E)
        },
        handleSelectAllLeafs: (x, w) => {
          const E = Wc(h.value, yS(x), !w)
          ;(d.value = E),
            o('select', E, x.key, x.raw),
            o('selectionChange', E),
            o('update:selectedKeys', E)
        },
        select: (x, w = !0) => {
          const E = [].concat(x),
            P = c.value ? E : Wc(h.value, E, !w)
          ;(d.value = P), o('selectionChange', P), o('update:selectedKeys', P)
        },
        selectAll: (x = !0) => {
          const w = Wc(h.value, i.value, !x)
          ;(d.value = w), o('selectionChange', w), o('update:selectedKeys', w)
        },
        clearSelected: () => {
          ;(d.value = []),
            o('selectionChange', []),
            o('update:selectedKeys', [])
        },
      }
    },
    Wte = ({
      expandedKeys: e,
      defaultExpandedKeys: t,
      defaultExpandAllRows: n,
      expandable: r,
      allRowKeys: i,
      emit: o,
    }) => {
      const s = J(
          (() => {
            var p, v
            return t.value
              ? t.value
              : (p = r.value) != null && p.defaultExpandedRowKeys
              ? r.value.defaultExpandedRowKeys
              : n.value || ((v = r.value) != null && v.defaultExpandAllRows)
              ? [...i.value]
              : []
          })()
        ),
        l = C(() => {
          var p, v, g
          return (g =
            (v = e.value) != null
              ? v
              : (p = r.value) == null
              ? void 0
              : p.expandedRowKeys) != null
            ? g
            : s.value
        })
      return {
        expandedRowKeys: l,
        handleExpand: (p, v) => {
          const _ = l.value.includes(p)
            ? l.value.filter((b) => p !== b)
            : l.value.concat(p)
          ;(s.value = _),
            o('expand', p, v),
            o('expandedChange', _),
            o('update:expandedKeys', _)
        },
        expand: (p, v = !0) => {
          const g = [].concat(p),
            _ = v ? l.value.concat(g) : l.value.filter((b) => !g.includes(b))
          ;(s.value = _), o('expandedChange', _), o('update:expandedKeys', _)
        },
        expandAll: (p = !0) => {
          const v = p ? [...i.value] : []
          ;(s.value = v), o('expandedChange', v), o('update:expandedKeys', v)
        },
      }
    },
    jte = (e, t) => {
      var n, r
      const i = J(
          Ht(e.pagination) && (n = e.pagination.defaultCurrent) != null ? n : 1
        ),
        o = J(
          Ht(e.pagination) && (r = e.pagination.defaultPageSize) != null
            ? r
            : 10
        ),
        a = C(() => {
          var d
          return Ht(e.pagination) && (d = e.pagination.pageSize) != null
            ? d
            : o.value
        })
      return {
        page: C(() => {
          var d
          return Ht(e.pagination) && (d = e.pagination.current) != null
            ? d
            : i.value
        }),
        pageSize: a,
        handlePageChange: (d) => {
          ;(i.value = d), t('pageChange', d)
        },
        handlePageSizeChange: (d) => {
          ;(o.value = d), t('pageSizeChange', d)
        },
      }
    },
    Gte = ce({
      name: 'ColGroup',
      props: {
        dataColumns: { type: Array, required: !0 },
        operations: { type: Array, required: !0 },
        columnWidth: { type: Object },
      },
      setup() {
        return {
          fixedWidth: (t) => {
            if (t)
              return { width: `${t}px`, minWidth: `${t}px`, maxWidth: `${t}px` }
          },
        }
      },
    })
  function Kte(e, t, n, r, i, o) {
    return (
      O(),
      Z('colgroup', null, [
        (O(!0),
        Z(
          yt,
          null,
          Yn(
            e.operations,
            (a) => (
              O(),
              Z(
                'col',
                {
                  key: `arco-col-${a.name}`,
                  class: H(`arco-table-${a.name}-col`),
                  style: at(e.fixedWidth(a.width)),
                },
                null,
                6
              )
            )
          ),
          128
        )),
        (O(!0),
        Z(
          yt,
          null,
          Yn(
            e.dataColumns,
            (a) => (
              O(),
              Z(
                'col',
                {
                  key: `arco-col-${a.dataIndex}`,
                  style: at(
                    e.fixedWidth(
                      (e.columnWidth &&
                        a.dataIndex &&
                        e.columnWidth[a.dataIndex]) ||
                        a.width
                    )
                  ),
                },
                null,
                4
              )
            )
          ),
          128
        )),
      ])
    )
  }
  var mh = Te(Gte, [['render', Kte]]),
    md = ce({
      name: 'Thead',
      setup(e, { slots: t }) {
        return () => {
          var n, r
          return m(
            (r = (n = t.thead) == null ? void 0 : n.call(t)[0]) != null
              ? r
              : 'thead',
            null,
            { default: t.default }
          )
        }
      },
    }),
    gd = ce({
      name: 'Tbody',
      setup(e, { slots: t }) {
        return () => {
          var n, r
          return m(
            (r = (n = t.tbody) == null ? void 0 : n.call(t)[0]) != null
              ? r
              : 'tbody',
            null,
            { default: t.default }
          )
        }
      },
    }),
    $a = ce({
      name: 'Tr',
      props: {
        expand: { type: Boolean },
        empty: { type: Boolean },
        checked: { type: Boolean },
        rowIndex: Number,
        record: { type: Object, default: () => ({}) },
      },
      setup(e, { slots: t }) {
        const n = ye('table'),
          r = C(() => [
            `${n}-tr`,
            {
              [`${n}-tr-expand`]: e.expand,
              [`${n}-tr-empty`]: e.empty,
              [`${n}-tr-checked`]: e.checked,
            },
          ])
        return () => {
          var i, o, a
          return m(
            (a =
              (o = t.tr) == null
                ? void 0
                : o.call(t, {
                    rowIndex: e.rowIndex,
                    record: (i = e.record) == null ? void 0 : i.raw,
                  })[0]) != null
              ? a
              : 'tr',
            { class: r.value },
            { default: t.default }
          )
        }
      },
    })
  const qte = ce({
      name: 'IconCaretDown',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-caret-down`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Xte = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Yte = Se(
      'path',
      {
        d: 'M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    Zte = [Yte]
  function Jte(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Zte,
        14,
        Xte
      )
    )
  }
  var Hy = Te(qte, [['render', Jte]])
  const LA = Object.assign(Hy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Hy.name, Hy)
      },
    }),
    Qte = ce({
      name: 'IconCaretUp',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-caret-up`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    ene = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    tne = Se(
      'path',
      {
        d: 'M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    nne = [tne]
  function rne(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        nne,
        14,
        ene
      )
    )
  }
  var Wy = Te(Qte, [['render', rne]])
  const ine = Object.assign(Wy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Wy.name, Wy)
      },
    }),
    one = ce({
      name: 'IconFilter',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-filter`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    ane = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    sne = Se(
      'path',
      {
        d: 'M30 42V22.549a1 1 0 0 1 .463-.844l10.074-6.41A1 1 0 0 0 41 14.45V8a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6.451a1 1 0 0 0 .463.844l10.074 6.41a1 1 0 0 1 .463.844V37',
      },
      null,
      -1
    ),
    lne = [sne]
  function une(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        lne,
        14,
        ane
      )
    )
  }
  var jy = Te(one, [['render', une]])
  const cne = Object.assign(jy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + jy.name, jy)
      },
    }),
    dne = ({ column: e, tableCtx: t }) => {
      const n = C(() => {
          var c
          if (
            e.value.dataIndex &&
            e.value.dataIndex === ((c = t.sorter) == null ? void 0 : c.field)
          )
            return t.sorter.direction
        }),
        r = C(() => {
          var c, d, h
          return (h =
            (d = (c = e.value) == null ? void 0 : c.sortable) == null
              ? void 0
              : d.sortDirections) != null
            ? h
            : []
        }),
        i = C(() => r.value.length > 0),
        o = C(() => r.value.includes('ascend')),
        a = C(() => r.value.includes('descend')),
        s = C(() => {
          var c, d
          return n.value
            ? n.value === r.value[0] && (d = r.value[1]) != null
              ? d
              : ''
            : (c = r.value[0]) != null
            ? c
            : ''
        })
      return {
        sortOrder: n,
        hasSorter: i,
        hasAscendBtn: o,
        hasDescendBtn: a,
        nextSortOrder: s,
        handleClickSorter: (c) => {
          var d
          e.value.dataIndex &&
            ((d = t.onSorterChange) == null ||
              d.call(t, e.value.dataIndex, s.value, c))
        },
      }
    },
    fne = ({ column: e, tableCtx: t }) => {
      const n = C(() => {
          var v
          return e.value.dataIndex &&
            (v = t.filters) != null &&
            v[e.value.dataIndex]
            ? t.filters[e.value.dataIndex]
            : []
        }),
        r = J(!1),
        i = C(() => n.value.length > 0),
        o = C(() => {
          var v
          return !!((v = e.value.filterable) != null && v.multiple)
        }),
        a = J(n.value)
      pt(n, (v) => {
        Ft(v) && String(v) !== String(a.value) && (a.value = v)
      })
      const s = (v) => {
          r.value = v
        },
        l = (v) => {
          a.value = v
        }
      return {
        filterPopupVisible: r,
        isFilterActive: i,
        isMultipleFilter: o,
        columnFilterValue: a,
        handleFilterPopupVisibleChange: s,
        setFilterValue: l,
        handleCheckboxFilterChange: (v) => {
          l(v)
        },
        handleRadioFilterChange: (v) => {
          l([v])
        },
        handleFilterConfirm: (v) => {
          var g
          e.value.dataIndex &&
            ((g = t.onFilterChange) == null ||
              g.call(t, e.value.dataIndex, a.value, v)),
            s(!1)
        },
        handleFilterReset: (v) => {
          var g
          l([]),
            e.value.dataIndex &&
              ((g = t.onFilterChange) == null ||
                g.call(t, e.value.dataIndex, a.value, v)),
            s(!1)
        },
      }
    },
    uc = Symbol('ArcoTable'),
    wE = Symbol('ArcoTableColumn')
  function xE(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var IA = ce({
      name: 'AutoTooltip',
      inheritAttrs: !1,
      props: { tooltipProps: { type: Object } },
      setup(e, { attrs: t, slots: n }) {
        const r = ye('auto-tooltip'),
          i = J(),
          o = J(),
          a = J(''),
          s = J(!1),
          l = () => {
            if (i.value && o.value) {
              const p = o.value.offsetWidth > i.value.offsetWidth
              p !== s.value && (s.value = p)
            }
          },
          c = () => {
            var p
            ;(p = o.value) != null &&
              p.textContent &&
              o.value.textContent !== a.value &&
              (a.value = o.value.textContent)
          },
          d = () => {
            c(), l()
          }
        Wt(() => {
          c(), l()
        }),
          Zr(() => {
            c(), l()
          })
        const h = () =>
          m('span', Fe({ ref: i, class: r }, t), [
            m(
              ks,
              { onResize: d },
              {
                default: () => {
                  var p
                  return [
                    m('span', { ref: o, class: `${r}-content` }, [
                      (p = n.default) == null ? void 0 : p.call(n),
                    ]),
                  ]
                },
              }
            ),
          ])
        return () => {
          let p
          if (s.value) {
            let v
            return m(
              uo,
              Fe({ content: a.value, onResize: d }, e.tooltipProps),
              xE((v = h())) ? v : { default: () => [v] }
            )
          }
          return m(
            ks,
            { onResize: d },
            xE((p = h())) ? p : { default: () => [p] }
          )
        }
      },
    }),
    hne = Object.defineProperty,
    ME = Object.getOwnPropertySymbols,
    pne = Object.prototype.hasOwnProperty,
    vne = Object.prototype.propertyIsEnumerable,
    EE = (e, t, n) =>
      t in e
        ? hne(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Gy = (e, t) => {
      for (var n in t || (t = {})) pne.call(t, n) && EE(e, n, t[n])
      if (ME) for (var n of ME(t)) vne.call(t, n) && EE(e, n, t[n])
      return e
    }
  function Ky(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var yd = ce({
      name: 'Th',
      props: {
        column: { type: Object, default: () => ({}) },
        operations: { type: Array, default: () => [] },
        dataColumns: { type: Array, default: () => [] },
        resizable: Boolean,
      },
      setup(e, { slots: t }) {
        const { column: n } = tt(e),
          r = ye('table'),
          { t: i } = Vn(),
          o = zt(uc, {}),
          a = C(() => {
            var L
            return (
              ((L = e.column) == null ? void 0 : L.dataIndex) &&
              o.resizingColumn === e.column.dataIndex
            )
          }),
          s = C(() => {
            var L
            if (Ht((L = e.column) == null ? void 0 : L.tooltip))
              return e.column.tooltip
          }),
          l = C(() => {
            var L
            return (L = e.column) != null &&
              L.filterable &&
              Ui(e.column.filterable.alignLeft)
              ? e.column.filterable.alignLeft
              : o.filterIconAlignLeft
          }),
          {
            sortOrder: c,
            hasSorter: d,
            hasAscendBtn: h,
            hasDescendBtn: p,
            nextSortOrder: v,
            handleClickSorter: g,
          } = dne({ column: n, tableCtx: o }),
          {
            filterPopupVisible: _,
            isFilterActive: b,
            isMultipleFilter: y,
            columnFilterValue: M,
            handleFilterPopupVisibleChange: x,
            setFilterValue: w,
            handleCheckboxFilterChange: E,
            handleRadioFilterChange: P,
            handleFilterConfirm: A,
            handleFilterReset: F,
          } = fne({ column: n, tableCtx: o }),
          T = () => {
            var L, W, Y, U, le
            let q, oe
            const { filterable: te } = e.column
            return (L = e.column.slots) != null && L['filter-content']
              ? (W = e.column.slots) == null
                ? void 0
                : W['filter-content']({
                    filterValue: M.value,
                    setFilterValue: w,
                    handleFilterConfirm: A,
                    handleFilterReset: F,
                  })
              : te != null && te.slotName
              ? (U =
                  (Y = o == null ? void 0 : o.slots) == null
                    ? void 0
                    : Y[te == null ? void 0 : te.slotName]) == null
                ? void 0
                : U.call(Y, {
                    filterValue: M.value,
                    setFilterValue: w,
                    handleFilterConfirm: A,
                    handleFilterReset: F,
                  })
              : te != null && te.renderContent
              ? te.renderContent({
                  filterValue: M.value,
                  setFilterValue: w,
                  handleFilterConfirm: A,
                  handleFilterReset: F,
                })
              : m('div', { class: `${r}-filters-content` }, [
                  m('ul', { class: `${r}-filters-list` }, [
                    (le = te == null ? void 0 : te.filters) == null
                      ? void 0
                      : le.map((ue, me) => {
                          var Re
                          return m(
                            'li',
                            { class: `${r}-filters-item`, key: me },
                            [
                              y.value
                                ? m(
                                    Lo,
                                    {
                                      value: ue.value,
                                      modelValue: M.value,
                                      uninjectGroupContext: !0,
                                      onChange: E,
                                    },
                                    { default: () => [ue.text] }
                                  )
                                : m(
                                    Ku,
                                    {
                                      value: ue.value,
                                      modelValue:
                                        (Re = M.value[0]) != null ? Re : '',
                                      uninjectGroupContext: !0,
                                      onChange: P,
                                    },
                                    { default: () => [ue.text] }
                                  ),
                            ]
                          )
                        }),
                  ]),
                  m('div', { class: `${r}-filters-bottom` }, [
                    m(
                      Yr,
                      { size: 'mini', onClick: F },
                      Ky((q = i('table.resetText')))
                        ? q
                        : { default: () => [q] }
                    ),
                    m(
                      Yr,
                      { type: 'primary', size: 'mini', onClick: A },
                      Ky((oe = i('table.okText')))
                        ? oe
                        : { default: () => [oe] }
                    ),
                  ]),
                ])
          },
          k = () => {
            const { filterable: L } = e.column
            return L
              ? m(
                  Mr,
                  Fe(
                    {
                      popupVisible: _.value,
                      trigger: 'click',
                      autoFitPosition: !0,
                      popupOffset: l.value ? 4 : 0,
                      onPopupVisibleChange: x,
                    },
                    L.triggerProps
                  ),
                  {
                    default: () => [
                      m(
                        In,
                        {
                          class: [
                            `${r}-filters`,
                            {
                              [`${r}-filters-active`]: b.value,
                              [`${r}-filters-open`]: _.value,
                              [`${r}-filters-align-left`]: l.value,
                            },
                          ],
                          disabled: !l.value,
                          onClick: (W) => W.stopPropagation(),
                        },
                        {
                          default: () => {
                            var W, Y, U, le, q
                            return [
                              (q =
                                (le =
                                  (Y =
                                    (W = e.column.slots) == null
                                      ? void 0
                                      : W['filter-icon']) == null
                                    ? void 0
                                    : Y.call(W)) != null
                                  ? le
                                  : (U = L.icon) == null
                                  ? void 0
                                  : U.call(L)) != null
                                ? q
                                : m(cne, null, null),
                            ]
                          },
                        }
                      ),
                    ],
                    content: T,
                  }
                )
              : null
          },
          R = C(() => {
            var L, W
            const Y = [
              `${r}-cell`,
              `${r}-cell-align-${
                (W = (L = e.column) == null ? void 0 : L.align) != null
                  ? W
                  : e.column.children
                  ? 'center'
                  : 'left'
              }`,
            ]
            return (
              d.value &&
                Y.push(`${r}-cell-with-sorter`, {
                  [`${r}-cell-next-ascend`]: v.value === 'ascend',
                  [`${r}-cell-next-descend`]: v.value === 'descend',
                }),
              l.value && Y.push(`${r}-cell-with-filter`),
              Y
            )
          }),
          j = () => {
            var L, W, Y, U, le, q
            return t.default
              ? t.default()
              : (L = e.column) != null &&
                L.titleSlotName &&
                (W = o.slots) != null &&
                W[e.column.titleSlotName]
              ? (U = (Y = o.slots)[e.column.titleSlotName]) == null
                ? void 0
                : U.call(Y, { column: e.column })
              : (q = (le = e.column) == null ? void 0 : le.slots) != null &&
                q.title
              ? e.column.slots.title()
              : xt(e.column.title)
              ? e.column.title()
              : e.column.title
          },
          N = () => {
            var L, W, Y
            let U
            return m(
              'span',
              { class: R.value, onClick: d.value ? g : void 0 },
              [
                (L = e.column) != null &&
                L.ellipsis &&
                (W = e.column) != null &&
                W.tooltip
                  ? m(
                      IA,
                      { class: `${r}-th-title`, tooltipProps: s.value },
                      Ky((U = j())) ? U : { default: () => [U] }
                    )
                  : m(
                      'span',
                      {
                        class: [
                          `${r}-th-title`,
                          {
                            [`${r}-text-ellipsis`]:
                              (Y = e.column) == null ? void 0 : Y.ellipsis,
                          },
                        ],
                      },
                      [j()]
                    ),
                d.value &&
                  m('span', { class: `${r}-sorter` }, [
                    h.value &&
                      m(
                        'div',
                        {
                          class: [
                            `${r}-sorter-icon`,
                            {
                              [`${r}-sorter-icon-active`]: c.value === 'ascend',
                            },
                          ],
                        },
                        [m(ine, null, null)]
                      ),
                    p.value &&
                      m(
                        'div',
                        {
                          class: [
                            `${r}-sorter-icon`,
                            {
                              [`${r}-sorter-icon-active`]:
                                c.value === 'descend',
                            },
                          ],
                        },
                        [m(LA, null, null)]
                      ),
                  ]),
                l.value && k(),
              ]
            )
          },
          I = C(() => {
            var L, W
            return Gy(
              Gy(
                Gy(
                  {},
                  $A(e.column, {
                    dataColumns: e.dataColumns,
                    operations: e.operations,
                  })
                ),
                (L = e.column) == null ? void 0 : L.cellStyle
              ),
              (W = e.column) == null ? void 0 : W.headerCellStyle
            )
          }),
          B = C(() => {
            var L, W
            return [
              `${r}-th`,
              { [`${r}-col-sorted`]: !!c.value, [`${r}-th-resizing`]: a.value },
              ...AA(r, e.column),
              (L = e.column) == null ? void 0 : L.cellClass,
              (W = e.column) == null ? void 0 : W.headerCellClass,
            ]
          }),
          V = (L) => {
            var W, Y, U
            ;(W = e.column) != null &&
              W.dataIndex &&
              ((U = o.onThMouseDown) == null ||
                U.call(o, (Y = e.column) == null ? void 0 : Y.dataIndex, L))
          }
        return () => {
          var L, W, Y, U
          const le = (L = e.column.colSpan) != null ? L : 1,
            q = (W = e.column.rowSpan) != null ? W : 1
          return m(
            (U =
              (Y = t.th) == null
                ? void 0
                : Y.call(t, { column: e.column })[0]) != null
              ? U
              : 'th',
            {
              class: B.value,
              style: I.value,
              colspan: le > 1 ? le : void 0,
              rowspan: q > 1 ? q : void 0,
            },
            {
              default: () => [
                N(),
                !l.value && k(),
                e.resizable &&
                  m(
                    'span',
                    { class: `${r}-column-handle`, onMousedown: V },
                    null
                  ),
              ],
            }
          )
        }
      },
    }),
    mne = Object.defineProperty,
    PE = Object.getOwnPropertySymbols,
    gne = Object.prototype.hasOwnProperty,
    yne = Object.prototype.propertyIsEnumerable,
    TE = (e, t, n) =>
      t in e
        ? mne(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    qy = (e, t) => {
      for (var n in t || (t = {})) gne.call(t, n) && TE(e, n, t[n])
      if (PE) for (var n of PE(t)) yne.call(t, n) && TE(e, n, t[n])
      return e
    }
  function bne(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var bs = ce({
      name: 'Td',
      props: {
        rowIndex: Number,
        record: { type: Object, default: () => ({}) },
        column: { type: Object, default: () => ({}) },
        type: { type: String, default: 'normal' },
        operations: { type: Array, default: () => [] },
        dataColumns: { type: Array, default: () => [] },
        colSpan: { type: Number, default: 1 },
        rowSpan: { type: Number, default: 1 },
        isFixedExpand: { type: Boolean, default: !1 },
        containerWidth: { type: Number },
        showExpandBtn: { type: Boolean, default: !1 },
        indentSize: { type: Number, default: 0 },
        renderExpandBtn: { type: Function },
        summary: { type: Boolean, default: !1 },
      },
      setup(e, { slots: t }) {
        const n = ye('table'),
          r = C(() => {
            var b
            if (Ht((b = e.column) == null ? void 0 : b.tooltip))
              return e.column.tooltip
          }),
          i = C(() => {
            var b, y
            return (
              ((b = e.column) == null ? void 0 : b.dataIndex) &&
              ((y = h.sorter) == null ? void 0 : y.field) === e.column.dataIndex
            )
          }),
          o = C(() => {
            var b
            return (
              ((b = e.column) == null ? void 0 : b.dataIndex) &&
              h.resizingColumn === e.column.dataIndex
            )
          }),
          a = () => {
            var b, y, M, x, w, E
            return e.summary
              ? xt((b = e.column) == null ? void 0 : b.summaryCellClass)
                ? e.column.summaryCellClass(
                    (y = e.record) == null ? void 0 : y.raw
                  )
                : (M = e.column) == null
                ? void 0
                : M.summaryCellClass
              : xt((x = e.column) == null ? void 0 : x.bodyCellClass)
              ? e.column.bodyCellClass((w = e.record) == null ? void 0 : w.raw)
              : (E = e.column) == null
              ? void 0
              : E.bodyCellClass
          },
          s = C(() => {
            var b
            return [
              `${n}-td`,
              { [`${n}-col-sorted`]: i.value, [`${n}-td-resizing`]: o.value },
              ...AA(n, e.column),
              (b = e.column) == null ? void 0 : b.cellClass,
              a(),
            ]
          }),
          l = () => {
            var b, y, M, x, w, E
            return e.summary
              ? xt((b = e.column) == null ? void 0 : b.summaryCellStyle)
                ? e.column.summaryCellStyle(
                    (y = e.record) == null ? void 0 : y.raw
                  )
                : (M = e.column) == null
                ? void 0
                : M.summaryCellStyle
              : xt((x = e.column) == null ? void 0 : x.bodyCellStyle)
              ? e.column.bodyCellStyle((w = e.record) == null ? void 0 : w.raw)
              : (E = e.column) == null
              ? void 0
              : E.bodyCellStyle
          },
          c = C(() => {
            var b
            const y = $A(e.column, {
                dataColumns: e.dataColumns,
                operations: e.operations,
              }),
              M = l()
            return qy(
              qy(qy({}, y), (b = e.column) == null ? void 0 : b.cellStyle),
              M
            )
          }),
          d = C(() => {
            if (e.isFixedExpand && e.containerWidth)
              return { width: `${e.containerWidth}px` }
          }),
          h = zt(uc, {}),
          p = () => {
            var b, y, M, x, w, E, P, A
            if (t.default) return t.default()
            const F = {
              record: (b = e.record) == null ? void 0 : b.raw,
              column: e.column,
              rowIndex: (y = e.rowIndex) != null ? y : -1,
            }
            return t.cell
              ? t.cell(F)
              : (M = e.column.slots) != null && M.cell
              ? e.column.slots.cell(F)
              : e.column.render
              ? e.column.render(F)
              : e.column.slotName &&
                (x = h.slots) != null &&
                x[e.column.slotName]
              ? (E = (w = h.slots)[e.column.slotName]) == null
                ? void 0
                : E.call(w, F)
              : String(
                  (A = ml(
                    (P = e.record) == null ? void 0 : P.raw,
                    e.column.dataIndex
                  )) != null
                    ? A
                    : ''
                )
          },
          v = J(!1),
          g = (b) => {
            var y, M
            xt(h.loadMore) &&
              !((y = e.record) != null && y.isLeaf) &&
              !((M = e.record) != null && M.children) &&
              ((v.value = !0),
              new Promise((x) => {
                var w
                ;(w = h.loadMore) == null || w.call(h, e.record.raw, x)
              }).then((x) => {
                var w
                ;(w = h.addLazyLoadData) == null || w.call(h, x, e.record),
                  (v.value = !1)
              })),
              b.stopPropagation()
          },
          _ = () => {
            var b, y, M, x, w, E
            let P
            return m(
              'span',
              {
                class: [
                  `${n}-cell`,
                  `${n}-cell-align-${
                    (y = (b = e.column) == null ? void 0 : b.align) != null
                      ? y
                      : 'left'
                  }`,
                  {
                    [`${n}-cell-fixed-expand`]: e.isFixedExpand,
                    [`${n}-cell-expand-icon`]: e.showExpandBtn,
                  },
                ],
                style: d.value,
              },
              [
                e.indentSize > 0 &&
                  m(
                    'span',
                    { style: { paddingLeft: `${e.indentSize}px` } },
                    null
                  ),
                e.showExpandBtn &&
                  m('span', { class: `${n}-cell-inline-icon`, onClick: g }, [
                    v.value
                      ? m(Xr, null, null)
                      : (M = e.renderExpandBtn) == null
                      ? void 0
                      : M.call(e, e.record, !1),
                  ]),
                (x = e.column) != null &&
                x.ellipsis &&
                (w = e.column) != null &&
                w.tooltip
                  ? m(
                      IA,
                      { class: `${n}-td-content`, tooltipProps: r.value },
                      bne((P = p())) ? P : { default: () => [P] }
                    )
                  : m(
                      'span',
                      {
                        class: [
                          `${n}-td-content`,
                          {
                            [`${n}-text-ellipsis`]:
                              (E = e.column) == null ? void 0 : E.ellipsis,
                          },
                        ],
                      },
                      [p()]
                    ),
              ]
            )
          }
        return () => {
          var b, y, M, x
          return m(
            (x =
              (M = t.td) == null
                ? void 0
                : M.call(t, {
                    record: (b = e.record) == null ? void 0 : b.raw,
                    column: e.column,
                    rowIndex: (y = e.rowIndex) != null ? y : -1,
                  })[0]) != null
              ? x
              : 'td',
            {
              class: s.value,
              style: c.value,
              rowspan: e.rowSpan > 1 ? e.rowSpan : void 0,
              colspan: e.colSpan > 1 ? e.colSpan : void 0,
            },
            { default: () => [_()] }
          )
        }
      },
    }),
    _ne = ce({
      name: 'OperationTh',
      props: {
        operationColumn: { type: Object, required: !0 },
        operations: { type: Array, required: !0 },
        rowSpan: { type: Number, default: 1 },
        selectAll: { type: Boolean, default: !1 },
      },
      setup(e) {
        const t = ye('table'),
          n = zt(uc, {}),
          r = C(() => {
            var s, l, c, d
            let h = !1,
              p = !1
            const g = (
                (l =
                  (s = n.currentSelectedRowKeys) == null
                    ? void 0
                    : s.filter((b) => {
                        var y, M
                        return (M =
                          (y = n.currentAllEnabledRowKeys) == null
                            ? void 0
                            : y.includes(b)) != null
                          ? M
                          : !0
                      })) != null
                  ? l
                  : []
              ).length,
              _ =
                (d =
                  (c = n.currentAllEnabledRowKeys) == null
                    ? void 0
                    : c.length) != null
                  ? d
                  : 0
            return (
              g > 0 && (g >= _ ? (h = !0) : (p = !0)),
              { checked: h, indeterminate: p }
            )
          }),
          i = () =>
            e.selectAll
              ? m(
                  Lo,
                  {
                    modelValue: r.value.checked,
                    indeterminate: r.value.indeterminate,
                    uninjectGroupContext: !0,
                    onChange: (s) => {
                      var l
                      ;(l = n.onSelectAll) == null || l.call(n, s)
                    },
                  },
                  {
                    default: xt(e.operationColumn.title)
                      ? e.operationColumn.title()
                      : e.operationColumn.title,
                  }
                )
              : e.operationColumn.title
              ? xt(e.operationColumn.title)
                ? e.operationColumn.title()
                : e.operationColumn.title
              : null,
          o = C(() => OA(e.operationColumn, e.operations)),
          a = C(() => [
            `${t}-th`,
            `${t}-operation`,
            { [`${t}-checkbox`]: e.selectAll },
            ...kA(t, e.operationColumn),
          ])
        return () =>
          m(
            'th',
            {
              class: a.value,
              style: o.value,
              rowspan: e.rowSpan > 1 ? e.rowSpan : void 0,
            },
            [m('span', { class: `${t}-cell` }, [i()])]
          )
      },
    }),
    kE = ce({
      name: 'OperationTd',
      components: { Checkbox: Lo, Radio: Ku, IconPlus: Xu, IconMinus: lS },
      props: {
        operationColumn: { type: Object, required: !0 },
        operations: { type: Array, required: !0 },
        record: { type: Object, required: !0 },
        hasExpand: { type: Boolean, default: !1 },
        selectedRowKeys: { type: Array },
        renderExpandBtn: { type: Function },
        colSpan: { type: Number, default: 1 },
        rowSpan: { type: Number, default: 1 },
        summary: { type: Boolean, default: !1 },
      },
      emits: ['select'],
      setup(e, { emit: t, slots: n }) {
        const r = ye('table'),
          i = zt(uc, {}),
          o = C(() => OA(e.operationColumn, e.operations)),
          a = C(() => [
            `${r}-td`,
            `${r}-operation`,
            {
              [`${r}-checkbox`]:
                e.operationColumn.name === 'selection-checkbox',
              [`${r}-radio`]: e.operationColumn.name === 'selection-radio',
              [`${r}-expand`]: e.operationColumn.name === 'expand',
              [`${r}-drag-handle`]: e.operationColumn.name === 'drag-handle',
            },
            ...kA(r, e.operationColumn),
          ]),
          s = C(() => yS(e.record)),
          l = C(() => {
            var d
            return Vte((d = i.currentSelectedRowKeys) != null ? d : [], s.value)
          }),
          c = () => {
            var d, h, p, v, g, _
            if (e.summary) return null
            if (e.operationColumn.render)
              return e.operationColumn.render(e.record.raw)
            if (e.operationColumn.name === 'selection-checkbox') {
              const b = e.record.key
              return !i.checkStrictly && !e.record.isLeaf
                ? m(
                    Lo,
                    {
                      modelValue: l.value.checked,
                      indeterminate: l.value.indeterminate,
                      disabled: !!e.record.disabled,
                      uninjectGroupContext: !0,
                      onChange: (y) => {
                        var M
                        return (M = i.onSelectAllLeafs) == null
                          ? void 0
                          : M.call(i, e.record, y)
                      },
                      onClick: (y) => y.stopPropagation(),
                    },
                    null
                  )
                : m(
                    Lo,
                    {
                      modelValue:
                        (h =
                          (d = e.selectedRowKeys) == null
                            ? void 0
                            : d.includes(b)) != null
                          ? h
                          : !1,
                      disabled: !!e.record.disabled,
                      uninjectGroupContext: !0,
                      onChange: (y) => {
                        var M
                        return (M = i.onSelect) == null
                          ? void 0
                          : M.call(i, y, e.record)
                      },
                      onClick: (y) => y.stopPropagation(),
                    },
                    null
                  )
            }
            if (e.operationColumn.name === 'selection-radio') {
              const b = e.record.key
              return m(
                Ku,
                {
                  modelValue:
                    (v =
                      (p = e.selectedRowKeys) == null
                        ? void 0
                        : p.includes(b)) != null
                      ? v
                      : !1,
                  disabled: !!e.record.disabled,
                  uninjectGroupContext: !0,
                  onChange: (y) => {
                    var M
                    return (M = i.onSelect) == null
                      ? void 0
                      : M.call(i, y, e.record)
                  },
                  onClick: (y) => y.stopPropagation(),
                },
                null
              )
            }
            return e.operationColumn.name === 'expand'
              ? e.hasExpand && e.renderExpandBtn
                ? e.renderExpandBtn(e.record)
                : null
              : e.operationColumn.name === 'drag-handle'
              ? (_ =
                  (g = n['drag-handle-icon']) == null ? void 0 : g.call(n)) !=
                null
                ? _
                : m(cS, null, null)
              : null
          }
        return () =>
          m(
            'td',
            {
              class: a.value,
              style: o.value,
              rowspan: e.rowSpan > 1 ? e.rowSpan : void 0,
              colspan: e.colSpan > 1 ? e.colSpan : void 0,
            },
            [m('span', { class: `${r}-cell` }, [c()])]
          )
      },
    })
  const Sne = (e) => {
      const t = C(() => {
          if (e.value) return e.value.type === 'handle' ? 'handle' : 'row'
        }),
        n = Je({
          dragging: !1,
          sourceKey: '',
          sourcePath: [],
          targetPath: [],
          data: {},
        }),
        r = () => {
          ;(n.dragging = !1),
            (n.sourceKey = ''),
            (n.sourcePath = []),
            (n.targetPath = []),
            (n.data = {})
        }
      return {
        dragType: t,
        dragState: n,
        handleDragStart: (d, h, p, v) => {
          if (
            d.dataTransfer &&
            ((d.dataTransfer.effectAllowed = 'move'),
            d.target && d.target.tagName === 'TD')
          ) {
            const { parentElement: g } = d.target
            g && g.tagName === 'TR' && d.dataTransfer.setDragImage(g, 0, 0)
          }
          ;(n.dragging = !0),
            (n.sourceKey = h),
            (n.sourcePath = p),
            (n.data = v)
        },
        handleDragEnter: (d, h) => {
          d.dataTransfer && (d.dataTransfer.dropEffect = 'move'),
            (n.targetPath = h),
            d.preventDefault()
        },
        handleDragLeave: (d) => {},
        handleDragover: (d) => {
          d.dataTransfer && (d.dataTransfer.dropEffect = 'move'),
            d.preventDefault()
        },
        handleDragEnd: (d) => {
          var h
          ;((h = d.dataTransfer) == null ? void 0 : h.dropEffect) === 'none' &&
            r()
        },
        handleDrop: (d) => {
          r(), d.preventDefault()
        },
      }
    },
    Cne = (e, t) => {
      const n = J(''),
        r = Je({}),
        i = (s, l) => {
          l.preventDefault(),
            (n.value = s),
            Cn(window, 'mousemove', a),
            Cn(window, 'mouseup', o),
            Cn(window, 'contextmenu', o)
        },
        o = () => {
          ;(n.value = ''),
            kn(window, 'mousemove', a),
            kn(window, 'mouseup', o),
            kn(window, 'contextmenu', o)
        },
        a = (s) => {
          const l = e.value[n.value]
          if (l) {
            const { clientX: c } = s,
              { x: d } = l.getBoundingClientRect()
            let h = Math.ceil(c - d)
            h < 40 && (h = 40), (r[n.value] = h), t('columnResize', n.value, h)
          }
        }
      return {
        resizingColumn: n,
        columnWidth: r,
        handleThMouseDown: i,
        handleThMouseUp: o,
      }
    },
    wne = ({ columns: e, onFilterChange: t }) => {
      const n = J(AE(e.value))
      pt(e, (a) => {
        const s = AE(a)
        ac(s, n.value) || (n.value = s)
      })
      const r = C(() => {
        var a, s
        const l = {}
        for (const c of e.value)
          if (c.dataIndex) {
            const d =
              (s = (a = c.filterable) == null ? void 0 : a.filteredValue) !=
              null
                ? s
                : n.value[c.dataIndex]
            d && (l[c.dataIndex] = d)
          }
        return l
      })
      return {
        _filters: n,
        computedFilters: r,
        resetFilters: (a) => {
          var s
          const l = a ? [].concat(a) : [],
            c = {}
          for (const d of e.value)
            if (
              d.dataIndex &&
              d.filterable &&
              (l.length === 0 || l.includes(d.dataIndex))
            ) {
              const h = (s = d.filterable.defaultFilteredValue) != null ? s : []
              ;(c[d.dataIndex] = h), t(d.dataIndex, h)
            }
          n.value = c
        },
        clearFilters: (a) => {
          const s = a ? [].concat(a) : [],
            l = {}
          for (const c of e.value)
            if (
              c.dataIndex &&
              c.filterable &&
              (s.length === 0 || s.includes(c.dataIndex))
            ) {
              const d = []
              ;(l[c.dataIndex] = d), t(c.dataIndex, d)
            }
          n.value = l
        },
      }
    },
    AE = (e) => {
      var t
      const n = {}
      for (const r of e)
        r.dataIndex &&
          (t = r.filterable) != null &&
          t.defaultFilteredValue &&
          (n[r.dataIndex] = r.filterable.defaultFilteredValue)
      return n
    },
    xne = ({ columns: e, onSorterChange: t }) => {
      const n = J($E(e.value))
      pt(e, (a) => {
        const s = $E(a)
        ac(s, n.value) || (n.value = s)
      })
      const r = C(() => {
        var a
        for (const s of e.value)
          if (s.dataIndex && s.sortable) {
            const l = ir(s.sortable.sortOrder)
              ? s.sortable.sortOrder
              : ((a = n.value) == null ? void 0 : a.field) === s.dataIndex
              ? n.value.direction
              : ''
            if (l) return { field: s.dataIndex, direction: l }
          }
      })
      return {
        _sorter: n,
        computedSorter: r,
        resetSorters: () => {
          var a
          let s
          for (const l of e.value)
            l.dataIndex &&
              l.sortable &&
              (!s &&
                l.sortable.defaultSortOrder &&
                (s = {
                  field: l.dataIndex,
                  direction: l.sortable.defaultSortOrder,
                }),
              t(
                l.dataIndex,
                (a = l.sortable.defaultSortOrder) != null ? a : ''
              ))
          n.value = s
        },
        clearSorters: () => {
          for (const a of e.value)
            a.dataIndex && a.sortable && t(a.dataIndex, '')
        },
      }
    },
    $E = (e) => {
      var t
      for (const n of e)
        if (n.dataIndex && (t = n.sortable) != null && t.defaultSortOrder)
          return { field: n.dataIndex, direction: n.sortable.defaultSortOrder }
    },
    OE = ({ spanMethod: e, data: t, columns: n }) => {
      const r = C(() => {
          const o = {}
          return (
            e.value &&
              t.value.forEach((a, s) => {
                n.value.forEach((l, c) => {
                  var d, h
                  const { rowspan: p = 1, colspan: v = 1 } =
                    (h =
                      (d = e.value) == null
                        ? void 0
                        : d.call(e, {
                            record: a.raw,
                            column: l,
                            rowIndex: s,
                            columnIndex: c,
                          })) != null
                      ? h
                      : {}
                  ;(p > 1 || v > 1) && (o[`${s}-${c}`] = [p, v])
                })
              }),
            o
          )
        }),
        i = C(() => {
          const o = []
          for (const a of Object.keys(r.value)) {
            const s = a.split('-').map((c) => Number(c)),
              l = r.value[a]
            for (let c = 1; c < l[0]; c++) {
              o.push(`${s[0] + c}-${s[1]}`)
              for (let d = 1; d < l[1]; d++) o.push(`${s[0] + c}-${s[1] + d}`)
            }
            for (let c = 1; c < l[1]; c++) o.push(`${s[0]}-${s[1] + c}`)
          }
          return o
        })
      return { tableSpan: r, removedCells: i }
    }
  var Mne = Object.defineProperty,
    Ene = Object.defineProperties,
    Pne = Object.getOwnPropertyDescriptors,
    LE = Object.getOwnPropertySymbols,
    Tne = Object.prototype.hasOwnProperty,
    kne = Object.prototype.propertyIsEnumerable,
    IE = (e, t, n) =>
      t in e
        ? Mne(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Zs = (e, t) => {
      for (var n in t || (t = {})) Tne.call(t, n) && IE(e, n, t[n])
      if (LE) for (var n of LE(t)) kne.call(t, n) && IE(e, n, t[n])
      return e
    },
    RE = (e, t) => Ene(e, Pne(t))
  function Ane(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  const DE = { wrapper: !0, cell: !1, headerCell: !1, bodyCell: !1 }
  var Xy = ce({
    name: 'Table',
    props: {
      columns: { type: Array, default: () => [] },
      data: { type: Array, default: () => [] },
      bordered: { type: [Boolean, Object], default: !0 },
      hoverable: { type: Boolean, default: !0 },
      stripe: { type: Boolean, default: !1 },
      size: {
        type: String,
        default: () => {
          var e, t
          return (t = (e = zt(di, void 0)) == null ? void 0 : e.size) != null
            ? t
            : 'large'
        },
      },
      tableLayoutFixed: { type: Boolean, default: !1 },
      loading: { type: [Boolean, Object], default: !1 },
      rowSelection: { type: Object },
      expandable: { type: Object },
      scroll: { type: Object },
      pagination: { type: [Boolean, Object], default: !0 },
      pagePosition: { type: String, default: 'br' },
      indentSize: { type: Number, default: 16 },
      rowKey: { type: String, default: 'key' },
      showHeader: { type: Boolean, default: !0 },
      virtualListProps: { type: Object },
      spanMethod: { type: Function },
      spanAll: { type: Boolean, default: !1 },
      components: { type: Object },
      loadMore: { type: Function },
      filterIconAlignLeft: { type: Boolean, default: !1 },
      hideExpandButtonOnEmpty: { type: Boolean, default: !1 },
      rowClass: { type: [String, Array, Object, Function] },
      draggable: { type: Object },
      rowNumber: { type: [Boolean, Object] },
      columnResizable: { type: Boolean },
      summary: { type: [Boolean, Function] },
      summaryText: { type: String, default: 'Summary' },
      summarySpanMethod: { type: Function },
      selectedKeys: { type: Array },
      defaultSelectedKeys: { type: Array },
      expandedKeys: { type: Array },
      defaultExpandedKeys: { type: Array },
      defaultExpandAllRows: { type: Boolean, default: !1 },
      stickyHeader: { type: [Boolean, Number], default: !1 },
      scrollbar: { type: [Object, Boolean], default: !0 },
    },
    emits: {
      'update:selectedKeys': (e) => !0,
      'update:expandedKeys': (e) => !0,
      expand: (e, t) => !0,
      expandedChange: (e) => !0,
      select: (e, t, n) => !0,
      selectAll: (e) => !0,
      selectionChange: (e) => !0,
      sorterChange: (e, t) => !0,
      filterChange: (e, t) => !0,
      pageChange: (e) => !0,
      pageSizeChange: (e) => !0,
      change: (e, t, n) => !0,
      cellClick: (e, t, n) => !0,
      rowClick: (e, t) => !0,
      headerClick: (e, t) => !0,
      columnResize: (e, t) => !0,
      rowDblclick: (e, t) => !0,
      cellDblclick: (e, t, n) => !0,
      rowContextmenu: (e, t) => !0,
      cellContextmenu: (e, t, n) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const {
          columns: r,
          rowKey: i,
          rowSelection: o,
          expandable: a,
          loadMore: s,
          filterIconAlignLeft: l,
          selectedKeys: c,
          defaultSelectedKeys: d,
          expandedKeys: h,
          defaultExpandedKeys: p,
          defaultExpandAllRows: v,
          spanMethod: g,
          draggable: _,
          summarySpanMethod: b,
          scrollbar: y,
        } = tt(e),
        M = ye('table'),
        x = zt(di, void 0),
        w = C(() =>
          Ht(e.bordered)
            ? Zs(Zs({}, DE), e.bordered)
            : RE(Zs({}, DE), { wrapper: e.bordered })
        ),
        { children: E, components: P } = Jd('TableColumn'),
        A = C(() => {
          var ke, Be
          return (Be = (ke = o.value) == null ? void 0 : ke.checkStrictly) !=
            null
            ? Be
            : !0
        }),
        { displayScrollbar: F, scrollbarProps: T } = qv(y),
        k = C(() => {
          var ke, Be, Qe, St
          const At = !!(
              ((ke = e.scroll) != null && ke.x) ||
              ((Be = e.scroll) != null && Be.minWidth)
            ),
            Vt = !!(
              ((Qe = e.scroll) != null && Qe.y) ||
              ((St = e.scroll) != null && St.maxHeight)
            )
          return { x: At, y: Vt }
        }),
        R = J(),
        j = J({}),
        { componentRef: N, elementRef: I } = Mu('containerRef'),
        { componentRef: B, elementRef: V } = Mu('containerRef'),
        { componentRef: L, elementRef: W } = Mu('viewportRef'),
        { componentRef: Y, elementRef: U } = Mu('containerRef'),
        le = C(() => (q.value ? (zo.value ? W.value : V.value) : I.value)),
        q = C(
          () =>
            k.value.y ||
            e.stickyHeader ||
            zo.value ||
            (k.value.x && Xe.value.length === 0)
        ),
        oe = Je(new Map()),
        te = J()
      pt([P, oe], ([ke, Be]) => {
        if (ke.length > 0) {
          const Qe = []
          ke.forEach((St) => {
            const At = Be.get(St)
            At && Qe.push(At)
          }),
            (te.value = Qe)
        } else te.value = void 0
      })
      const ue = new Map(),
        me = J([]),
        Re = J([])
      pt(
        [r, te],
        ([ke, Be]) => {
          var Qe
          const St = Dte((Qe = Be ?? ke) != null ? Qe : [], ue)
          ;(me.value = St.dataColumns), (Re.value = St.groupColumns)
        },
        { immediate: !0, deep: !0 }
      )
      const qe = C(() => ['tl', 'top', 'tr'].includes(e.pagePosition)),
        Ve = J(!1),
        nt = J(!1),
        We = J(!1)
      pr(() => {
        var ke, Be, Qe
        let St = !1,
          At = !1,
          Vt = !1
        ;(((ke = e.rowSelection) != null && ke.fixed) ||
          ((Be = e.expandable) != null && Be.fixed) ||
          ((Qe = e.draggable) != null && Qe.fixed)) &&
          (St = !0)
        for (const vn of me.value)
          vn.fixed === 'left'
            ? ((St = !0), (Vt = !0))
            : vn.fixed === 'right' && (At = !0)
        St !== Ve.value && (Ve.value = St),
          At !== nt.value && (nt.value = At),
          Vt !== We.value && (We.value = Vt)
      })
      const D = C(() => {
          for (const ke of me.value) if (ke.ellipsis) return !0
          return !1
        }),
        G = (ke) => {
          const Be = {
            type: ke,
            page: fo.value,
            pageSize: ho.value,
            sorter: Ae.value,
            filters: re.value,
            dragTarget: ke === 'drag' ? ln.data : void 0,
          }
          t('change', De.value, Be, ki.value)
        },
        z = (ke, Be) => {
          ;(ae.value = RE(Zs({}, re.value), { [ke]: Be })),
            t('filterChange', ke, Be),
            G('filter')
        },
        ie = (ke, Be) => {
          ;($e.value = Be ? { field: ke, direction: Be } : void 0),
            t('sorterChange', ke, Be),
            G('sorter')
        },
        {
          _filters: ae,
          computedFilters: re,
          resetFilters: pe,
          clearFilters: we,
        } = wne({ columns: me, onFilterChange: z }),
        {
          _sorter: $e,
          computedSorter: Ae,
          resetSorters: ft,
          clearSorters: Q,
        } = xne({ columns: me, onSorterChange: ie }),
        X = new Set(),
        he = C(() => {
          const ke = []
          X.clear()
          const Be = (Qe) => {
            if (Ft(Qe) && Qe.length > 0)
              for (const St of Qe)
                ke.push(St[i.value]),
                  St.disabled && X.add(St[i.value]),
                  St.children && Be(St.children)
          }
          return Be(e.data), ke
        }),
        de = C(() => {
          const ke = [],
            Be = (Qe) => {
              for (const St of Qe)
                ke.push(St.key), St.children && Be(St.children)
            }
          return Be(Xe.value), ke
        }),
        xe = C(() => {
          const ke = [],
            Be = (Qe) => {
              for (const St of Qe)
                St.disabled || ke.push(St.key), St.children && Be(St.children)
            }
          return Be(Xe.value), ke
        }),
        {
          isRadio: ne,
          selectedRowKeys: Le,
          currentSelectedRowKeys: et,
          handleSelect: Ne,
          handleSelectAllLeafs: Et,
          handleSelectAll: kt,
          select: je,
          selectAll: Ge,
          clearSelected: Ye,
        } = Hte({
          selectedKeys: c,
          defaultSelectedKeys: d,
          rowSelection: o,
          currentAllRowKeys: de,
          currentAllEnabledRowKeys: xe,
          emit: t,
        }),
        {
          expandedRowKeys: lt,
          handleExpand: gt,
          expand: _e,
          expandAll: bt,
        } = Wte({
          expandedKeys: h,
          defaultExpandedKeys: p,
          defaultExpandAllRows: v,
          expandable: a,
          allRowKeys: he,
          emit: t,
        }),
        He = Je({}),
        _t = (ke, Be) => {
          ke && (He[Be.key] = ke)
        },
        wt = (ke) => {
          var Be, Qe
          for (const St of Object.keys(re.value)) {
            const At = re.value[St],
              Vt = ue.get(St)
            if (
              Vt &&
              (Be = Vt.filterable) != null &&
              Be.filter &&
              At.length > 0
            ) {
              const vn =
                (Qe = Vt.filterable) == null ? void 0 : Qe.filter(At, ke.raw)
              if (!vn) return vn
            }
          }
          return !0
        },
        {
          dragType: Zt,
          dragState: ln,
          handleDragStart: Pn,
          handleDragEnter: Tr,
          handleDragLeave: vt,
          handleDragover: Gt,
          handleDragEnd: pn,
          handleDrop: yr,
        } = Sne(_),
        {
          resizingColumn: hi,
          columnWidth: Qr,
          handleThMouseDown: Ur,
        } = Cne(j, t),
        da = C(() => {
          var ke
          const Be = (Qe) => {
            const St = []
            for (const At of Qe) {
              const Vt = {
                raw: At,
                key: At[e.rowKey],
                disabled: At.disabled,
                expand: At.expand,
                isLeaf: At.isLeaf,
              }
              At.children
                ? ((Vt.isLeaf = !1), (Vt.children = Be(At.children)))
                : e.loadMore && !At.isLeaf
                ? ((Vt.isLeaf = !1),
                  He[Vt.key] && (Vt.children = Be(He[Vt.key])))
                : (Vt.isLeaf = !0),
                (Vt.hasSubtree = !!(Vt.children
                  ? !e.hideExpandButtonOnEmpty || Vt.children.length > 0
                  : e.loadMore && !Vt.isLeaf)),
                St.push(Vt)
            }
            return St
          }
          return Be((ke = e.data) != null ? ke : [])
        }),
        co = C(() => {
          const ke = (Be) =>
            Be.filter((Qe) =>
              wt(Qe) ? (Qe.children && (Qe.children = ke(Qe.children)), !0) : !1
            )
          return Object.keys(re.value).length > 0 ? ke(da.value) : da.value
        }),
        ki = C(() => {
          var ke, Be
          const Qe = [...co.value]
          if (Qe.length > 0) {
            if ((ke = Ae.value) != null && ke.field) {
              const St = ue.get(Ae.value.field)
              if (
                St &&
                ((Be = St.sortable) == null ? void 0 : Be.sorter) !== !0
              ) {
                const { field: At, direction: Vt } = Ae.value
                Qe.sort((vn, or) => {
                  var ti
                  const pi = ml(vn.raw, At),
                    Fl = ml(or.raw, At)
                  if (
                    (ti = St.sortable) != null &&
                    ti.sorter &&
                    xt(St.sortable.sorter)
                  )
                    return St.sortable.sorter(vn.raw, or.raw, {
                      dataIndex: At,
                      direction: Vt,
                    })
                  const jn = pi > Fl ? 1 : -1
                  return Vt === 'descend' ? -jn : jn
                })
              }
            }
            if (ln.dragging && ln.targetPath.length > 0) {
              const St = CE(Qe, ln.sourcePath)
              CE(Qe, ln.targetPath, St)
            }
          }
          return Qe
        }),
        {
          page: fo,
          pageSize: ho,
          handlePageChange: Rs,
          handlePageSizeChange: fe,
        } = jte(e, t),
        Ue = C(() => {
          var ke, Be
          return (Be = (ke = o.value) == null ? void 0 : ke.onlyCurrent) != null
            ? Be
            : !1
        })
      pt(fo, (ke, Be) => {
        ke !== Be && Ue.value && Ye()
      })
      const Xe = C(() =>
          e.pagination && ki.value.length > ho.value
            ? ki.value.slice((fo.value - 1) * ho.value, fo.value * ho.value)
            : ki.value
        ),
        De = C(() => Xe.value.map((ke) => ke.raw)),
        rt = () =>
          me.value.reduce((ke, Be, Qe) => {
            if (Be.dataIndex)
              if (Qe === 0) fv(ke, Be.dataIndex, e.summaryText, { addPath: !0 })
              else {
                let St = 0,
                  At = !1
                Xe.value.forEach((Vt) => {
                  if (Be.dataIndex) {
                    const vn = ml(Vt.raw, Be.dataIndex)
                    it(vn) ? (St += vn) : !Mt(vn) && !fi(vn) && (At = !0)
                  }
                }),
                  fv(ke, Be.dataIndex, At ? '' : St, { addPath: !0 })
              }
            return ke
          }, {}),
        Ot = (ke) => {
          if (ke && ke.length > 0)
            return ke.map((Be) => ({ raw: Be, key: Be[e.rowKey] }))
        },
        Ke = C(() => {
          if (e.summary)
            return xt(e.summary)
              ? Ot(e.summary({ columns: me.value, data: De.value }))
              : Ot([rt()])
        }),
        ct = J(0),
        Tt = J(!0),
        Bt = J(!0),
        Dt = () => {
          let ke = !0,
            Be = !0
          const Qe = le.value
          Qe &&
            ((ke = ct.value === 0),
            (Be = Math.ceil(ct.value + Qe.offsetWidth) >= Qe.scrollWidth)),
            ke !== Tt.value && (Tt.value = ke),
            Be !== Bt.value && (Bt.value = Be)
        },
        jt = () =>
          Tt.value && Bt.value
            ? `${M}-scroll-position-both`
            : Tt.value
            ? `${M}-scroll-position-left`
            : Bt.value
            ? `${M}-scroll-position-right`
            : `${M}-scroll-position-middle`,
        _n = () => {
          const ke = []
          return (
            Ve.value && ke.push(`${M}-has-fixed-col-left`),
            nt.value && ke.push(`${M}-has-fixed-col-right`),
            ke
          )
        },
        Dn = (ke) => {
          ke.target.scrollLeft !== ct.value &&
            (ct.value = ke.target.scrollLeft),
            Dt()
        },
        kr = (ke) => {
          Dn(ke)
          const { scrollLeft: Be } = ke.target
          U.value && (U.value.scrollLeft = Be),
            R.value && (R.value.scrollLeft = Be)
        },
        ei = (ke, Be) => {
          t('rowClick', ke.raw, Be)
        },
        Fn = (ke, Be) => {
          t('rowDblclick', ke.raw, Be)
        },
        un = (ke, Be) => {
          t('rowContextmenu', ke.raw, Be)
        },
        Ka = (ke, Be, Qe) => {
          t('cellClick', ke.raw, Be, Qe)
        },
        Wn = (ke, Be, Qe) => {
          t('cellDblclick', ke.raw, Be, Qe)
        },
        Wi = (ke, Be, Qe) => {
          t('cellContextmenu', ke.raw, Be, Qe)
        },
        Ds = (ke, Be) => {
          t('headerClick', ke, Be)
        },
        $n = C(() => {
          var ke, Be
          const Qe = [],
            St = Ve.value || nt.value
          let At, Vt, vn
          ;((ke = e.draggable) == null ? void 0 : ke.type) === 'handle' &&
            ((At = {
              name: 'drag-handle',
              title: e.draggable.title,
              width: e.draggable.width,
              fixed: e.draggable.fixed || St,
            }),
            Qe.push(At)),
            e.expandable &&
              ((Vt = {
                name: 'expand',
                title: e.expandable.title,
                width: e.expandable.width,
                fixed: e.expandable.fixed || St,
              }),
              Qe.push(Vt)),
            e.rowSelection &&
              ((vn = {
                name:
                  e.rowSelection.type === 'radio'
                    ? 'selection-radio'
                    : 'selection-checkbox',
                title: e.rowSelection.title,
                width: e.rowSelection.width,
                fixed: e.rowSelection.fixed || St,
              }),
              Qe.push(vn)),
            !We.value &&
              Qe.length > 0 &&
              Qe[Qe.length - 1].fixed &&
              (Qe[Qe.length - 1].isLastLeftFixed = !0)
          const or = (Be = e.components) == null ? void 0 : Be.operations
          return xt(or) ? or({ dragHandle: At, expand: Vt, selection: vn }) : Qe
        }),
        qa = C(() => {
          var ke, Be, Qe, St
          if (k.value.x) {
            const At = {
              width: it((ke = e.scroll) == null ? void 0 : ke.x)
                ? `${(Be = e.scroll) == null ? void 0 : Be.x}px`
                : (Qe = e.scroll) == null
                ? void 0
                : Qe.x,
            }
            return (
              (St = e.scroll) != null &&
                St.minWidth &&
                (At.minWidth = it(e.scroll.minWidth)
                  ? `${e.scroll.minWidth}px`
                  : e.scroll.minWidth),
              At
            )
          }
        }),
        Un = C(() => {
          var ke, Be, Qe, St
          if (k.value.x && Xe.value.length > 0) {
            const At = {
              width: it((ke = e.scroll) == null ? void 0 : ke.x)
                ? `${(Be = e.scroll) == null ? void 0 : Be.x}px`
                : (Qe = e.scroll) == null
                ? void 0
                : Qe.x,
            }
            return (
              (St = e.scroll) != null &&
                St.minWidth &&
                (At.minWidth = it(e.scroll.minWidth)
                  ? `${e.scroll.minWidth}px`
                  : e.scroll.minWidth),
              At
            )
          }
        })
      sn(
        uc,
        Je({
          loadMore: s,
          addLazyLoadData: _t,
          slots: n,
          sorter: Ae,
          filters: re,
          filterIconAlignLeft: l,
          resizingColumn: hi,
          checkStrictly: A,
          currentAllEnabledRowKeys: xe,
          currentSelectedRowKeys: et,
          addColumn: (ke, Be) => {
            oe.set(ke, Be)
          },
          removeColumn: (ke) => {
            oe.delete(ke)
          },
          onSelectAll: kt,
          onSelect: Ne,
          onSelectAllLeafs: Et,
          onSorterChange: ie,
          onFilterChange: z,
          onThMouseDown: Ur,
        })
      )
      const Qn = C(() => [
          M,
          `${M}-size-${e.size}`,
          {
            [`${M}-border`]: w.value.wrapper,
            [`${M}-border-cell`]: w.value.cell,
            [`${M}-border-header-cell`]: !w.value.cell && w.value.headerCell,
            [`${M}-border-body-cell`]: !w.value.cell && w.value.bodyCell,
            [`${M}-stripe`]: e.stripe,
            [`${M}-hover`]: e.hoverable,
            [`${M}-dragging`]: ln.dragging,
            [`${M}-type-selection`]: !!e.rowSelection,
            [`${M}-empty`]: e.data && Xe.value.length === 0,
            [`${M}-layout-fixed`]:
              e.tableLayoutFixed || k.value.x || q.value || D.value,
          },
        ]),
        Xa = C(() => [
          `${M}-pagination`,
          {
            [`${M}-pagination-left`]:
              e.pagePosition === 'tl' || e.pagePosition === 'bl',
            [`${M}-pagination-center`]:
              e.pagePosition === 'top' || e.pagePosition === 'bottom',
            [`${M}-pagination-right`]:
              e.pagePosition === 'tr' || e.pagePosition === 'br',
            [`${M}-pagination-top`]: qe.value,
          },
        ]),
        hc = C(() => {
          const ke = _n()
          return (
            k.value.x && ke.push(jt()), q.value && ke.push(`${M}-scroll-y`), ke
          )
        }),
        zo = C(() => !!e.virtualListProps),
        Dl = J({}),
        Nl = () => {
          const ke = {}
          for (const Be of Object.keys(j.value))
            ke[Be] = j.value[Be].offsetWidth
          Dl.value = ke
        },
        Bs = J(!1),
        pc = () => (V.value ? V.value.offsetWidth > V.value.clientWidth : !1),
        vc = () => {
          const ke = pc()
          Bs.value !== ke && (Bs.value = ke), Dt(), Nl()
        }
      Wt(() => {
        ;(Bs.value = pc()), Nl()
      })
      const mc = C(() => (Ht(e.loading) ? e.loading : { loading: e.loading })),
        Ya = () =>
          m(
            $a,
            { empty: !0 },
            {
              default: () => [
                m(
                  bs,
                  { colSpan: me.value.length + $n.value.length },
                  {
                    default: () => {
                      var ke, Be, Qe, St, At
                      return [
                        (At =
                          (St = (ke = n.empty) == null ? void 0 : ke.call(n)) !=
                          null
                            ? St
                            : (Qe =
                                x == null ? void 0 : (Be = x.slots).empty) ==
                              null
                            ? void 0
                            : Qe.call(Be, { component: 'table' })) != null
                          ? At
                          : m(Ls, null, null),
                      ]
                    },
                  }
                ),
              ],
            }
          ),
        lf = (ke) => {
          var Be
          if (ke.expand) return xt(ke.expand) ? ke.expand() : ke.expand
          if (n['expand-row']) return n['expand-row']({ record: ke.raw })
          if ((Be = e.expandable) != null && Be.expandedRowRender)
            return e.expandable.expandedRowRender(ke.raw)
        },
        gc = C(() => [].concat($n.value, me.value)),
        Cm = C(() => (e.spanAll ? gc.value : me.value)),
        { tableSpan: yc, removedCells: bc } = OE({
          spanMethod: g,
          data: Xe,
          columns: Cm,
        }),
        { tableSpan: _c, removedCells: Sc } = OE({
          spanMethod: b,
          data: Xe,
          columns: gc,
        }),
        Bl = (ke) => {
          if (!(!zo.value || !ke || !Dl.value[ke]))
            return { width: `${Dl.value[ke]}px` }
        },
        wm = (ke, Be) =>
          m(
            $a,
            {
              key: `table-summary-${Be}`,
              class: [
                `${M}-tr-summary`,
                xt(e.rowClass) ? e.rowClass(ke.raw, Be) : e.rowClass,
              ],
              onClick: (Qe) => ei(ke, Qe),
            },
            {
              default: () => [
                $n.value.map((Qe, St) => {
                  var At
                  const Vt = `${Be}-${St}`,
                    [vn, or] = (At = _c.value[Vt]) != null ? At : [1, 1]
                  if (Sc.value.includes(Vt)) return null
                  const ti = Bl(Qe.name)
                  return m(
                    kE,
                    {
                      style: ti,
                      operationColumn: Qe,
                      operations: $n.value,
                      record: ke,
                      rowSpan: vn,
                      colSpan: or,
                      summary: !0,
                    },
                    null
                  )
                }),
                me.value.map((Qe, St) => {
                  var At
                  const Vt = `${Be}-${$n.value.length + St}`,
                    [vn, or] = (At = _c.value[Vt]) != null ? At : [1, 1]
                  if (Sc.value.includes(Vt)) return null
                  const ti = Bl(Qe.dataIndex)
                  return m(
                    bs,
                    {
                      key: `td-${Vt}`,
                      style: ti,
                      rowIndex: Be,
                      record: ke,
                      column: Qe,
                      operations: $n.value,
                      dataColumns: me.value,
                      rowSpan: vn,
                      colSpan: or,
                      summary: !0,
                      onClick: (pi) => Ka(ke, Qe, pi),
                      onDblclick: (pi) => Wn(ke, Qe, pi),
                      onContextmenu: (pi) => Wi(ke, Qe, pi),
                    },
                    { td: n.td, cell: n['summary-cell'] }
                  )
                }),
              ],
              tr: n.tr,
            }
          ),
        uf = () =>
          Ke.value
            ? m('tfoot', null, [Ke.value.map((ke, Be) => wm(ke, Be))])
            : null,
        Cc = (ke, Be = !0) => {
          var Qe, St, At, Vt, vn
          const or = ke.key,
            ti = lt.value.includes(or)
          return m(
            'button',
            {
              type: 'button',
              class: `${M}-expand-btn`,
              onClick: (pi) => {
                gt(or, ke.raw), Be && pi.stopPropagation()
              },
            },
            [
              (vn =
                (Vt =
                  (Qe = n['expand-icon']) == null
                    ? void 0
                    : Qe.call(n, { expanded: ti, record: ke.raw })) != null
                  ? Vt
                  : (At = (St = e.expandable) == null ? void 0 : St.icon) ==
                    null
                  ? void 0
                  : At.call(St, ti, ke.raw)) != null
                ? vn
                : m(ti ? lS : Xu, null, null),
            ]
          )
        },
        xm = (
          ke,
          { indentSize: Be, indexPath: Qe, allowDrag: St, expandContent: At }
        ) => {
          var Vt
          if (ke.hasSubtree)
            return (Vt = ke.children) == null
              ? void 0
              : Vt.map((vn, or) =>
                  wc(vn, or, { indentSize: Be, indexPath: Qe, allowDrag: St })
                )
          if (At) {
            const vn = le.value
            return m(
              $a,
              { key: `${ke.key}-expand`, expand: !0 },
              {
                default: () => [
                  m(
                    bs,
                    {
                      isFixedExpand: Ve.value || nt.value,
                      containerWidth: vn == null ? void 0 : vn.clientWidth,
                      colSpan: me.value.length + $n.value.length,
                    },
                    Ane(At) ? At : { default: () => [At] }
                  ),
                ],
              }
            )
          }
          return null
        },
        wc = (
          ke,
          Be,
          { indentSize: Qe = 0, indexPath: St, allowDrag: At = !0 } = {}
        ) => {
          var Vt
          const vn = ke.key,
            or = (St ?? []).concat(Be),
            ti = lf(ke),
            pi = lt.value.includes(vn),
            Fl = ln.sourceKey === ke.key,
            jn = Zt.value
              ? {
                  draggable: At,
                  onDragstart: (Sn) => {
                    At && Pn(Sn, ke.key, or, ke.raw)
                  },
                  onDragend: (Sn) => {
                    At && pn(Sn)
                  },
                }
              : {},
            Mc = Zt.value
              ? {
                  onDragenter: (Sn) => {
                    At && Tr(Sn, or)
                  },
                  onDragover: (Sn) => {
                    At && Gt(Sn)
                  },
                  onDrop: (Sn) => {
                    At && (G('drag'), yr(Sn))
                  },
                }
              : {}
          return m(yt, null, [
            m(
              $a,
              Fe(
                {
                  key: vn,
                  class: [
                    {
                      [`${M}-tr-draggable`]: Zt.value === 'row',
                      [`${M}-tr-drag`]: Fl,
                    },
                    xt(e.rowClass) ? e.rowClass(ke, Be) : e.rowClass,
                  ],
                  rowIndex: Be,
                  record: ke,
                  checked: (Vt = Le.value) == null ? void 0 : Vt.includes(vn),
                  onClick: (Sn) => ei(ke, Sn),
                  onDblclick: (Sn) => Fn(ke, Sn),
                  onContextmenu: (Sn) => un(ke, Sn),
                },
                Zt.value === 'row' ? jn : {},
                Mc
              ),
              {
                default: () => [
                  $n.value.map((Sn, Vo) => {
                    var fa
                    const br = `${Be}-${Vo}`,
                      [zl, Vl] = e.spanAll
                        ? (fa = yc.value[br]) != null
                          ? fa
                          : [1, 1]
                        : [1, 1]
                    if (e.spanAll && bc.value.includes(br)) return null
                    const Ul = Bl(Sn.name)
                    return m(
                      kE,
                      Fe(
                        {
                          key: `operation-td-${Vo}`,
                          style: Ul,
                          operationColumn: Sn,
                          operations: $n.value,
                          record: ke,
                          hasExpand: !!ti,
                          selectedRowKeys: et.value,
                          rowSpan: zl,
                          colSpan: Vl,
                          renderExpandBtn: Cc,
                        },
                        Zt.value === 'handle' ? jn : {}
                      ),
                      { 'drag-handle-icon': n['drag-handle-icon'] }
                    )
                  }),
                  me.value.map((Sn, Vo) => {
                    var fa
                    const br = `${Be}-${e.spanAll ? $n.value.length + Vo : Vo}`,
                      [zl, Vl] = (fa = yc.value[br]) != null ? fa : [1, 1]
                    if (bc.value.includes(br)) return null
                    const Ul =
                        Vo === 0
                          ? {
                              showExpandBtn: ke.hasSubtree,
                              indentSize: ke.hasSubtree ? Qe - 20 : Qe,
                            }
                          : {},
                      pf = Bl(Sn.dataIndex)
                    return m(
                      bs,
                      Fe(
                        {
                          key: `td-${Vo}`,
                          style: pf,
                          rowIndex: Be,
                          record: ke,
                          column: Sn,
                          operations: $n.value,
                          dataColumns: me.value,
                          rowSpan: zl,
                          renderExpandBtn: Cc,
                          colSpan: Vl,
                        },
                        Ul,
                        {
                          onClick: (Za) => Ka(ke, Sn, Za),
                          onDblclick: (Za) => Wn(ke, Sn, Za),
                          onContextmenu: (Za) => Wi(ke, Sn, Za),
                        }
                      ),
                      { td: n.td }
                    )
                  }),
                ],
                tr: n.tr,
              }
            ),
            pi &&
              xm(ke, {
                indentSize: Qe + e.indentSize,
                indexPath: or,
                allowDrag: At && !Fl,
                expandContent: ti,
              }),
          ])
        },
        cf = () => {
          const ke = Xe.value.some((Be) => !!Be.hasSubtree)
          return m(gd, null, {
            default: () => [
              Xe.value.length > 0
                ? Xe.value.map((Be, Qe) =>
                    wc(Be, Qe, { indentSize: ke ? 20 : 0 })
                  )
                : Ya(),
            ],
            tbody: n.tbody,
          })
        },
        df = () =>
          m(md, null, {
            default: () => [
              Re.value.map((ke, Be) =>
                m(
                  $a,
                  { key: `header-row-${Be}` },
                  {
                    default: () => [
                      Be === 0 &&
                        $n.value.map((Qe, St) => {
                          var At
                          return m(
                            _ne,
                            {
                              key: `operation-th-${St}`,
                              ref: (Vt) => {
                                Vt != null &&
                                  Vt.$el &&
                                  Qe.name &&
                                  (j.value[Qe.name] = Vt.$el)
                              },
                              operationColumn: Qe,
                              operations: $n.value,
                              selectAll: !!(
                                Qe.name === 'selection-checkbox' &&
                                (At = e.rowSelection) != null &&
                                At.showCheckedAll
                              ),
                              rowSpan: Re.value.length,
                            },
                            null
                          )
                        }),
                      ke.map((Qe, St) => {
                        const At =
                          e.columnResizable &&
                          !!Qe.dataIndex &&
                          St < ke.length - 1
                        return m(
                          yd,
                          {
                            key: `th-${St}`,
                            ref: (Vt) => {
                              Vt != null &&
                                Vt.$el &&
                                Qe.dataIndex &&
                                (j.value[Qe.dataIndex] = Vt.$el)
                            },
                            column: Qe,
                            operations: $n.value,
                            dataColumns: me.value,
                            resizable: At,
                            onClick: (Vt) => Ds(Qe, Vt),
                          },
                          { th: n.th }
                        )
                      }),
                    ],
                  }
                )
              ),
            ],
            thead: n.thead,
          }),
        xc = () => {
          if (q.value) {
            const ke = {}
            Bs.value && (ke.overflowY = 'scroll'),
              it(e.stickyHeader) && (ke.top = `${e.stickyHeader}px`)
            const Be = F.value ? ia : 'div'
            return m(yt, null, [
              e.showHeader &&
                m(
                  Be,
                  Fe(
                    {
                      ref: Y,
                      class: [
                        `${M}-header`,
                        { [`${M}-header-sticky`]: e.stickyHeader },
                      ],
                      style: ke,
                    },
                    y.value
                      ? Zs(
                          { hide: Xe.value.length !== 0, disableVertical: !0 },
                          T.value
                        )
                      : void 0
                  ),
                  {
                    default: () => [
                      m(
                        'table',
                        {
                          class: `${M}-element`,
                          style: qa.value,
                          cellpadding: 0,
                          cellspacing: 0,
                        },
                        [
                          m(
                            mh,
                            {
                              dataColumns: me.value,
                              operations: $n.value,
                              columnWidth: Qr,
                            },
                            null
                          ),
                          df(),
                        ]
                      ),
                    ],
                  }
                ),
              m(
                Ro,
                { onResize: vc },
                {
                  default: () => {
                    var Qe, St
                    return [
                      zo.value
                        ? m(
                            Qv,
                            Fe(
                              {
                                ref: (At) => {
                                  At != null && At.$el && (V.value = At.$el)
                                },
                                class: `${M}-body`,
                                data: Xe.value,
                                itemKey: '_key',
                                component: { list: 'table', content: 'tbody' },
                                listAttrs: {
                                  class: `${M}-element`,
                                  style: Un.value,
                                },
                                paddingPosition: 'list',
                              },
                              e.virtualListProps,
                              { onScroll: kr }
                            ),
                            { item: ({ item: At, index: Vt }) => wc(At, Vt) }
                          )
                        : m(
                            Be,
                            Fe(
                              {
                                ref: B,
                                class: `${M}-body`,
                                style: {
                                  maxHeight: it(
                                    (Qe = e.scroll) == null ? void 0 : Qe.y
                                  )
                                    ? `${
                                        (St = e.scroll) == null ? void 0 : St.y
                                      }px`
                                    : '100%',
                                },
                              },
                              y.value
                                ? Zs(
                                    {
                                      outerStyle: {
                                        display: 'flex',
                                        minHeight: '0',
                                      },
                                    },
                                    T.value
                                  )
                                : void 0,
                              { onScroll: kr }
                            ),
                            {
                              default: () => [
                                m(
                                  'table',
                                  {
                                    class: `${M}-element`,
                                    style: Un.value,
                                    cellpadding: 0,
                                    cellspacing: 0,
                                  },
                                  [
                                    Xe.value.length !== 0 &&
                                      m(
                                        mh,
                                        {
                                          dataColumns: me.value,
                                          operations: $n.value,
                                          columnWidth: Qr,
                                        },
                                        null
                                      ),
                                    cf(),
                                  ]
                                ),
                              ],
                            }
                          ),
                    ]
                  },
                }
              ),
              Ke.value &&
                Ke.value.length &&
                m(
                  'div',
                  {
                    ref: R,
                    class: `${M}-tfoot`,
                    style: { overflowY: Bs.value ? 'scroll' : 'hidden' },
                  },
                  [
                    m(
                      'table',
                      {
                        class: `${M}-element`,
                        style: Un.value,
                        cellpadding: 0,
                        cellspacing: 0,
                      },
                      [
                        m(
                          mh,
                          {
                            dataColumns: me.value,
                            operations: $n.value,
                            columnWidth: Qr,
                          },
                          null
                        ),
                        uf(),
                      ]
                    ),
                  ]
                ),
            ])
          }
          return m(
            Ro,
            { onResize: () => Dt() },
            {
              default: () => [
                m(
                  'table',
                  {
                    class: `${M}-element`,
                    cellpadding: 0,
                    cellspacing: 0,
                    style: Un.value,
                  },
                  [
                    m(
                      mh,
                      {
                        dataColumns: me.value,
                        operations: $n.value,
                        columnWidth: Qr,
                      },
                      null
                    ),
                    e.showHeader && df(),
                    cf(),
                    Ke.value && Ke.value.length && uf(),
                  ]
                ),
              ],
            }
          )
        },
        ff = (ke) => {
          var Be
          const Qe =
              (Be = e.scroll) != null && Be.maxHeight
                ? { maxHeight: e.scroll.maxHeight }
                : void 0,
            St = F.value ? ia : 'div'
          return m(yt, null, [
            m('div', { class: [`${M}-container`, hc.value] }, [
              m(
                St,
                Fe(
                  {
                    ref: N,
                    class: [
                      `${M}-content`,
                      { [`${M}-content-scroll-x`]: !q.value },
                    ],
                    style: Qe,
                  },
                  y.value
                    ? Zs({ outerStyle: { height: '100%' } }, T.value)
                    : void 0,
                  { onScroll: Dn }
                ),
                {
                  default: () => [
                    ke
                      ? m(
                          'table',
                          {
                            class: `${M}-element`,
                            cellpadding: 0,
                            cellspacing: 0,
                          },
                          [ke()]
                        )
                      : xc(),
                  ],
                }
              ),
            ]),
            n.footer && m('div', { class: `${M}-footer` }, [n.footer()]),
          ])
        },
        hf = () => {
          var ke, Be
          const Qe = Ht(e.pagination)
            ? xr(e.pagination, [
                'current',
                'pageSize',
                'defaultCurrent',
                'defaultPageSize',
              ])
            : {}
          return m('div', { class: Xa.value }, [
            (ke = n['pagination-left']) == null ? void 0 : ke.call(n),
            m(
              hS,
              Fe(
                {
                  total: co.value.length,
                  current: fo.value,
                  pageSize: ho.value,
                  onChange: (St) => {
                    Rs(St), G('pagination')
                  },
                  onPageSizeChange: (St) => {
                    fe(St), G('pagination')
                  },
                },
                Qe
              ),
              null
            ),
            (Be = n['pagination-right']) == null ? void 0 : Be.call(n),
          ])
        },
        Mm = C(() => {
          var ke, Be
          if (ir((ke = e.scroll) == null ? void 0 : ke.y))
            return { height: (Be = e.scroll) == null ? void 0 : Be.y }
        })
      return {
        render: () => {
          var ke
          return n.default
            ? m('div', { class: Qn.value }, [ff(n.default)])
            : ((E.value = (ke = n.columns) == null ? void 0 : ke.call(n)),
              m('div', { class: Qn.value, style: Mm.value }, [
                E.value,
                m(Do, mc.value, {
                  default: () => [
                    e.pagination !== !1 &&
                      (Xe.value.length > 0 || ki.value.length > 0) &&
                      qe.value &&
                      hf(),
                    ff(),
                    e.pagination !== !1 &&
                      (Xe.value.length > 0 || ki.value.length > 0) &&
                      !qe.value &&
                      hf(),
                  ],
                }),
              ]))
        },
        selfExpand: _e,
        selfExpandAll: bt,
        selfSelect: je,
        selfSelectAll: Ge,
        selfResetFilters: pe,
        selfClearFilters: we,
        selfResetSorters: ft,
        selfClearSorters: Q,
      }
    },
    methods: {
      selectAll(e) {
        return this.selfSelectAll(e)
      },
      select(e, t) {
        return this.selfSelect(e, t)
      },
      expandAll(e) {
        return this.selfExpandAll(e)
      },
      expand(e, t) {
        return this.selfExpand(e, t)
      },
      resetFilters(e) {
        return this.selfResetFilters(e)
      },
      clearFilters(e) {
        return this.selfClearFilters(e)
      },
      resetSorters() {
        return this.selfResetSorters()
      },
      clearSorters() {
        return this.selfClearSorters()
      },
    },
    render() {
      return this.render()
    },
  })
  const yo = (e, t) => {
    const n = Vi(e, t),
      r = J(n.value)
    return (
      pt(n, (i, o) => {
        ac(i, o) || (r.value = i)
      }),
      r
    )
  }
  var zp = ce({
    name: 'TableColumn',
    props: {
      dataIndex: String,
      title: String,
      width: Number,
      align: { type: String },
      fixed: { type: String },
      ellipsis: { type: Boolean, default: !1 },
      sortable: { type: Object, default: void 0 },
      filterable: { type: Object, default: void 0 },
      cellClass: { type: [String, Array, Object] },
      headerCellClass: { type: [String, Array, Object] },
      bodyCellClass: { type: [String, Array, Object, Function] },
      summaryCellClass: { type: [String, Array, Object, Function] },
      cellStyle: { type: Object },
      headerCellStyle: { type: Object },
      bodyCellStyle: { type: [Object, Function] },
      summaryCellStyle: { type: [Object, Function] },
      index: { type: Number },
      tooltip: { type: [Boolean, Object], default: !1 },
    },
    setup(e, { slots: t }) {
      var n
      const {
          dataIndex: r,
          title: i,
          width: o,
          align: a,
          fixed: s,
          ellipsis: l,
          index: c,
        } = tt(e),
        d = yo(e, 'sortable'),
        h = yo(e, 'filterable'),
        p = yo(e, 'cellClass'),
        v = yo(e, 'headerCellClass'),
        g = yo(e, 'bodyCellClass'),
        _ = yo(e, 'summaryCellClass'),
        b = yo(e, 'cellStyle'),
        y = yo(e, 'headerCellStyle'),
        M = yo(e, 'bodyCellStyle'),
        x = yo(e, 'summaryCellStyle'),
        w = yo(e, 'tooltip'),
        E = Jr(),
        P = zt(uc, {}),
        A = zt(wE, void 0),
        { children: F, components: T } = Jd('TableColumn'),
        k = Je(new Map())
      sn(wE, {
        addChild: (B, V) => {
          k.set(B, V)
        },
        removeChild: (B) => {
          k.delete(B)
        },
      })
      const N = J()
      pt([T, k], ([B, V]) => {
        if (B.length > 0) {
          const L = []
          B.forEach((W) => {
            const Y = V.get(W)
            Y && L.push(Y)
          }),
            (N.value = L)
        } else N.value = void 0
      })
      const I = Je({
        dataIndex: r,
        title: i,
        width: o,
        align: a,
        fixed: s,
        ellipsis: l,
        sortable: d,
        filterable: h,
        cellClass: p,
        headerCellClass: v,
        bodyCellClass: g,
        summaryCellClass: _,
        cellStyle: b,
        headerCellStyle: y,
        bodyCellStyle: M,
        summaryCellStyle: x,
        index: c,
        tooltip: w,
        children: N,
        slots: t,
      })
      return (
        E &&
          (A
            ? A.addChild(E.uid, I)
            : (n = P.addColumn) == null || n.call(P, E.uid, I)),
        Pr(() => {
          var B
          E &&
            (A
              ? A.removeChild(E.uid)
              : (B = P.removeColumn) == null || B.call(P, E.uid))
        }),
        () => {
          var B
          return (
            (F.value = (B = t.default) == null ? void 0 : B.call(t)), F.value
          )
        }
      )
    },
  })
  const $ne = Object.assign(Xy, {
      Thead: md,
      Tbody: gd,
      Tr: $a,
      Th: yd,
      Td: bs,
      Column: zp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Xy.name, Xy),
          e.component(n + md.name, md),
          e.component(n + gd.name, gd),
          e.component(n + $a.name, $a),
          e.component(n + yd.name, yd),
          e.component(n + bs.name, bs),
          e.component(n + zp.name, zp)
      },
    }),
    One = ({ direction: e, type: t, offset: n }) =>
      e === 'vertical'
        ? { transform: `translateY(${-n}px)` }
        : { transform: `translateX(${-n}px)` },
    bS = Symbol('ArcoTabs'),
    Lne = ce({
      name: 'TabsTab',
      components: { IconHover: In, IconClose: zr },
      props: {
        tab: { type: Object, required: !0 },
        active: Boolean,
        editable: Boolean,
      },
      emits: ['click', 'delete'],
      setup(e, { emit: t }) {
        const n = ye('tabs-tab'),
          r = zt(bS, {}),
          i = (c) => {
            e.tab.disabled || t('click', e.tab.key, c)
          },
          o = (c) => {
            c.key === 'Enter' && i(c)
          },
          a = C(() =>
            Object.assign(
              r.trigger === 'click' ? { onClick: i } : { onMouseover: i },
              { onKeydown: o }
            )
          ),
          s = (c) => {
            e.tab.disabled || t('delete', e.tab.key, c)
          },
          l = C(() => [
            n,
            {
              [`${n}-active`]: e.active,
              [`${n}-closable`]: e.editable && e.tab.closable,
              [`${n}-disabled`]: e.tab.disabled,
            },
          ])
        return { prefixCls: n, cls: l, eventHandlers: a, handleDelete: s }
      },
    })
  function Ine(e, t, n, r, i, o) {
    const a = ge('icon-close'),
      s = ge('icon-hover')
    return (
      O(),
      Z(
        'div',
        Fe({ tabindex: '0', class: e.cls }, e.eventHandlers),
        [
          Se(
            'span',
            { class: H(`${e.prefixCls}-title`) },
            [ve(e.$slots, 'default')],
            2
          ),
          e.editable && e.tab.closable
            ? (O(),
              Ee(
                s,
                {
                  key: 0,
                  class: H(`${e.prefixCls}-close-btn`),
                  onClick: io(e.handleDelete, ['stop']),
                },
                { default: ze(() => [m(a)]), _: 1 },
                8,
                ['class', 'onClick']
              ))
            : Ce('v-if', !0),
        ],
        16
      )
    )
  }
  var Rne = Te(Lne, [['render', Ine]])
  function Dne(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var NE = ce({
    name: 'TabsButton',
    props: {
      type: { type: String, default: 'next' },
      direction: { type: String, default: 'horizontal' },
      disabled: { type: Boolean, default: !1 },
      onClick: { type: Function },
    },
    emits: ['click'],
    setup(e, { emit: t }) {
      const n = ye('tabs-nav-button'),
        r = (a) => {
          e.disabled || t('click', e.type, a)
        },
        i = () =>
          e.direction === 'horizontal'
            ? e.type === 'next'
              ? m(No, null, null)
              : m(ja, null, null)
            : e.type === 'next'
            ? m(sc, null, null)
            : m(Y_, null, null),
        o = C(() => [
          n,
          {
            [`${n}-disabled`]: e.disabled,
            [`${n}-left`]:
              e.direction === 'horizontal' && e.type === 'previous',
            [`${n}-right`]: e.direction === 'horizontal' && e.type === 'next',
            [`${n}-up`]: e.direction === 'vertical' && e.type === 'previous',
            [`${n}-down`]: e.direction === 'vertical' && e.type === 'next',
          },
        ])
      return () => {
        let a
        return m('div', { class: o.value, onClick: r }, [
          m(
            In,
            { disabled: e.disabled },
            Dne((a = i())) ? a : { default: () => [a] }
          ),
        ])
      }
    },
  })
  const Nne = ce({
    name: 'TabsNavInk',
    props: {
      activeTabRef: { type: Object },
      direction: { type: String },
      disabled: Boolean,
      animation: Boolean,
    },
    setup(e) {
      const { activeTabRef: t } = tt(e),
        n = ye('tabs-nav-ink'),
        r = J(0),
        i = J(0),
        o = C(() =>
          e.direction === 'vertical'
            ? { top: `${r.value}px`, height: `${i.value}px` }
            : { left: `${r.value}px`, width: `${i.value}px` }
        ),
        a = () => {
          if (t.value) {
            const l =
                e.direction === 'vertical'
                  ? t.value.offsetTop
                  : t.value.offsetLeft,
              c =
                e.direction === 'vertical'
                  ? t.value.offsetHeight
                  : t.value.offsetWidth
            ;(l !== r.value || c !== i.value) && ((r.value = l), (i.value = c))
          }
        }
      Wt(() => {
        hn(() => a())
      }),
        Zr(() => {
          a()
        })
      const s = C(() => [
        n,
        { [`${n}-animation`]: e.animation, [`${n}-disabled`]: e.disabled },
      ])
      return { prefixCls: n, cls: s, style: o }
    },
  })
  function Bne(e, t, n, r, i, o) {
    return O(), Z('div', { class: H(e.cls), style: at(e.style) }, null, 6)
  }
  var Fne = Te(Nne, [['render', Bne]]),
    zne = ce({
      name: 'TabsNav',
      props: {
        tabs: { type: Array, required: !0 },
        direction: { type: String, required: !0 },
        type: { type: String, required: !0 },
        activeKey: { type: [String, Number] },
        activeIndex: { type: Number, required: !0 },
        position: { type: String, required: !0 },
        size: { type: String, required: !0 },
        showAddButton: { type: Boolean, default: !1 },
        editable: { type: Boolean, default: !1 },
        animation: { type: Boolean, required: !0 },
        headerPadding: { type: Boolean, default: !0 },
      },
      emits: ['click', 'add', 'delete'],
      setup(e, { emit: t, slots: n }) {
        const { tabs: r, activeKey: i, activeIndex: o, direction: a } = tt(e),
          s = ye('tabs-nav'),
          l = J(),
          c = J(),
          d = J({}),
          h = C(() => {
            if (!Mt(i.value)) return d.value[i.value]
          }),
          p = J(),
          v = C(
            () => e.editable && ['line', 'card', 'card-gutter'].includes(e.type)
          ),
          g = J(!1),
          _ = J(0),
          b = J(0),
          y = J([]),
          M = J(0),
          x = () => {
            var U, le, q
            return (q =
              a.value === 'vertical'
                ? (U = l.value) == null
                  ? void 0
                  : U.offsetHeight
                : (le = l.value) == null
                ? void 0
                : le.offsetWidth) != null
              ? q
              : 0
          },
          w = () =>
            !c.value || !l.value
              ? 0
              : a.value === 'vertical'
              ? c.value.offsetHeight - l.value.offsetHeight
              : c.value.offsetWidth - l.value.offsetWidth,
          E = () =>
            r.value.map((U) => {
              const le = d.value[U.key]
              return a.value === 'vertical'
                ? le.offsetTop + le.offsetHeight
                : le.offsetLeft + le.offsetWidth
            }),
          P = () => {
            ;(g.value = A()),
              g.value
                ? ((_.value = x()),
                  (b.value = w()),
                  (y.value = E()),
                  M.value > b.value && (M.value = b.value))
                : (M.value = 0)
          },
          A = () =>
            l.value && c.value
              ? e.direction === 'vertical'
                ? c.value.offsetHeight > l.value.offsetHeight
                : c.value.offsetWidth > l.value.offsetWidth
              : !1,
          F = (U) => {
            var le
            return (
              ((le = y.value[U - 1]) != null ? le : 0) >= M.value &&
              y.value[U] <= M.value + _.value
            )
          },
          T = (U) =>
            l.value
              ? U === 'previous'
                ? M.value - _.value
                : M.value + _.value
              : 0,
          k = (U) =>
            !l.value || !c.value || U < 0 ? 0 : U > b.value ? b.value : U,
          R = (U, le) => {
            t('click', U, le)
          },
          j = (U, le) => {
            t('delete', U, le)
          },
          N = (U) => {
            M.value = k(T(U))
          },
          I = () => {
            P(), p.value && p.value.$forceUpdate()
          }
        pt(r, () => {
          hn(() => {
            P()
          })
        }),
          pt(o, (U, le) => {
            hn(() => {
              var q
              if (g.value)
                if (U >= le) {
                  const oe = U < y.value.length - 1 ? U + 1 : U
                  F(oe) || (M.value = y.value[oe] - _.value)
                } else {
                  const oe = U > 0 ? U - 1 : U
                  F(oe) || (M.value = (q = y.value[oe - 1]) != null ? q : 0)
                }
            })
          }),
          Wt(() => {
            P()
          })
        const B = () =>
            !v.value || !e.showAddButton
              ? null
              : m(
                  'div',
                  { class: `${s}-add-btn`, onClick: (U) => t('add', U) },
                  [m(In, null, { default: () => [m(Xu, null, null)] })]
                ),
          V = C(() => [
            s,
            `${s}-${e.direction}`,
            `${s}-${e.position}`,
            `${s}-size-${e.size}`,
            `${s}-type-${e.type}`,
          ]),
          L = C(() => [
            `${s}-tab-list`,
            {
              [`${s}-tab-list-no-padding`]:
                !e.headerPadding &&
                ['line', 'text'].includes(e.type) &&
                e.direction === 'horizontal',
            },
          ]),
          W = C(() =>
            One({ direction: e.direction, type: e.type, offset: M.value })
          ),
          Y = C(() => [`${s}-tab`, { [`${s}-tab-scroll`]: g.value }])
        return () => {
          var U
          return m('div', { class: V.value }, [
            g.value &&
              m(
                NE,
                {
                  type: 'previous',
                  direction: e.direction,
                  disabled: M.value <= 0,
                  onClick: N,
                },
                null
              ),
            m(
              Ro,
              { onResize: () => P() },
              {
                default: () => [
                  m('div', { class: Y.value, ref: l }, [
                    m(
                      Ro,
                      { onResize: I },
                      {
                        default: () => [
                          m('div', { ref: c, class: L.value, style: W.value }, [
                            e.tabs.map((le, q) =>
                              m(
                                Rne,
                                {
                                  key: le.key,
                                  ref: (oe) => {
                                    oe != null &&
                                      oe.$el &&
                                      (d.value[le.key] = oe.$el)
                                  },
                                  active: le.key === i.value,
                                  tab: le,
                                  editable: e.editable,
                                  onClick: R,
                                  onDelete: j,
                                },
                                {
                                  default: () => {
                                    var oe, te, ue
                                    return [
                                      (ue =
                                        (te = (oe = le.slots).title) == null
                                          ? void 0
                                          : te.call(oe)) != null
                                        ? ue
                                        : le.title,
                                    ]
                                  },
                                }
                              )
                            ),
                            e.type === 'line' &&
                              h.value &&
                              m(
                                Fne,
                                {
                                  ref: p,
                                  activeTabRef: h.value,
                                  direction: e.direction,
                                  disabled: !1,
                                  animation: e.animation,
                                },
                                null
                              ),
                          ]),
                        ],
                      }
                    ),
                    !g.value && B(),
                  ]),
                ],
              }
            ),
            g.value &&
              m(
                NE,
                {
                  type: 'next',
                  direction: e.direction,
                  disabled: M.value >= b.value,
                  onClick: N,
                },
                null
              ),
            m('div', { class: `${s}-extra` }, [
              g.value && B(),
              (U = n.extra) == null ? void 0 : U.call(n),
            ]),
          ])
        }
      },
    }),
    Yy = ce({
      name: 'Tabs',
      props: {
        activeKey: { type: [String, Number], default: void 0 },
        defaultActiveKey: { type: [String, Number], default: void 0 },
        position: { type: String, default: 'top' },
        size: { type: String },
        type: { type: String, default: 'line' },
        direction: { type: String, default: 'horizontal' },
        editable: { type: Boolean, default: !1 },
        showAddButton: { type: Boolean, default: !1 },
        destroyOnHide: { type: Boolean, default: !1 },
        lazyLoad: { type: Boolean, default: !1 },
        justify: { type: Boolean, default: !1 },
        animation: { type: Boolean, default: !1 },
        headerPadding: { type: Boolean, default: !0 },
        autoSwitch: { type: Boolean, default: !1 },
        hideContent: { type: Boolean, default: !1 },
        trigger: { type: String, default: 'click' },
      },
      emits: {
        'update:activeKey': (e) => !0,
        change: (e) => !0,
        tabClick: (e, t) => !0,
        add: (e) => !0,
        delete: (e, t) => !0,
      },
      setup(e, { emit: t, slots: n }) {
        const { size: r, lazyLoad: i, destroyOnHide: o, trigger: a } = tt(e),
          s = ye('tabs'),
          { mergedSize: l } = Vr(r),
          c = C(() => (e.direction === 'vertical' ? 'left' : e.position)),
          d = C(() =>
            ['left', 'right'].includes(c.value) ? 'vertical' : 'horizontal'
          ),
          { children: h, components: p } = Jd('TabPane'),
          v = Je(new Map()),
          g = C(() => {
            const R = []
            return (
              p.value.forEach((j) => {
                const N = v.get(j)
                N && R.push(N)
              }),
              R
            )
          }),
          _ = C(() => g.value.map((R) => R.key)),
          b = (R, j) => {
            v.set(R, j)
          },
          y = (R) => {
            v.delete(R)
          },
          M = J(e.defaultActiveKey),
          x = C(() => {
            var R
            const j = (R = e.activeKey) != null ? R : M.value
            return Mt(j) ? _.value[0] : j
          }),
          w = C(() => {
            const R = _.value.indexOf(x.value)
            return R === -1 ? 0 : R
          })
        sn(
          bS,
          Je({
            lazyLoad: i,
            destroyOnHide: o,
            activeKey: x,
            addItem: b,
            removeItem: y,
            trigger: a,
          })
        )
        const E = (R) => {
            R !== x.value &&
              ((M.value = R), t('update:activeKey', R), t('change', R))
          },
          P = (R, j) => {
            E(R), t('tabClick', R, j)
          },
          A = (R) => {
            t('add', R),
              e.autoSwitch &&
                hn(() => {
                  const j = _.value[_.value.length - 1]
                  E(j)
                })
          },
          F = (R, j) => {
            t('delete', R, j)
          },
          T = () =>
            m(
              'div',
              {
                class: [
                  `${s}-content`,
                  { [`${s}-content-hide`]: e.hideContent },
                ],
              },
              [
                m(
                  'div',
                  {
                    class: [
                      `${s}-content-list`,
                      { [`${s}-content-animation`]: e.animation },
                    ],
                    style: { marginLeft: `-${w.value * 100}%` },
                  },
                  [h.value]
                ),
              ]
            ),
          k = C(() => [
            s,
            `${s}-${d.value}`,
            `${s}-${c.value}`,
            `${s}-type-${e.type}`,
            `${s}-size-${l.value}`,
            { [`${s}-justify`]: e.justify },
          ])
        return () => {
          var R
          return (
            (h.value = (R = n.default) == null ? void 0 : R.call(n)),
            m('div', { class: k.value }, [
              c.value === 'bottom' && T(),
              m(
                zne,
                {
                  tabs: g.value,
                  activeKey: x.value,
                  activeIndex: w.value,
                  direction: d.value,
                  position: c.value,
                  editable: e.editable,
                  animation: e.animation,
                  showAddButton: e.showAddButton,
                  headerPadding: e.headerPadding,
                  size: l.value,
                  type: e.type,
                  onClick: P,
                  onAdd: A,
                  onDelete: F,
                },
                { extra: n.extra }
              ),
              c.value !== 'bottom' && T(),
            ])
          )
        }
      },
    }),
    Vne = Object.defineProperty,
    BE = Object.getOwnPropertySymbols,
    Une = Object.prototype.hasOwnProperty,
    Hne = Object.prototype.propertyIsEnumerable,
    FE = (e, t, n) =>
      t in e
        ? Vne(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Wne = (e, t) => {
      for (var n in t || (t = {})) Une.call(t, n) && FE(e, n, t[n])
      if (BE) for (var n of BE(t)) Hne.call(t, n) && FE(e, n, t[n])
      return e
    }
  const jne = ce({
    name: 'TabPane',
    props: {
      title: String,
      disabled: { type: Boolean, default: !1 },
      closable: { type: Boolean, default: !0 },
      destroyOnHide: { type: Boolean, default: !1 },
    },
    setup(e, { slots: t }) {
      var n
      const { title: r, disabled: i, closable: o } = tt(e),
        a = Jr(),
        s = ye('tabs'),
        l = zt(bS, {}),
        c = J(),
        d = C(() => (a == null ? void 0 : a.vnode.key)),
        h = C(() => d.value === l.activeKey),
        p = J(l.lazyLoad ? h.value : !0),
        v = Je({ key: d, title: r, disabled: i, closable: o, slots: t })
      return (
        a != null && a.uid && ((n = l.addItem) == null || n.call(l, a.uid, v)),
        Pr(() => {
          var g
          a != null && a.uid && ((g = l.removeItem) == null || g.call(l, a.uid))
        }),
        pt(h, (g) => {
          g
            ? p.value || (p.value = !0)
            : (e.destroyOnHide || l.destroyOnHide) && (p.value = !1)
        }),
        Zr(() => {
          v.slots = Wne({}, t)
        }),
        { prefixCls: s, active: h, itemRef: c, mounted: p }
      )
    },
  })
  function Gne(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        {
          ref: 'itemRef',
          class: H([
            `${e.prefixCls}-content-item`,
            { [`${e.prefixCls}-content-item-active`]: e.active },
          ]),
        },
        [
          e.mounted
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-pane`) },
                [ve(e.$slots, 'default')],
                2
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Vp = Te(jne, [['render', Gne]])
  const Kne = Object.assign(Yy, {
    TabPane: Vp,
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + Yy.name, Yy), e.component(n + Vp.name, Vp)
    },
  })
  function qne(e) {
    const { modelValue: t, defaultValue: n, format: r, isRange: i } = tt(e)
    function o() {
      return i.value ? [] : void 0
    }
    function a(b) {
      if (!Mt(b)) return i.value ? (Ft(b) ? b : [b, void 0]) : b
    }
    const s = C(() => {
        const b = a(t.value)
        return Hi(b, r.value)
      }),
      l = C(() => {
        const b = a(n.value)
        return Hi(b, r.value)
      }),
      [c, d] = zi(Mt(s.value) ? (Mt(l.value) ? o() : l.value) : s.value)
    pt(s, () => {
      Mt(s.value) && d(o())
    })
    const h = C(() => s.value || c.value),
      [p, v] = zi(h.value)
    pt([h], () => {
      v(h.value)
    })
    const [g, _] = zi()
    return (
      pt([p], () => {
        _(void 0)
      }),
      {
        computedValue: h,
        panelValue: p,
        inputValue: g,
        setValue: d,
        setPanelValue: v,
        setInputValue: _,
      }
    )
  }
  var Xne = Object.defineProperty,
    Yne = Object.defineProperties,
    Zne = Object.getOwnPropertyDescriptors,
    zE = Object.getOwnPropertySymbols,
    Jne = Object.prototype.hasOwnProperty,
    Qne = Object.prototype.propertyIsEnumerable,
    VE = (e, t, n) =>
      t in e
        ? Xne(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    ere = (e, t) => {
      for (var n in t || (t = {})) Jne.call(t, n) && VE(e, n, t[n])
      if (zE) for (var n of zE(t)) Qne.call(t, n) && VE(e, n, t[n])
      return e
    },
    tre = (e, t) => Yne(e, Zne(t)),
    nre = ce({
      name: 'TimePickerRangePanel',
      components: { Panel: cv },
      props: {
        value: { type: Array },
        displayIndex: { type: Number, default: 0 },
      },
      emits: [
        'select',
        'confirm',
        'update:displayIndex',
        'display-index-change',
      ],
      setup(e, { emit: t }) {
        const { value: n, displayIndex: r } = tt(e),
          i = J(r.value)
        pt(r, () => {
          i.value = r.value
        })
        const o = C(() => (n != null && n.value ? n.value[i.value] : void 0))
        function a(l) {
          const c =
            Mt(n) || Mt(n == null ? void 0 : n.value) ? [] : [...n.value]
          ;(c[i.value] = l), t('select', c)
        }
        function s() {
          if (ed(n == null ? void 0 : n.value))
            t('confirm', n == null ? void 0 : n.value)
          else {
            const l = (i.value + 1) % 2
            ;(i.value = l),
              t('display-index-change', l),
              t('update:displayIndex', l)
          }
        }
        return { displayValue: o, onSelect: a, onConfirm: s }
      },
      render() {
        const e = tre(ere({}, this.$attrs), {
          isRange: !0,
          value: this.displayValue,
          onSelect: this.onSelect,
          onConfirm: this.onConfirm,
        })
        return m(cv, e, this.$slots)
      },
    }),
    rre = Object.defineProperty,
    UE = Object.getOwnPropertySymbols,
    ire = Object.prototype.hasOwnProperty,
    ore = Object.prototype.propertyIsEnumerable,
    HE = (e, t, n) =>
      t in e
        ? rre(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    WE = (e, t) => {
      for (var n in t || (t = {})) ire.call(t, n) && HE(e, n, t[n])
      if (UE) for (var n of UE(t)) ore.call(t, n) && HE(e, n, t[n])
      return e
    }
  const are = ce({
    name: 'TimePicker',
    components: {
      Trigger: Mr,
      DateInput: Tk,
      DateRangeInput: Kk,
      Panel: cv,
      RangePanel: nre,
      IconClockCircle: Lk,
    },
    inheritAttrs: !1,
    props: {
      type: { type: String, default: 'time' },
      modelValue: { type: [String, Number, Date, Array] },
      defaultValue: { type: [String, Number, Date, Array] },
      disabled: { type: Boolean },
      allowClear: { type: Boolean, default: !0 },
      readonly: { type: Boolean },
      error: { type: Boolean },
      format: { type: String, default: 'HH:mm:ss' },
      placeholder: { type: String },
      size: { type: String },
      popupContainer: { type: [String, Object] },
      use12Hours: { type: Boolean },
      step: { type: Object },
      disabledHours: { type: Function },
      disabledMinutes: { type: Function },
      disabledSeconds: { type: Function },
      hideDisabledOptions: { type: Boolean },
      disableConfirm: { type: Boolean },
      position: { type: String, default: 'bl' },
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean, default: !1 },
      triggerProps: { type: Object },
      unmountOnClose: { type: Boolean },
    },
    emits: {
      change: (e, t) => !0,
      'update:modelValue': (e) => !0,
      select: (e, t) => !0,
      clear: () => !0,
      'popup-visible-change': (e) => !0,
      'update:popupVisible': (e) => !0,
    },
    setup(e, { emit: t }) {
      const {
          type: n,
          format: r,
          use12Hours: i,
          modelValue: o,
          defaultValue: a,
          popupVisible: s,
          defaultPopupVisible: l,
          disabled: c,
          placeholder: d,
          disableConfirm: h,
          disabledHours: p,
          disabledMinutes: v,
          disabledSeconds: g,
        } = tt(e),
        { mergedDisabled: _, eventHandlers: b } = Rn({ disabled: c }),
        y = C(() => n.value === 'time-range'),
        M = ye('timepicker'),
        x = J(),
        { format: w, use12Hours: E } = tS(Je({ format: r, use12Hours: i })),
        {
          computedValue: P,
          panelValue: A,
          inputValue: F,
          setValue: T,
          setPanelValue: k,
          setInputValue: R,
        } = qne(Je({ modelValue: o, defaultValue: a, isRange: y, format: w })),
        [j, N] = Er(l.value, Je({ value: s })),
        I = (z) => {
          z !== j.value &&
            (N(z), t('popup-visible-change', z), t('update:popupVisible', z))
        },
        { t: B } = Vn(),
        [V, L] = zi(0),
        W = C(() => {
          const z = d == null ? void 0 : d.value
          return y.value
            ? Mt(z)
              ? B('datePicker.rangePlaceholder.time')
              : Ft(z)
              ? z
              : [z, z]
            : Mt(z)
            ? B('datePicker.placeholder.time')
            : z
        }),
        Y = Ok(Je({ disabledHours: p, disabledMinutes: v, disabledSeconds: g }))
      function U(z) {
        var ie, ae
        if (G_(z, P.value)) {
          const re = Jo(z, w.value),
            pe = wi(z)
          t('update:modelValue', re),
            t('change', re, pe),
            (ae = (ie = b.value) == null ? void 0 : ie.onChange) == null ||
              ae.call(ie)
        }
      }
      function le(z, ie) {
        if (Y(z)) return
        let ae = z
        if (Ft(z)) {
          const re = nr()
          ;(ae = z.map(
            (pe) => (
              pe &&
                ((pe = pe.year(re.year())),
                (pe = pe.month(re.month())),
                (pe = pe.date(re.date()))),
              pe
            )
          )),
            ed(ae) && (ae = Ld(ae)),
            (ae == null ? void 0 : ae.length) === 0 && (ae = void 0)
        }
        U(ae), T(ae), ie !== j.value && I(ie)
      }
      function q(z, ie) {
        k(z), ie !== j.value && I(ie)
      }
      function oe(z) {
        x.value && x.value.focus && x.value.focus(z)
      }
      function te(z) {
        _.value ||
          (I(z),
          z &&
            hn(() => {
              oe(V.value)
            }))
      }
      function ue(z) {
        const ie = Jo(z, w.value),
          ae = wi(z)
        t('select', ie, ae),
          h.value && (!y.value || ed(z)) ? le(z, !0) : (q(z, !0), R(void 0))
      }
      function me(z) {
        le(z, !1)
      }
      function Re() {
        le(A.value || P.value, !1)
      }
      function qe() {
        if (ed(A.value)) le(A.value, !1)
        else {
          const z = (V.value + 1) % 2
          L(z), oe(z)
        }
      }
      function Ve(z) {
        I(!0)
        const ie = z.target.value
        if ((R(ie), !uv(ie, w.value))) return
        const ae = nr(ie, w.value)
        Y(ae) || (h.value ? le(ae, !0) : q(ae, !0))
      }
      function nt(z) {
        I(!0)
        const ie = z.target.value,
          ae = Ft(F.value)
            ? [...F.value]
            : (Ft(A.value) && Jo(A.value, w.value)) || []
        if (((ae[V.value] = ie), R(ae), !uv(ie, w.value))) return
        const re = nr(ie, w.value)
        if (Y(re)) return
        const pe = Ft(A.value) ? [...A.value] : []
        ;(pe[V.value] = re), h.value && ed(pe) ? le(pe, !0) : q(pe, !0)
      }
      function We(z) {
        z.stopPropagation(), k(void 0), le(void 0, y.value)
      }
      pt(j, (z, ie) => {
        z !== ie && k(P.value), z || R(void 0)
      })
      const D = C(() =>
          y.value
            ? {
                focusedIndex: V.value,
                onFocusedIndexChange: (z) => {
                  L(z)
                },
                onChange: nt,
                onPressEnter: qe,
              }
            : { onChange: Ve, onPressEnter: Re }
        ),
        G = C(() =>
          y.value
            ? {
                displayIndex: V.value,
                onDisplayIndexChange: (z) => {
                  L(z), oe(z)
                },
              }
            : {}
        )
      return {
        refInput: x,
        isRange: y,
        prefixCls: M,
        panelVisible: j,
        focusedInputIndex: V,
        computedPlaceholder: W,
        panelValue: A,
        inputValue: F,
        computedFormat: w,
        computedUse12Hours: E,
        inputProps: D,
        panelProps: G,
        mergedDisabled: _,
        onPanelVisibleChange: te,
        onInputClear: We,
        onPanelSelect: ue,
        onPanelConfirm: me,
        onPanelClick: () => {
          oe(V.value)
        },
      }
    },
  })
  function sre(e, t, n, r, i, o) {
    const a = ge('IconClockCircle'),
      s = ge('Trigger')
    return (
      O(),
      Ee(
        s,
        {
          trigger: 'click',
          'animation-name': 'slide-dynamic-origin',
          'auto-fit-transform-origin': '',
          'click-to-close': !1,
          position: e.position,
          disabled: e.mergedDisabled || e.readonly,
          'popup-offset': 4,
          'popup-visible': e.panelVisible,
          'prevent-focus': !0,
          'unmount-on-close': e.unmountOnClose,
          'popup-container': e.popupContainer,
          onPopupVisibleChange: e.onPanelVisibleChange,
        },
        {
          content: ze(() => [
            Se(
              'div',
              {
                class: H(`${e.prefixCls}-container`),
                onClick:
                  t[0] ||
                  (t[0] = (...l) => e.onPanelClick && e.onPanelClick(...l)),
              },
              [
                (O(),
                Ee(
                  xi(e.isRange ? 'RangePanel' : 'Panel'),
                  Fe(e.panelProps, {
                    value: e.panelValue,
                    visible: e.panelVisible,
                    format: e.computedFormat,
                    'use12-hours': e.computedUse12Hours,
                    step: e.step,
                    'disabled-hours': e.disabledHours,
                    'disabled-minutes': e.disabledMinutes,
                    'disabled-seconds': e.disabledSeconds,
                    'hide-disabled-options': e.hideDisabledOptions,
                    'hide-footer': e.disableConfirm,
                    onSelect: e.onPanelSelect,
                    onConfirm: e.onPanelConfirm,
                  }),
                  Nn({ _: 2 }, [
                    e.$slots.extra
                      ? {
                          name: 'extra-footer',
                          fn: ze(() => [ve(e.$slots, 'extra')]),
                        }
                      : void 0,
                  ]),
                  1040,
                  [
                    'value',
                    'visible',
                    'format',
                    'use12-hours',
                    'step',
                    'disabled-hours',
                    'disabled-minutes',
                    'disabled-seconds',
                    'hide-disabled-options',
                    'hide-footer',
                    'onSelect',
                    'onConfirm',
                  ]
                )),
              ],
              2
            ),
          ]),
          default: ze(() => [
            (O(),
            Ee(
              xi(e.isRange ? 'DateRangeInput' : 'DateInput'),
              Fe(WE(WE({}, e.$attrs), e.inputProps), {
                ref: 'refInput',
                'input-value': e.inputValue,
                value: e.panelValue,
                size: e.size,
                focused: e.panelVisible,
                format: e.computedFormat,
                visible: e.panelVisible,
                disabled: e.mergedDisabled,
                error: e.error,
                editable: !e.readonly,
                'allow-clear': e.allowClear && !e.readonly,
                placeholder: e.computedPlaceholder,
                onClear: e.onInputClear,
              }),
              Nn(
                {
                  'suffix-icon': ze(() => [
                    ve(e.$slots, 'suffix-icon', {}, () => [m(a)]),
                  ]),
                  _: 2,
                },
                [
                  e.$slots.prefix
                    ? { name: 'prefix', fn: ze(() => [ve(e.$slots, 'prefix')]) }
                    : void 0,
                ]
              ),
              1040,
              [
                'input-value',
                'value',
                'size',
                'focused',
                'format',
                'visible',
                'disabled',
                'error',
                'editable',
                'allow-clear',
                'placeholder',
                'onClear',
              ]
            )),
          ]),
          _: 3,
        },
        8,
        [
          'position',
          'disabled',
          'popup-visible',
          'unmount-on-close',
          'popup-container',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var Zy = Te(are, [['render', sre]])
  const lre = Object.assign(Zy, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Zy.name, Zy)
      },
    }),
    RA = Symbol('ArcoTimeline')
  var ure = Object.defineProperty,
    jE = Object.getOwnPropertySymbols,
    cre = Object.prototype.hasOwnProperty,
    dre = Object.prototype.propertyIsEnumerable,
    GE = (e, t, n) =>
      t in e
        ? ure(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    fre = (e, t) => {
      for (var n in t || (t = {})) cre.call(t, n) && GE(e, n, t[n])
      if (jE) for (var n of jE(t)) dre.call(t, n) && GE(e, n, t[n])
      return e
    }
  const hre = (e, t, n, r) => {
      let i = ['left', 'right']
      n === 'horizontal' && (i = ['top', 'bottom'])
      const o = t === 'alternate' ? r || i[e % 2] : t
      return i.indexOf(o) > -1 ? o : i[0]
    },
    pre = ce({
      name: 'TimelineItem',
      props: {
        dotColor: { type: String },
        dotType: { type: String, default: 'solid' },
        lineType: { type: String, default: 'solid' },
        lineColor: { type: String },
        label: { type: String },
        position: { type: String },
      },
      setup(e) {
        const t = ye('timeline-item'),
          n = Jr(),
          r = zt(RA, {}),
          i = C(() => {
            var p, v, g
            return (g =
              (v = r.items) == null
                ? void 0
                : v.indexOf(
                    (p = n == null ? void 0 : n.uid) != null ? p : -1
                  )) != null
              ? g
              : -1
          }),
          o = C(() => {
            var p
            return (p = r == null ? void 0 : r.direction) != null
              ? p
              : 'vertical'
          }),
          a = C(() => {
            var p
            return (p = r == null ? void 0 : r.labelPosition) != null
              ? p
              : 'same'
          }),
          s = C(() => {
            const {
                items: p = [],
                reverse: v,
                labelPosition: g,
                mode: _ = 'left',
              } = r,
              b = o.value,
              y = hre(i.value, _, b, e.position)
            return [
              t,
              {
                [`${t}-${b}-${y}`]: b,
                [`${t}-label-${g}`]: g,
                [`${t}-last`]: i.value === (v === !0 ? 0 : p.length - 1),
              },
            ]
          }),
          l = C(() => [`${t}-dot-line`, `${t}-dot-line-is-${o.value}`]),
          c = C(() => {
            const { direction: p } = r || {}
            return fre(
              {
                [p === 'horizontal' ? 'borderTopStyle' : 'borderLeftStyle']:
                  e.lineType,
              },
              e.lineColor ? { borderColor: e.lineColor } : {}
            )
          }),
          d = C(() => [`${t}-dot`, `${t}-dot-${e.dotType}`]),
          h = C(() => ({
            [e.dotType === 'solid' ? 'backgroundColor' : 'borderColor']:
              e.dotColor,
          }))
        return {
          cls: s,
          dotLineCls: l,
          dotTypeCls: d,
          prefixCls: t,
          computedDotLineStyle: c,
          computedDotStyle: h,
          labelPosition: a,
        }
      },
    })
  function vre(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'div',
        { role: 'listitem', class: H(e.cls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-dot-wrapper`) },
            [
              Se(
                'div',
                { class: H(e.dotLineCls), style: at(e.computedDotLineStyle) },
                null,
                6
              ),
              Se(
                'div',
                { class: H(`${e.prefixCls}-dot-content`) },
                [
                  e.$slots.dot
                    ? (O(),
                      Z(
                        'div',
                        { key: 0, class: H(`${e.prefixCls}-dot-custom`) },
                        [ve(e.$slots, 'dot')],
                        2
                      ))
                    : (O(),
                      Z(
                        'div',
                        {
                          key: 1,
                          class: H(e.dotTypeCls),
                          style: at(e.computedDotStyle),
                        },
                        null,
                        6
                      )),
                ],
                2
              ),
            ],
            2
          ),
          Se(
            'div',
            { class: H(`${e.prefixCls}-content-wrapper`) },
            [
              e.$slots.default
                ? (O(),
                  Z(
                    'div',
                    { key: 0, class: H(`${e.prefixCls}-content`) },
                    [ve(e.$slots, 'default')],
                    2
                  ))
                : Ce('v-if', !0),
              e.labelPosition !== 'relative'
                ? (O(),
                  Z(
                    'div',
                    { key: 1, class: H(`${e.prefixCls}-label`) },
                    mt(e.label),
                    3
                  ))
                : Ce('v-if', !0),
            ],
            2
          ),
          e.labelPosition === 'relative'
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-label`) },
                mt(e.label),
                3
              ))
            : Ce('v-if', !0),
        ],
        2
      )
    )
  }
  var Fu = Te(pre, [['render', vre]]),
    Jy = ce({
      name: 'Timeline',
      components: { Item: Fu, Spin: Do },
      props: {
        reverse: { type: Boolean },
        direction: { type: String, default: 'vertical' },
        mode: { type: String, default: 'left' },
        pending: { type: [Boolean, String] },
        labelPosition: { type: String, default: 'same' },
      },
      setup(e, { slots: t }) {
        const n = ye('timeline'),
          r = C(() => e.pending || t.pending),
          { children: i, components: o } = Jd('TimelineItem'),
          { reverse: a, direction: s, labelPosition: l, mode: c } = tt(e),
          d = Je({
            items: o,
            direction: s,
            reverse: a,
            labelPosition: l,
            mode: c,
          })
        sn(RA, d)
        const h = C(() => [
          n,
          `${n}-${e.mode}`,
          `${n}-direction-${e.direction}`,
          { [`${n}-is-reverse`]: e.reverse },
        ])
        return () => {
          var p, v
          return (
            r.value
              ? (i.value =
                  (p = t.default) == null
                    ? void 0
                    : p.call(t).concat(
                        m(
                          Fu,
                          { lineType: 'dashed' },
                          {
                            default: () => [
                              e.pending !== !0 && m('div', null, [e.pending]),
                            ],
                            dot: () => {
                              var g, _
                              return (_ =
                                (g = t.dot) == null ? void 0 : g.call(t)) !=
                                null
                                ? _
                                : m(Do, { size: 12 }, null)
                            },
                          }
                        )
                      ))
              : (i.value = (v = t.default) == null ? void 0 : v.call(t)),
            m('div', { role: 'list', class: h.value }, [i.value])
          )
        }
      },
    })
  const mre = Object.assign(Jy, {
      Item: Fu,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + Jy.name, Jy), e.component(n + Fu.name, Fu)
      },
    }),
    gre = ce({
      name: 'IconDelete',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-delete`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    yre = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    bre = Se(
      'path',
      {
        d: 'M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15',
      },
      null,
      -1
    ),
    _re = [bre]
  function Sre(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        _re,
        14,
        yre
      )
    )
  }
  var Qy = Te(gre, [['render', Sre]])
  const _S = Object.assign(Qy, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + Qy.name, Qy)
      },
    }),
    SS = Symbol('ArcoTransfer')
  var Cre = ce({
    name: 'TransferListItem',
    props: {
      type: { type: String },
      data: { type: Object, required: !0 },
      allowClear: { type: Boolean },
      disabled: { type: Boolean },
      draggable: { type: Boolean },
      simple: Boolean,
    },
    setup(e) {
      const t = ye('transfer-list-item'),
        n = zt(SS, void 0),
        r = () => {
          e.simple &&
            (n == null ||
              n.moveTo(
                [e.data.value],
                e.type === 'target' ? 'source' : 'target'
              ))
        },
        i = C(() => [
          t,
          { [`${t}-disabled`]: e.disabled, [`${t}-draggable`]: e.draggable },
        ]),
        o = () => {
          n == null || n.moveTo([e.data.value], 'source')
        }
      return () => {
        var a, s, l
        return m('div', { class: i.value, onClick: r }, [
          e.allowClear || e.simple
            ? m('span', { class: `${t}-content` }, [
                (l =
                  (s = n == null ? void 0 : (a = n.slots).item) == null
                    ? void 0
                    : s.call(a, {
                        label: e.data.label,
                        value: e.data.value,
                      })) != null
                  ? l
                  : e.data.label,
              ])
            : m(
                Lo,
                {
                  class: [`${t}-content`, `${t}-checkbox`],
                  modelValue: n == null ? void 0 : n.selected,
                  value: e.data.value,
                  onChange: (c) => (n == null ? void 0 : n.onSelect(c)),
                  uninjectGroupContext: !0,
                  disabled: e.disabled,
                },
                {
                  default: () => {
                    var c, d, h
                    return [
                      (h =
                        (d = n == null ? void 0 : (c = n.slots).item) == null
                          ? void 0
                          : d.call(c, {
                              label: e.data.label,
                              value: e.data.value,
                            })) != null
                        ? h
                        : e.data.label,
                    ]
                  },
                }
              ),
          e.allowClear &&
            !e.disabled &&
            m(
              In,
              { class: `${t}-remove-btn`, onClick: o },
              { default: () => [m(zr, null, null)] }
            ),
        ])
      }
    },
  })
  const wre = ce({
    name: 'TransferView',
    components: {
      Empty: Jh,
      Checkbox: Lo,
      IconHover: In,
      IconDelete: _S,
      InputSearch: ic.Search,
      List: vA,
      TransferListItem: Cre,
      Scrollbar: ia,
    },
    props: {
      type: { type: String },
      dataInfo: { type: Object, required: !0 },
      title: String,
      data: { type: Array, required: !0 },
      allowClear: Boolean,
      selected: { type: Array, required: !0 },
      showSearch: Boolean,
      showSelectAll: Boolean,
      simple: Boolean,
    },
    emits: ['search'],
    setup(e, { emit: t }) {
      const n = ye('transfer-view'),
        r = J(''),
        i = zt(SS, void 0),
        o = C(() => e.dataInfo.selected.length),
        a = C(() => e.dataInfo.data.length),
        s = C(
          () =>
            e.dataInfo.selected.length > 0 &&
            e.dataInfo.selected.length === e.dataInfo.allValidValues.length
        ),
        l = C(
          () =>
            e.dataInfo.selected.length > 0 &&
            e.dataInfo.selected.length < e.dataInfo.allValidValues.length
        ),
        c = (v) => {
          v
            ? i == null ||
              i.onSelect([...e.selected, ...e.dataInfo.allValidValues])
            : i == null ||
              i.onSelect(
                e.selected.filter((g) => !e.dataInfo.allValidValues.includes(g))
              )
        },
        d = C(() =>
          e.dataInfo.data.filter((v) =>
            r.value ? v.label.includes(r.value) : !0
          )
        )
      return {
        prefixCls: n,
        filteredData: d,
        filter: r,
        checked: s,
        indeterminate: l,
        countSelected: o,
        countRendered: a,
        handleSelectAllChange: c,
        handleSearch: (v) => {
          t('search', v, e.type)
        },
        handleClear: () => {
          i == null || i.moveTo(e.dataInfo.allValidValues, 'source')
        },
        transferCtx: i,
      }
    },
  })
  function xre(e, t, n, r, i, o) {
    const a = ge('checkbox'),
      s = ge('icon-delete'),
      l = ge('icon-hover'),
      c = ge('input-search'),
      d = ge('transfer-list-item'),
      h = ge('list'),
      p = ge('Scrollbar'),
      v = ge('Empty')
    return (
      O(),
      Z(
        'div',
        { class: H(e.prefixCls) },
        [
          Se(
            'div',
            { class: H(`${e.prefixCls}-header`) },
            [
              ve(
                e.$slots,
                'title',
                {
                  countTotal: e.dataInfo.data.length,
                  countSelected: e.dataInfo.selected.length,
                  searchValue: e.filter,
                  checked: e.checked,
                  indeterminate: e.indeterminate,
                  onSelectAllChange: e.handleSelectAllChange,
                  onClear: e.handleClear,
                },
                () => [
                  Se(
                    'span',
                    { class: H(`${e.prefixCls}-header-title`) },
                    [
                      e.allowClear || e.simple || !e.showSelectAll
                        ? (O(),
                          Z(
                            'span',
                            {
                              key: 0,
                              class: H(`${e.prefixCls}-header-title-simple`),
                            },
                            mt(e.title),
                            3
                          ))
                        : (O(),
                          Ee(
                            a,
                            {
                              key: 1,
                              'model-value': e.checked,
                              indeterminate: e.indeterminate,
                              'uninject-group-context': '',
                              onChange: e.handleSelectAllChange,
                            },
                            { default: ze(() => [Lt(mt(e.title), 1)]), _: 1 },
                            8,
                            ['model-value', 'indeterminate', 'onChange']
                          )),
                    ],
                    2
                  ),
                  e.allowClear
                    ? (O(),
                      Ee(
                        l,
                        {
                          key: 0,
                          class: H(`${e.prefixCls}-header-clear-btn`),
                          onClick: e.handleClear,
                        },
                        { default: ze(() => [m(s)]), _: 1 },
                        8,
                        ['class', 'onClick']
                      ))
                    : e.simple
                    ? Ce('v-if', !0)
                    : (O(),
                      Z(
                        'span',
                        { key: 1, class: H(`${e.prefixCls}-header-count`) },
                        mt(e.dataInfo.selected.length) +
                          ' / ' +
                          mt(e.dataInfo.data.length),
                        3
                      )),
                ]
              ),
            ],
            2
          ),
          e.showSearch
            ? (O(),
              Z(
                'div',
                { key: 0, class: H(`${e.prefixCls}-search`) },
                [
                  m(
                    c,
                    {
                      modelValue: e.filter,
                      'onUpdate:modelValue':
                        t[0] || (t[0] = (g) => (e.filter = g)),
                      onChange: e.handleSearch,
                    },
                    null,
                    8,
                    ['modelValue', 'onChange']
                  ),
                ],
                2
              ))
            : Ce('v-if', !0),
          Se(
            'div',
            { class: H(`${e.prefixCls}-body`) },
            [
              e.filteredData.length > 0
                ? (O(),
                  Ee(
                    p,
                    { key: 0 },
                    {
                      default: ze(() => {
                        var g, _
                        return [
                          ve(
                            e.$slots,
                            'default',
                            {
                              data: e.filteredData,
                              selectedKeys:
                                (g = e.transferCtx) == null
                                  ? void 0
                                  : g.selected,
                              onSelect:
                                (_ = e.transferCtx) == null
                                  ? void 0
                                  : _.onSelect,
                            },
                            () => [
                              m(
                                h,
                                {
                                  class: H(`${e.prefixCls}-list`),
                                  bordered: !1,
                                  scrollbar: !1,
                                },
                                {
                                  default: ze(() => [
                                    (O(!0),
                                    Z(
                                      yt,
                                      null,
                                      Yn(
                                        e.filteredData,
                                        (b) => (
                                          O(),
                                          Ee(
                                            d,
                                            {
                                              key: b.value,
                                              type: e.type,
                                              data: b,
                                              simple: e.simple,
                                              'allow-clear': e.allowClear,
                                              disabled: b.disabled,
                                            },
                                            null,
                                            8,
                                            [
                                              'type',
                                              'data',
                                              'simple',
                                              'allow-clear',
                                              'disabled',
                                            ]
                                          )
                                        )
                                      ),
                                      128
                                    )),
                                  ]),
                                  _: 1,
                                },
                                8,
                                ['class']
                              ),
                            ]
                          ),
                        ]
                      }),
                      _: 3,
                    }
                  ))
                : (O(),
                  Ee(v, { key: 1, class: H(`${e.prefixCls}-empty`) }, null, 8, [
                    'class',
                  ])),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Mre = Te(wre, [['render', xre]])
  const Ere = ce({
    name: 'Transfer',
    components: {
      ArcoButton: Yr,
      TransferView: Mre,
      IconLeft: ja,
      IconRight: No,
    },
    props: {
      data: { type: Array, default: () => [] },
      modelValue: { type: Array, default: void 0 },
      defaultValue: { type: Array, default: () => [] },
      selected: { type: Array, default: void 0 },
      defaultSelected: { type: Array, default: () => [] },
      disabled: { type: Boolean, default: !1 },
      simple: { type: Boolean, default: !1 },
      oneWay: { type: Boolean, default: !1 },
      showSearch: { type: Boolean, default: !1 },
      showSelectAll: { type: Boolean, default: !0 },
      title: { type: Array, default: () => ['Source', 'Target'] },
    },
    emits: {
      'update:modelValue': (e) => !0,
      'update:selected': (e) => !0,
      change: (e) => !0,
      select: (e) => !0,
      search: (e, t) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const { mergedDisabled: r, eventHandlers: i } = Rn({
          disabled: Vi(e, 'disabled'),
        }),
        o = ye('transfer'),
        a = J(e.defaultValue),
        s = C(() => {
          var M
          return (M = e.modelValue) != null ? M : a.value
        }),
        l = J(e.defaultSelected),
        c = C(() => {
          var M
          return (M = e.selected) != null ? M : l.value
        }),
        d = C(() => {
          var M
          return (M = e.title) == null ? void 0 : M[0]
        }),
        h = C(() => {
          var M
          return (M = e.title) == null ? void 0 : M[1]
        }),
        p = C(() => {
          const M = {
              data: [],
              allValidValues: [],
              selected: [],
              validSelected: [],
            },
            x = {
              data: [],
              allValidValues: [],
              selected: [],
              validSelected: [],
            }
          for (const w of e.data)
            s.value.includes(w.value)
              ? (x.data.push(w),
                w.disabled || x.allValidValues.push(w.value),
                c.value.includes(w.value) &&
                  (x.selected.push(w.value),
                  w.disabled || x.validSelected.push(w.value)))
              : (M.data.push(w),
                w.disabled || M.allValidValues.push(w.value),
                c.value.includes(w.value) &&
                  (M.selected.push(w.value),
                  w.disabled || M.validSelected.push(w.value)))
          return { sourceInfo: M, targetInfo: x }
        }),
        v = (M, x) => {
          t('search', M, x)
        },
        g = (M, x) => {
          var w, E
          const P =
            x === 'target'
              ? [...s.value, ...M]
              : s.value.filter((A) => !M.includes(A))
          b(p.value[x === 'target' ? 'targetInfo' : 'sourceInfo'].selected),
            (a.value = P),
            t('update:modelValue', P),
            t('change', P),
            (E = (w = i.value) == null ? void 0 : w.onChange) == null ||
              E.call(w)
        },
        _ = (M) => {
          const x =
            M === 'target'
              ? p.value.sourceInfo.validSelected
              : p.value.targetInfo.validSelected
          g(x, M)
        },
        b = (M) => {
          ;(l.value = M), t('update:selected', M), t('select', M)
        }
      sn(SS, Je({ selected: c, slots: n, moveTo: g, onSelect: b }))
      const y = C(() => [
        o,
        { [`${o}-simple`]: e.simple, [`${o}-disabled`]: r.value },
      ])
      return {
        prefixCls: o,
        cls: y,
        dataInfo: p,
        computedSelected: c,
        sourceTitle: d,
        targetTitle: h,
        handleClick: _,
        handleSearch: v,
      }
    },
  })
  function Pre(e, t, n, r, i, o) {
    const a = ge('transfer-view'),
      s = ge('icon-right'),
      l = ge('arco-button'),
      c = ge('icon-left')
    return (
      O(),
      Z(
        'div',
        { class: H(e.cls) },
        [
          m(
            a,
            {
              type: 'source',
              class: H(`${e.prefixCls}-view-source`),
              title: e.sourceTitle,
              'data-info': e.dataInfo.sourceInfo,
              data: e.dataInfo.sourceInfo.data,
              selected: e.computedSelected,
              'show-search': e.showSearch,
              'show-select-all': e.showSelectAll,
              simple: e.simple,
              onSearch: e.handleSearch,
            },
            Nn({ _: 2 }, [
              e.$slots.source
                ? {
                    name: 'default',
                    fn: ze((d) => [ve(e.$slots, 'source', En(Rr(d)))]),
                  }
                : void 0,
              e.$slots['source-title']
                ? {
                    name: 'title',
                    fn: ze((d) => [ve(e.$slots, 'source-title', En(Rr(d)))]),
                  }
                : void 0,
            ]),
            1032,
            [
              'class',
              'title',
              'data-info',
              'data',
              'selected',
              'show-search',
              'show-select-all',
              'simple',
              'onSearch',
            ]
          ),
          e.simple
            ? Ce('v-if', !0)
            : (O(),
              Z(
                'div',
                { key: 0, class: H([`${e.prefixCls}-operations`]) },
                [
                  m(
                    l,
                    {
                      tabindex: '-1',
                      'aria-label': 'Move selected right',
                      size: 'small',
                      shape: 'round',
                      disabled:
                        e.dataInfo.sourceInfo.validSelected.length === 0,
                      onClick: t[0] || (t[0] = (d) => e.handleClick('target')),
                    },
                    { icon: ze(() => [m(s)]), _: 1 },
                    8,
                    ['disabled']
                  ),
                  e.oneWay
                    ? Ce('v-if', !0)
                    : (O(),
                      Ee(
                        l,
                        {
                          key: 0,
                          tabindex: '-1',
                          'aria-label': 'Move selected left',
                          size: 'small',
                          shape: 'round',
                          disabled:
                            e.dataInfo.targetInfo.validSelected.length === 0,
                          onClick:
                            t[1] || (t[1] = (d) => e.handleClick('source')),
                        },
                        { icon: ze(() => [m(c)]), _: 1 },
                        8,
                        ['disabled']
                      )),
                ],
                2
              )),
          m(
            a,
            {
              type: 'target',
              class: H(`${e.prefixCls}-view-target`),
              title: e.targetTitle,
              'data-info': e.dataInfo.targetInfo,
              data: e.dataInfo.targetInfo.data,
              selected: e.computedSelected,
              'allow-clear': e.oneWay,
              'show-search': e.showSearch,
              'show-select-all': e.showSelectAll,
              simple: e.simple,
              onSearch: e.handleSearch,
            },
            Nn({ _: 2 }, [
              e.$slots.target
                ? {
                    name: 'default',
                    fn: ze((d) => [ve(e.$slots, 'target', En(Rr(d)))]),
                  }
                : void 0,
              e.$slots['target-title']
                ? {
                    name: 'title',
                    fn: ze((d) => [ve(e.$slots, 'target-title', En(Rr(d)))]),
                  }
                : void 0,
            ]),
            1032,
            [
              'class',
              'title',
              'data-info',
              'data',
              'selected',
              'allow-clear',
              'show-search',
              'show-select-all',
              'simple',
              'onSearch',
            ]
          ),
        ],
        2
      )
    )
  }
  var e1 = Te(Ere, [['render', Pre]])
  const Tre = Object.assign(e1, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + e1.name, e1)
      },
    }),
    DA = Symbol('TreeInjectionKey')
  function kre(e) {
    const t = []
    function n(r) {
      r &&
        r.forEach((i) => {
          t.push(i), n(i.children)
        })
    }
    return n(e), t
  }
  function Are(e) {
    const t = new Map()
    return (
      e.forEach((n) => {
        t.set(n.key, n)
      }),
      t
    )
  }
  function Db(e) {
    return e.selectable && !e.disabled
  }
  function KE(e) {
    return !e.isLeaf && e.children
  }
  function $re(e) {
    return Ui(e.isLeaf) ? e.isLeaf : !e.children
  }
  function Nb(e) {
    return Set.prototype.add.bind(e)
  }
  function Bb(e) {
    return Set.prototype.delete.bind(e)
  }
  function bl(e) {
    return e.disabled || e.disableCheckbox ? !1 : !!e.checkable
  }
  function CS(e) {
    var t
    const n = []
    return (
      (t = e.children) == null ||
        t.forEach((r) => {
          bl(r) && n.push(r.key, ...CS(r))
        }),
      n
    )
  }
  function NA(e) {
    var t
    const { node: n, checkedKeySet: r, indeterminateKeySet: i } = e
    let o = n.parent
    for (; o; ) {
      if (bl(o)) {
        const a = o.key,
          s = ((t = o.children) == null ? void 0 : t.filter(bl)) || []
        let l = 0
        const c = s.length
        s.some(({ key: d }) => {
          if (r.has(d)) l += 1
          else if (i.has(d)) return (l += 0.5), !0
          return !1
        }),
          l && l !== c ? i.add(a) : i.delete(a),
          l && l === c ? r.add(a) : r.delete(a)
      }
      o = o.parent
    }
  }
  function Fb(e) {
    const {
        node: t,
        checked: n,
        checkedKeys: r,
        indeterminateKeys: i,
        checkStrictly: o = !1,
      } = e,
      { key: a } = t,
      s = new Set(r),
      l = new Set(i)
    if ((n ? s.add(a) : s.delete(a), l.delete(a), !o)) {
      const c = CS(t)
      n ? c.forEach(Nb(s)) : c.forEach(Bb(s)),
        c.forEach(Bb(l)),
        NA({ node: t, checkedKeySet: s, indeterminateKeySet: l })
    }
    return [[...s], [...l]]
  }
  function Ore(e) {
    const {
        initCheckedKeys: t,
        key2TreeNode: n,
        checkStrictly: r,
        onlyCheckLeaf: i,
      } = e,
      o = new Set(),
      a = new Set(),
      s = new Set()
    return (
      r
        ? t.forEach(Nb(o))
        : t.forEach((l) => {
            var c
            const d = n.get(l)
            if (!d || a.has(l) || (i && (c = d.children) != null && c.length))
              return
            const h = CS(d)
            h.forEach(Nb(a)),
              h.forEach(Bb(s)),
              o.add(l),
              s.delete(l),
              NA({ node: d, checkedKeySet: o, indeterminateKeySet: s })
          }),
      [[...o, ...a], [...s]]
    )
  }
  function um() {
    return zt(DA) || {}
  }
  const Lre = ce({
      name: 'IconFile',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-file`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Ire = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Rre = Se(
      'path',
      {
        d: 'M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z',
      },
      null,
      -1
    ),
    Dre = [Rre]
  function Nre(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Dre,
        14,
        Ire
      )
    )
  }
  var t1 = Te(Lre, [['render', Nre]])
  const BA = Object.assign(t1, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + t1.name, t1)
    },
  })
  var Bre = ce({
      name: 'TreeNodeSwitcher',
      components: { IconLoading: Xr, RenderFunction: Ga },
      props: {
        prefixCls: String,
        loading: Boolean,
        showLine: Boolean,
        treeNodeData: { type: Object },
        icons: { type: Object },
        nodeStatus: { type: Object },
      },
      emits: ['click'],
      setup(e, { slots: t, emit: n }) {
        const { icons: r, nodeStatus: i, treeNodeData: o } = tt(e),
          a = um(),
          s = Mo(t, 'switcher-icon'),
          l = Mo(t, 'loading-icon')
        return {
          getSwitcherIcon: () => {
            var c, d, h
            const p =
              (d =
                (c = r == null ? void 0 : r.value) == null
                  ? void 0
                  : c.switcherIcon) != null
                ? d
                : s.value
            return p
              ? p(i.value)
              : (h = a.switcherIcon) == null
              ? void 0
              : h.call(a, o.value, i.value)
          },
          getLoadingIcon: () => {
            var c, d, h
            const p =
              (d =
                (c = r == null ? void 0 : r.value) == null
                  ? void 0
                  : c.loadingIcon) != null
                ? d
                : l.value
            return p
              ? p(i.value)
              : (h = a.loadingIcon) == null
              ? void 0
              : h.call(a, o.value, i.value)
          },
          onClick(c) {
            n('click', c)
          },
        }
      },
      render() {
        var e, t, n
        const {
            prefixCls: r,
            getSwitcherIcon: i,
            getLoadingIcon: o,
            onClick: a,
            nodeStatus: s = {},
            loading: l,
            showLine: c,
          } = this,
          { expanded: d, isLeaf: h } = s
        if (l) return (e = o()) != null ? e : _i(Xr)
        let p = null,
          v = !1
        if (h) c && (p = (n = i()) != null ? n : _i(BA))
        else {
          const _ = c
            ? _i('span', { class: `${r}-${d ? 'minus' : 'plus'}-icon` })
            : _i(LA)
          ;(p = (t = i()) != null ? t : _), (v = !c)
        }
        if (!p) return null
        const g = _i('span', { class: `${r}-switcher-icon`, onClick: a }, p)
        return v ? _i(In, { class: `${r}-icon-hover` }, () => g) : g
      },
    }),
    Fre = Object.defineProperty,
    zre = Object.defineProperties,
    Vre = Object.getOwnPropertyDescriptors,
    qE = Object.getOwnPropertySymbols,
    Ure = Object.prototype.hasOwnProperty,
    Hre = Object.prototype.propertyIsEnumerable,
    XE = (e, t, n) =>
      t in e
        ? Fre(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    zb = (e, t) => {
      for (var n in t || (t = {})) Ure.call(t, n) && XE(e, n, t[n])
      if (qE) for (var n of qE(t)) Hre.call(t, n) && XE(e, n, t[n])
      return e
    },
    YE = (e, t) => zre(e, Vre(t))
  const FA = (() => {
    let e = 0
    return () => ((e += 1), `__arco_tree${e}`)
  })()
  function Wre(e, t) {
    return !!(Mt(e) ? t : e)
  }
  function jre(e, t) {
    const n = zb({}, e)
    return (
      t &&
        Object.keys(t).forEach((i) => {
          const o = t[i]
          o !== i && ((n[i] = e[o]), delete n[o])
        }),
      n
    )
  }
  function ZE({
    subEnable: e,
    superEnable: t,
    isLeaf: n,
    treeNodeData: r,
    level: i,
  }) {
    return Mt(e) ? (xt(t) ? t(r, { isLeaf: n, level: i }) : t ?? !1) : e
  }
  function Gre(e) {
    var t, n
    const { treeNodeData: r, parentNode: i, isTail: o = !0, treeProps: a } = e,
      { fieldNames: s } = a || {},
      l = jre(r, s),
      c = a.loadMore ? !!l.isLeaf : !((t = l.children) != null && t.length),
      d = i ? i.level + 1 : 0,
      h = YE(zb({}, xr(l, ['children'])), {
        key: (n = l.key) != null ? n : FA(),
        selectable: ZE({
          subEnable: l.selectable,
          superEnable: a == null ? void 0 : a.selectable,
          isLeaf: c,
          level: d,
          treeNodeData: r,
        }),
        disabled: !!l.disabled,
        disableCheckbox: !!l.disableCheckbox,
        checkable: ZE({
          subEnable: l.checkable,
          superEnable: a == null ? void 0 : a.checkable,
          isLeaf: c,
          level: d,
          treeNodeData: r,
        }),
        isLeaf: c,
        isTail: o,
        blockNode: !!(a != null && a.blockNode),
        showLine: !!(a != null && a.showLine),
        level: d,
        lineless: i ? [...i.lineless, i.isTail] : [],
        draggable: Wre(l.draggable, a == null ? void 0 : a.draggable),
      })
    return YE(zb({}, h), {
      treeNodeProps: h,
      treeNodeData: r,
      parent: i,
      parentKey: i == null ? void 0 : i.key,
      pathParentKeys: i ? [...i.pathParentKeys, i.key] : [],
    })
  }
  function Kre(e, t) {
    function n(r, i) {
      if (!r) return
      const { fieldNames: o } = t,
        a = []
      return (
        r.forEach((s, l) => {
          const c = Gre({
            treeNodeData: s,
            treeProps: t,
            parentNode: i,
            isTail: l === r.length - 1,
          })
          ;(c.children = n(
            s[(o == null ? void 0 : o.children) || 'children'],
            c
          )),
            a.push(c)
        }),
        a
      )
    }
    return n(e)
  }
  function zA() {
    const e = Jr(),
      t = () => {
        var r
        return (r = e == null ? void 0 : e.vnode.key) != null ? r : FA()
      },
      n = J(t())
    return (
      Zr(() => {
        n.value = t()
      }),
      n
    )
  }
  function qre(e) {
    const { key: t, refTitle: n } = tt(e),
      r = um(),
      i = J(!1),
      o = J(!1),
      a = J(!1),
      s = J(0),
      l = Gu((c) => {
        if (!n.value) return
        const d = n.value.getBoundingClientRect(),
          h = window.pageYOffset + d.top,
          { pageY: p } = c,
          v = d.height / 4,
          g = p - h
        ;(s.value = g < v ? -1 : g < d.height - v ? 0 : 1),
          (a.value = r.allowDrop ? r.allowDrop(t.value, s.value) : !0)
      })
    return {
      isDragOver: i,
      isDragging: o,
      isAllowDrop: a,
      dropPosition: s,
      setDragStatus(c, d) {
        switch (c) {
          case 'dragStart':
            ;(o.value = !0),
              (s.value = 0),
              r.onDragStart && r.onDragStart(t.value, d)
            break
          case 'dragEnd':
            ;(o.value = !1),
              (i.value = !1),
              (s.value = 0),
              l.cancel(),
              r.onDragEnd && r.onDragEnd(t.value, d)
            break
          case 'dragOver':
            ;(i.value = !0), l(d), r.onDragOver && r.onDragOver(t.value, d)
            break
          case 'dragLeave':
            ;(i.value = !1),
              (s.value = 0),
              l.cancel(),
              r.onDragLeave && r.onDragLeave(t.value, d)
            break
          case 'drop':
            r.onDrop && r.onDrop(t.value, s.value, d),
              (i.value = !1),
              (s.value = 0),
              l.cancel()
            break
        }
      },
    }
  }
  function Xre(e) {
    return Ft(e) ? e : [e]
  }
  const Yre = ce({
      name: 'BaseTreeNode',
      components: {
        NodeSwitcher: Bre,
        Checkbox: Lo,
        RenderFunction: Ga,
        IconDragDotVertical: cS,
      },
      props: {
        key: { type: [String, Number] },
        title: { type: String },
        selectable: { type: Boolean },
        disabled: { type: Boolean },
        disableCheckbox: { type: Boolean },
        checkable: { type: Boolean },
        draggable: { type: Boolean },
        isLeaf: { type: Boolean },
        icon: { type: Function },
        switcherIcon: { type: Function },
        loadingIcon: { type: Function },
        dragIcon: { type: Function },
        isTail: { type: Boolean },
        blockNode: { type: Boolean },
        showLine: { type: Boolean },
        level: { type: Number, default: 0 },
        lineless: { type: Array, default: () => [] },
      },
      setup(e) {
        const t = zA(),
          n = ye('tree-node'),
          r = um(),
          i = C(() => {
            var L
            return (L = r.key2TreeNode) == null ? void 0 : L.get(t.value)
          }),
          o = C(() => i.value.treeNodeData),
          a = C(() => i.value.children),
          s = C(() => {
            var L
            const W = (L = r.treeProps) == null ? void 0 : L.actionOnNodeClick
            return W ? Xre(W) : []
          }),
          {
            isLeaf: l,
            isTail: c,
            selectable: d,
            disabled: h,
            disableCheckbox: p,
            draggable: v,
          } = tt(e),
          g = C(() => {
            var L
            return [
              `${n}`,
              {
                [`${n}-selected`]: F.value,
                [`${n}-is-leaf`]: l.value,
                [`${n}-is-tail`]: c.value,
                [`${n}-expanded`]: T.value,
                [`${n}-disabled-selectable`]:
                  !d.value &&
                  !((L = r.treeProps) != null && L.disableSelectActionOnly),
                [`${n}-disabled`]: h.value,
              },
            ]
          }),
          _ = J(),
          {
            isDragOver: b,
            isDragging: y,
            isAllowDrop: M,
            dropPosition: x,
            setDragStatus: w,
          } = qre(Je({ key: t, refTitle: _ })),
          E = C(() => [
            `${n}-title`,
            {
              [`${n}-title-draggable`]: v.value,
              [`${n}-title-gap-top`]: b.value && M.value && x.value < 0,
              [`${n}-title-gap-bottom`]: b.value && M.value && x.value > 0,
              [`${n}-title-highlight`]:
                !y.value && b.value && M.value && x.value === 0,
              [`${n}-title-dragging`]: y.value,
              [`${n}-title-block`]: i.value.blockNode,
            },
          ]),
          P = C(() => {
            var L, W
            return (W = (L = r.checkedKeys) == null ? void 0 : L.includes) ==
              null
              ? void 0
              : W.call(L, t.value)
          }),
          A = C(() => {
            var L, W
            return (W =
              (L = r.indeterminateKeys) == null ? void 0 : L.includes) == null
              ? void 0
              : W.call(L, t.value)
          }),
          F = C(() => {
            var L, W
            return (W = (L = r.selectedKeys) == null ? void 0 : L.includes) ==
              null
              ? void 0
              : W.call(L, t.value)
          }),
          T = C(() => {
            var L, W
            return (W = (L = r.expandedKeys) == null ? void 0 : L.includes) ==
              null
              ? void 0
              : W.call(L, t.value)
          }),
          k = C(() => {
            var L, W
            return (W = (L = r.loadingKeys) == null ? void 0 : L.includes) ==
              null
              ? void 0
              : W.call(L, t.value)
          }),
          R = C(() => r.dragIcon),
          j = C(() => r.nodeIcon)
        function N(L) {
          var W, Y
          l.value ||
            (!((W = a.value) != null && W.length) && xt(r.onLoadMore)
              ? r.onLoadMore(t.value)
              : (Y = r == null ? void 0 : r.onExpand) == null ||
                Y.call(r, !T.value, t.value, L))
        }
        const I = Je({
            loading: k,
            checked: P,
            selected: F,
            indeterminate: A,
            expanded: T,
            isLeaf: l,
          }),
          B = C(() =>
            r.nodeTitle
              ? () => {
                  var L
                  return (L = r.nodeTitle) == null
                    ? void 0
                    : L.call(r, o.value, I)
                }
              : void 0
          ),
          V = C(() =>
            r.nodeExtra
              ? () => {
                  var L
                  return (L = r.nodeExtra) == null
                    ? void 0
                    : L.call(r, o.value, I)
                }
              : void 0
          )
        return {
          nodekey: t,
          refTitle: _,
          prefixCls: n,
          classNames: g,
          titleClassNames: E,
          indeterminate: A,
          checked: P,
          expanded: T,
          selected: F,
          treeTitle: B,
          treeNodeData: o,
          loading: k,
          treeDragIcon: R,
          treeNodeIcon: j,
          extra: V,
          nodeStatus: I,
          onCheckboxChange(L, W) {
            var Y
            p.value ||
              h.value ||
              (Y = r.onCheck) == null ||
              Y.call(r, L, t.value, W)
          },
          onTitleClick(L) {
            var W
            s.value.includes('expand') && N(L),
              !(!d.value || h.value) &&
                ((W = r.onSelect) == null || W.call(r, t.value, L))
          },
          onSwitcherClick: N,
          onDragStart(L) {
            var W
            if (v.value) {
              L.stopPropagation(), w('dragStart', L)
              try {
                ;(W = L.dataTransfer) == null || W.setData('text/plain', '')
              } catch {}
            }
          },
          onDragEnd(L) {
            v.value && (L.stopPropagation(), w('dragEnd', L))
          },
          onDragOver(L) {
            v && (L.stopPropagation(), L.preventDefault(), w('dragOver', L))
          },
          onDragLeave(L) {
            v.value && (L.stopPropagation(), w('dragLeave', L))
          },
          onDrop(L) {
            !v.value ||
              !M.value ||
              (L.stopPropagation(), L.preventDefault(), w('drop', L))
          },
        }
      },
    }),
    Zre = ['data-level', 'data-key'],
    Jre = ['draggable']
  function Qre(e, t, n, r, i, o) {
    const a = ge('NodeSwitcher'),
      s = ge('Checkbox'),
      l = ge('RenderFunction'),
      c = ge('IconDragDotVertical')
    return (
      O(),
      Z(
        'div',
        {
          class: H(e.classNames),
          'data-level': e.level,
          'data-key': e.nodekey,
        },
        [
          Ce('  '),
          Se(
            'span',
            { class: H(`${e.prefixCls}-indent`) },
            [
              (O(!0),
              Z(
                yt,
                null,
                Yn(
                  e.level,
                  (d) => (
                    O(),
                    Z(
                      'span',
                      {
                        key: d,
                        class: H([
                          `${e.prefixCls}-indent-block`,
                          {
                            [`${e.prefixCls}-indent-block-lineless`]:
                              e.lineless[d - 1],
                          },
                        ]),
                      },
                      null,
                      2
                    )
                  )
                ),
                128
              )),
            ],
            2
          ),
          Ce(' switcher '),
          Se(
            'span',
            {
              class: H([
                `${e.prefixCls}-switcher`,
                { [`${e.prefixCls}-switcher-expanded`]: e.expanded },
              ]),
            },
            [
              m(
                a,
                {
                  'prefix-cls': e.prefixCls,
                  loading: e.loading,
                  'show-line': e.showLine,
                  'tree-node-data': e.treeNodeData,
                  icons: {
                    switcherIcon: e.switcherIcon,
                    loadingIcon: e.loadingIcon,
                  },
                  'node-status': e.nodeStatus,
                  onClick: e.onSwitcherClick,
                },
                Nn({ _: 2 }, [
                  e.$slots['switcher-icon']
                    ? {
                        name: 'switcher-icon',
                        fn: ze(() => [
                          Ce(' @slot  switcher  Tree  '),
                          ve(e.$slots, 'switcher-icon'),
                        ]),
                      }
                    : void 0,
                  e.$slots['loading-icon']
                    ? {
                        name: 'loading-icon',
                        fn: ze(() => [
                          Ce(' @slot  loading  Tree  '),
                          ve(e.$slots, 'loading-icon'),
                        ]),
                      }
                    : void 0,
                ]),
                1032,
                [
                  'prefix-cls',
                  'loading',
                  'show-line',
                  'tree-node-data',
                  'icons',
                  'node-status',
                  'onClick',
                ]
              ),
            ],
            2
          ),
          Ce(' checkbox '),
          e.checkable
            ? (O(),
              Ee(
                s,
                {
                  key: 0,
                  disabled: e.disableCheckbox || e.disabled,
                  'model-value': e.checked,
                  indeterminate: e.indeterminate,
                  'uninject-group-context': '',
                  onChange: e.onCheckboxChange,
                },
                null,
                8,
                ['disabled', 'model-value', 'indeterminate', 'onChange']
              ))
            : Ce('v-if', !0),
          Ce('  '),
          Se(
            'span',
            {
              ref: 'refTitle',
              class: H(e.titleClassNames),
              draggable: e.draggable,
              onDragstart:
                t[0] || (t[0] = (...d) => e.onDragStart && e.onDragStart(...d)),
              onDragend:
                t[1] || (t[1] = (...d) => e.onDragEnd && e.onDragEnd(...d)),
              onDragover:
                t[2] || (t[2] = (...d) => e.onDragOver && e.onDragOver(...d)),
              onDragleave:
                t[3] || (t[3] = (...d) => e.onDragLeave && e.onDragLeave(...d)),
              onDrop: t[4] || (t[4] = (...d) => e.onDrop && e.onDrop(...d)),
              onClick:
                t[5] ||
                (t[5] = (...d) => e.onTitleClick && e.onTitleClick(...d)),
            },
            [
              e.$slots.icon || e.icon || e.treeNodeIcon
                ? (O(),
                  Z(
                    'span',
                    {
                      key: 0,
                      class: H([
                        `${e.prefixCls}-icon`,
                        `${e.prefixCls}-custom-icon`,
                      ]),
                    },
                    [
                      Ce('  '),
                      e.$slots.icon
                        ? ve(e.$slots, 'icon', En(Fe({ key: 0 }, e.nodeStatus)))
                        : e.icon
                        ? (O(),
                          Ee(
                            l,
                            Fe({ key: 1, 'render-func': e.icon }, e.nodeStatus),
                            null,
                            16,
                            ['render-func']
                          ))
                        : e.treeNodeIcon
                        ? (O(),
                          Ee(
                            l,
                            Fe(
                              {
                                key: 2,
                                'render-func': e.treeNodeIcon,
                                node: e.treeNodeData,
                              },
                              e.nodeStatus
                            ),
                            null,
                            16,
                            ['render-func', 'node']
                          ))
                        : Ce('v-if', !0),
                    ],
                    2
                  ))
                : Ce('v-if', !0),
              Se(
                'span',
                { class: H(`${e.prefixCls}-title-text`) },
                [
                  e.treeTitle
                    ? (O(),
                      Ee(l, { key: 0, 'render-func': e.treeTitle }, null, 8, [
                        'render-func',
                      ]))
                    : (O(),
                      Z(
                        yt,
                        { key: 1 },
                        [
                          Ce(' treeTitle  title '),
                          ve(e.$slots, 'title', {}, () => [Lt(mt(e.title), 1)]),
                        ],
                        2112
                      )),
                  e.draggable
                    ? (O(),
                      Z(
                        'span',
                        {
                          key: 2,
                          class: H([
                            `${e.prefixCls}-icon`,
                            `${e.prefixCls}-drag-icon`,
                          ]),
                        },
                        [
                          Ce('  '),
                          e.$slots['drag-icon']
                            ? ve(
                                e.$slots,
                                'drag-icon',
                                En(Fe({ key: 0 }, e.nodeStatus))
                              )
                            : e.dragIcon
                            ? (O(),
                              Ee(
                                l,
                                Fe(
                                  { key: 1, 'render-func': e.dragIcon },
                                  e.nodeStatus
                                ),
                                null,
                                16,
                                ['render-func']
                              ))
                            : e.treeDragIcon
                            ? (O(),
                              Ee(
                                l,
                                Fe(
                                  {
                                    key: 2,
                                    'render-func': e.treeDragIcon,
                                    node: e.treeNodeData,
                                  },
                                  e.nodeStatus
                                ),
                                null,
                                16,
                                ['render-func', 'node']
                              ))
                            : (O(), Ee(c, { key: 3 })),
                        ],
                        2
                      ))
                    : Ce('v-if', !0),
                ],
                2
              ),
            ],
            42,
            Jre
          ),
          Ce('  '),
          e.extra
            ? (O(),
              Ee(l, { key: 1, 'render-func': e.extra }, null, 8, [
                'render-func',
              ]))
            : Ce('v-if', !0),
        ],
        10,
        Zre
      )
    )
  }
  var Vb = Te(Yre, [['render', Qre]])
  const eie = ce({
    name: 'ExpandTransition',
    props: { expanded: Boolean },
    emits: ['end'],
    setup(e, { emit: t }) {
      return {
        onBeforeEnter(n) {
          n.style.height = e.expanded ? '0' : `${n.scrollHeight}px`
        },
        onEnter(n) {
          n.style.height = e.expanded ? `${n.scrollHeight}px` : '0'
        },
        onAfterEnter(n) {
          ;(n.style.height = e.expanded ? '' : '0'), t('end')
        },
        onBeforeLeave(n) {
          n.style.display = 'none'
        },
      }
    },
  })
  function tie(e, t, n, r, i, o) {
    return (
      O(),
      Ee(
        Fr,
        {
          onBeforeEnter: e.onBeforeEnter,
          onEnter: e.onEnter,
          onAfterEnter: e.onAfterEnter,
          onBeforeLeave: e.onBeforeLeave,
        },
        { default: ze(() => [ve(e.$slots, 'default')]), _: 3 },
        8,
        ['onBeforeEnter', 'onEnter', 'onAfterEnter', 'onBeforeLeave']
      )
    )
  }
  var nie = Te(eie, [['render', tie]])
  const rie = ce({
    name: 'TransitionNodeList',
    components: { ExpandTransition: nie, BaseTreeNode: Vb },
    props: { nodeKey: { type: [String, Number], required: !0 } },
    setup(e) {
      const n = [`${ye('tree')}-node-list`],
        r = um(),
        { nodeKey: i } = tt(e),
        o = C(() => {
          var l, c
          return (c = (l = r.expandedKeys) == null ? void 0 : l.includes) ==
            null
            ? void 0
            : c.call(l, i.value)
        }),
        a = C(() => {
          var l
          const c = new Set(r.expandedKeys || []),
            d =
              (l = r.flattenTreeData) == null
                ? void 0
                : l.filter((h) => {
                    var p, v
                    return (p = h.pathParentKeys) != null && p.includes(i.value)
                      ? !r.filterTreeNode ||
                          ((v = r.filterTreeNode) == null
                            ? void 0
                            : v.call(r, h.treeNodeData))
                      : !1
                  })
          return d == null
            ? void 0
            : d.filter((h) => {
                var p
                if (o.value)
                  return (p = h.pathParentKeys) == null
                    ? void 0
                    : p.every((g) => c.has(g))
                const v = h.pathParentKeys.indexOf(i.value)
                return h.pathParentKeys.slice(v + 1).every((g) => c.has(g))
              })
        }),
        s = C(() => {
          var l, c
          return (
            ((l = r.currentExpandKeys) == null
              ? void 0
              : l.includes(i.value)) &&
            ((c = a.value) == null ? void 0 : c.length)
          )
        })
      return {
        classNames: n,
        visibleNodeList: a,
        show: s,
        expanded: o,
        onTransitionEnd() {
          var l
          ;(l = r.onExpandEnd) == null || l.call(r, i.value)
        },
      }
    },
  })
  function iie(e, t, n, r, i, o) {
    const a = ge('BaseTreeNode'),
      s = ge('ExpandTransition')
    return (
      O(),
      Ee(
        s,
        { expanded: e.expanded, onEnd: e.onTransitionEnd },
        {
          default: ze(() => [
            e.show
              ? (O(),
                Z(
                  'div',
                  { key: 0, class: H(e.classNames) },
                  [
                    (O(!0),
                    Z(
                      yt,
                      null,
                      Yn(
                        e.visibleNodeList,
                        (l) => (
                          O(),
                          Ee(a, Fe({ key: l.key }, l.treeNodeProps), null, 16)
                        )
                      ),
                      128
                    )),
                  ],
                  2
                ))
              : Ce('v-if', !0),
          ]),
          _: 1,
        },
        8,
        ['expanded', 'onEnd']
      )
    )
  }
  var oie = Te(rie, [['render', iie]]),
    aie = Object.defineProperty,
    JE = Object.getOwnPropertySymbols,
    sie = Object.prototype.hasOwnProperty,
    lie = Object.prototype.propertyIsEnumerable,
    QE = (e, t, n) =>
      t in e
        ? aie(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    uie = (e, t) => {
      for (var n in t || (t = {})) sie.call(t, n) && QE(e, n, t[n])
      if (JE) for (var n of JE(t)) lie.call(t, n) && QE(e, n, t[n])
      return e
    },
    cie = ce({
      name: 'TreeNode',
      inheritAttrs: !1,
      props: uie({}, Vb.props),
      setup(e, { slots: t, attrs: n }) {
        const r = zA()
        return () =>
          m(yt, null, [
            m(Vb, Fe(e, n, { key: r.value }), t),
            m(oie, { key: r.value, nodeKey: r.value }, null),
          ])
      },
    })
  function die(e) {
    const {
        defaultCheckedKeys: t,
        checkedKeys: n,
        key2TreeNode: r,
        checkStrictly: i,
        halfCheckedKeys: o,
        onlyCheckLeaf: a,
      } = tt(e),
      s = J(!1),
      l = J([]),
      c = J([]),
      d = J(),
      h = J(),
      p = (g) =>
        Ore({
          initCheckedKeys: g,
          key2TreeNode: r.value,
          checkStrictly: i.value,
          onlyCheckLeaf: a.value,
        }),
      v = (g) => {
        const _ = p(g)
        ;[l.value, c.value] = _
      }
    return (
      v(n.value || (t == null ? void 0 : t.value) || []),
      pr(() => {
        n.value
          ? ([d.value, h.value] = p(n.value))
          : s.value &&
            ((d.value = void 0),
            (h.value = void 0),
            (l.value = []),
            (c.value = [])),
          s.value || (s.value = !0)
      }),
      {
        checkedKeys: C(() => d.value || l.value),
        indeterminateKeys: C(() =>
          i.value && o.value ? o.value : h.value || c.value
        ),
        setCheckedState(g, _, b = !1) {
          return b ? v(g) : ((l.value = g), (c.value = _)), [l.value, c.value]
        },
      }
    )
  }
  function VA(e) {
    const {
        treeData: t,
        fieldNames: n,
        selectable: r,
        showLine: i,
        blockNode: o,
        checkable: a,
        loadMore: s,
        draggable: l,
      } = tt(e),
      c = J([])
    pr(() => {
      var p, v
      c.value = Kre(t.value || [], {
        selectable: (p = r == null ? void 0 : r.value) != null ? p : !1,
        showLine: !!(i != null && i.value),
        blockNode: !!(o != null && o.value),
        checkable: (v = a == null ? void 0 : a.value) != null ? v : !1,
        fieldNames: n == null ? void 0 : n.value,
        loadMore: !!(s != null && s.value),
        draggable: !!(l != null && l.value),
      })
    })
    const d = C(() => kre(c.value)),
      h = C(() => Are(d.value))
    return { treeData: c, flattenTreeData: d, key2TreeNode: h }
  }
  const fie = ce({
    name: 'Tree',
    components: { VirtualList: Qv, TreeNode: cie },
    props: {
      size: { type: String, default: 'medium' },
      blockNode: { type: Boolean },
      defaultExpandAll: { type: Boolean, default: !0 },
      multiple: { type: Boolean },
      checkable: { type: [Boolean, String, Function], default: !1 },
      selectable: { type: [Boolean, Function], default: !0 },
      checkStrictly: { type: Boolean },
      checkedStrategy: { type: String, default: 'all' },
      defaultSelectedKeys: { type: Array },
      selectedKeys: { type: Array },
      defaultCheckedKeys: { type: Array },
      checkedKeys: { type: Array },
      defaultExpandedKeys: { type: Array },
      expandedKeys: { type: Array },
      data: { type: Array, default: () => [] },
      fieldNames: { type: Object },
      showLine: { type: Boolean },
      loadMore: { type: Function },
      draggable: { type: Boolean },
      allowDrop: { type: Function },
      filterTreeNode: { type: Function },
      searchValue: { type: String, default: '' },
      virtualListProps: { type: Object },
      defaultExpandSelected: { type: Boolean },
      defaultExpandChecked: { type: Boolean },
      autoExpandParent: { type: Boolean, default: !0 },
      halfCheckedKeys: { type: Array },
      onlyCheckLeaf: { type: Boolean, default: !1 },
      animation: { type: Boolean, default: !0 },
      actionOnNodeClick: { type: String },
      disableSelectActionOnly: { type: Boolean, default: !1 },
    },
    emits: {
      select: (e, t) => !0,
      'update:selectedKeys': (e) => !0,
      check: (e, t) => !0,
      'update:checkedKeys': (e) => !0,
      'update:halfCheckedKeys': (e) => !0,
      expand: (e, t) => !0,
      'update:expandedKeys': (e) => !0,
      dragStart: (e, t) => !0,
      dragEnd: (e, t) => !0,
      dragOver: (e, t) => !0,
      dragLeave: (e, t) => !0,
      drop: (e) => !0,
    },
    setup(e, { emit: t, slots: n }) {
      const {
          data: r,
          showLine: i,
          multiple: o,
          loadMore: a,
          checkStrictly: s,
          checkedKeys: l,
          defaultCheckedKeys: c,
          selectedKeys: d,
          defaultSelectedKeys: h,
          expandedKeys: p,
          defaultExpandedKeys: v,
          checkedStrategy: g,
          selectable: _,
          checkable: b,
          blockNode: y,
          fieldNames: M,
          size: x,
          defaultExpandAll: w,
          filterTreeNode: E,
          draggable: P,
          allowDrop: A,
          defaultExpandSelected: F,
          defaultExpandChecked: T,
          autoExpandParent: k,
          halfCheckedKeys: R,
          onlyCheckLeaf: j,
          animation: N,
        } = tt(e),
        I = ye('tree'),
        B = C(() => [
          `${I}`,
          { [`${I}-checkable`]: b.value, [`${I}-show-line`]: i.value },
          `${I}-size-${x.value}`,
        ]),
        V = Mo(n, 'switcher-icon'),
        L = Mo(n, 'loading-icon'),
        W = Mo(n, 'drag-icon'),
        Y = Mo(n, 'icon'),
        U = Mo(n, 'title'),
        le = Mo(n, 'extra'),
        {
          treeData: q,
          flattenTreeData: oe,
          key2TreeNode: te,
        } = VA(
          Je({
            treeData: r,
            selectable: _,
            showLine: i,
            blockNode: y,
            checkable: b,
            fieldNames: M,
            loadMore: a,
            draggable: P,
          })
        ),
        {
          checkedKeys: ue,
          indeterminateKeys: me,
          setCheckedState: Re,
        } = die(
          Je({
            defaultCheckedKeys: c,
            checkedKeys: l,
            checkStrictly: s,
            key2TreeNode: te,
            halfCheckedKeys: R,
            onlyCheckLeaf: j,
          })
        ),
        [qe, Ve] = Er((h == null ? void 0 : h.value) || [], Je({ value: d })),
        nt = J([]),
        We = J()
      function D() {
        if (v != null && v.value) {
          const je = new Set([])
          return (
            v.value.forEach((Ge) => {
              if (je.has(Ge)) return
              const Ye = te.value.get(Ge)
              Ye &&
                [...(k.value ? Ye.pathParentKeys : []), Ge].forEach((lt) =>
                  je.add(lt)
                )
            }),
            [...je]
          )
        }
        if (w.value)
          return oe.value
            .filter((je) => je.children && je.children.length)
            .map((je) => je.key)
        if (F.value || T.value) {
          const je = new Set([]),
            Ge = (Ye) => {
              Ye.forEach((lt) => {
                const gt = te.value.get(lt)
                gt && (gt.pathParentKeys || []).forEach((_e) => je.add(_e))
              })
            }
          return F.value && Ge(qe.value), T.value && Ge(ue.value), [...je]
        }
        return []
      }
      const [G, z] = Er(D(), Je({ value: p })),
        ie = J([]),
        ae = C(() => {
          const je = new Set(G.value),
            Ge = new Set(ie.value)
          return oe.value.filter((Ye) => {
            var lt
            if (
              !(
                !E ||
                !E.value ||
                (E == null ? void 0 : E.value(Ye.treeNodeData))
              )
            )
              return !1
            const _e = Mt(Ye.parentKey),
              bt =
                (lt = Ye.pathParentKeys) == null
                  ? void 0
                  : lt.every((He) => je.has(He) && !Ge.has(He))
            return _e || bt
          })
        })
      function re(je, Ge = g.value) {
        let Ye = [...je]
        return (
          Ge === 'parent'
            ? (Ye = je.filter((lt) => {
                const gt = te.value.get(lt)
                return gt && !(!Mt(gt.parentKey) && je.includes(gt.parentKey))
              }))
            : Ge === 'child' &&
              (Ye = je.filter((lt) => {
                var gt, _e
                return !(
                  (_e =
                    (gt = te.value.get(lt)) == null ? void 0 : gt.children) !=
                    null && _e.length
                )
              })),
          Ye
        )
      }
      function pe(je) {
        return je
          .map((Ge) => {
            var Ye
            return (
              ((Ye = te.value.get(Ge)) == null ? void 0 : Ye.treeNodeData) ||
              void 0
            )
          })
          .filter(Boolean)
      }
      function we(je) {
        const {
            targetKey: Ge,
            targetChecked: Ye,
            newCheckedKeys: lt,
            newIndeterminateKeys: gt,
            event: _e,
          } = je,
          bt = Ge ? te.value.get(Ge) : void 0,
          He = re(lt)
        t('update:checkedKeys', He),
          t('update:halfCheckedKeys', gt),
          t('check', He, {
            checked: Ye,
            node: bt == null ? void 0 : bt.treeNodeData,
            checkedNodes: pe(He),
            halfCheckedKeys: gt,
            halfCheckedNodes: pe(gt),
            e: _e,
          })
      }
      function $e(je) {
        const {
            targetKey: Ge,
            targetSelected: Ye,
            newSelectedKeys: lt,
            event: gt,
          } = je,
          _e = Ge ? te.value.get(Ge) : void 0
        t('update:selectedKeys', lt),
          t('select', lt, {
            selected: Ye,
            node: _e == null ? void 0 : _e.treeNodeData,
            selectedNodes: pe(lt),
            e: gt,
          })
      }
      function Ae(je) {
        const {
            targetKey: Ge,
            targetExpanded: Ye,
            newExpandedKeys: lt,
            event: gt,
          } = je,
          _e = Ge ? te.value.get(Ge) : void 0
        t('expand', lt, {
          expanded: Ye,
          node: _e == null ? void 0 : _e.treeNodeData,
          expandedNodes: pe(lt),
          e: gt,
        }),
          t('update:expandedKeys', lt)
      }
      function ft(je) {
        const [Ge, Ye] = Re(je, [], !0)
        we({ newCheckedKeys: Ge, newIndeterminateKeys: Ye })
      }
      function Q(je) {
        let Ge = je
        !o.value && je.length > 1 && (Ge = [je[0]]),
          Ve(Ge),
          $e({ newSelectedKeys: Ge })
      }
      function X(je) {
        ;(ie.value = []), z(je), Ae({ newExpandedKeys: je })
      }
      function he(je, Ge, Ye) {
        if (!je.length) return
        let lt = [...ue.value],
          gt = [...me.value]
        je.forEach((_e) => {
          const bt = te.value.get(_e)
          bt &&
            ([lt, gt] = Fb({
              node: bt,
              checked: Ge,
              checkedKeys: [...lt],
              indeterminateKeys: [...gt],
              checkStrictly: s.value,
            }))
        }),
          Re(lt, gt),
          we({
            targetKey: Ye,
            targetChecked: Mt(Ye) ? void 0 : Ge,
            newCheckedKeys: lt,
            newIndeterminateKeys: gt,
          })
      }
      function de(je, Ge, Ye) {
        if (!je.length) return
        let lt
        if (o.value) {
          const gt = new Set(qe.value)
          je.forEach((_e) => {
            Ge ? gt.add(_e) : gt.delete(_e)
          }),
            (lt = [...gt])
        } else lt = Ge ? [je[0]] : []
        Ve(lt),
          $e({
            targetKey: Ye,
            targetSelected: Mt(Ye) ? void 0 : Ge,
            newSelectedKeys: lt,
          })
      }
      function xe(je, Ge, Ye) {
        const lt = new Set(G.value)
        je.forEach((_e) => {
          Ge ? lt.add(_e) : lt.delete(_e), Ne(_e)
        })
        const gt = [...lt]
        z(gt),
          Ae({
            targetKey: Ye,
            targetExpanded: Mt(Ye) ? void 0 : Ge,
            newExpandedKeys: gt,
          })
      }
      function ne(je, Ge, Ye) {
        const lt = te.value.get(Ge)
        if (!lt) return
        const [gt, _e] = Fb({
          node: lt,
          checked: je,
          checkedKeys: ue.value,
          indeterminateKeys: me.value,
          checkStrictly: s.value,
        })
        Re(gt, _e),
          we({
            targetKey: Ge,
            targetChecked: je,
            newCheckedKeys: gt,
            newIndeterminateKeys: _e,
            event: Ye,
          })
      }
      function Le(je, Ge) {
        if (!te.value.get(je)) return
        let lt, gt
        if (o.value) {
          const _e = new Set(qe.value)
          ;(gt = !_e.has(je)), gt ? _e.add(je) : _e.delete(je), (lt = [..._e])
        } else (gt = !0), (lt = [je])
        Ve(lt),
          $e({
            targetKey: je,
            targetSelected: gt,
            newSelectedKeys: lt,
            event: Ge,
          })
      }
      function et(je, Ge, Ye) {
        if (ie.value.includes(Ge) || !te.value.get(Ge)) return
        const gt = new Set(G.value)
        je ? gt.add(Ge) : gt.delete(Ge)
        const _e = [...gt]
        z(_e),
          N.value && ie.value.push(Ge),
          Ae({
            targetKey: Ge,
            targetExpanded: je,
            newExpandedKeys: _e,
            event: Ye,
          })
      }
      function Ne(je) {
        const Ge = ie.value.indexOf(je)
        ie.value.splice(Ge, 1)
      }
      const Et = C(() =>
          a != null && a.value
            ? async (je) => {
                if (!xt(a.value)) return
                const Ge = te.value.get(je)
                if (!Ge) return
                const { treeNodeData: Ye } = Ge
                nt.value = [...new Set([...nt.value, je])]
                try {
                  await a.value(Ye),
                    (nt.value = nt.value.filter((lt) => lt !== je)),
                    et(!0, je),
                    ue.value.includes(je) && ne(!0, je)
                } catch (lt) {
                  ;(nt.value = nt.value.filter((gt) => gt !== je)),
                    console.error('[tree]load data error: ', lt)
                }
              }
            : void 0
        ),
        kt = Je({
          treeProps: e,
          switcherIcon: V,
          loadingIcon: L,
          dragIcon: W,
          nodeIcon: Y,
          nodeTitle: U,
          nodeExtra: le,
          treeData: q,
          flattenTreeData: oe,
          key2TreeNode: te,
          checkedKeys: ue,
          indeterminateKeys: me,
          selectedKeys: qe,
          expandedKeys: G,
          loadingKeys: nt,
          currentExpandKeys: ie,
          onLoadMore: Et,
          filterTreeNode: E,
          onCheck: ne,
          onSelect: Le,
          onExpand: et,
          onExpandEnd: Ne,
          allowDrop(je, Ge) {
            const Ye = te.value.get(je)
            return Ye && xt(A.value)
              ? !!A.value({ dropNode: Ye.treeNodeData, dropPosition: Ge })
              : !0
          },
          onDragStart(je, Ge) {
            const Ye = te.value.get(je)
            ;(We.value = Ye), Ye && t('dragStart', Ge, Ye.treeNodeData)
          },
          onDragEnd(je, Ge) {
            const Ye = te.value.get(je)
            ;(We.value = void 0), Ye && t('dragEnd', Ge, Ye.treeNodeData)
          },
          onDragOver(je, Ge) {
            const Ye = te.value.get(je)
            Ye && t('dragOver', Ge, Ye.treeNodeData)
          },
          onDragLeave(je, Ge) {
            const Ye = te.value.get(je)
            Ye && t('dragLeave', Ge, Ye.treeNodeData)
          },
          onDrop(je, Ge, Ye) {
            const lt = te.value.get(je)
            We.value &&
              lt &&
              !(
                lt.key === We.value.key ||
                lt.pathParentKeys.includes(We.value.key || '')
              ) &&
              t('drop', {
                e: Ye,
                dragNode: We.value.treeNodeData,
                dropNode: lt.treeNodeData,
                dropPosition: Ge,
              })
          },
        })
      return (
        sn(DA, kt),
        {
          classNames: B,
          visibleTreeNodeList: ae,
          treeContext: kt,
          virtualListRef: J(),
          computedSelectedKeys: qe,
          computedExpandedKeys: G,
          computedCheckedKeys: ue,
          computedIndeterminateKeys: me,
          getPublicCheckedKeys: re,
          getNodes: pe,
          internalCheckNodes: he,
          internalSetCheckedKeys: ft,
          internalSelectNodes: de,
          internalSetSelectedKeys: Q,
          internalExpandNodes: xe,
          internalSetExpandedKeys: X,
        }
      )
    },
    methods: {
      toggleCheck(e, t) {
        const {
            key2TreeNode: n,
            onCheck: r,
            checkedKeys: i,
          } = this.treeContext,
          o = !i.includes(e),
          a = n.get(e)
        a && bl(a) && r(o, e, t)
      },
      scrollIntoView(e) {
        this.virtualListRef && this.virtualListRef.scrollTo(e)
      },
      getSelectedNodes() {
        return this.getNodes(this.computedSelectedKeys)
      },
      getCheckedNodes(e = {}) {
        const { checkedStrategy: t, includeHalfChecked: n } = e,
          r = this.getPublicCheckedKeys(this.computedCheckedKeys, t)
        return [...this.getNodes(r), ...(n ? this.getHalfCheckedNodes() : [])]
      },
      getHalfCheckedNodes() {
        return this.getNodes(this.computedIndeterminateKeys)
      },
      getExpandedNodes() {
        return this.getNodes(this.computedExpandedKeys)
      },
      checkAll(e = !0) {
        const { key2TreeNode: t } = this.treeContext,
          n = e
            ? [...t.keys()].filter((r) => {
                const i = t.get(r)
                return i && bl(i)
              })
            : []
        this.internalSetCheckedKeys(n)
      },
      checkNode(e, t = !0, n = !1) {
        const { checkStrictly: r, treeContext: i } = this,
          { key2TreeNode: o } = i,
          a = Ft(e),
          s = (a ? e : [e]).filter((l) => {
            const c = o.get(l)
            return c && bl(c) && (r || !n || $re(c))
          })
        this.internalCheckNodes(s, t, a ? void 0 : e)
      },
      selectAll(e = !0) {
        const { key2TreeNode: t } = this.treeContext,
          n = e
            ? [...t.keys()].filter((r) => {
                const i = t.get(r)
                return i && Db(i)
              })
            : []
        this.internalSetSelectedKeys(n)
      },
      selectNode(e, t = !0) {
        const { key2TreeNode: n } = this.treeContext,
          r = Ft(e),
          i = (r ? e : [e]).filter((o) => {
            const a = n.get(o)
            return a && Db(a)
          })
        this.internalSelectNodes(i, t, r ? void 0 : e)
      },
      expandAll(e = !0) {
        const { key2TreeNode: t } = this.treeContext,
          n = e
            ? [...t.keys()].filter((r) => {
                const i = t.get(r)
                return i && KE(i)
              })
            : []
        this.internalSetExpandedKeys(n)
      },
      expandNode(e, t = !0) {
        const { key2TreeNode: n } = this.treeContext,
          r = Ft(e),
          i = (r ? e : [e]).filter((o) => {
            const a = n.get(o)
            return a && KE(a)
          })
        this.internalExpandNodes(i, t, r ? void 0 : e)
      },
    },
  })
  function hie(e, t, n, r, i, o) {
    const a = ge('TreeNode'),
      s = ge('VirtualList')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          e.virtualListProps
            ? (O(),
              Ee(
                s,
                Fe({ key: 0, ref: 'virtualListRef' }, e.virtualListProps, {
                  data: e.visibleTreeNodeList,
                }),
                {
                  item: ze(({ item: l }) => [
                    m(
                      a,
                      Fe({ key: `${e.searchValue}-${l.key}` }, l.treeNodeProps),
                      null,
                      16
                    ),
                  ]),
                  _: 1,
                },
                16,
                ['data']
              ))
            : (O(!0),
              Z(
                yt,
                { key: 1 },
                Yn(
                  e.visibleTreeNodeList,
                  (l) => (
                    O(), Ee(a, Fe({ key: l.key }, l.treeNodeProps), null, 16)
                  )
                ),
                128
              )),
        ],
        2
      )
    )
  }
  var n1 = Te(fie, [['render', hie]])
  const Ub = Object.assign(n1, {
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + n1.name, n1)
      },
    }),
    pie = ce({
      name: 'Typography',
      setup() {
        return { classNames: [ye('typography')] }
      },
    })
  function vie(e, t, n, r, i, o) {
    return (
      O(),
      Z('article', { class: H(e.classNames) }, [ve(e.$slots, 'default')], 2)
    )
  }
  var r1 = Te(pie, [['render', vie]])
  const mie = ce({
    name: 'TypographyEditContent',
    components: { Input: ic },
    props: { text: { type: String, required: !0 } },
    emits: ['change', 'end', 'update:text'],
    setup(e, { emit: t }) {
      const r = [`${ye('typography')}-edit-content`],
        i = J()
      function o(s) {
        t('update:text', s), t('change', s)
      }
      function a() {
        t('end')
      }
      return (
        Wt(() => {
          if (!i.value || !i.value.$el) return
          const s = i.value.$el.querySelector('input')
          if (!s) return
          s.focus && s.focus()
          const { length: l } = s.value
          s.setSelectionRange(l, l)
        }),
        { classNames: r, inputRef: i, onBlur: a, onChange: o, onEnd: a }
      )
    },
  })
  function gie(e, t, n, r, i, o) {
    const a = ge('Input')
    return (
      O(),
      Z(
        'div',
        { class: H(e.classNames) },
        [
          m(
            a,
            {
              ref: 'inputRef',
              'auto-size': '',
              'model-value': e.text,
              onBlur: e.onBlur,
              onInput: e.onChange,
              onKeydown: xu(e.onEnd, ['enter']),
            },
            null,
            8,
            ['model-value', 'onBlur', 'onInput', 'onKeydown']
          ),
        ],
        2
      )
    )
  }
  var yie = Te(mie, [['render', gie]])
  const bie = ce({
      name: 'IconCopy',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-copy`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    _ie = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Sie = Se(
      'path',
      {
        d: 'M20 6h18a2 2 0 0 1 2 2v22M8 16v24c0 1.105.891 2 1.996 2h20.007A1.99 1.99 0 0 0 32 40.008V15.997A1.997 1.997 0 0 0 30 14H10a2 2 0 0 0-2 2Z',
      },
      null,
      -1
    ),
    Cie = [Sie]
  function wie(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Cie,
        14,
        _ie
      )
    )
  }
  var i1 = Te(bie, [['render', wie]])
  const xie = Object.assign(i1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + i1.name, i1)
      },
    }),
    Mie = ce({
      name: 'IconEdit',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-edit`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Eie = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Pie = Se(
      'path',
      {
        d: 'm30.48 19.038 5.733-5.734a1 1 0 0 0 0-1.414l-5.586-5.586a1 1 0 0 0-1.414 0l-5.734 5.734m7 7L15.763 33.754a1 1 0 0 1-.59.286l-6.048.708a1 1 0 0 1-1.113-1.069l.477-6.31a1 1 0 0 1 .29-.631l14.7-14.7m7 7-7-7M6 42h36',
      },
      null,
      -1
    ),
    Tie = [Pie]
  function kie(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Tie,
        14,
        Eie
      )
    )
  }
  var o1 = Te(Mie, [['render', kie]])
  const Aie = Object.assign(o1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + o1.name, o1)
      },
    }),
    $ie = ce({
      name: 'TypographyOperations',
      components: {
        Tooltip: uo,
        IconCheckCircleFill: $l,
        IconCopy: xie,
        IconEdit: Aie,
      },
      props: {
        editable: Boolean,
        copyable: Boolean,
        expandable: Boolean,
        isCopied: Boolean,
        isEllipsis: Boolean,
        expanded: Boolean,
        forceRenderExpand: Boolean,
        editTooltipProps: Object,
        copyTooltipProps: Object,
      },
      emits: { edit: () => !0, copy: () => !0, expand: () => !0 },
      setup(e, { emit: t }) {
        const n = ye('typography'),
          r = C(() => e.forceRenderExpand || (e.expandable && e.isEllipsis)),
          { t: i } = Vn()
        return {
          prefixCls: n,
          showExpand: r,
          t: i,
          onEditClick() {
            t('edit')
          },
          onCopyClick() {
            t('copy')
          },
          onExpandClick() {
            t('expand')
          },
        }
      },
    })
  function Oie(e, t, n, r, i, o) {
    const a = ge('IconEdit'),
      s = ge('Tooltip'),
      l = ge('IconCheckCircleFill'),
      c = ge('IconCopy')
    return (
      O(),
      Z(
        yt,
        null,
        [
          e.editable
            ? (O(),
              Ee(
                s,
                Fe(
                  { key: 0, content: e.t('typography.edit') },
                  e.editTooltipProps
                ),
                {
                  default: ze(() => [
                    Se(
                      'span',
                      {
                        class: H(`${e.prefixCls}-operation-edit`),
                        onClick:
                          t[0] ||
                          (t[0] = io(
                            (...d) => e.onEditClick && e.onEditClick(...d),
                            ['stop']
                          )),
                      },
                      [m(a)],
                      2
                    ),
                  ]),
                  _: 1,
                },
                16,
                ['content']
              ))
            : Ce('v-if', !0),
          e.copyable
            ? (O(),
              Ee(
                s,
                En(Fe({ key: 1 }, e.copyTooltipProps)),
                {
                  content: ze(() => [
                    ve(e.$slots, 'copy-tooltip', { copied: e.isCopied }, () => [
                      Lt(
                        mt(
                          e.isCopied
                            ? e.t('typography.copied')
                            : e.t('typography.copy')
                        ),
                        1
                      ),
                    ]),
                  ]),
                  default: ze(() => [
                    Se(
                      'span',
                      {
                        class: H({
                          [`${e.prefixCls}-operation-copied`]: e.isCopied,
                          [`${e.prefixCls}-operation-copy`]: !e.isCopied,
                        }),
                        onClick:
                          t[1] ||
                          (t[1] = io(
                            (...d) => e.onCopyClick && e.onCopyClick(...d),
                            ['stop']
                          )),
                      },
                      [
                        ve(
                          e.$slots,
                          'copy-icon',
                          { copied: e.isCopied },
                          () => [
                            e.isCopied
                              ? (O(), Ee(l, { key: 0 }))
                              : (O(), Ee(c, { key: 1 })),
                          ]
                        ),
                      ],
                      2
                    ),
                  ]),
                  _: 3,
                },
                16
              ))
            : Ce('v-if', !0),
          e.showExpand
            ? (O(),
              Z(
                'a',
                {
                  key: 2,
                  class: H(`${e.prefixCls}-operation-expand`),
                  onClick:
                    t[2] ||
                    (t[2] = io(
                      (...d) => e.onExpandClick && e.onExpandClick(...d),
                      ['stop']
                    )),
                },
                [
                  ve(e.$slots, 'expand-node', { expanded: e.expanded }, () => [
                    Lt(
                      mt(
                        e.expanded
                          ? e.t('typography.collapse')
                          : e.t('typography.expand')
                      ),
                      1
                    ),
                  ]),
                ],
                2
              ))
            : Ce('v-if', !0),
        ],
        64
      )
    )
  }
  var e3 = Te($ie, [['render', Oie]])
  let ar
  function Lie(e) {
    return Array.prototype.slice
      .apply(e)
      .map((n) => `${n}: ${e.getPropertyValue(n)};`)
      .join('')
  }
  function a1(e) {
    if (!e) return 0
    const t = e.match(/^\d*(\.\d*)?/)
    return t ? Number(t[0]) : 0
  }
  var Iie = (e, t, n, r) => {
    ar || ((ar = document.createElement('div')), document.body.appendChild(ar))
    const { rows: i, suffix: o, ellipsisStr: a } = t,
      s = window.getComputedStyle(e),
      l = Lie(s),
      c = a1(s.lineHeight),
      d = Math.round(c * i + a1(s.paddingTop) + a1(s.paddingBottom))
    ar.setAttribute('style', l),
      ar.setAttribute('aria-hidden', 'true'),
      (ar.style.height = 'auto'),
      (ar.style.minHeight = 'auto'),
      (ar.style.maxHeight = 'auto'),
      (ar.style.position = 'fixed'),
      (ar.style.left = '0'),
      (ar.style.top = '-99999999px'),
      (ar.style.zIndex = '-200'),
      (ar.style.whiteSpace = 'normal')
    const h = $_({
      render() {
        return m('span', null, [n])
      },
    })
    h.mount(ar)
    const p = Array.prototype.slice.apply(
      ar.childNodes[0].cloneNode(!0).childNodes
    )
    h.unmount(), (ar.innerHTML = '')
    const v = document.createTextNode(`${a}${o}`)
    ar.appendChild(v),
      p.forEach((y) => {
        ar.appendChild(y)
      })
    const g = document.createTextNode(r)
    ar.insertBefore(g, v)
    function _() {
      return ar.offsetHeight <= d
    }
    if (_()) return { ellipsis: !1, text: r }
    function b(y, M = 0, x = r.length, w = 0) {
      const E = Math.floor((M + x) / 2),
        P = r.slice(0, E)
      if (((y.textContent = P), M >= x - 1))
        for (let A = x; A >= M; A -= 1) {
          const F = r.slice(0, A)
          if (((y.textContent = F), _() || !F)) return
        }
      _() ? b(y, E, x, E) : b(y, M, E, w)
    }
    return b(g), { text: g.textContent, ellipsis: !0 }
  }
  const Rie = async (e) => {
    var t
    if ((t = navigator.clipboard) != null && t.writeText)
      try {
        await navigator.clipboard.writeText(e)
        return
      } catch (o) {
        console.error(
          o ?? new DOMException('The request is not allowed', 'NotAllowedError')
        )
      }
    const n = document.createElement('span')
    ;(n.textContent = e),
      (n.style.whiteSpace = 'pre'),
      document.body.appendChild(n)
    const r = window.getSelection(),
      i = window.document.createRange()
    r == null || r.removeAllRanges(),
      i.selectNode(n),
      r == null || r.addRange(i)
    try {
      window.document.execCommand('copy')
    } catch (o) {
      console.error(`execCommand Error: ${o}`)
    }
    r == null || r.removeAllRanges(), window.document.body.removeChild(n)
  }
  let ru
  function Die(e) {
    if (!e) return ''
    ru ||
      ((ru = document.createElement('div')),
      ru.setAttribute('aria-hidden', 'true'),
      document.body.appendChild(ru))
    const t = $_({
      render() {
        return m('div', null, [e])
      },
    })
    t.mount(ru)
    const n = ru.innerText
    return t.unmount(), n
  }
  var Nie = Object.defineProperty,
    Bie = Object.defineProperties,
    Fie = Object.getOwnPropertyDescriptors,
    t3 = Object.getOwnPropertySymbols,
    zie = Object.prototype.hasOwnProperty,
    Vie = Object.prototype.propertyIsEnumerable,
    n3 = (e, t, n) =>
      t in e
        ? Nie(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Uie = (e, t) => {
      for (var n in t || (t = {})) zie.call(t, n) && n3(e, n, t[n])
      if (t3) for (var n of t3(t)) Vie.call(t, n) && n3(e, n, t[n])
      return e
    },
    Hie = (e, t) => Bie(e, Fie(t))
  function UA(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  function Wie(e) {
    const { bold: t, mark: n, underline: r, delete: i, code: o } = e,
      a = []
    return (
      t && a.push('b'),
      r && a.push('u'),
      i && a.push('del'),
      o && a.push('code'),
      n && a.push('mark'),
      a
    )
  }
  function r3(e, t) {
    const { mark: n } = e,
      r = Wie(e),
      i = Ht(n) && n.color ? { backgroundColor: n.color } : {}
    return r.reduce(
      (o, a) =>
        m(
          a,
          a === 'mark' ? { style: i } : {},
          UA(o) ? o : { default: () => [o] }
        ),
      t
    )
  }
  function jie(e) {
    const t = !!e.showTooltip,
      n = Ht(e.showTooltip) && e.showTooltip.type === 'popover' ? H_ : uo,
      r = (Ht(e.showTooltip) && e.showTooltip.props) || {}
    return Hie(
      Uie(
        { rows: 1, suffix: '', ellipsisStr: '...', expandable: !1, css: !1 },
        xr(e, ['showTooltip'])
      ),
      { showTooltip: t, TooltipComponent: n, tooltipProps: r }
    )
  }
  var wS = ce({
      name: 'TypographyBase',
      inheritAttrs: !1,
      props: {
        component: { type: String, required: !0 },
        type: { type: String },
        bold: { type: Boolean },
        mark: { type: [Boolean, Object], default: !1 },
        underline: { type: Boolean },
        delete: { type: Boolean },
        code: { type: Boolean },
        disabled: { type: Boolean },
        editable: { type: Boolean },
        editing: { type: Boolean, default: void 0 },
        defaultEditing: { type: Boolean },
        editText: { type: String },
        copyable: { type: Boolean },
        copyText: { type: String },
        copyDelay: { type: Number, default: 3e3 },
        ellipsis: { type: [Boolean, Object], default: !1 },
        editTooltipProps: { type: Object },
        copyTooltipProps: { type: Object },
      },
      emits: {
        editStart: () => !0,
        change: (e) => !0,
        'update:editText': (e) => !0,
        editEnd: () => !0,
        'update:editing': (e) => !0,
        copy: (e) => !0,
        ellipsis: (e) => !0,
        expand: (e) => !0,
      },
      setup(e, { slots: t, emit: n, attrs: r }) {
        const {
            editing: i,
            defaultEditing: o,
            ellipsis: a,
            copyable: s,
            editable: l,
            copyText: c,
            editText: d,
            copyDelay: h,
            component: p,
          } = tt(e),
          v = ye('typography'),
          g = C(() => [
            v,
            { [`${v}-${e.type}`]: e.type, [`${v}-disabled`]: e.disabled },
          ]),
          _ = J(),
          b = J(''),
          [y, M] = Er(o.value, Je({ value: i })),
          x = C(() => l.value && y.value)
        function w() {
          n('update:editing', !0), n('editStart'), M(!0)
        }
        function E(ue) {
          n('update:editText', ue), n('change', ue)
        }
        function P() {
          y.value && (n('update:editing', !1), n('editEnd'), M(!1))
        }
        const A = J(!1)
        let F = null
        function T() {
          var ue
          const me = (ue = c.value) != null ? ue : b.value
          Rie(me || ''),
            (A.value = !0),
            n('copy', me),
            (F = setTimeout(() => {
              A.value = !1
            }, h.value))
        }
        wr(() => {
          F && clearTimeout(F), (F = null)
        })
        const k = J(!1),
          R = J(!1),
          j = J(''),
          N = C(() => jie((Ht(a.value) && a.value) || {}))
        let I = null
        function B() {
          const ue = !R.value
          ;(R.value = ue), n('expand', ue)
        }
        function V(ue = !1) {
          return N.value.css
            ? m(
                e3,
                {
                  editable: l.value,
                  copyable: s.value,
                  expandable: N.value.expandable,
                  isCopied: A.value,
                  isEllipsis: q.value,
                  expanded: R.value,
                  forceRenderExpand: ue || R.value,
                  editTooltipProps: e.editTooltipProps,
                  copyTooltipProps: e.copyTooltipProps,
                  onEdit: w,
                  onCopy: T,
                  onExpand: B,
                },
                {
                  'copy-tooltip': t['copy-tooltip'],
                  'copy-icon': t['copy-icon'],
                  'expand-node': t['expand-node'],
                }
              )
            : m(
                e3,
                {
                  editable: l.value,
                  copyable: s.value,
                  expandable: N.value.expandable,
                  isCopied: A.value,
                  isEllipsis: k.value,
                  expanded: R.value,
                  forceRenderExpand: ue,
                  editTooltipProps: e.editTooltipProps,
                  copyTooltipProps: e.copyTooltipProps,
                  onEdit: w,
                  onCopy: T,
                  onExpand: B,
                },
                {
                  'copy-tooltip': t['copy-tooltip'],
                  'copy-icon': t['copy-icon'],
                  'expand-node': t['expand-node'],
                }
              )
        }
        function L() {
          if (!_.value) return
          const { ellipsis: ue, text: me } = Iie(
            _.value,
            N.value,
            V(!!N.value.expandable),
            b.value
          )
          k.value !== ue && ((k.value = ue), N.value.css || n('ellipsis', ue)),
            j.value !== me && (j.value = me || '')
        }
        function W() {
          a.value &&
            !R.value &&
            (ov(I),
            (I = D4(() => {
              L()
            })))
        }
        wr(() => {
          ov(I)
        }),
          pt(
            () => N.value.rows,
            () => {
              W()
            }
          ),
          pt(a, (ue) => {
            ue ? W() : (k.value = !1)
          })
        let Y = []
        const U = () => {
          if (a.value || s.value || l.value) {
            const ue = Die(Y)
            ue !== b.value && ((b.value = ue), W())
          }
        }
        Wt(U), Zr(U)
        const le = J(),
          q = J(!1),
          oe = () => {
            if (_.value && le.value) {
              const ue = le.value.offsetHeight > _.value.offsetHeight
              ue !== q.value && ((q.value = ue), n('ellipsis', ue))
            }
          },
          te = C(() =>
            R.value
              ? {}
              : {
                  overflow: 'hidden',
                  'text-overflow': 'ellipsis',
                  display: '-webkit-box',
                  '-webkit-line-clamp': N.value.rows,
                  '-webkit-box-orient': 'vertical',
                }
          )
        return () => {
          var ue, me
          if (
            ((Y = ((ue = t.default) == null ? void 0 : ue.call(t)) || []),
            x.value)
          ) {
            const ae = (me = d.value) != null ? me : b.value
            return m(
              yie,
              {
                text: ae,
                onChange: (re) => {
                  re !== ae && E(re)
                },
                onEnd: P,
              },
              null
            )
          }
          const {
              suffix: Re,
              ellipsisStr: qe,
              showTooltip: Ve,
              tooltipProps: nt,
              TooltipComponent: We,
            } = N.value,
            D = k.value && !R.value,
            G = D && !Ve ? { title: b.value } : {},
            z = p.value
          if (N.value.css) {
            const ae = r3(e, Y),
              re = m(z, Fe({ class: g.value, ref: _, style: te.value }, G, r), {
                default: () => [m('span', { ref: le }, [ae])],
              })
            return q.value
              ? m(We, Fe(nt, { onResize: () => oe() }), {
                  default: () => [re],
                  content: () => b.value,
                })
              : m(
                  Ro,
                  {
                    onResize: () => {
                      oe()
                    },
                  },
                  UA(re) ? re : { default: () => [re] }
                )
          }
          const ie = r3(e, D ? j.value : Y)
          return m(
            Ro,
            { onResize: () => W() },
            {
              default: () => [
                m(z, Fe({ class: g.value, ref: _ }, G, r), {
                  default: () => [
                    D && Ve
                      ? m(We, nt, {
                          default: () => [m('span', null, [ie])],
                          content: () => b.value,
                        })
                      : ie,
                    D ? qe : null,
                    Re,
                    V(),
                  ],
                }),
              ],
            }
          )
        }
      },
    }),
    Up = ce({
      name: 'TypographyParagraph',
      inheritAttrs: !1,
      props: {
        blockquote: { type: Boolean },
        spacing: { type: String, default: 'default' },
      },
      setup(e) {
        const { blockquote: t, spacing: n } = tt(e),
          r = ye('typography'),
          i = C(() => (t != null && t.value ? 'blockquote' : 'div')),
          o = C(() => [
            {
              [`${r}-spacing-close`]:
                (n == null ? void 0 : n.value) === 'close',
            },
          ])
        return { component: i, classNames: o }
      },
      render() {
        const { component: e, classNames: t } = this
        return m(
          wS,
          Fe({ class: t }, this.$attrs, { component: e }),
          this.$slots
        )
      },
    }),
    Hp = ce({
      name: 'TypographyTitle',
      inheritAttrs: !1,
      props: { heading: { type: Number, default: 1 } },
      setup(e) {
        const { heading: t } = tt(e)
        return { component: C(() => `h${t == null ? void 0 : t.value}`) }
      },
      render() {
        const { component: e } = this
        return m(wS, Fe(this.$attrs, { component: e }), this.$slots)
      },
    }),
    Wp = ce({
      name: 'TypographyText',
      inheritAttrs: !1,
      props: { ellipsis: { type: [Boolean, Object], default: !1 } },
      setup(e) {
        const { ellipsis: t } = tt(e)
        return { component: C(() => (t != null && t.value ? 'div' : 'span')) }
      },
      render() {
        const { ellipsis: e, component: t } = this
        return m(
          wS,
          Fe(this.$attrs, { ellipsis: e, component: t }),
          this.$slots
        )
      },
    })
  const Gie = Object.assign(r1, {
      Paragraph: Up,
      Title: Hp,
      Text: Wp,
      install: (e, t) => {
        Rt(e, t)
        const n = It(t)
        e.component(n + r1.name, r1),
          e.component(n + Up.name, Up),
          e.component(n + Hp.name, Hp),
          e.component(n + Wp.name, Wp)
      },
    }),
    i3 = (e) => {
      const t = e.responseText || e.response
      if (!t) return
      const n = e.getResponseHeader('Content-Type')
      if (n && n.includes('json'))
        try {
          return JSON.parse(t)
        } catch {
          return t
        }
      return t
    },
    Kie = (e) => {
      switch (e) {
        case 'done':
          return 'success'
        case 'error':
          return 'danger'
        default:
          return 'normal'
      }
    },
    o3 = (e, t) => (xt(e) ? e(t) : e),
    qie = ({
      fileItem: e,
      action: t,
      name: n,
      data: r,
      headers: i = {},
      withCredentials: o = !1,
      onProgress: a = Ru,
      onSuccess: s = Ru,
      onError: l = Ru,
    }) => {
      const c = o3(n, e) || 'file',
        d = o3(r, e),
        h = new XMLHttpRequest()
      o && (h.withCredentials = !0),
        (h.upload.onprogress = (v) => {
          const g = v.total > 0 ? ci.round(v.loaded / v.total, 2) : 0
          a(g, v)
        }),
        (h.onerror = function (g) {
          l(g)
        }),
        (h.onload = () => {
          if (h.status < 200 || h.status >= 300) {
            l(i3(h))
            return
          }
          s(i3(h))
        })
      const p = new FormData()
      if (d) for (const v of Object.keys(d)) p.append(v, d[v])
      e.file && p.append(c, e.file), h.open('post', t ?? '', !0)
      for (const v of Object.keys(i)) h.setRequestHeader(v, i[v])
      return (
        h.send(p),
        {
          abort() {
            h.abort()
          },
        }
      )
    },
    HA = (e, t) => {
      if (t && e) {
        const n = Ft(t)
            ? t
            : t
                .split(',')
                .map((i) => i.trim())
                .filter((i) => i),
          r = (
            e.name.indexOf('.') > -1 ? `.${e.name.split('.').pop()}` : ''
          ).toLowerCase()
        return n.some((i) => {
          const o = i && i.toLowerCase(),
            a = (e.type || '').toLowerCase(),
            s = a.split('/')[0]
          if (
            o === a ||
            `${s}${r.replace('.', '/')}` === o ||
            /^\*(\/\*)?$/.test(o)
          )
            return !0
          if (/\/\*/.test(o))
            return a.replace(/\/.*$/, '') === o.replace(/\/.*$/, '')
          if (/\..*/.test(o)) {
            let l = [o]
            return (
              (o === '.jpg' || o === '.jpeg') && (l = ['.jpg', '.jpeg']),
              l.indexOf(r) > -1
            )
          }
          return !1
        })
      }
      return !!e
    },
    Xie = (e, t, n) => {
      const r = []
      let i = 0
      const o = () => {
          !i && n(r)
        },
        a = (s) => {
          if (((i += 1), s != null && s.isFile)) {
            s.file((l) => {
              ;(i -= 1),
                HA(l, t) &&
                  (Object.defineProperty(l, 'webkitRelativePath', {
                    value: s.fullPath.replace(/^\//, ''),
                  }),
                  r.push(l)),
                o()
            })
            return
          }
          if (s != null && s.isDirectory) {
            const l = s.createReader()
            let c = !1
            const d = () => {
              l.readEntries((h) => {
                c || ((i -= 1), (c = !0)),
                  h.length === 0 ? o() : (d(), h.forEach(a))
              })
            }
            d()
            return
          }
          ;(i -= 1), o()
        }
      ;[].slice
        .call(e)
        .forEach((s) => s.webkitGetAsEntry && a(s.webkitGetAsEntry()))
    },
    Yie = (e) => {
      var t
      return (t = e.type) == null ? void 0 : t.includes('image')
    },
    s1 = (e, t) => {
      if (!e) return []
      const n = Array.from(e)
      return t ? n.filter((r) => HA(r, t)) : n
    },
    Zie = ce({
      name: 'IconUpload',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-upload`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Jie = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Qie = Se(
      'path',
      { d: 'M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6' },
      null,
      -1
    ),
    eoe = [Qie]
  function toe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        eoe,
        14,
        Jie
      )
    )
  }
  var l1 = Te(Zie, [['render', toe]])
  const xS = Object.assign(l1, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + l1.name, l1)
    },
  })
  var noe = ce({
    name: 'UploadButton',
    props: {
      disabled: { type: Boolean, default: !1 },
      directory: { type: Boolean, default: !1 },
      accept: String,
      listType: { type: String },
      tip: String,
      draggable: { type: Boolean, default: !1 },
      multiple: { type: Boolean, default: !1 },
      uploadFiles: { type: Function, required: !0 },
      hide: Boolean,
      onButtonClick: { type: Function },
    },
    setup(e, { slots: t }) {
      const n = ye('upload'),
        { t: r } = Vn(),
        i = J(!1),
        o = J(null),
        a = J(null),
        s = J(0),
        l = (b) => {
          b === 'subtract'
            ? (s.value -= 1)
            : b === 'add'
            ? (s.value += 1)
            : b === 'reset' && (s.value = 0)
        },
        c = (b) => {
          if (!e.disabled) {
            if (xt(e.onButtonClick)) {
              const y = e.onButtonClick(b)
              if (xl(y)) {
                y.then((M) => {
                  e.uploadFiles(s1(M))
                })
                return
              }
            }
            o.value && o.value.click()
          }
        },
        d = (b) => {
          const y = b.target
          y.files && e.uploadFiles(s1(y.files)), (y.value = '')
        },
        h = (b) => {
          var y, M
          if ((b.preventDefault(), (i.value = !1), l('reset'), !e.disabled))
            if (e.directory && (y = b.dataTransfer) != null && y.items)
              Xie(b.dataTransfer.items, e.accept, (x) => {
                e.uploadFiles(x)
              })
            else {
              const x = s1(
                (M = b.dataTransfer) == null ? void 0 : M.files,
                e.accept
              )
              e.uploadFiles(e.multiple ? x : x.slice(0, 1))
            }
        },
        p = (b) => {
          b.preventDefault(),
            l('subtract'),
            s.value === 0 && ((i.value = !1), l('reset'))
        },
        v = (b) => {
          b.preventDefault(), !e.disabled && !i.value && (i.value = !0)
        },
        g = () =>
          t.default
            ? m('span', null, [t.default()])
            : e.listType === 'picture-card'
            ? m('div', { class: `${n}-picture-card` }, [
                m('div', { class: `${n}-picture-card-text` }, [
                  m(Xu, null, null),
                ]),
                e.tip && m('div', { class: `${n}-tip` }, [e.tip]),
              ])
            : e.draggable
            ? m(
                'div',
                { class: [`${n}-drag`, { [`${n}-drag-active`]: i.value }] },
                [
                  m('div', null, [m(Xu, null, null)]),
                  m('div', { class: `${n}-drag-text` }, [
                    i.value ? r('upload.dragHover') : r('upload.drag'),
                  ]),
                  e.tip && m('div', { class: `${n}-tip` }, [e.tip]),
                ]
              )
            : m(
                Yr,
                { type: 'primary', disabled: e.disabled },
                {
                  default: () => [r('upload.buttonText')],
                  icon: () => m(xS, null, null),
                }
              ),
        _ = C(() => [
          n,
          {
            [`${n}-type-picture-card`]: e.listType === 'picture-card',
            [`${n}-draggable`]: e.draggable,
            [`${n}-disabled`]: e.disabled,
            [`${n}-hide`]: e.hide,
          },
        ])
      return () =>
        m(
          'span',
          {
            ref: a,
            class: _.value,
            onClick: c,
            onDragenter: () => {
              l('add')
            },
            onDrop: h,
            onDragover: v,
            onDragleave: p,
          },
          [
            m(
              'input',
              Fe(
                {
                  ref: o,
                  type: 'file',
                  style: { display: 'none' },
                  disabled: e.disabled,
                  accept: e.accept,
                  multiple: e.multiple,
                },
                e.directory ? { webkitdirectory: 'webkitdirectory' } : {},
                { onChange: d }
              ),
              null
            ),
            g(),
          ]
        )
    },
  })
  const roe = ce({
      name: 'IconPause',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-pause`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    ioe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    ooe = Se('path', { d: 'M14 12h4v24h-4zM30 12h4v24h-4z' }, null, -1),
    aoe = Se(
      'path',
      {
        fill: 'currentColor',
        stroke: 'none',
        d: 'M14 12h4v24h-4zM30 12h4v24h-4z',
      },
      null,
      -1
    ),
    soe = [ooe, aoe]
  function loe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        soe,
        14,
        ioe
      )
    )
  }
  var u1 = Te(roe, [['render', loe]])
  const uoe = Object.assign(u1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + u1.name, u1)
      },
    }),
    coe = ce({
      name: 'IconPlayArrowFill',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-play-arrow-fill`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    doe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    foe = Se(
      'path',
      {
        d: 'M17.533 10.974a1 1 0 0 0-1.537.844v24.356a1 1 0 0 0 1.537.844L36.67 24.84a1 1 0 0 0 0-1.688L17.533 10.974Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    hoe = [foe]
  function poe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        hoe,
        14,
        doe
      )
    )
  }
  var c1 = Te(coe, [['render', poe]])
  const voe = Object.assign(c1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + c1.name, c1)
      },
    }),
    cm = Symbol('ArcoUpload')
  var WA = ce({
    name: 'UploadProgress',
    props: {
      file: { type: Object, required: !0 },
      listType: { type: String, required: !0 },
    },
    setup(e) {
      const t = ye('upload-progress'),
        { t: n } = Vn(),
        r = zt(cm, void 0),
        i = () => {
          var a, s, l, c, d, h, p, v, g, _, b
          return e.file.status === 'error'
            ? m(
                'span',
                {
                  class: [
                    r == null ? void 0 : r.iconCls,
                    `${r == null ? void 0 : r.iconCls}-upload`,
                  ],
                  onClick: () => (r == null ? void 0 : r.onUpload(e.file)),
                },
                [
                  (r != null &&
                    r.showRetryButton &&
                    ((d =
                      (s = r == null ? void 0 : (a = r.slots)['retry-icon']) ==
                      null
                        ? void 0
                        : s.call(a)) != null
                      ? d
                      : (c =
                          (l = r == null ? void 0 : r.customIcon) == null
                            ? void 0
                            : l.retryIcon) != null && c.call(l))) ||
                  e.listType === 'picture-card'
                    ? m(xS, null, null)
                    : n('upload.retry'),
                ]
              )
            : e.file.status === 'done'
            ? m(
                'span',
                {
                  class: [
                    r == null ? void 0 : r.iconCls,
                    `${r == null ? void 0 : r.iconCls}-success`,
                  ],
                },
                [
                  (b =
                    (_ =
                      (p =
                        r == null ? void 0 : (h = r.slots)['success-icon']) ==
                      null
                        ? void 0
                        : p.call(h)) != null
                      ? _
                      : (g =
                          (v = r == null ? void 0 : r.customIcon) == null
                            ? void 0
                            : v.successIcon) == null
                      ? void 0
                      : g.call(v)) != null
                    ? b
                    : m(sm, null, null),
                ]
              )
            : e.file.status === 'init'
            ? m(
                uo,
                { content: n('upload.start') },
                {
                  default: () => {
                    var y, M, x, w, E, P
                    return [
                      m(
                        'span',
                        {
                          class: [
                            r == null ? void 0 : r.iconCls,
                            `${r == null ? void 0 : r.iconCls}-start`,
                          ],
                          onClick: () =>
                            r == null ? void 0 : r.onUpload(e.file),
                        },
                        [
                          (P =
                            (E =
                              (M =
                                r == null
                                  ? void 0
                                  : (y = r.slots)['start-icon']) == null
                                ? void 0
                                : M.call(y)) != null
                              ? E
                              : (w =
                                  (x = r == null ? void 0 : r.customIcon) ==
                                  null
                                    ? void 0
                                    : x.startIcon) == null
                              ? void 0
                              : w.call(x)) != null
                            ? P
                            : m(voe, null, null),
                        ]
                      ),
                    ]
                  },
                }
              )
            : (r == null ? void 0 : r.showCancelButton) &&
              m(
                uo,
                { content: n('upload.cancel') },
                {
                  default: () => {
                    var y, M, x, w, E, P
                    return [
                      m(
                        'span',
                        {
                          class: [
                            r == null ? void 0 : r.iconCls,
                            `${r == null ? void 0 : r.iconCls}-cancel`,
                          ],
                          onClick: () =>
                            r == null ? void 0 : r.onAbort(e.file),
                        },
                        [
                          (P =
                            (E =
                              (M =
                                r == null
                                  ? void 0
                                  : (y = r.slots)['cancel-icon']) == null
                                ? void 0
                                : M.call(y)) != null
                              ? E
                              : (w =
                                  (x = r == null ? void 0 : r.customIcon) ==
                                  null
                                    ? void 0
                                    : x.cancelIcon) == null
                              ? void 0
                              : w.call(x)) != null
                            ? P
                            : m(uoe, null, null),
                        ]
                      ),
                    ]
                  },
                }
              )
        },
        o = () => {
          var a
          if (
            ['init', 'uploading'].includes((a = e.file.status) != null ? a : '')
          ) {
            const s = Kie(e.file.status)
            return m(
              MA,
              {
                type: 'circle',
                size: 'mini',
                showText: !1,
                status: s,
                percent: e.file.percent,
              },
              null
            )
          }
          return null
        }
      return () => m('span', { class: t }, [o(), i()])
    },
  })
  const moe = ce({
      name: 'IconFilePdf',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-file-pdf`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    goe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    yoe = Se(
      'path',
      {
        d: 'M11 42h26a2 2 0 0 0 2-2V13.828a2 2 0 0 0-.586-1.414l-5.828-5.828A2 2 0 0 0 31.172 6H11a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2Z',
      },
      null,
      -1
    ),
    boe = Se(
      'path',
      {
        d: 'M22.305 21.028c.874 1.939 3.506 6.265 4.903 8.055 1.747 2.237 3.494 2.685 4.368 2.237.873-.447 1.21-4.548-7.425-2.685-7.523 1.623-7.424 3.58-6.988 4.476.728 1.193 2.522 2.627 5.678-6.266C25.699 18.79 24.489 17 23.277 17c-1.409 0-2.538.805-.972 4.028Z',
      },
      null,
      -1
    ),
    _oe = [yoe, boe]
  function Soe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        _oe,
        14,
        goe
      )
    )
  }
  var d1 = Te(moe, [['render', Soe]])
  const Coe = Object.assign(d1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + d1.name, d1)
      },
    }),
    woe = ce({
      name: 'IconFileImage',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-file-image`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    xoe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Moe = Se(
      'path',
      {
        d: 'm26 33 5-6v6h-5Zm0 0-3-4-4 4h7Zm11 9H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2ZM17 19h1v1h-1v-1Z',
      },
      null,
      -1
    ),
    Eoe = [Moe]
  function Poe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Eoe,
        14,
        xoe
      )
    )
  }
  var f1 = Te(woe, [['render', Poe]])
  const Toe = Object.assign(f1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + f1.name, f1)
      },
    }),
    koe = ce({
      name: 'IconFileVideo',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-file-video`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Aoe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    $oe = Se(
      'path',
      { d: 'M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z' },
      null,
      -1
    ),
    Ooe = Se('path', { d: 'M22 27.796v-6l5 3-5 3Z' }, null, -1),
    Loe = [$oe, Ooe]
  function Ioe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Loe,
        14,
        Aoe
      )
    )
  }
  var h1 = Te(koe, [['render', Ioe]])
  const Roe = Object.assign(h1, {
      install: (e, t) => {
        var n
        const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
        e.component(r + h1.name, h1)
      },
    }),
    Doe = ce({
      name: 'IconFileAudio',
      props: {
        size: { type: [Number, String] },
        strokeWidth: { type: Number, default: 4 },
        strokeLinecap: {
          type: String,
          default: 'butt',
          validator: (e) => ['butt', 'round', 'square'].includes(e),
        },
        strokeLinejoin: {
          type: String,
          default: 'miter',
          validator: (e) =>
            ['arcs', 'bevel', 'miter', 'miter-clip', 'round'].includes(e),
        },
        rotate: Number,
        spin: Boolean,
      },
      emits: { click: (e) => !0 },
      setup(e, { emit: t }) {
        const n = ye('icon'),
          r = C(() => [n, `${n}-file-audio`, { [`${n}-spin`]: e.spin }]),
          i = C(() => {
            const a = {}
            return (
              e.size && (a.fontSize = it(e.size) ? `${e.size}px` : e.size),
              e.rotate && (a.transform = `rotate(${e.rotate}deg)`),
              a
            )
          })
        return {
          cls: r,
          innerStyle: i,
          onClick: (a) => {
            t('click', a)
          },
        }
      },
    }),
    Noe = ['stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    Boe = Se(
      'path',
      { d: 'M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z' },
      null,
      -1
    ),
    Foe = Se(
      'path',
      {
        d: 'M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z',
        fill: 'currentColor',
        stroke: 'none',
      },
      null,
      -1
    ),
    zoe = Se(
      'path',
      {
        d: 'M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm0 0-.951-12.363a.5.5 0 0 1 .58-.532L30 18',
      },
      null,
      -1
    ),
    Voe = [Boe, Foe, zoe]
  function Uoe(e, t, n, r, i, o) {
    return (
      O(),
      Z(
        'svg',
        {
          viewBox: '0 0 48 48',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          stroke: 'currentColor',
          class: H(e.cls),
          style: at(e.innerStyle),
          'stroke-width': e.strokeWidth,
          'stroke-linecap': e.strokeLinecap,
          'stroke-linejoin': e.strokeLinejoin,
          onClick: t[0] || (t[0] = (...a) => e.onClick && e.onClick(...a)),
        },
        Voe,
        14,
        Noe
      )
    )
  }
  var p1 = Te(Doe, [['render', Uoe]])
  const Hoe = Object.assign(p1, {
    install: (e, t) => {
      var n
      const r = (n = t == null ? void 0 : t.iconPrefix) != null ? n : ''
      e.component(r + p1.name, p1)
    },
  })
  var a3 = ce({
      name: 'UploadListItem',
      props: {
        file: { type: Object, required: !0 },
        listType: { type: String, required: !0 },
      },
      setup(e) {
        const n = `${ye('upload-list')}-item`,
          { t: r } = Vn(),
          i = zt(cm, void 0),
          o = () => {
            var a, s
            let l = ''
            if (e.file.file && e.file.file.type) l = e.file.file.type
            else {
              const c =
                (s = (a = e.file.name) == null ? void 0 : a.split('.')[1]) !=
                null
                  ? s
                  : ''
              ;['png', 'jpg', 'jpeg', 'bmp', 'gif', 'webp'].includes(c)
                ? (l = 'image')
                : ['mp4', 'm2v', 'mkv', 'm4v', 'mov'].includes(c)
                ? (l = 'video')
                : ['mp3', 'wav', 'wmv', 'm4a', 'acc', 'flac'].includes(c) &&
                  (l = 'audio')
            }
            return l.includes('image')
              ? m(Toe, null, null)
              : l.includes('pdf')
              ? m(Coe, null, null)
              : l.includes('audio')
              ? m(Hoe, null, null)
              : l.includes('video')
              ? m(Roe, null, null)
              : m(BA, null, null)
          }
        return () => {
          var a,
            s,
            l,
            c,
            d,
            h,
            p,
            v,
            g,
            _,
            b,
            y,
            M,
            x,
            w,
            E,
            P,
            A,
            F,
            T,
            k,
            R,
            j
          return m('div', { class: [n, `${n}-${e.file.status}`] }, [
            m('div', { class: `${n}-content` }, [
              (i == null ? void 0 : i.listType) === 'picture' &&
                m('span', { class: `${n}-thumbnail` }, [
                  (l =
                    (s = i == null ? void 0 : (a = i.slots).image) == null
                      ? void 0
                      : s.call(a, { fileItem: e.file })) != null
                    ? l
                    : m(
                        'img',
                        Fe(
                          { src: e.file.url, alt: e.file.name },
                          i != null && i.imageLoading
                            ? { loading: i.imageLoading }
                            : void 0
                        ),
                        null
                      ),
                ]),
              m('div', { class: `${n}-name` }, [
                (i == null ? void 0 : i.listType) === 'text' &&
                  m('span', { class: `${n}-file-icon` }, [
                    (g =
                      (v =
                        (d = i == null ? void 0 : (c = i.slots)['file-icon']) ==
                        null
                          ? void 0
                          : d.call(c, { fileItem: e.file })) != null
                        ? v
                        : (p =
                            (h = i == null ? void 0 : i.customIcon) == null
                              ? void 0
                              : h.fileIcon) == null
                        ? void 0
                        : p.call(h, e.file)) != null
                      ? g
                      : o(),
                  ]),
                i != null && i.showLink && e.file.url
                  ? m(
                      'a',
                      Fe(
                        {
                          class: `${n}-name-link`,
                          target: '_blank',
                          href: e.file.url,
                        },
                        i != null && i.download
                          ? { download: e.file.name }
                          : void 0
                      ),
                      [
                        (w =
                          (x =
                            (b =
                              i == null
                                ? void 0
                                : (_ = i.slots)['file-name']) == null
                              ? void 0
                              : b.call(_, { fileItem: e.file })) != null
                            ? x
                            : (M =
                                (y = i == null ? void 0 : i.customIcon) == null
                                  ? void 0
                                  : y.fileName) == null
                            ? void 0
                            : M.call(y, e.file)) != null
                          ? w
                          : e.file.name,
                      ]
                    )
                  : m(
                      'span',
                      {
                        class: `${n}-name-text`,
                        onClick: () =>
                          i == null ? void 0 : i.onPreview(e.file),
                      },
                      [
                        (k =
                          (T =
                            (P =
                              i == null
                                ? void 0
                                : (E = i.slots)['file-name']) == null
                              ? void 0
                              : P.call(E, { fileItem: e.file })) != null
                            ? T
                            : (F =
                                (A = i == null ? void 0 : i.customIcon) == null
                                  ? void 0
                                  : A.fileName) == null
                            ? void 0
                            : F.call(A, e.file)) != null
                          ? k
                          : e.file.name,
                      ]
                    ),
                e.file.status === 'error' &&
                  m(
                    uo,
                    { content: r('upload.error') },
                    {
                      default: () => {
                        var N, I, B, V, L, W
                        return [
                          m(
                            'span',
                            {
                              class: [
                                i == null ? void 0 : i.iconCls,
                                `${i == null ? void 0 : i.iconCls}-error`,
                              ],
                            },
                            [
                              (W =
                                (L =
                                  (I =
                                    i == null
                                      ? void 0
                                      : (N = i.slots)['error-icon']) == null
                                    ? void 0
                                    : I.call(N)) != null
                                  ? L
                                  : (V =
                                      (B = i == null ? void 0 : i.customIcon) ==
                                      null
                                        ? void 0
                                        : B.errorIcon) == null
                                  ? void 0
                                  : V.call(B)) != null
                                ? W
                                : m(Wa, null, null),
                            ]
                          ),
                        ]
                      },
                    }
                  ),
              ]),
              m(WA, { file: e.file, listType: e.listType }, null),
            ]),
            (i == null ? void 0 : i.showRemoveButton) &&
              m('span', { class: `${n}-operation` }, [
                m(
                  In,
                  {
                    onClick: () => {
                      var N
                      return (N = i == null ? void 0 : i.onRemove) == null
                        ? void 0
                        : N.call(i, e.file)
                    },
                  },
                  {
                    default: () => {
                      var N, I, B, V, L, W
                      return [
                        m(
                          'span',
                          {
                            class: [
                              i == null ? void 0 : i.iconCls,
                              `${i == null ? void 0 : i.iconCls}-remove`,
                            ],
                          },
                          [
                            (W =
                              (L =
                                (I =
                                  i == null
                                    ? void 0
                                    : (N = i.slots)['remove-icon']) == null
                                  ? void 0
                                  : I.call(N)) != null
                                ? L
                                : (V =
                                    (B = i == null ? void 0 : i.customIcon) ==
                                    null
                                      ? void 0
                                      : B.removeIcon) == null
                                ? void 0
                                : V.call(B)) != null
                              ? W
                              : m(_S, null, null),
                          ]
                        ),
                      ]
                    },
                  }
                ),
              ]),
            (j = i == null ? void 0 : (R = i.slots)['extra-button']) == null
              ? void 0
              : j.call(R, { fileItem: e.file }),
          ])
        }
      },
    }),
    s3 = ce({
      name: 'UploadPictureItem',
      props: {
        file: { type: Object, required: !0 },
        disabled: { type: Boolean, default: !1 },
      },
      setup(e) {
        const n = `${ye('upload-list')}-picture`,
          r = C(() => [
            n,
            { [`${n}-status-error`]: e.file.status === 'error' },
          ]),
          i = zt(cm, void 0),
          o = () => {
            var a,
              s,
              l,
              c,
              d,
              h,
              p,
              v,
              g,
              _,
              b,
              y,
              M,
              x,
              w,
              E,
              P,
              A,
              F,
              T,
              k,
              R,
              j,
              N,
              I,
              B,
              V,
              L,
              W
            return e.file.status === 'uploading'
              ? m(WA, { file: e.file, listType: 'picture-card' }, null)
              : m(yt, null, [
                  (l =
                    (s = i == null ? void 0 : (a = i.slots).image) == null
                      ? void 0
                      : s.call(a, { fileItem: e.file })) != null
                    ? l
                    : m(
                        'img',
                        Fe(
                          { src: e.file.url, alt: e.file.name },
                          i != null && i.imageLoading
                            ? { loading: i.imageLoading }
                            : void 0
                        ),
                        null
                      ),
                  m('div', { class: `${n}-mask` }, [
                    e.file.status === 'error' &&
                      (i == null ? void 0 : i.showCancelButton) &&
                      m('div', { class: `${n}-error-tip` }, [
                        m(
                          'span',
                          {
                            class: [
                              i == null ? void 0 : i.iconCls,
                              `${i == null ? void 0 : i.iconCls}-error`,
                            ],
                          },
                          [
                            (g =
                              (v =
                                (d =
                                  i == null
                                    ? void 0
                                    : (c = i.slots)['error-icon']) == null
                                  ? void 0
                                  : d.call(c)) != null
                                ? v
                                : (p =
                                    (h = i == null ? void 0 : i.customIcon) ==
                                    null
                                      ? void 0
                                      : h.errorIcon) == null
                                ? void 0
                                : p.call(h)) != null
                              ? g
                              : m(U_, null, null),
                          ]
                        ),
                      ]),
                    m('div', { class: `${n}-operation` }, [
                      e.file.status !== 'error' &&
                        (i == null ? void 0 : i.showPreviewButton) &&
                        m(
                          'span',
                          {
                            class: [
                              i == null ? void 0 : i.iconCls,
                              `${i == null ? void 0 : i.iconCls}-preview`,
                            ],
                            onClick: () =>
                              i == null ? void 0 : i.onPreview(e.file),
                          },
                          [
                            (w =
                              (x =
                                (b =
                                  i == null
                                    ? void 0
                                    : (_ = i.slots)['preview-icon']) == null
                                  ? void 0
                                  : b.call(_)) != null
                                ? x
                                : (M =
                                    (y = i == null ? void 0 : i.customIcon) ==
                                    null
                                      ? void 0
                                      : y.previewIcon) == null
                                ? void 0
                                : M.call(y)) != null
                              ? w
                              : m(U4, null, null),
                          ]
                        ),
                      ['init', 'error'].includes(e.file.status) &&
                        (i == null ? void 0 : i.showRetryButton) &&
                        m(
                          'span',
                          {
                            class: [
                              i == null ? void 0 : i.iconCls,
                              `${i == null ? void 0 : i.iconCls}-upload`,
                            ],
                            onClick: () =>
                              i == null ? void 0 : i.onUpload(e.file),
                          },
                          [
                            (k =
                              (T =
                                (P =
                                  i == null
                                    ? void 0
                                    : (E = i.slots)['retry-icon']) == null
                                  ? void 0
                                  : P.call(E)) != null
                                ? T
                                : (F =
                                    (A = i == null ? void 0 : i.customIcon) ==
                                    null
                                      ? void 0
                                      : A.retryIcon) == null
                                ? void 0
                                : F.call(A)) != null
                              ? k
                              : m(xS, null, null),
                          ]
                        ),
                      !(i != null && i.disabled) &&
                        (i == null ? void 0 : i.showRemoveButton) &&
                        m(
                          'span',
                          {
                            class: [
                              i == null ? void 0 : i.iconCls,
                              `${i == null ? void 0 : i.iconCls}-remove`,
                            ],
                            onClick: () =>
                              i == null ? void 0 : i.onRemove(e.file),
                          },
                          [
                            (V =
                              (B =
                                (j =
                                  i == null
                                    ? void 0
                                    : (R = i.slots)['remove-icon']) == null
                                  ? void 0
                                  : j.call(R)) != null
                                ? B
                                : (I =
                                    (N = i == null ? void 0 : i.customIcon) ==
                                    null
                                      ? void 0
                                      : N.removeIcon) == null
                                ? void 0
                                : I.call(N)) != null
                              ? V
                              : m(_S, null, null),
                          ]
                        ),
                      (W =
                        i == null ? void 0 : (L = i.slots)['extra-button']) ==
                      null
                        ? void 0
                        : W.call(L, e.file),
                    ]),
                  ]),
                ])
          }
        return () => m('span', { class: r.value }, [o()])
      },
    }),
    Woe = ce({
      name: 'UploadList',
      components: { UploadListItem: a3, UploadPictureItem: s3 },
      props: {
        fileList: { type: Array, required: !0 },
        listType: { type: String, required: !0 },
      },
      setup(e, { slots: t }) {
        const n = ye('upload'),
          r = C(() => [`${n}-list`, `${n}-list-type-${e.listType}`]),
          i = (o, a) =>
            xt(t['upload-item'])
              ? t['upload-item']({ fileItem: o, index: a })
              : e.listType === 'picture-card'
              ? m(s3, { file: o, key: `item-${a}` }, null)
              : m(a3, { file: o, listType: e.listType, key: `item-${a}` }, null)
        return () =>
          m(
            jd,
            { tag: 'div', class: r.value },
            {
              default: () => {
                var o
                return [
                  ...e.fileList.map((a, s) => i(a, s)),
                  e.listType === 'picture-card' &&
                    ((o = t['upload-button']) == null ? void 0 : o.call(t)),
                ]
              },
            }
          )
      },
    }),
    joe = Object.defineProperty,
    Goe = Object.defineProperties,
    Koe = Object.getOwnPropertyDescriptors,
    l3 = Object.getOwnPropertySymbols,
    qoe = Object.prototype.hasOwnProperty,
    Xoe = Object.prototype.propertyIsEnumerable,
    u3 = (e, t, n) =>
      t in e
        ? joe(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Yoe = (e, t) => {
      for (var n in t || (t = {})) qoe.call(t, n) && u3(e, n, t[n])
      if (l3) for (var n of l3(t)) Xoe.call(t, n) && u3(e, n, t[n])
      return e
    },
    Zoe = (e, t) => Goe(e, Koe(t)),
    v1 = ce({
      name: 'Upload',
      props: {
        fileList: { type: Array, default: void 0 },
        defaultFileList: { type: Array, default: () => [] },
        accept: String,
        action: String,
        disabled: { type: Boolean, default: !1 },
        multiple: { type: Boolean, default: !1 },
        directory: { type: Boolean, default: !1 },
        draggable: { type: Boolean, default: !1 },
        tip: String,
        headers: { type: Object },
        data: { type: [Object, Function] },
        name: { type: [String, Function] },
        withCredentials: { type: Boolean, default: !1 },
        customRequest: { type: Function },
        limit: { type: Number, default: 0 },
        autoUpload: { type: Boolean, default: !0 },
        showFileList: { type: Boolean, default: !0 },
        showRemoveButton: { type: Boolean, default: !0 },
        showRetryButton: { type: Boolean, default: !0 },
        showCancelButton: { type: Boolean, default: !0 },
        showUploadButton: { type: [Boolean, Object], default: !0 },
        showPreviewButton: { type: Boolean, default: !0 },
        download: { type: Boolean, default: !1 },
        showLink: { type: Boolean, default: !0 },
        imageLoading: { type: String },
        listType: { type: String, default: 'text' },
        responseUrlKey: { type: [String, Function] },
        customIcon: { type: Object },
        imagePreview: { type: Boolean, default: !1 },
        onBeforeUpload: { type: Function },
        onBeforeRemove: { type: Function },
        onButtonClick: { type: Function },
      },
      emits: {
        'update:fileList': (e) => !0,
        exceedLimit: (e, t) => !0,
        change: (e, t) => !0,
        progress: (e, t) => !0,
        preview: (e) => !0,
        success: (e) => !0,
        error: (e) => !0,
      },
      setup(e, { emit: t, slots: n }) {
        const {
            fileList: r,
            disabled: i,
            listType: o,
            customIcon: a,
            showRetryButton: s,
            showCancelButton: l,
            showRemoveButton: c,
            showPreviewButton: d,
            imageLoading: h,
            download: p,
            showLink: v,
          } = tt(e),
          g = ye('upload'),
          { mergedDisabled: _, eventHandlers: b } = Rn({ disabled: i }),
          y = J([]),
          M = new Map(),
          x = new Map(),
          w = C(() => e.limit > 0 && y.value.length >= e.limit),
          E = (te) => {
            M.clear()
            const ue =
              te == null
                ? void 0
                : te.map((me, Re) => {
                    var qe, Ve, nt
                    const We = (qe = me.status) != null ? qe : 'done',
                      D = Je(
                        Zoe(Yoe({}, me), {
                          uid:
                            (Ve = me.uid) != null ? Ve : `${Date.now()}${Re}`,
                          status: We,
                          percent:
                            (nt = me.percent) != null
                              ? nt
                              : ['error', 'init'].indexOf(We) > -1
                              ? 0
                              : 1,
                        })
                      )
                    return M.set(D.uid, D), D
                  })
            y.value = ue ?? []
          }
        E(e.defaultFileList),
          pt(
            r,
            (te) => {
              te && E(te)
            },
            { immediate: !0, deep: !0 }
          )
        const P = (te) => {
            var ue, me
            t('update:fileList', y.value),
              t('change', y.value, te),
              (me = (ue = b.value) == null ? void 0 : ue.onChange) == null ||
                me.call(ue)
          },
          A = (te, ue) => {
            for (const me of y.value)
              if (me.uid === te) {
                ;(me.file = ue), P(me)
                break
              }
          },
          F = (te) => {
            const ue = (nt, We) => {
                const D = M.get(te.uid)
                D &&
                  ((D.status = 'uploading'),
                  (D.percent = nt),
                  t('progress', D, We),
                  P(D))
              },
              me = (nt) => {
                const We = M.get(te.uid)
                We &&
                  ((We.status = 'done'),
                  (We.percent = 1),
                  (We.response = nt),
                  e.responseUrlKey &&
                    (xt(e.responseUrlKey)
                      ? (We.url = e.responseUrlKey(We))
                      : nt[e.responseUrlKey] &&
                        (We.url = nt[e.responseUrlKey])),
                  x.delete(We.uid),
                  t('success', We),
                  P(We))
              },
              Re = (nt) => {
                const We = M.get(te.uid)
                We &&
                  ((We.status = 'error'),
                  (We.percent = 0),
                  (We.response = nt),
                  x.delete(We.uid),
                  t('error', We),
                  P(We))
              },
              qe = {
                fileItem: te,
                action: e.action,
                name: e.name,
                data: e.data,
                headers: e.headers,
                withCredentials: e.withCredentials,
                onProgress: ue,
                onSuccess: me,
                onError: Re,
              }
            ;(te.status = 'uploading'), (te.percent = 0)
            const Ve = xt(e.customRequest) ? e.customRequest(qe) : qie(qe)
            x.set(te.uid, Ve), P(te)
          },
          T = (te) => {
            var ue
            const me = x.get(te.uid)
            if (me) {
              ;(ue = me.abort) == null || ue.call(me), x.delete(te.uid)
              const Re = M.get(te.uid)
              Re && ((Re.status = 'error'), (Re.percent = 0), P(Re))
            }
          },
          k = (te) => {
            if (te) {
              const ue = M.get(te.uid)
              ue && F(ue)
            } else for (const ue of y.value) ue.status === 'init' && F(ue)
          },
          R = async (te, ue) => {
            const me = `${Date.now()}-${ue}`,
              Re = Yie(te) ? URL.createObjectURL(te) : void 0,
              qe = Je({
                uid: me,
                file: te,
                url: Re,
                name: te.name,
                status: 'init',
                percent: 0,
              })
            M.set(me, qe),
              (y.value = [...y.value, qe]),
              P(qe),
              e.autoUpload && F(qe)
          },
          j = (te) => {
            if (e.limit > 0 && y.value.length + te.length > e.limit) {
              t('exceedLimit', y.value, te)
              return
            }
            for (let ue = 0; ue < te.length; ue++) {
              const me = te[ue]
              xt(e.onBeforeUpload)
                ? Promise.resolve(e.onBeforeUpload(me))
                    .then((Re) => {
                      Re && R(Ui(Re) ? me : Re, ue)
                    })
                    .catch((Re) => {
                      console.error(Re)
                    })
                : R(me, ue)
            }
          },
          N = (te) => {
            ;(y.value = y.value.filter((ue) => ue.uid !== te.uid)), P(te)
          },
          I = (te) => {
            xt(e.onBeforeRemove)
              ? Promise.resolve(e.onBeforeRemove(te))
                  .then((ue) => {
                    ue && N(te)
                  })
                  .catch((ue) => {
                    console.error(ue)
                  })
              : N(te)
          },
          B = (te) => {
            if (e.imagePreview && te.url) {
              const ue = q.value.indexOf(te.url)
              ue > -1 && ((Y.value = ue), (W.value = !0))
            }
            t('preview', te)
          }
        sn(
          cm,
          Je({
            disabled: _,
            listType: o,
            iconCls: `${g}-icon`,
            showRemoveButton: c,
            showRetryButton: s,
            showCancelButton: l,
            showPreviewButton: d,
            showLink: v,
            imageLoading: h,
            download: p,
            customIcon: a,
            slots: n,
            onUpload: F,
            onAbort: T,
            onRemove: I,
            onPreview: B,
          })
        )
        const V = C(() => {
            if (e.accept) return e.accept
            if (e.listType === 'picture' || e.listType === 'picture-card')
              return 'image/*'
          }),
          L = () => {
            const te = m(
              noe,
              {
                key: 'arco-upload-button',
                disabled: _.value,
                draggable: e.draggable,
                listType: e.listType,
                uploadFiles: j,
                multiple: e.multiple,
                directory: e.directory,
                tip: e.tip,
                hide:
                  !e.showUploadButton ||
                  (w.value &&
                    !(
                      Ht(e.showUploadButton) &&
                      e.showUploadButton.showOnExceedLimit
                    )),
                accept: V.value,
                onButtonClick: e.onButtonClick,
              },
              { default: n['upload-button'] }
            )
            return e.tip && e.listType !== 'picture-card' && !e.draggable
              ? m('span', null, [te, m('div', { class: `${g}-tip` }, [e.tip])])
              : te
          },
          W = J(!1),
          Y = J(0),
          U = (te) => {
            Y.value = te
          },
          le = (te) => {
            W.value = te
          },
          q = C(() => y.value.filter((te) => !!te.url).map((te) => te.url))
        return {
          prefixCls: g,
          render: () =>
            e.showFileList
              ? m(
                  'div',
                  {
                    class: [`${g}-wrapper`, `${g}-wrapper-type-${e.listType}`],
                  },
                  [
                    e.imagePreview &&
                      q.value.length > 0 &&
                      m(
                        hd,
                        {
                          srcList: q.value,
                          visible: W.value,
                          current: Y.value,
                          onChange: U,
                          onVisibleChange: le,
                        },
                        null
                      ),
                    e.listType !== 'picture-card' && e.showUploadButton && L(),
                    m(
                      Woe,
                      { fileList: y.value, listType: e.listType },
                      { 'upload-button': L, 'upload-item': n['upload-item'] }
                    ),
                  ]
                )
              : e.showUploadButton && L(),
          innerSubmit: k,
          innerAbort: T,
          innerUpdateFile: A,
          innerUpload: j,
        }
      },
      methods: {
        submit(e) {
          return this.innerSubmit(e)
        },
        abort(e) {
          return this.innerAbort(e)
        },
        updateFile(e, t) {
          return this.innerUpdateFile(e, t)
        },
        upload(e) {
          return this.innerUpload(e)
        },
      },
      render() {
        return this.render()
      },
    })
  const Joe = Object.assign(v1, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + v1.name, v1)
    },
  })
  var m1 = ce({
    name: 'OverflowList',
    props: {
      min: { type: Number, default: 0 },
      margin: { type: Number, default: 8 },
      from: { type: String, default: 'end' },
    },
    emits: { change: (e) => !0 },
    setup(e, { emit: t, slots: n }) {
      const r = ye('overflow-list'),
        i = J(),
        o = J(),
        a = J(),
        s = {},
        l = [],
        c = J(0),
        d = J(0),
        h = C(() => d.value > 0),
        p = J(0),
        v = C(() => e.from === 'start')
      pt(c, (b, y) => {
        d.value > 0 && ((d.value += b - y), d.value < 0 && (d.value = 0))
      }),
        pt(d, (b) => {
          t('change', b)
        })
      const g = () => {
        var b, y, M
        if (i.value && s.value && a.value) {
          const x = a.value.offsetWidth
          if (x > 1 && (d.value === 0 || x < p.value)) return
          for (let A = 0; A < s.value.length; A++) {
            const F = s.value[A].el
            F && F.offsetWidth && (l[A] = F.offsetWidth + e.margin)
          }
          let w =
            i.value.clientWidth -
            ((y = (b = o.value) == null ? void 0 : b.offsetWidth) != null
              ? y
              : 0) -
            (v.value ? e.margin : 0)
          const E = v.value ? Ute(l) : l
          let P = 0
          for (let A = 0; A < E.length; A++) {
            const F = (M = E[A]) != null ? M : 0
            if (F < w - 1) (w -= F), (P += 1)
            else {
              p.value = F
              break
            }
          }
          P < e.min && e.min < c.value && (P = e.min),
            d.value !== c.value - P && (d.value = c.value - P)
        }
      }
      pt(h, () => g(), { flush: 'post' }),
        Wt(() => {
          a.value && a.value.offsetWidth < 1 && g()
        })
      const _ = () => {
        var b, y
        const M = v.value ? { marginRight: `${e.margin}px` } : void 0
        return m('div', { ref: o, class: `${r}-overflow`, style: M }, [
          (y =
            (b = n.overflow) == null
              ? void 0
              : b.call(n, { number: d.value })) != null
            ? y
            : m(K_, null, { default: () => [Lt('+'), d.value] }),
        ])
      }
      return () => {
        var b, y
        ;(s.value = ea((b = n.default) == null ? void 0 : b.call(n))),
          c.value !== s.value.length &&
            ((c.value = s.value.length), (l.length = c.value))
        let M = s.value
        d.value > 0 &&
          (M = v.value ? s.value.slice(d.value) : s.value.slice(0, -d.value))
        const x = d.value === 0 || v.value ? M.length - 1 : M.length
        for (let w = 0; w < x; w++)
          M[w].props = Fe((y = M[w].props) != null ? y : {}, {
            style: { marginRight: `${e.margin}px` },
          })
        return m('div', { ref: i, class: r }, [
          v.value && d.value > 0 && _(),
          M,
          !v.value && d.value > 0 && _(),
          m(
            ks,
            { onResize: g },
            {
              default: () => [m('div', { ref: a, class: `${r}-spacer` }, null)],
            }
          ),
        ])
      }
    },
  })
  const Qoe = Object.assign(m1, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + m1.name, m1)
    },
  })
  var eae = Object.defineProperty,
    tae = Object.defineProperties,
    nae = Object.getOwnPropertyDescriptors,
    c3 = Object.getOwnPropertySymbols,
    rae = Object.prototype.hasOwnProperty,
    iae = Object.prototype.propertyIsEnumerable,
    d3 = (e, t, n) =>
      t in e
        ? eae(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    oae = (e, t) => {
      for (var n in t || (t = {})) rae.call(t, n) && d3(e, n, t[n])
      if (c3) for (var n of c3(t)) iae.call(t, n) && d3(e, n, t[n])
      return e
    },
    aae = (e, t) => tae(e, nae(t))
  function sae(e) {
    return (
      typeof e == 'function' ||
      (Object.prototype.toString.call(e) === '[object Object]' && !An(e))
    )
  }
  var lae = ce({
      name: 'TreeSelectPanel',
      components: { Tree: Ub },
      props: {
        treeProps: { type: Object, default: () => ({}) },
        selectedKeys: { type: Array },
        showCheckable: { type: Boolean },
        treeSlots: { type: Object, default: () => ({}) },
        scrollbar: { type: [Boolean, Object], default: !0 },
      },
      emits: ['change'],
      setup(e, { emit: t }) {
        const {
            showCheckable: n,
            selectedKeys: r,
            treeProps: i,
            scrollbar: o,
          } = tt(e),
          { displayScrollbar: a, scrollbarProps: s } = qv(o),
          l = ye('tree-select'),
          c = J(),
          d = C(() =>
            aae(oae({}, i.value), {
              disableSelectActionOnly: !0,
              checkedKeys: n.value ? r.value : [],
              selectedKeys: n.value ? [] : r.value,
            })
          ),
          h = (g, _) => {
            var b, y
            n.value
              ? (y = (b = c.value) == null ? void 0 : b.toggleCheck) == null ||
                y.call(b, g[0], _)
              : t('change', g)
          },
          p = (g) => {
            t('change', g)
          },
          v = () =>
            m(
              Ub,
              Fe({ ref: c }, d.value, { onSelect: h, onCheck: p }),
              e.treeSlots
            )
        return () => {
          if (a.value) {
            let g
            return m(
              ia,
              Fe({ class: `${l}-tree-wrapper` }, s.value),
              sae((g = v())) ? g : { default: () => [g] }
            )
          }
          return m('div', { class: `${l}-tree-wrapper` }, [v()])
        }
      },
    }),
    uae = Object.defineProperty,
    cae = Object.defineProperties,
    dae = Object.getOwnPropertyDescriptors,
    f3 = Object.getOwnPropertySymbols,
    fae = Object.prototype.hasOwnProperty,
    hae = Object.prototype.propertyIsEnumerable,
    h3 = (e, t, n) =>
      t in e
        ? uae(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    p3 = (e, t) => {
      for (var n in t || (t = {})) fae.call(t, n) && h3(e, n, t[n])
      if (f3) for (var n of f3(t)) hae.call(t, n) && h3(e, n, t[n])
      return e
    },
    pae = (e, t) => cae(e, dae(t))
  function MS(e) {
    return Ht(e)
  }
  function jA(e) {
    return e != null && e !== ''
  }
  function ES(e) {
    return MS(e) ? e.value : e
  }
  function vae(e) {
    return MS(e) ? e.label : void 0
  }
  function v3(e) {
    const t = ES(e)
    return jA(t)
  }
  function m3(e) {
    return e.map(ES).filter(jA)
  }
  function mae(e) {
    var t
    const {
      defaultValue: n,
      modelValue: r,
      key2TreeNode: i,
      multiple: o,
      treeCheckable: a,
      fallbackOption: s,
      fieldNames: l,
    } = tt(e)
    function c(w) {
      const E = (Ft(w) ? w : [w]).filter(v3)
      return (o != null && o.value) || (a != null && a.value)
        ? E
        : E.slice(0, 1)
    }
    function d(w, E) {
      const P = [],
        A = w ? w.filter(v3) : []
      if (A.length) {
        const F = new Map()
        E == null ||
          E.forEach((T) => {
            F.set(T.value, T)
          }),
          A.forEach((T) => {
            var k, R, j, N, I
            const B = ES(T),
              V = F.get(B),
              L = i.value.get(B)
            let W = null
            const Y =
              ((k = l == null ? void 0 : l.value) == null ? void 0 : k.title) ||
              'title'
            if (!L) {
              const U = xt(s == null ? void 0 : s.value)
                ? s == null
                  ? void 0
                  : s.value(B)
                : s == null
                ? void 0
                : s.value
              if (U === !1) return
              Ht(U) && (W = U)
            }
            P.push(
              pae(p3(p3({}, MS(T) ? T : {}), V || {}), {
                value: B,
                label:
                  (I =
                    (N =
                      (j =
                        (R = vae(T)) != null
                          ? R
                          : L == null
                          ? void 0
                          : L.title) != null
                        ? j
                        : V == null
                        ? void 0
                        : V.label) != null
                      ? N
                      : W == null
                      ? void 0
                      : W[Y]) != null
                    ? I
                    : B,
              })
            )
          })
      }
      return P
    }
    const h = J(),
      p = J()
    pr(() => {
      var w
      const E = (r == null ? void 0 : r.value) !== void 0,
        P = c((w = r == null ? void 0 : r.value) != null ? w : []),
        A = m3(P)
      ;(p.value = E ? d(A, d(P)) : void 0), (h.value = E ? A : void 0)
    })
    const v = c((t = n == null ? void 0 : n.value) != null ? t : []),
      g = m3(v),
      _ = d(g, d(v)),
      b = J(g || []),
      y = J(_)
    pt(b, () => {
      y.value = d(b.value, _)
    }),
      pt([h, p], ([w, E]) => {
        ;(b.value = w || []), (y.value = E || [])
      })
    const M = C(() => {
        var w
        return (w = h.value) != null ? w : b.value
      }),
      x = C(() => {
        var w
        return (w = p.value) != null ? w : y.value
      })
    return {
      selectedKeys: M,
      selectedValue: x,
      setLocalSelectedKeys(w) {
        b.value = w
      },
      localSelectedKeys: b,
      localSelectedValue: y,
    }
  }
  function gae(e) {
    const {
        searchValue: t,
        flattenTreeData: n,
        filterMethod: r,
        disableFilter: i,
        fieldNames: o,
      } = tt(e),
      a = C(() => {
        var g
        return ((g = o.value) == null ? void 0 : g.key) || 'key'
      }),
      s = (g, _) => {
        const b = _[a.value]
        return !Mt(b) && String(b).indexOf(g) > -1
      },
      l = C(() => (r == null ? void 0 : r.value) || s),
      c = J(),
      d = C(() => !!t.value),
      h = C(
        () =>
          !(i != null && i.value) && d.value && c.value && c.value.size === 0
      ),
      p = C(() =>
        i != null && i.value
          ? void 0
          : (g) => {
              var _, b
              if (!d.value) return !0
              const y = g[a.value]
              return (b = (_ = c.value) == null ? void 0 : _.has(y || '')) !=
                null
                ? b
                : !1
            }
      ),
      v = q_((g, _) => {
        const b = g.filter((M) => l.value(_, M.treeNodeData)),
          y = new Set()
        b.forEach((M) => {
          y.add(M.key),
            M.pathParentKeys.forEach((x) => {
              y.add(x)
            })
        }),
          (c.value = y)
      }, 100)
    return (
      pr(() => {
        i != null && i.value ? (c.value = void 0) : v(n.value, t.value)
      }),
      { isEmptyFilterResult: h, filterTreeNode: p }
    )
  }
  function yae(e, t) {
    const n = `${t}-slot-`
    return Object.keys(e).reduce((i, o) => {
      if (o.startsWith(n)) {
        const a = o.slice(n.length)
        a && (i[a] = e[o])
      }
      return i
    }, {})
  }
  var bae = Object.defineProperty,
    _ae = Object.defineProperties,
    Sae = Object.getOwnPropertyDescriptors,
    g3 = Object.getOwnPropertySymbols,
    Cae = Object.prototype.hasOwnProperty,
    wae = Object.prototype.propertyIsEnumerable,
    y3 = (e, t, n) =>
      t in e
        ? bae(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    GA = (e, t) => {
      for (var n in t || (t = {})) Cae.call(t, n) && y3(e, n, t[n])
      if (g3) for (var n of g3(t)) wae.call(t, n) && y3(e, n, t[n])
      return e
    },
    KA = (e, t) => _ae(e, Sae(t))
  const xae = ce({
    name: 'TreeSelect',
    components: {
      Trigger: Mr,
      SelectView: sv,
      Panel: lae,
      Empty: Ls,
      Spin: Do,
    },
    inheritAttrs: !1,
    props: {
      disabled: { type: Boolean },
      loading: { type: Boolean },
      error: { type: Boolean },
      size: { type: String },
      border: { type: Boolean },
      allowSearch: { type: [Boolean, Object], default: (e) => !!e.multiple },
      allowClear: { type: Boolean },
      placeholder: { type: String },
      maxTagCount: { type: Number },
      multiple: { type: Boolean },
      defaultValue: { type: [String, Number, Array, Object] },
      modelValue: { type: [String, Number, Array, Object] },
      fieldNames: { type: Object },
      data: { type: Array, default: () => [] },
      labelInValue: { type: Boolean },
      treeCheckable: { type: Boolean },
      treeCheckStrictly: { type: Boolean },
      treeCheckedStrategy: { type: String, default: 'all' },
      treeProps: { type: Object },
      triggerProps: { type: Object },
      popupVisible: { type: Boolean, default: void 0 },
      defaultPopupVisible: { type: Boolean },
      dropdownStyle: { type: Object },
      dropdownClassName: { type: [String, Array] },
      filterTreeNode: { type: Function },
      loadMore: { type: Function },
      disableFilter: { type: Boolean },
      popupContainer: { type: [String, Object] },
      fallbackOption: { type: [Boolean, Function], default: !0 },
      selectable: { type: [Boolean, String, Function], default: !0 },
      scrollbar: { type: [Boolean, Object], default: !0 },
    },
    emits: {
      change: (e) => !0,
      'update:modelValue': (e) => !0,
      'popup-visible-change': (e) => !0,
      'update:popupVisible': (e) => !0,
      search: (e) => !0,
      clear: () => !0,
    },
    setup(e, { emit: t, slots: n }) {
      var r, i, o
      const {
          defaultValue: a,
          modelValue: s,
          multiple: l,
          popupVisible: c,
          defaultPopupVisible: d,
          treeCheckable: h,
          treeCheckStrictly: p,
          data: v,
          fieldNames: g,
          disabled: _,
          labelInValue: b,
          filterTreeNode: y,
          disableFilter: M,
          dropdownStyle: x,
          treeProps: w,
          fallbackOption: E,
          selectable: P,
          dropdownClassName: A,
        } = tt(e),
        { mergedDisabled: F, eventHandlers: T } = Rn({ disabled: _ }),
        k = ye('tree-select'),
        R = zt(di, void 0),
        j =
          (o =
            (i = R == null ? void 0 : (r = R.slots).empty) == null
              ? void 0
              : i.call(r, { component: 'tree-select' })) == null
            ? void 0
            : o[0],
        N = C(() => l.value || h.value),
        I = (re, pe) => {
          var we
          return P.value === 'leaf'
            ? pe.isLeaf
            : xt(P.value)
            ? P.value(re, pe)
            : (we = P.value) != null
            ? we
            : !1
        },
        B = C(() => (h.value ? I : !1)),
        V = C(() => Ht(e.allowSearch) && !!e.allowSearch.retainInputValue),
        { flattenTreeData: L, key2TreeNode: W } = VA(
          Je({ treeData: v, fieldNames: g, selectable: I, checkable: B })
        ),
        {
          selectedKeys: Y,
          selectedValue: U,
          setLocalSelectedKeys: le,
          localSelectedKeys: q,
          localSelectedValue: oe,
        } = mae(
          Je({
            defaultValue: a,
            modelValue: s,
            key2TreeNode: W,
            multiple: l,
            treeCheckable: h,
            treeCheckStrictly: p,
            fallbackOption: E,
            fieldNames: g,
          })
        )
      function te(re) {
        return h.value ? bl(re) : Db(re)
      }
      const ue = C(() =>
          Mt(U.value)
            ? []
            : N.value && !F.value
            ? U.value.map((re) => {
                const pe = W.value.get(re.value)
                return KA(GA({}, re), { closable: !pe || te(pe) })
              })
            : U.value
        ),
        me = (re) => {
          le(re),
            hn(() => {
              var pe, we
              const $e = (b.value ? oe.value : q.value) || [],
                Ae = N.value ? $e : $e[0]
              t('update:modelValue', Ae),
                t('change', Ae),
                (we = (pe = T.value) == null ? void 0 : pe.onChange) == null ||
                  we.call(pe)
            })
        },
        Re = J(''),
        [qe, Ve] = Er(d.value, Je({ value: c })),
        nt = (re) => {
          re !== qe.value &&
            (Ve(re),
            t('popup-visible-change', re),
            t('update:popupVisible', re)),
            re || (z.value && z.value.blur && z.value.blur())
        },
        { isEmptyFilterResult: We, filterTreeNode: D } = gae(
          Je({
            searchValue: Re,
            flattenTreeData: L,
            filterMethod: y,
            disableFilter: M,
            fieldNames: g,
          })
        ),
        G = C(() => !L.value.length || We.value),
        z = J(),
        ie = C(() => {
          var re
          return [
            (x == null ? void 0 : x.value) || {},
            (re = w == null ? void 0 : w.value) != null && re.virtualListProps
              ? { 'max-height': 'unset' }
              : {},
          ]
        })
      return {
        refSelectView: z,
        prefixCls: k,
        TreeSelectEmpty: j,
        selectedValue: U,
        selectedKeys: Y,
        mergedDisabled: F,
        searchValue: Re,
        panelVisible: qe,
        isEmpty: G,
        computedFilterTreeNode: D,
        isMultiple: N,
        selectViewValue: ue,
        computedDropdownStyle: ie,
        onSearchValueChange(re) {
          re !== Re.value && (nt(!0), (Re.value = re), t('search', re))
        },
        onSelectChange(re) {
          me(re), (Re.value = ''), N.value || nt(!1)
        },
        onVisibleChange: nt,
        onInnerClear() {
          me([]), t('clear')
        },
        pickSubCompSlots: yae,
        isSelectable: I,
        isCheckable: B,
        onBlur: () => {
          !V.value && Re.value && (Re.value = '')
        },
        onItemRemove(re) {
          if (F.value) return
          const pe = W.value.get(re)
          if (h.value && pe) {
            if (te(pe)) {
              const [we] = Fb({
                node: pe,
                checked: !1,
                checkedKeys: Y.value,
                indeterminateKeys: [],
                checkStrictly: p.value,
              })
              me(we)
            }
          } else {
            const we = Y.value.filter(($e) => $e !== re)
            me(we)
          }
        },
      }
    },
  })
  function Mae(e, t, n, r, i, o) {
    const a = ge('SelectView'),
      s = ge('Spin'),
      l = ge('Panel'),
      c = ge('Trigger')
    return (
      O(),
      Ee(
        c,
        Fe(
          {
            class: `${e.prefixCls}-trigger`,
            'auto-fit-popup-min-width': '',
            trigger: 'click',
            position: 'bl',
            'popup-offset': 4,
            'animation-name': 'slide-dynamic-origin',
            'prevent-focus': !0,
          },
          e.triggerProps,
          {
            disabled: e.mergedDisabled,
            'popup-visible': e.panelVisible,
            'popup-container': e.popupContainer,
            'click-to-close': !e.allowSearch,
            'auto-fit-transform-origin': '',
            onPopupVisibleChange: e.onVisibleChange,
          }
        ),
        {
          content: ze(() => [
            Se(
              'div',
              {
                class: H([
                  `${e.prefixCls}-popup`,
                  {
                    [`${e.prefixCls}-has-header`]: !!e.$slots.header,
                    [`${e.prefixCls}-has-footer`]: !!e.$slots.footer,
                  },
                  e.dropdownClassName,
                ]),
                style: at(e.computedDropdownStyle),
              },
              [
                e.$slots.header && !e.isEmpty
                  ? (O(),
                    Z(
                      'div',
                      { key: 0, class: H(`${e.prefixCls}-header`) },
                      [ve(e.$slots, 'header')],
                      2
                    ))
                  : Ce('v-if', !0),
                e.loading
                  ? ve(e.$slots, 'loader', { key: 1 }, () => [m(s)])
                  : e.isEmpty
                  ? ve(e.$slots, 'empty', { key: 2 }, () => [
                      (O(),
                      Ee(xi(e.TreeSelectEmpty ? e.TreeSelectEmpty : 'Empty'))),
                    ])
                  : (O(),
                    Ee(
                      l,
                      {
                        key: 3,
                        'selected-keys': e.selectedKeys,
                        'show-checkable': e.treeCheckable,
                        scrollbar: e.scrollbar,
                        'tree-props': KA(
                          GA(
                            {
                              actionOnNodeClick:
                                e.selectable === 'leaf' ? 'expand' : void 0,
                              blockNode: !0,
                            },
                            e.treeProps
                          ),
                          {
                            data: e.data,
                            checkStrictly: e.treeCheckStrictly,
                            checkedStrategy: e.treeCheckedStrategy,
                            fieldNames: e.fieldNames,
                            multiple: e.multiple,
                            loadMore: e.loadMore,
                            filterTreeNode: e.computedFilterTreeNode,
                            size: e.size,
                            checkable: e.isCheckable,
                            selectable: e.isSelectable,
                            searchValue: e.searchValue,
                          }
                        ),
                        'tree-slots': e.pickSubCompSlots(e.$slots, 'tree'),
                        onChange: e.onSelectChange,
                      },
                      null,
                      8,
                      [
                        'selected-keys',
                        'show-checkable',
                        'scrollbar',
                        'tree-props',
                        'tree-slots',
                        'onChange',
                      ]
                    )),
                e.$slots.footer && !e.isEmpty
                  ? (O(),
                    Z(
                      'div',
                      { key: 4, class: H(`${e.prefixCls}-footer`) },
                      [ve(e.$slots, 'footer')],
                      2
                    ))
                  : Ce('v-if', !0),
              ],
              6
            ),
          ]),
          default: ze(() => [
            ve(e.$slots, 'trigger', {}, () => [
              m(
                a,
                Fe(
                  {
                    ref: 'refSelectView',
                    'model-value': e.selectViewValue,
                    'input-value': e.searchValue,
                    'allow-search': !!e.allowSearch,
                    'allow-clear': e.allowClear,
                    loading: e.loading,
                    size: e.size,
                    'max-tag-count': e.maxTagCount,
                    disabled: e.mergedDisabled,
                    opened: e.panelVisible,
                    error: e.error,
                    border: e.border,
                    placeholder: e.placeholder,
                    multiple: e.isMultiple,
                  },
                  e.$attrs,
                  {
                    onInputValueChange: e.onSearchValueChange,
                    onClear: e.onInnerClear,
                    onRemove: e.onItemRemove,
                    onBlur: e.onBlur,
                  }
                ),
                Nn({ _: 2 }, [
                  e.$slots.prefix
                    ? { name: 'prefix', fn: ze(() => [ve(e.$slots, 'prefix')]) }
                    : void 0,
                  e.$slots.label
                    ? {
                        name: 'label',
                        fn: ze((d) => [ve(e.$slots, 'label', En(Rr(d)))]),
                      }
                    : void 0,
                ]),
                1040,
                [
                  'model-value',
                  'input-value',
                  'allow-search',
                  'allow-clear',
                  'loading',
                  'size',
                  'max-tag-count',
                  'disabled',
                  'opened',
                  'error',
                  'border',
                  'placeholder',
                  'multiple',
                  'onInputValueChange',
                  'onClear',
                  'onRemove',
                  'onBlur',
                ]
              ),
            ]),
          ]),
          _: 3,
        },
        16,
        [
          'class',
          'disabled',
          'popup-visible',
          'popup-container',
          'click-to-close',
          'onPopupVisibleChange',
        ]
      )
    )
  }
  var g1 = Te(xae, [['render', Mae]])
  const Eae = Object.assign(g1, {
    install: (e, t) => {
      Rt(e, t)
      const n = It(t)
      e.component(n + g1.name, g1)
    },
  })
  var Pae = Object.defineProperty,
    Tae = Object.defineProperties,
    kae = Object.getOwnPropertyDescriptors,
    b3 = Object.getOwnPropertySymbols,
    Aae = Object.prototype.hasOwnProperty,
    $ae = Object.prototype.propertyIsEnumerable,
    _3 = (e, t, n) =>
      t in e
        ? Pae(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n,
          })
        : (e[t] = n),
    Oae = (e, t) => {
      for (var n in t || (t = {})) Aae.call(t, n) && _3(e, n, t[n])
      if (b3) for (var n of b3(t)) $ae.call(t, n) && _3(e, n, t[n])
      return e
    },
    Lae = (e, t) => Tae(e, kae(t))
  const Hb = {
      Button: Yr,
      Link: zk,
      Typography: Gie,
      Divider: WG,
      Grid: td,
      Layout: UY,
      Space: ste,
      Avatar: bz,
      Badge: Dz,
      Calendar: gk,
      Card: zU,
      Carousel: oH,
      Collapse: IH,
      Comment: jH,
      Descriptions: HG,
      Empty: Ls,
      Image: GX,
      Scrollbar: ia,
      List: vA,
      Popover: H_,
      Statistic: yte,
      Table: $ne,
      Tabs: Kne,
      Tag: K_,
      Timeline: mre,
      Tooltip: uo,
      AutoComplete: iz,
      Cascader: bH,
      Checkbox: Lo,
      DatePicker: kG,
      Form: pq,
      Input: ic,
      InputNumber: uS,
      InputTag: vk,
      Mention: gZ,
      Radio: Ku,
      Rate: yee,
      Select: lv,
      Slider: ate,
      Switch: Pte,
      Textarea: mA,
      TimePicker: lre,
      Transfer: Tre,
      Tree: Ub,
      Upload: Joe,
      TreeSelect: Eae,
      Alter: O9,
      Drawer: Eb,
      Message: Lb,
      Modal: Ib,
      Notification: Rb,
      Popconfirm: sQ,
      Progress: MA,
      Result: Iee,
      Spin: Do,
      Skeleton: Vee,
      Breadcrumb: gV,
      Dropdown: Z4,
      Menu: yJ,
      PageHeader: iQ,
      Pagination: hS,
      Steps: wte,
      Affix: n9,
      Anchor: iF,
      BackTop: kz,
      ConfigProvider: qH,
      ResizeBox: fA,
      Trigger: Mr,
      Split: dte,
      Icon: bq,
      OverflowList: Qoe,
    },
    Iae = (e, t) => {
      for (const n of Object.keys(Hb)) e.use(Hb[n], t)
    },
    Rae = Lae(Oae({}, Hb), {
      AnchorLink: qh,
      AvatarGroup: np,
      BreadcrumbItem: ud,
      ButtonGroup: ld,
      Calendar: gk,
      CardMeta: up,
      CardGrid: cp,
      CarouselItem: dp,
      CascaderPanel: fp,
      CheckboxGroup: ep,
      CollapseItem: hp,
      DescriptionsItem: Sp,
      WeekPicker: mp,
      MonthPicker: gp,
      YearPicker: yp,
      QuarterPicker: bp,
      RangePicker: _p,
      Doption: Du,
      Dgroup: ip,
      Dsubmenu: op,
      DropdownButton: ap,
      FormItem: xp,
      Row: dd,
      Col: fd,
      GridItem: wp,
      ImagePreview: Nu,
      ImagePreviewGroup: hd,
      InputGroup: Zh,
      InputSearch: Xh,
      InputPassword: Yh,
      LayoutHeader: Ep,
      LayoutContent: Pp,
      LayoutFooter: Tp,
      LayoutSider: kp,
      ListItem: Ap,
      ListItemMeta: $p,
      MenuItem: Op,
      MenuItemGroup: Lp,
      SubMenu: pd,
      RadioGroup: lp,
      Option: pl,
      Optgroup: cd,
      SkeletonLine: Dp,
      SkeletonShape: Np,
      Countdown: Bp,
      Step: Fp,
      Thead: md,
      Td: bs,
      Th: yd,
      Tr: $a,
      Tbody: gd,
      TableColumn: zp,
      TabPane: Vp,
      TimelineItem: Fu,
      TypographyParagraph: Up,
      TypographyTitle: Hp,
      TypographyText: Wp,
      install: Iae,
      addI18nMessages: hB,
      useLocale: pB,
      getLocale: vB,
      useFormItem: Rn,
    })
  /**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   */ const PS = '153',
    iu = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    ou = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    Dae = 0,
    S3 = 1,
    Nae = 2,
    qA = 1,
    Bae = 2,
    ka = 3,
    $s = 0,
    Mi = 1,
    Oa = 2,
    Ms = 0,
    zu = 1,
    C3 = 2,
    w3 = 3,
    x3 = 4,
    Fae = 5,
    wu = 100,
    zae = 101,
    Vae = 102,
    M3 = 103,
    E3 = 104,
    Uae = 200,
    Hae = 201,
    Wae = 202,
    jae = 203,
    XA = 204,
    YA = 205,
    Gae = 206,
    Kae = 207,
    qae = 208,
    Xae = 209,
    Yae = 210,
    Zae = 0,
    Jae = 1,
    Qae = 2,
    Wb = 3,
    ese = 4,
    tse = 5,
    nse = 6,
    rse = 7,
    nf = 0,
    ise = 1,
    ose = 2,
    Ba = 0,
    ase = 1,
    sse = 2,
    lse = 3,
    use = 4,
    cse = 5,
    ZA = 300,
    Yu = 301,
    Zu = 302,
    jb = 303,
    Gb = 304,
    dm = 306,
    Rd = 1e3,
    To = 1001,
    Kb = 1002,
    li = 1003,
    P3 = 1004,
    y1 = 1005,
    eo = 1006,
    dse = 1007,
    Dd = 1008,
    Es = 1009,
    fse = 1010,
    hse = 1011,
    TS = 1012,
    JA = 1013,
    _s = 1014,
    Ss = 1015,
    Nd = 1016,
    QA = 1017,
    e$ = 1018,
    _l = 1020,
    pse = 1021,
    ko = 1023,
    vse = 1024,
    mse = 1025,
    Sl = 1026,
    Ju = 1027,
    gse = 1028,
    t$ = 1029,
    yse = 1030,
    n$ = 1031,
    r$ = 1033,
    b1 = 33776,
    _1 = 33777,
    S1 = 33778,
    C1 = 33779,
    T3 = 35840,
    k3 = 35841,
    A3 = 35842,
    $3 = 35843,
    bse = 36196,
    O3 = 37492,
    L3 = 37496,
    I3 = 37808,
    R3 = 37809,
    D3 = 37810,
    N3 = 37811,
    B3 = 37812,
    F3 = 37813,
    z3 = 37814,
    V3 = 37815,
    U3 = 37816,
    H3 = 37817,
    W3 = 37818,
    j3 = 37819,
    G3 = 37820,
    K3 = 37821,
    w1 = 36492,
    _se = 36283,
    q3 = 36284,
    X3 = 36285,
    Y3 = 36286,
    i$ = 3e3,
    Fa = 3001,
    Sse = 3200,
    Cse = 3201,
    kS = 0,
    wse = 1,
    Cl = '',
    rn = 'srgb',
    aa = 'srgb-linear',
    o$ = 'display-p3',
    x1 = 7680,
    xse = 519,
    Mse = 512,
    Ese = 513,
    Pse = 514,
    Tse = 515,
    kse = 516,
    Ase = 517,
    $se = 518,
    Ose = 519,
    qb = 35044,
    Z3 = '300 es',
    Xb = 1035,
    Ia = 2e3,
    Sv = 2001
  class Rl {
    addEventListener(t, n) {
      this._listeners === void 0 && (this._listeners = {})
      const r = this._listeners
      r[t] === void 0 && (r[t] = []), r[t].indexOf(n) === -1 && r[t].push(n)
    }
    hasEventListener(t, n) {
      if (this._listeners === void 0) return !1
      const r = this._listeners
      return r[t] !== void 0 && r[t].indexOf(n) !== -1
    }
    removeEventListener(t, n) {
      if (this._listeners === void 0) return
      const i = this._listeners[t]
      if (i !== void 0) {
        const o = i.indexOf(n)
        o !== -1 && i.splice(o, 1)
      }
    }
    dispatchEvent(t) {
      if (this._listeners === void 0) return
      const r = this._listeners[t.type]
      if (r !== void 0) {
        t.target = this
        const i = r.slice(0)
        for (let o = 0, a = i.length; o < a; o++) i[o].call(this, t)
        t.target = null
      }
    }
  }
  const jr = [
    '00',
    '01',
    '02',
    '03',
    '04',
    '05',
    '06',
    '07',
    '08',
    '09',
    '0a',
    '0b',
    '0c',
    '0d',
    '0e',
    '0f',
    '10',
    '11',
    '12',
    '13',
    '14',
    '15',
    '16',
    '17',
    '18',
    '19',
    '1a',
    '1b',
    '1c',
    '1d',
    '1e',
    '1f',
    '20',
    '21',
    '22',
    '23',
    '24',
    '25',
    '26',
    '27',
    '28',
    '29',
    '2a',
    '2b',
    '2c',
    '2d',
    '2e',
    '2f',
    '30',
    '31',
    '32',
    '33',
    '34',
    '35',
    '36',
    '37',
    '38',
    '39',
    '3a',
    '3b',
    '3c',
    '3d',
    '3e',
    '3f',
    '40',
    '41',
    '42',
    '43',
    '44',
    '45',
    '46',
    '47',
    '48',
    '49',
    '4a',
    '4b',
    '4c',
    '4d',
    '4e',
    '4f',
    '50',
    '51',
    '52',
    '53',
    '54',
    '55',
    '56',
    '57',
    '58',
    '59',
    '5a',
    '5b',
    '5c',
    '5d',
    '5e',
    '5f',
    '60',
    '61',
    '62',
    '63',
    '64',
    '65',
    '66',
    '67',
    '68',
    '69',
    '6a',
    '6b',
    '6c',
    '6d',
    '6e',
    '6f',
    '70',
    '71',
    '72',
    '73',
    '74',
    '75',
    '76',
    '77',
    '78',
    '79',
    '7a',
    '7b',
    '7c',
    '7d',
    '7e',
    '7f',
    '80',
    '81',
    '82',
    '83',
    '84',
    '85',
    '86',
    '87',
    '88',
    '89',
    '8a',
    '8b',
    '8c',
    '8d',
    '8e',
    '8f',
    '90',
    '91',
    '92',
    '93',
    '94',
    '95',
    '96',
    '97',
    '98',
    '99',
    '9a',
    '9b',
    '9c',
    '9d',
    '9e',
    '9f',
    'a0',
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'a6',
    'a7',
    'a8',
    'a9',
    'aa',
    'ab',
    'ac',
    'ad',
    'ae',
    'af',
    'b0',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'b6',
    'b7',
    'b8',
    'b9',
    'ba',
    'bb',
    'bc',
    'bd',
    'be',
    'bf',
    'c0',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'c6',
    'c7',
    'c8',
    'c9',
    'ca',
    'cb',
    'cc',
    'cd',
    'ce',
    'cf',
    'd0',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'd6',
    'd7',
    'd8',
    'd9',
    'da',
    'db',
    'dc',
    'dd',
    'de',
    'df',
    'e0',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'e6',
    'e7',
    'e8',
    'e9',
    'ea',
    'eb',
    'ec',
    'ed',
    'ee',
    'ef',
    'f0',
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'fa',
    'fb',
    'fc',
    'fd',
    'fe',
    'ff',
  ]
  let J3 = 1234567
  const bd = Math.PI / 180,
    Bd = 180 / Math.PI
  function ta() {
    const e = (Math.random() * 4294967295) | 0,
      t = (Math.random() * 4294967295) | 0,
      n = (Math.random() * 4294967295) | 0,
      r = (Math.random() * 4294967295) | 0
    return (
      jr[e & 255] +
      jr[(e >> 8) & 255] +
      jr[(e >> 16) & 255] +
      jr[(e >> 24) & 255] +
      '-' +
      jr[t & 255] +
      jr[(t >> 8) & 255] +
      '-' +
      jr[((t >> 16) & 15) | 64] +
      jr[(t >> 24) & 255] +
      '-' +
      jr[(n & 63) | 128] +
      jr[(n >> 8) & 255] +
      '-' +
      jr[(n >> 16) & 255] +
      jr[(n >> 24) & 255] +
      jr[r & 255] +
      jr[(r >> 8) & 255] +
      jr[(r >> 16) & 255] +
      jr[(r >> 24) & 255]
    ).toLowerCase()
  }
  function hr(e, t, n) {
    return Math.max(t, Math.min(n, e))
  }
  function AS(e, t) {
    return ((e % t) + t) % t
  }
  function Lse(e, t, n, r, i) {
    return r + ((e - t) * (i - r)) / (n - t)
  }
  function Ise(e, t, n) {
    return e !== t ? (n - e) / (t - e) : 0
  }
  function _d(e, t, n) {
    return (1 - n) * e + n * t
  }
  function Rse(e, t, n, r) {
    return _d(e, t, 1 - Math.exp(-n * r))
  }
  function Dse(e, t = 1) {
    return t - Math.abs(AS(e, t * 2) - t)
  }
  function Nse(e, t, n) {
    return e <= t
      ? 0
      : e >= n
      ? 1
      : ((e = (e - t) / (n - t)), e * e * (3 - 2 * e))
  }
  function Bse(e, t, n) {
    return e <= t
      ? 0
      : e >= n
      ? 1
      : ((e = (e - t) / (n - t)), e * e * e * (e * (e * 6 - 15) + 10))
  }
  function Fse(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1))
  }
  function zse(e, t) {
    return e + Math.random() * (t - e)
  }
  function Vse(e) {
    return e * (0.5 - Math.random())
  }
  function Use(e) {
    e !== void 0 && (J3 = e)
    let t = (J3 += 1831565813)
    return (
      (t = Math.imul(t ^ (t >>> 15), t | 1)),
      (t ^= t + Math.imul(t ^ (t >>> 7), t | 61)),
      ((t ^ (t >>> 14)) >>> 0) / 4294967296
    )
  }
  function Hse(e) {
    return e * bd
  }
  function Wse(e) {
    return e * Bd
  }
  function Yb(e) {
    return (e & (e - 1)) === 0 && e !== 0
  }
  function jse(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
  }
  function Cv(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
  }
  function Gse(e, t, n, r, i) {
    const o = Math.cos,
      a = Math.sin,
      s = o(n / 2),
      l = a(n / 2),
      c = o((t + r) / 2),
      d = a((t + r) / 2),
      h = o((t - r) / 2),
      p = a((t - r) / 2),
      v = o((r - t) / 2),
      g = a((r - t) / 2)
    switch (i) {
      case 'XYX':
        e.set(s * d, l * h, l * p, s * c)
        break
      case 'YZY':
        e.set(l * p, s * d, l * h, s * c)
        break
      case 'ZXZ':
        e.set(l * h, l * p, s * d, s * c)
        break
      case 'XZX':
        e.set(s * d, l * g, l * v, s * c)
        break
      case 'YXY':
        e.set(l * v, s * d, l * g, s * c)
        break
      case 'ZYZ':
        e.set(l * g, l * v, s * d, s * c)
        break
      default:
        console.warn(
          'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
            i
        )
    }
  }
  function Ra(e, t) {
    switch (t.constructor) {
      case Float32Array:
        return e
      case Uint32Array:
        return e / 4294967295
      case Uint16Array:
        return e / 65535
      case Uint8Array:
        return e / 255
      case Int32Array:
        return Math.max(e / 2147483647, -1)
      case Int16Array:
        return Math.max(e / 32767, -1)
      case Int8Array:
        return Math.max(e / 127, -1)
      default:
        throw new Error('Invalid component type.')
    }
  }
  function Ln(e, t) {
    switch (t.constructor) {
      case Float32Array:
        return e
      case Uint32Array:
        return Math.round(e * 4294967295)
      case Uint16Array:
        return Math.round(e * 65535)
      case Uint8Array:
        return Math.round(e * 255)
      case Int32Array:
        return Math.round(e * 2147483647)
      case Int16Array:
        return Math.round(e * 32767)
      case Int8Array:
        return Math.round(e * 127)
      default:
        throw new Error('Invalid component type.')
    }
  }
  const a$ = {
    DEG2RAD: bd,
    RAD2DEG: Bd,
    generateUUID: ta,
    clamp: hr,
    euclideanModulo: AS,
    mapLinear: Lse,
    inverseLerp: Ise,
    lerp: _d,
    damp: Rse,
    pingpong: Dse,
    smoothstep: Nse,
    smootherstep: Bse,
    randInt: Fse,
    randFloat: zse,
    randFloatSpread: Vse,
    seededRandom: Use,
    degToRad: Hse,
    radToDeg: Wse,
    isPowerOfTwo: Yb,
    ceilPowerOfTwo: jse,
    floorPowerOfTwo: Cv,
    setQuaternionFromProperEuler: Gse,
    normalize: Ln,
    denormalize: Ra,
  }
  class Ct {
    constructor(t = 0, n = 0) {
      ;(Ct.prototype.isVector2 = !0), (this.x = t), (this.y = n)
    }
    get width() {
      return this.x
    }
    set width(t) {
      this.x = t
    }
    get height() {
      return this.y
    }
    set height(t) {
      this.y = t
    }
    set(t, n) {
      return (this.x = t), (this.y = n), this
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this
    }
    setX(t) {
      return (this.x = t), this
    }
    setY(t) {
      return (this.y = t), this
    }
    setComponent(t, n) {
      switch (t) {
        case 0:
          this.x = n
          break
        case 1:
          this.y = n
          break
        default:
          throw new Error('index is out of range: ' + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x
        case 1:
          return this.y
        default:
          throw new Error('index is out of range: ' + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y)
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), this
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this
    }
    addVectors(t, n) {
      return (this.x = t.x + n.x), (this.y = t.y + n.y), this
    }
    addScaledVector(t, n) {
      return (this.x += t.x * n), (this.y += t.y * n), this
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), this
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this
    }
    subVectors(t, n) {
      return (this.x = t.x - n.x), (this.y = t.y - n.y), this
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    applyMatrix3(t) {
      const n = this.x,
        r = this.y,
        i = t.elements
      return (
        (this.x = i[0] * n + i[3] * r + i[6]),
        (this.y = i[1] * n + i[4] * r + i[7]),
        this
      )
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      )
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      )
    }
    clamp(t, n) {
      return (
        (this.x = Math.max(t.x, Math.min(n.x, this.x))),
        (this.y = Math.max(t.y, Math.min(n.y, this.y))),
        this
      )
    }
    clampScalar(t, n) {
      return (
        (this.x = Math.max(t, Math.min(n, this.x))),
        (this.y = Math.max(t, Math.min(n, this.y))),
        this
      )
    }
    clampLength(t, n) {
      const r = this.length()
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(t, Math.min(n, r))
      )
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      )
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this
    }
    dot(t) {
      return this.x * t.x + this.y * t.y
    }
    cross(t) {
      return this.x * t.y - this.y * t.x
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(t) {
      const n = Math.sqrt(this.lengthSq() * t.lengthSq())
      if (n === 0) return Math.PI / 2
      const r = this.dot(t) / n
      return Math.acos(hr(r, -1, 1))
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
      const n = this.x - t.x,
        r = this.y - t.y
      return n * n + r * r
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, n) {
      return (
        (this.x += (t.x - this.x) * n), (this.y += (t.y - this.y) * n), this
      )
    }
    lerpVectors(t, n, r) {
      return (
        (this.x = t.x + (n.x - t.x) * r), (this.y = t.y + (n.y - t.y) * r), this
      )
    }
    equals(t) {
      return t.x === this.x && t.y === this.y
    }
    fromArray(t, n = 0) {
      return (this.x = t[n]), (this.y = t[n + 1]), this
    }
    toArray(t = [], n = 0) {
      return (t[n] = this.x), (t[n + 1] = this.y), t
    }
    fromBufferAttribute(t, n) {
      return (this.x = t.getX(n)), (this.y = t.getY(n)), this
    }
    rotateAround(t, n) {
      const r = Math.cos(n),
        i = Math.sin(n),
        o = this.x - t.x,
        a = this.y - t.y
      return (
        (this.x = o * r - a * i + t.x), (this.y = o * i + a * r + t.y), this
      )
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y
    }
  }
  class cn {
    constructor(t, n, r, i, o, a, s, l, c) {
      ;(cn.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        t !== void 0 && this.set(t, n, r, i, o, a, s, l, c)
    }
    set(t, n, r, i, o, a, s, l, c) {
      const d = this.elements
      return (
        (d[0] = t),
        (d[1] = i),
        (d[2] = s),
        (d[3] = n),
        (d[4] = o),
        (d[5] = l),
        (d[6] = r),
        (d[7] = a),
        (d[8] = c),
        this
      )
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(t) {
      const n = this.elements,
        r = t.elements
      return (
        (n[0] = r[0]),
        (n[1] = r[1]),
        (n[2] = r[2]),
        (n[3] = r[3]),
        (n[4] = r[4]),
        (n[5] = r[5]),
        (n[6] = r[6]),
        (n[7] = r[7]),
        (n[8] = r[8]),
        this
      )
    }
    extractBasis(t, n, r) {
      return (
        t.setFromMatrix3Column(this, 0),
        n.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
      )
    }
    setFromMatrix4(t) {
      const n = t.elements
      return (
        this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
      )
    }
    multiply(t) {
      return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, n) {
      const r = t.elements,
        i = n.elements,
        o = this.elements,
        a = r[0],
        s = r[3],
        l = r[6],
        c = r[1],
        d = r[4],
        h = r[7],
        p = r[2],
        v = r[5],
        g = r[8],
        _ = i[0],
        b = i[3],
        y = i[6],
        M = i[1],
        x = i[4],
        w = i[7],
        E = i[2],
        P = i[5],
        A = i[8]
      return (
        (o[0] = a * _ + s * M + l * E),
        (o[3] = a * b + s * x + l * P),
        (o[6] = a * y + s * w + l * A),
        (o[1] = c * _ + d * M + h * E),
        (o[4] = c * b + d * x + h * P),
        (o[7] = c * y + d * w + h * A),
        (o[2] = p * _ + v * M + g * E),
        (o[5] = p * b + v * x + g * P),
        (o[8] = p * y + v * w + g * A),
        this
      )
    }
    multiplyScalar(t) {
      const n = this.elements
      return (
        (n[0] *= t),
        (n[3] *= t),
        (n[6] *= t),
        (n[1] *= t),
        (n[4] *= t),
        (n[7] *= t),
        (n[2] *= t),
        (n[5] *= t),
        (n[8] *= t),
        this
      )
    }
    determinant() {
      const t = this.elements,
        n = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        a = t[4],
        s = t[5],
        l = t[6],
        c = t[7],
        d = t[8]
      return (
        n * a * d - n * s * c - r * o * d + r * s * l + i * o * c - i * a * l
      )
    }
    invert() {
      const t = this.elements,
        n = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        a = t[4],
        s = t[5],
        l = t[6],
        c = t[7],
        d = t[8],
        h = d * a - s * c,
        p = s * l - d * o,
        v = c * o - a * l,
        g = n * h + r * p + i * v
      if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
      const _ = 1 / g
      return (
        (t[0] = h * _),
        (t[1] = (i * c - d * r) * _),
        (t[2] = (s * r - i * a) * _),
        (t[3] = p * _),
        (t[4] = (d * n - i * l) * _),
        (t[5] = (i * o - s * n) * _),
        (t[6] = v * _),
        (t[7] = (r * l - c * n) * _),
        (t[8] = (a * n - r * o) * _),
        this
      )
    }
    transpose() {
      let t
      const n = this.elements
      return (
        (t = n[1]),
        (n[1] = n[3]),
        (n[3] = t),
        (t = n[2]),
        (n[2] = n[6]),
        (n[6] = t),
        (t = n[5]),
        (n[5] = n[7]),
        (n[7] = t),
        this
      )
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose()
    }
    transposeIntoArray(t) {
      const n = this.elements
      return (
        (t[0] = n[0]),
        (t[1] = n[3]),
        (t[2] = n[6]),
        (t[3] = n[1]),
        (t[4] = n[4]),
        (t[5] = n[7]),
        (t[6] = n[2]),
        (t[7] = n[5]),
        (t[8] = n[8]),
        this
      )
    }
    setUvTransform(t, n, r, i, o, a, s) {
      const l = Math.cos(o),
        c = Math.sin(o)
      return (
        this.set(
          r * l,
          r * c,
          -r * (l * a + c * s) + a + t,
          -i * c,
          i * l,
          -i * (-c * a + l * s) + s + n,
          0,
          0,
          1
        ),
        this
      )
    }
    scale(t, n) {
      return this.premultiply(M1.makeScale(t, n)), this
    }
    rotate(t) {
      return this.premultiply(M1.makeRotation(-t)), this
    }
    translate(t, n) {
      return this.premultiply(M1.makeTranslation(t, n)), this
    }
    makeTranslation(t, n) {
      return (
        t.isVector2
          ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
          : this.set(1, 0, t, 0, 1, n, 0, 0, 1),
        this
      )
    }
    makeRotation(t) {
      const n = Math.cos(t),
        r = Math.sin(t)
      return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this
    }
    makeScale(t, n) {
      return this.set(t, 0, 0, 0, n, 0, 0, 0, 1), this
    }
    equals(t) {
      const n = this.elements,
        r = t.elements
      for (let i = 0; i < 9; i++) if (n[i] !== r[i]) return !1
      return !0
    }
    fromArray(t, n = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = t[r + n]
      return this
    }
    toArray(t = [], n = 0) {
      const r = this.elements
      return (
        (t[n] = r[0]),
        (t[n + 1] = r[1]),
        (t[n + 2] = r[2]),
        (t[n + 3] = r[3]),
        (t[n + 4] = r[4]),
        (t[n + 5] = r[5]),
        (t[n + 6] = r[6]),
        (t[n + 7] = r[7]),
        (t[n + 8] = r[8]),
        t
      )
    }
    clone() {
      return new this.constructor().fromArray(this.elements)
    }
  }
  const M1 = new cn()
  function s$(e) {
    for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0
    return !1
  }
  function Fd(e) {
    return document.createElementNS('http://www.w3.org/1999/xhtml', e)
  }
  const Q3 = {}
  function Sd(e) {
    e in Q3 || ((Q3[e] = !0), console.warn(e))
  }
  function Vu(e) {
    return e < 0.04045
      ? e * 0.0773993808
      : Math.pow(e * 0.9478672986 + 0.0521327014, 2.4)
  }
  function E1(e) {
    return e < 0.0031308 ? e * 12.92 : 1.055 * Math.pow(e, 0.41666) - 0.055
  }
  const Kse = new cn().fromArray([
      0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
      1e-7, 0.9105199,
    ]),
    qse = new cn().fromArray([
      1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361,
      1e-7, 0, 1.0982735,
    ])
  function Xse(e) {
    return e.convertSRGBToLinear().applyMatrix3(qse)
  }
  function Yse(e) {
    return e.applyMatrix3(Kse).convertLinearToSRGB()
  }
  const Zse = {
      [aa]: (e) => e,
      [rn]: (e) => e.convertSRGBToLinear(),
      [o$]: Xse,
    },
    Jse = { [aa]: (e) => e, [rn]: (e) => e.convertLinearToSRGB(), [o$]: Yse },
    bo = {
      enabled: !0,
      get legacyMode() {
        return (
          console.warn(
            'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
          ),
          !this.enabled
        )
      },
      set legacyMode(e) {
        console.warn(
          'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
        ),
          (this.enabled = !e)
      },
      get workingColorSpace() {
        return aa
      },
      set workingColorSpace(e) {
        console.warn('THREE.ColorManagement: .workingColorSpace is readonly.')
      },
      convert: function (e, t, n) {
        if (this.enabled === !1 || t === n || !t || !n) return e
        const r = Zse[t],
          i = Jse[n]
        if (r === void 0 || i === void 0)
          throw new Error(
            `Unsupported color space conversion, "${t}" to "${n}".`
          )
        return i(r(e))
      },
      fromWorkingColorSpace: function (e, t) {
        return this.convert(e, this.workingColorSpace, t)
      },
      toWorkingColorSpace: function (e, t) {
        return this.convert(e, t, this.workingColorSpace)
      },
    }
  let au
  class l$ {
    static getDataURL(t) {
      if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > 'u') return t.src
      let n
      if (t instanceof HTMLCanvasElement) n = t
      else {
        au === void 0 && (au = Fd('canvas')),
          (au.width = t.width),
          (au.height = t.height)
        const r = au.getContext('2d')
        t instanceof ImageData
          ? r.putImageData(t, 0, 0)
          : r.drawImage(t, 0, 0, t.width, t.height),
          (n = au)
      }
      return n.width > 2048 || n.height > 2048
        ? (console.warn(
            'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
            t
          ),
          n.toDataURL('image/jpeg', 0.6))
        : n.toDataURL('image/png')
    }
    static sRGBToLinear(t) {
      if (
        (typeof HTMLImageElement < 'u' && t instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && t instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && t instanceof ImageBitmap)
      ) {
        const n = Fd('canvas')
        ;(n.width = t.width), (n.height = t.height)
        const r = n.getContext('2d')
        r.drawImage(t, 0, 0, t.width, t.height)
        const i = r.getImageData(0, 0, t.width, t.height),
          o = i.data
        for (let a = 0; a < o.length; a++) o[a] = Vu(o[a] / 255) * 255
        return r.putImageData(i, 0, 0), n
      } else if (t.data) {
        const n = t.data.slice(0)
        for (let r = 0; r < n.length; r++)
          n instanceof Uint8Array || n instanceof Uint8ClampedArray
            ? (n[r] = Math.floor(Vu(n[r] / 255) * 255))
            : (n[r] = Vu(n[r]))
        return { data: n, width: t.width, height: t.height }
      } else
        return (
          console.warn(
            'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
          ),
          t
        )
    }
  }
  let Qse = 0
  class u$ {
    constructor(t = null) {
      ;(this.isSource = !0),
        Object.defineProperty(this, 'id', { value: Qse++ }),
        (this.uuid = ta()),
        (this.data = t),
        (this.version = 0)
    }
    set needsUpdate(t) {
      t === !0 && this.version++
    }
    toJSON(t) {
      const n = t === void 0 || typeof t == 'string'
      if (!n && t.images[this.uuid] !== void 0) return t.images[this.uuid]
      const r = { uuid: this.uuid, url: '' },
        i = this.data
      if (i !== null) {
        let o
        if (Array.isArray(i)) {
          o = []
          for (let a = 0, s = i.length; a < s; a++)
            i[a].isDataTexture ? o.push(P1(i[a].image)) : o.push(P1(i[a]))
        } else o = P1(i)
        r.url = o
      }
      return n || (t.images[this.uuid] = r), r
    }
  }
  function P1(e) {
    return (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
      ? l$.getDataURL(e)
      : e.data
      ? {
          data: Array.from(e.data),
          width: e.width,
          height: e.height,
          type: e.data.constructor.name,
        }
      : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
  }
  let ele = 0
  class Ei extends Rl {
    constructor(
      t = Ei.DEFAULT_IMAGE,
      n = Ei.DEFAULT_MAPPING,
      r = To,
      i = To,
      o = eo,
      a = Dd,
      s = ko,
      l = Es,
      c = Ei.DEFAULT_ANISOTROPY,
      d = Cl
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, 'id', { value: ele++ }),
        (this.uuid = ta()),
        (this.name = ''),
        (this.source = new u$(t)),
        (this.mipmaps = []),
        (this.mapping = n),
        (this.channel = 0),
        (this.wrapS = r),
        (this.wrapT = i),
        (this.magFilter = o),
        (this.minFilter = a),
        (this.anisotropy = c),
        (this.format = s),
        (this.internalFormat = null),
        (this.type = l),
        (this.offset = new Ct(0, 0)),
        (this.repeat = new Ct(1, 1)),
        (this.center = new Ct(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new cn()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        typeof d == 'string'
          ? (this.colorSpace = d)
          : (Sd(
              'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
            ),
            (this.colorSpace = d === Fa ? rn : Cl)),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1)
    }
    get image() {
      return this.source.data
    }
    set image(t = null) {
      this.source.data = t
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      )
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.source = t.source),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.channel = t.channel),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.colorSpace = t.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.needsUpdate = !0),
        this
      )
    }
    toJSON(t) {
      const n = t === void 0 || typeof t == 'string'
      if (!n && t.textures[this.uuid] !== void 0) return t.textures[this.uuid]
      const r = {
        metadata: {
          version: 4.6,
          type: 'Texture',
          generator: 'Texture.toJSON',
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      }
      return (
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        n || (t.textures[this.uuid] = r),
        r
      )
    }
    dispose() {
      this.dispatchEvent({ type: 'dispose' })
    }
    transformUv(t) {
      if (this.mapping !== ZA) return t
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case Rd:
            t.x = t.x - Math.floor(t.x)
            break
          case To:
            t.x = t.x < 0 ? 0 : 1
            break
          case Kb:
            Math.abs(Math.floor(t.x) % 2) === 1
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x))
            break
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case Rd:
            t.y = t.y - Math.floor(t.y)
            break
          case To:
            t.y = t.y < 0 ? 0 : 1
            break
          case Kb:
            Math.abs(Math.floor(t.y) % 2) === 1
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y))
            break
        }
      return this.flipY && (t.y = 1 - t.y), t
    }
    set needsUpdate(t) {
      t === !0 && (this.version++, (this.source.needsUpdate = !0))
    }
    get encoding() {
      return (
        Sd(
          'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
        ),
        this.colorSpace === rn ? Fa : i$
      )
    }
    set encoding(t) {
      Sd('THREE.Texture: Property .encoding has been replaced by .colorSpace.'),
        (this.colorSpace = t === Fa ? rn : Cl)
    }
  }
  Ei.DEFAULT_IMAGE = null
  Ei.DEFAULT_MAPPING = ZA
  Ei.DEFAULT_ANISOTROPY = 1
  class Jn {
    constructor(t = 0, n = 0, r = 0, i = 1) {
      ;(Jn.prototype.isVector4 = !0),
        (this.x = t),
        (this.y = n),
        (this.z = r),
        (this.w = i)
    }
    get width() {
      return this.z
    }
    set width(t) {
      this.z = t
    }
    get height() {
      return this.w
    }
    set height(t) {
      this.w = t
    }
    set(t, n, r, i) {
      return (this.x = t), (this.y = n), (this.z = r), (this.w = i), this
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
    }
    setX(t) {
      return (this.x = t), this
    }
    setY(t) {
      return (this.y = t), this
    }
    setZ(t) {
      return (this.z = t), this
    }
    setW(t) {
      return (this.w = t), this
    }
    setComponent(t, n) {
      switch (t) {
        case 0:
          this.x = n
          break
        case 1:
          this.y = n
          break
        case 2:
          this.z = n
          break
        case 3:
          this.w = n
          break
        default:
          throw new Error('index is out of range: ' + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x
        case 1:
          return this.y
        case 2:
          return this.z
        case 3:
          return this.w
        default:
          throw new Error('index is out of range: ' + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = t.w !== void 0 ? t.w : 1),
        this
      )
    }
    add(t) {
      return (
        (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
      )
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
    }
    addVectors(t, n) {
      return (
        (this.x = t.x + n.x),
        (this.y = t.y + n.y),
        (this.z = t.z + n.z),
        (this.w = t.w + n.w),
        this
      )
    }
    addScaledVector(t, n) {
      return (
        (this.x += t.x * n),
        (this.y += t.y * n),
        (this.z += t.z * n),
        (this.w += t.w * n),
        this
      )
    }
    sub(t) {
      return (
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
      )
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
    }
    subVectors(t, n) {
      return (
        (this.x = t.x - n.x),
        (this.y = t.y - n.y),
        (this.z = t.z - n.z),
        (this.w = t.w - n.w),
        this
      )
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      )
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
    }
    applyMatrix4(t) {
      const n = this.x,
        r = this.y,
        i = this.z,
        o = this.w,
        a = t.elements
      return (
        (this.x = a[0] * n + a[4] * r + a[8] * i + a[12] * o),
        (this.y = a[1] * n + a[5] * r + a[9] * i + a[13] * o),
        (this.z = a[2] * n + a[6] * r + a[10] * i + a[14] * o),
        (this.w = a[3] * n + a[7] * r + a[11] * i + a[15] * o),
        this
      )
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w)
      const n = Math.sqrt(1 - t.w * t.w)
      return (
        n < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / n), (this.y = t.y / n), (this.z = t.z / n)),
        this
      )
    }
    setAxisAngleFromRotationMatrix(t) {
      let n, r, i, o
      const l = t.elements,
        c = l[0],
        d = l[4],
        h = l[8],
        p = l[1],
        v = l[5],
        g = l[9],
        _ = l[2],
        b = l[6],
        y = l[10]
      if (
        Math.abs(d - p) < 0.01 &&
        Math.abs(h - _) < 0.01 &&
        Math.abs(g - b) < 0.01
      ) {
        if (
          Math.abs(d + p) < 0.1 &&
          Math.abs(h + _) < 0.1 &&
          Math.abs(g + b) < 0.1 &&
          Math.abs(c + v + y - 3) < 0.1
        )
          return this.set(1, 0, 0, 0), this
        n = Math.PI
        const x = (c + 1) / 2,
          w = (v + 1) / 2,
          E = (y + 1) / 2,
          P = (d + p) / 4,
          A = (h + _) / 4,
          F = (g + b) / 4
        return (
          x > w && x > E
            ? x < 0.01
              ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
              : ((r = Math.sqrt(x)), (i = P / r), (o = A / r))
            : w > E
            ? w < 0.01
              ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
              : ((i = Math.sqrt(w)), (r = P / i), (o = F / i))
            : E < 0.01
            ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
            : ((o = Math.sqrt(E)), (r = A / o), (i = F / o)),
          this.set(r, i, o, n),
          this
        )
      }
      let M = Math.sqrt(
        (b - g) * (b - g) + (h - _) * (h - _) + (p - d) * (p - d)
      )
      return (
        Math.abs(M) < 0.001 && (M = 1),
        (this.x = (b - g) / M),
        (this.y = (h - _) / M),
        (this.z = (p - d) / M),
        (this.w = Math.acos((c + v + y - 1) / 2)),
        this
      )
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      )
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      )
    }
    clamp(t, n) {
      return (
        (this.x = Math.max(t.x, Math.min(n.x, this.x))),
        (this.y = Math.max(t.y, Math.min(n.y, this.y))),
        (this.z = Math.max(t.z, Math.min(n.z, this.z))),
        (this.w = Math.max(t.w, Math.min(n.w, this.w))),
        this
      )
    }
    clampScalar(t, n) {
      return (
        (this.x = Math.max(t, Math.min(n, this.x))),
        (this.y = Math.max(t, Math.min(n, this.y))),
        (this.z = Math.max(t, Math.min(n, this.z))),
        (this.w = Math.max(t, Math.min(n, this.w))),
        this
      )
    }
    clampLength(t, n) {
      const r = this.length()
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(t, Math.min(n, r))
      )
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      )
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      )
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      )
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      )
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      )
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      )
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      )
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      )
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, n) {
      return (
        (this.x += (t.x - this.x) * n),
        (this.y += (t.y - this.y) * n),
        (this.z += (t.z - this.z) * n),
        (this.w += (t.w - this.w) * n),
        this
      )
    }
    lerpVectors(t, n, r) {
      return (
        (this.x = t.x + (n.x - t.x) * r),
        (this.y = t.y + (n.y - t.y) * r),
        (this.z = t.z + (n.z - t.z) * r),
        (this.w = t.w + (n.w - t.w) * r),
        this
      )
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      )
    }
    fromArray(t, n = 0) {
      return (
        (this.x = t[n]),
        (this.y = t[n + 1]),
        (this.z = t[n + 2]),
        (this.w = t[n + 3]),
        this
      )
    }
    toArray(t = [], n = 0) {
      return (
        (t[n] = this.x),
        (t[n + 1] = this.y),
        (t[n + 2] = this.z),
        (t[n + 3] = this.w),
        t
      )
    }
    fromBufferAttribute(t, n) {
      return (
        (this.x = t.getX(n)),
        (this.y = t.getY(n)),
        (this.z = t.getZ(n)),
        (this.w = t.getW(n)),
        this
      )
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      )
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w
    }
  }
  class El extends Rl {
    constructor(t = 1, n = 1, r = {}) {
      super(),
        (this.isWebGLRenderTarget = !0),
        (this.width = t),
        (this.height = n),
        (this.depth = 1),
        (this.scissor = new Jn(0, 0, t, n)),
        (this.scissorTest = !1),
        (this.viewport = new Jn(0, 0, t, n))
      const i = { width: t, height: n, depth: 1 }
      r.encoding !== void 0 &&
        (Sd(
          'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.'
        ),
        (r.colorSpace = r.encoding === Fa ? rn : Cl)),
        (this.texture = new Ei(
          i,
          r.mapping,
          r.wrapS,
          r.wrapT,
          r.magFilter,
          r.minFilter,
          r.format,
          r.type,
          r.anisotropy,
          r.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps =
          r.generateMipmaps !== void 0 ? r.generateMipmaps : !1),
        (this.texture.internalFormat =
          r.internalFormat !== void 0 ? r.internalFormat : null),
        (this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : eo),
        (this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0),
        (this.stencilBuffer =
          r.stencilBuffer !== void 0 ? r.stencilBuffer : !1),
        (this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null),
        (this.samples = r.samples !== void 0 ? r.samples : 0)
    }
    setSize(t, n, r = 1) {
      ;(this.width !== t || this.height !== n || this.depth !== r) &&
        ((this.width = t),
        (this.height = n),
        (this.depth = r),
        (this.texture.image.width = t),
        (this.texture.image.height = n),
        (this.texture.image.depth = r),
        this.dispose()),
        this.viewport.set(0, 0, t, n),
        this.scissor.set(0, 0, t, n)
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      ;(this.width = t.width),
        (this.height = t.height),
        (this.depth = t.depth),
        this.scissor.copy(t.scissor),
        (this.scissorTest = t.scissorTest),
        this.viewport.copy(t.viewport),
        (this.texture = t.texture.clone()),
        (this.texture.isRenderTargetTexture = !0)
      const n = Object.assign({}, t.texture.image)
      return (
        (this.texture.source = new u$(n)),
        (this.depthBuffer = t.depthBuffer),
        (this.stencilBuffer = t.stencilBuffer),
        t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()),
        (this.samples = t.samples),
        this
      )
    }
    dispose() {
      this.dispatchEvent({ type: 'dispose' })
    }
  }
  class c$ extends Ei {
    constructor(t = null, n = 1, r = 1, i = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: t, width: n, height: r, depth: i }),
        (this.magFilter = li),
        (this.minFilter = li),
        (this.wrapR = To),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1)
    }
  }
  class tle extends Ei {
    constructor(t = null, n = 1, r = 1, i = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: t, width: n, height: r, depth: i }),
        (this.magFilter = li),
        (this.minFilter = li),
        (this.wrapR = To),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1)
    }
  }
  class Pl {
    constructor(t = 0, n = 0, r = 0, i = 1) {
      ;(this.isQuaternion = !0),
        (this._x = t),
        (this._y = n),
        (this._z = r),
        (this._w = i)
    }
    static slerpFlat(t, n, r, i, o, a, s) {
      let l = r[i + 0],
        c = r[i + 1],
        d = r[i + 2],
        h = r[i + 3]
      const p = o[a + 0],
        v = o[a + 1],
        g = o[a + 2],
        _ = o[a + 3]
      if (s === 0) {
        ;(t[n + 0] = l), (t[n + 1] = c), (t[n + 2] = d), (t[n + 3] = h)
        return
      }
      if (s === 1) {
        ;(t[n + 0] = p), (t[n + 1] = v), (t[n + 2] = g), (t[n + 3] = _)
        return
      }
      if (h !== _ || l !== p || c !== v || d !== g) {
        let b = 1 - s
        const y = l * p + c * v + d * g + h * _,
          M = y >= 0 ? 1 : -1,
          x = 1 - y * y
        if (x > Number.EPSILON) {
          const E = Math.sqrt(x),
            P = Math.atan2(E, y * M)
          ;(b = Math.sin(b * P) / E), (s = Math.sin(s * P) / E)
        }
        const w = s * M
        if (
          ((l = l * b + p * w),
          (c = c * b + v * w),
          (d = d * b + g * w),
          (h = h * b + _ * w),
          b === 1 - s)
        ) {
          const E = 1 / Math.sqrt(l * l + c * c + d * d + h * h)
          ;(l *= E), (c *= E), (d *= E), (h *= E)
        }
      }
      ;(t[n] = l), (t[n + 1] = c), (t[n + 2] = d), (t[n + 3] = h)
    }
    static multiplyQuaternionsFlat(t, n, r, i, o, a) {
      const s = r[i],
        l = r[i + 1],
        c = r[i + 2],
        d = r[i + 3],
        h = o[a],
        p = o[a + 1],
        v = o[a + 2],
        g = o[a + 3]
      return (
        (t[n] = s * g + d * h + l * v - c * p),
        (t[n + 1] = l * g + d * p + c * h - s * v),
        (t[n + 2] = c * g + d * v + s * p - l * h),
        (t[n + 3] = d * g - s * h - l * p - c * v),
        t
      )
    }
    get x() {
      return this._x
    }
    set x(t) {
      ;(this._x = t), this._onChangeCallback()
    }
    get y() {
      return this._y
    }
    set y(t) {
      ;(this._y = t), this._onChangeCallback()
    }
    get z() {
      return this._z
    }
    set z(t) {
      ;(this._z = t), this._onChangeCallback()
    }
    get w() {
      return this._w
    }
    set w(t) {
      ;(this._w = t), this._onChangeCallback()
    }
    set(t, n, r, i) {
      return (
        (this._x = t),
        (this._y = n),
        (this._z = r),
        (this._w = i),
        this._onChangeCallback(),
        this
      )
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      )
    }
    setFromEuler(t, n) {
      const r = t._x,
        i = t._y,
        o = t._z,
        a = t._order,
        s = Math.cos,
        l = Math.sin,
        c = s(r / 2),
        d = s(i / 2),
        h = s(o / 2),
        p = l(r / 2),
        v = l(i / 2),
        g = l(o / 2)
      switch (a) {
        case 'XYZ':
          ;(this._x = p * d * h + c * v * g),
            (this._y = c * v * h - p * d * g),
            (this._z = c * d * g + p * v * h),
            (this._w = c * d * h - p * v * g)
          break
        case 'YXZ':
          ;(this._x = p * d * h + c * v * g),
            (this._y = c * v * h - p * d * g),
            (this._z = c * d * g - p * v * h),
            (this._w = c * d * h + p * v * g)
          break
        case 'ZXY':
          ;(this._x = p * d * h - c * v * g),
            (this._y = c * v * h + p * d * g),
            (this._z = c * d * g + p * v * h),
            (this._w = c * d * h - p * v * g)
          break
        case 'ZYX':
          ;(this._x = p * d * h - c * v * g),
            (this._y = c * v * h + p * d * g),
            (this._z = c * d * g - p * v * h),
            (this._w = c * d * h + p * v * g)
          break
        case 'YZX':
          ;(this._x = p * d * h + c * v * g),
            (this._y = c * v * h + p * d * g),
            (this._z = c * d * g - p * v * h),
            (this._w = c * d * h - p * v * g)
          break
        case 'XZY':
          ;(this._x = p * d * h - c * v * g),
            (this._y = c * v * h - p * d * g),
            (this._z = c * d * g + p * v * h),
            (this._w = c * d * h + p * v * g)
          break
        default:
          console.warn(
            'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
              a
          )
      }
      return n !== !1 && this._onChangeCallback(), this
    }
    setFromAxisAngle(t, n) {
      const r = n / 2,
        i = Math.sin(r)
      return (
        (this._x = t.x * i),
        (this._y = t.y * i),
        (this._z = t.z * i),
        (this._w = Math.cos(r)),
        this._onChangeCallback(),
        this
      )
    }
    setFromRotationMatrix(t) {
      const n = t.elements,
        r = n[0],
        i = n[4],
        o = n[8],
        a = n[1],
        s = n[5],
        l = n[9],
        c = n[2],
        d = n[6],
        h = n[10],
        p = r + s + h
      if (p > 0) {
        const v = 0.5 / Math.sqrt(p + 1)
        ;(this._w = 0.25 / v),
          (this._x = (d - l) * v),
          (this._y = (o - c) * v),
          (this._z = (a - i) * v)
      } else if (r > s && r > h) {
        const v = 2 * Math.sqrt(1 + r - s - h)
        ;(this._w = (d - l) / v),
          (this._x = 0.25 * v),
          (this._y = (i + a) / v),
          (this._z = (o + c) / v)
      } else if (s > h) {
        const v = 2 * Math.sqrt(1 + s - r - h)
        ;(this._w = (o - c) / v),
          (this._x = (i + a) / v),
          (this._y = 0.25 * v),
          (this._z = (l + d) / v)
      } else {
        const v = 2 * Math.sqrt(1 + h - r - s)
        ;(this._w = (a - i) / v),
          (this._x = (o + c) / v),
          (this._y = (l + d) / v),
          (this._z = 0.25 * v)
      }
      return this._onChangeCallback(), this
    }
    setFromUnitVectors(t, n) {
      let r = t.dot(n) + 1
      return (
        r < Number.EPSILON
          ? ((r = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = r))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = r)))
          : ((this._x = t.y * n.z - t.z * n.y),
            (this._y = t.z * n.x - t.x * n.z),
            (this._z = t.x * n.y - t.y * n.x),
            (this._w = r)),
        this.normalize()
      )
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(hr(this.dot(t), -1, 1)))
    }
    rotateTowards(t, n) {
      const r = this.angleTo(t)
      if (r === 0) return this
      const i = Math.min(1, n / r)
      return this.slerp(t, i), this
    }
    identity() {
      return this.set(0, 0, 0, 1)
    }
    invert() {
      return this.conjugate()
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      )
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      )
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      )
    }
    normalize() {
      let t = this.length()
      return (
        t === 0
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      )
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t)
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this)
    }
    multiplyQuaternions(t, n) {
      const r = t._x,
        i = t._y,
        o = t._z,
        a = t._w,
        s = n._x,
        l = n._y,
        c = n._z,
        d = n._w
      return (
        (this._x = r * d + a * s + i * c - o * l),
        (this._y = i * d + a * l + o * s - r * c),
        (this._z = o * d + a * c + r * l - i * s),
        (this._w = a * d - r * s - i * l - o * c),
        this._onChangeCallback(),
        this
      )
    }
    slerp(t, n) {
      if (n === 0) return this
      if (n === 1) return this.copy(t)
      const r = this._x,
        i = this._y,
        o = this._z,
        a = this._w
      let s = a * t._w + r * t._x + i * t._y + o * t._z
      if (
        (s < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (s = -s))
          : this.copy(t),
        s >= 1)
      )
        return (this._w = a), (this._x = r), (this._y = i), (this._z = o), this
      const l = 1 - s * s
      if (l <= Number.EPSILON) {
        const v = 1 - n
        return (
          (this._w = v * a + n * this._w),
          (this._x = v * r + n * this._x),
          (this._y = v * i + n * this._y),
          (this._z = v * o + n * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        )
      }
      const c = Math.sqrt(l),
        d = Math.atan2(c, s),
        h = Math.sin((1 - n) * d) / c,
        p = Math.sin(n * d) / c
      return (
        (this._w = a * h + this._w * p),
        (this._x = r * h + this._x * p),
        (this._y = i * h + this._y * p),
        (this._z = o * h + this._z * p),
        this._onChangeCallback(),
        this
      )
    }
    slerpQuaternions(t, n, r) {
      return this.copy(t).slerp(n, r)
    }
    random() {
      const t = Math.random(),
        n = Math.sqrt(1 - t),
        r = Math.sqrt(t),
        i = 2 * Math.PI * Math.random(),
        o = 2 * Math.PI * Math.random()
      return this.set(
        n * Math.cos(i),
        r * Math.sin(o),
        r * Math.cos(o),
        n * Math.sin(i)
      )
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      )
    }
    fromArray(t, n = 0) {
      return (
        (this._x = t[n]),
        (this._y = t[n + 1]),
        (this._z = t[n + 2]),
        (this._w = t[n + 3]),
        this._onChangeCallback(),
        this
      )
    }
    toArray(t = [], n = 0) {
      return (
        (t[n] = this._x),
        (t[n + 1] = this._y),
        (t[n + 2] = this._z),
        (t[n + 3] = this._w),
        t
      )
    }
    fromBufferAttribute(t, n) {
      return (
        (this._x = t.getX(n)),
        (this._y = t.getY(n)),
        (this._z = t.getZ(n)),
        (this._w = t.getW(n)),
        this
      )
    }
    toJSON() {
      return this.toArray()
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w
    }
  }
  class Pe {
    constructor(t = 0, n = 0, r = 0) {
      ;(Pe.prototype.isVector3 = !0), (this.x = t), (this.y = n), (this.z = r)
    }
    set(t, n, r) {
      return (
        r === void 0 && (r = this.z),
        (this.x = t),
        (this.y = n),
        (this.z = r),
        this
      )
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this
    }
    setX(t) {
      return (this.x = t), this
    }
    setY(t) {
      return (this.y = t), this
    }
    setZ(t) {
      return (this.z = t), this
    }
    setComponent(t, n) {
      switch (t) {
        case 0:
          this.x = n
          break
        case 1:
          this.y = n
          break
        case 2:
          this.z = n
          break
        default:
          throw new Error('index is out of range: ' + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x
        case 1:
          return this.y
        case 2:
          return this.z
        default:
          throw new Error('index is out of range: ' + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z)
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), (this.z += t.z), this
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this
    }
    addVectors(t, n) {
      return (
        (this.x = t.x + n.x), (this.y = t.y + n.y), (this.z = t.z + n.z), this
      )
    }
    addScaledVector(t, n) {
      return (this.x += t.x * n), (this.y += t.y * n), (this.z += t.z * n), this
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this
    }
    subVectors(t, n) {
      return (
        (this.x = t.x - n.x), (this.y = t.y - n.y), (this.z = t.z - n.z), this
      )
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this
    }
    multiplyVectors(t, n) {
      return (
        (this.x = t.x * n.x), (this.y = t.y * n.y), (this.z = t.z * n.z), this
      )
    }
    applyEuler(t) {
      return this.applyQuaternion(eP.setFromEuler(t))
    }
    applyAxisAngle(t, n) {
      return this.applyQuaternion(eP.setFromAxisAngle(t, n))
    }
    applyMatrix3(t) {
      const n = this.x,
        r = this.y,
        i = this.z,
        o = t.elements
      return (
        (this.x = o[0] * n + o[3] * r + o[6] * i),
        (this.y = o[1] * n + o[4] * r + o[7] * i),
        (this.z = o[2] * n + o[5] * r + o[8] * i),
        this
      )
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize()
    }
    applyMatrix4(t) {
      const n = this.x,
        r = this.y,
        i = this.z,
        o = t.elements,
        a = 1 / (o[3] * n + o[7] * r + o[11] * i + o[15])
      return (
        (this.x = (o[0] * n + o[4] * r + o[8] * i + o[12]) * a),
        (this.y = (o[1] * n + o[5] * r + o[9] * i + o[13]) * a),
        (this.z = (o[2] * n + o[6] * r + o[10] * i + o[14]) * a),
        this
      )
    }
    applyQuaternion(t) {
      const n = this.x,
        r = this.y,
        i = this.z,
        o = t.x,
        a = t.y,
        s = t.z,
        l = t.w,
        c = l * n + a * i - s * r,
        d = l * r + s * n - o * i,
        h = l * i + o * r - a * n,
        p = -o * n - a * r - s * i
      return (
        (this.x = c * l + p * -o + d * -s - h * -a),
        (this.y = d * l + p * -a + h * -o - c * -s),
        (this.z = h * l + p * -s + c * -a - d * -o),
        this
      )
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      )
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld
      )
    }
    transformDirection(t) {
      const n = this.x,
        r = this.y,
        i = this.z,
        o = t.elements
      return (
        (this.x = o[0] * n + o[4] * r + o[8] * i),
        (this.y = o[1] * n + o[5] * r + o[9] * i),
        (this.z = o[2] * n + o[6] * r + o[10] * i),
        this.normalize()
      )
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      )
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      )
    }
    clamp(t, n) {
      return (
        (this.x = Math.max(t.x, Math.min(n.x, this.x))),
        (this.y = Math.max(t.y, Math.min(n.y, this.y))),
        (this.z = Math.max(t.z, Math.min(n.z, this.z))),
        this
      )
    }
    clampScalar(t, n) {
      return (
        (this.x = Math.max(t, Math.min(n, this.x))),
        (this.y = Math.max(t, Math.min(n, this.y))),
        (this.z = Math.max(t, Math.min(n, this.z))),
        this
      )
    }
    clampLength(t, n) {
      const r = this.length()
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(t, Math.min(n, r))
      )
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      )
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      )
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      )
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      )
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, n) {
      return (
        (this.x += (t.x - this.x) * n),
        (this.y += (t.y - this.y) * n),
        (this.z += (t.z - this.z) * n),
        this
      )
    }
    lerpVectors(t, n, r) {
      return (
        (this.x = t.x + (n.x - t.x) * r),
        (this.y = t.y + (n.y - t.y) * r),
        (this.z = t.z + (n.z - t.z) * r),
        this
      )
    }
    cross(t) {
      return this.crossVectors(this, t)
    }
    crossVectors(t, n) {
      const r = t.x,
        i = t.y,
        o = t.z,
        a = n.x,
        s = n.y,
        l = n.z
      return (
        (this.x = i * l - o * s),
        (this.y = o * a - r * l),
        (this.z = r * s - i * a),
        this
      )
    }
    projectOnVector(t) {
      const n = t.lengthSq()
      if (n === 0) return this.set(0, 0, 0)
      const r = t.dot(this) / n
      return this.copy(t).multiplyScalar(r)
    }
    projectOnPlane(t) {
      return T1.copy(this).projectOnVector(t), this.sub(T1)
    }
    reflect(t) {
      return this.sub(T1.copy(t).multiplyScalar(2 * this.dot(t)))
    }
    angleTo(t) {
      const n = Math.sqrt(this.lengthSq() * t.lengthSq())
      if (n === 0) return Math.PI / 2
      const r = this.dot(t) / n
      return Math.acos(hr(r, -1, 1))
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
      const n = this.x - t.x,
        r = this.y - t.y,
        i = this.z - t.z
      return n * n + r * r + i * i
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      )
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }
    setFromSphericalCoords(t, n, r) {
      const i = Math.sin(n) * t
      return (
        (this.x = i * Math.sin(r)),
        (this.y = Math.cos(n) * t),
        (this.z = i * Math.cos(r)),
        this
      )
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }
    setFromCylindricalCoords(t, n, r) {
      return (
        (this.x = t * Math.sin(n)),
        (this.y = r),
        (this.z = t * Math.cos(n)),
        this
      )
    }
    setFromMatrixPosition(t) {
      const n = t.elements
      return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this
    }
    setFromMatrixScale(t) {
      const n = this.setFromMatrixColumn(t, 0).length(),
        r = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length()
      return (this.x = n), (this.y = r), (this.z = i), this
    }
    setFromMatrixColumn(t, n) {
      return this.fromArray(t.elements, n * 4)
    }
    setFromMatrix3Column(t, n) {
      return this.fromArray(t.elements, n * 3)
    }
    setFromEuler(t) {
      return (this.x = t._x), (this.y = t._y), (this.z = t._z), this
    }
    setFromColor(t) {
      return (this.x = t.r), (this.y = t.g), (this.z = t.b), this
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z
    }
    fromArray(t, n = 0) {
      return (this.x = t[n]), (this.y = t[n + 1]), (this.z = t[n + 2]), this
    }
    toArray(t = [], n = 0) {
      return (t[n] = this.x), (t[n + 1] = this.y), (t[n + 2] = this.z), t
    }
    fromBufferAttribute(t, n) {
      return (
        (this.x = t.getX(n)), (this.y = t.getY(n)), (this.z = t.getZ(n)), this
      )
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      )
    }
    randomDirection() {
      const t = (Math.random() - 0.5) * 2,
        n = Math.random() * Math.PI * 2,
        r = Math.sqrt(1 - t ** 2)
      return (
        (this.x = r * Math.cos(n)),
        (this.y = r * Math.sin(n)),
        (this.z = t),
        this
      )
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z
    }
  }
  const T1 = new Pe(),
    eP = new Pl()
  class Is {
    constructor(
      t = new Pe(1 / 0, 1 / 0, 1 / 0),
      n = new Pe(-1 / 0, -1 / 0, -1 / 0)
    ) {
      ;(this.isBox3 = !0), (this.min = t), (this.max = n)
    }
    set(t, n) {
      return this.min.copy(t), this.max.copy(n), this
    }
    setFromArray(t) {
      this.makeEmpty()
      for (let n = 0, r = t.length; n < r; n += 3)
        this.expandByPoint(wa.fromArray(t, n))
      return this
    }
    setFromBufferAttribute(t) {
      this.makeEmpty()
      for (let n = 0, r = t.count; n < r; n++)
        this.expandByPoint(wa.fromBufferAttribute(t, n))
      return this
    }
    setFromPoints(t) {
      this.makeEmpty()
      for (let n = 0, r = t.length; n < r; n++) this.expandByPoint(t[n])
      return this
    }
    setFromCenterAndSize(t, n) {
      const r = wa.copy(n).multiplyScalar(0.5)
      return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
    }
    setFromObject(t, n = !1) {
      return this.makeEmpty(), this.expandByObject(t, n)
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      )
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      )
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5)
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this
    }
    expandByObject(t, n = !1) {
      if ((t.updateWorldMatrix(!1, !1), t.boundingBox !== void 0))
        t.boundingBox === null && t.computeBoundingBox(),
          su.copy(t.boundingBox),
          su.applyMatrix4(t.matrixWorld),
          this.union(su)
      else {
        const i = t.geometry
        if (i !== void 0)
          if (
            n &&
            i.attributes !== void 0 &&
            i.attributes.position !== void 0
          ) {
            const o = i.attributes.position
            for (let a = 0, s = o.count; a < s; a++)
              wa.fromBufferAttribute(o, a).applyMatrix4(t.matrixWorld),
                this.expandByPoint(wa)
          } else
            i.boundingBox === null && i.computeBoundingBox(),
              su.copy(i.boundingBox),
              su.applyMatrix4(t.matrixWorld),
              this.union(su)
      }
      const r = t.children
      for (let i = 0, o = r.length; i < o; i++) this.expandByObject(r[i], n)
      return this
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      )
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      )
    }
    getParameter(t, n) {
      return n.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      )
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      )
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, wa),
        wa.distanceToSquared(t.center) <= t.radius * t.radius
      )
    }
    intersectsPlane(t) {
      let n, r
      return (
        t.normal.x > 0
          ? ((n = t.normal.x * this.min.x), (r = t.normal.x * this.max.x))
          : ((n = t.normal.x * this.max.x), (r = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((n += t.normal.y * this.min.y), (r += t.normal.y * this.max.y))
          : ((n += t.normal.y * this.max.y), (r += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((n += t.normal.z * this.min.z), (r += t.normal.z * this.max.z))
          : ((n += t.normal.z * this.max.z), (r += t.normal.z * this.min.z)),
        n <= -t.constant && r >= -t.constant
      )
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1
      this.getCenter(jc),
        gh.subVectors(this.max, jc),
        lu.subVectors(t.a, jc),
        uu.subVectors(t.b, jc),
        cu.subVectors(t.c, jc),
        cs.subVectors(uu, lu),
        ds.subVectors(cu, uu),
        Js.subVectors(lu, cu)
      let n = [
        0,
        -cs.z,
        cs.y,
        0,
        -ds.z,
        ds.y,
        0,
        -Js.z,
        Js.y,
        cs.z,
        0,
        -cs.x,
        ds.z,
        0,
        -ds.x,
        Js.z,
        0,
        -Js.x,
        -cs.y,
        cs.x,
        0,
        -ds.y,
        ds.x,
        0,
        -Js.y,
        Js.x,
        0,
      ]
      return !k1(n, lu, uu, cu, gh) ||
        ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !k1(n, lu, uu, cu, gh))
        ? !1
        : (yh.crossVectors(cs, ds),
          (n = [yh.x, yh.y, yh.z]),
          k1(n, lu, uu, cu, gh))
    }
    clampPoint(t, n) {
      return n.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
      return this.clampPoint(t, wa).distanceTo(t)
    }
    getBoundingSphere(t) {
      return (
        this.isEmpty()
          ? t.makeEmpty()
          : (this.getCenter(t.center),
            (t.radius = this.getSize(wa).length() * 0.5)),
        t
      )
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      )
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this
    }
    applyMatrix4(t) {
      return this.isEmpty()
        ? this
        : (Ca[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          Ca[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          Ca[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          Ca[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          Ca[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          Ca[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          Ca[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          Ca[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(Ca),
          this)
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }
  const Ca = [
      new Pe(),
      new Pe(),
      new Pe(),
      new Pe(),
      new Pe(),
      new Pe(),
      new Pe(),
      new Pe(),
    ],
    wa = new Pe(),
    su = new Is(),
    lu = new Pe(),
    uu = new Pe(),
    cu = new Pe(),
    cs = new Pe(),
    ds = new Pe(),
    Js = new Pe(),
    jc = new Pe(),
    gh = new Pe(),
    yh = new Pe(),
    Qs = new Pe()
  function k1(e, t, n, r, i) {
    for (let o = 0, a = e.length - 3; o <= a; o += 3) {
      Qs.fromArray(e, o)
      const s =
          i.x * Math.abs(Qs.x) + i.y * Math.abs(Qs.y) + i.z * Math.abs(Qs.z),
        l = t.dot(Qs),
        c = n.dot(Qs),
        d = r.dot(Qs)
      if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > s) return !1
    }
    return !0
  }
  const nle = new Is(),
    Gc = new Pe(),
    A1 = new Pe()
  class rf {
    constructor(t = new Pe(), n = -1) {
      ;(this.center = t), (this.radius = n)
    }
    set(t, n) {
      return this.center.copy(t), (this.radius = n), this
    }
    setFromPoints(t, n) {
      const r = this.center
      n !== void 0 ? r.copy(n) : nle.setFromPoints(t).getCenter(r)
      let i = 0
      for (let o = 0, a = t.length; o < a; o++)
        i = Math.max(i, r.distanceToSquared(t[o]))
      return (this.radius = Math.sqrt(i)), this
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this
    }
    isEmpty() {
      return this.radius < 0
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius
    }
    intersectsSphere(t) {
      const n = this.radius + t.radius
      return t.center.distanceToSquared(this.center) <= n * n
    }
    intersectsBox(t) {
      return t.intersectsSphere(this)
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(t, n) {
      const r = this.center.distanceToSquared(t)
      return (
        n.copy(t),
        r > this.radius * this.radius &&
          (n.sub(this.center).normalize(),
          n.multiplyScalar(this.radius).add(this.center)),
        n
      )
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      )
    }
    translate(t) {
      return this.center.add(t), this
    }
    expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this
      Gc.subVectors(t, this.center)
      const n = Gc.lengthSq()
      if (n > this.radius * this.radius) {
        const r = Math.sqrt(n),
          i = (r - this.radius) * 0.5
        this.center.addScaledVector(Gc, i / r), (this.radius += i)
      }
      return this
    }
    union(t) {
      return t.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(t), this)
        : (this.center.equals(t.center) === !0
            ? (this.radius = Math.max(this.radius, t.radius))
            : (A1.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(Gc.copy(t.center).add(A1)),
              this.expandByPoint(Gc.copy(t.center).sub(A1))),
          this)
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  const xa = new Pe(),
    $1 = new Pe(),
    bh = new Pe(),
    fs = new Pe(),
    O1 = new Pe(),
    _h = new Pe(),
    L1 = new Pe()
  class d$ {
    constructor(t = new Pe(), n = new Pe(0, 0, -1)) {
      ;(this.origin = t), (this.direction = n)
    }
    set(t, n) {
      return this.origin.copy(t), this.direction.copy(n), this
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }
    at(t, n) {
      return n.copy(this.origin).addScaledVector(this.direction, t)
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this
    }
    recast(t) {
      return this.origin.copy(this.at(t, xa)), this
    }
    closestPointToPoint(t, n) {
      n.subVectors(t, this.origin)
      const r = n.dot(this.direction)
      return r < 0
        ? n.copy(this.origin)
        : n.copy(this.origin).addScaledVector(this.direction, r)
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t))
    }
    distanceSqToPoint(t) {
      const n = xa.subVectors(t, this.origin).dot(this.direction)
      return n < 0
        ? this.origin.distanceToSquared(t)
        : (xa.copy(this.origin).addScaledVector(this.direction, n),
          xa.distanceToSquared(t))
    }
    distanceSqToSegment(t, n, r, i) {
      $1.copy(t).add(n).multiplyScalar(0.5),
        bh.copy(n).sub(t).normalize(),
        fs.copy(this.origin).sub($1)
      const o = t.distanceTo(n) * 0.5,
        a = -this.direction.dot(bh),
        s = fs.dot(this.direction),
        l = -fs.dot(bh),
        c = fs.lengthSq(),
        d = Math.abs(1 - a * a)
      let h, p, v, g
      if (d > 0)
        if (((h = a * l - s), (p = a * s - l), (g = o * d), h >= 0))
          if (p >= -g)
            if (p <= g) {
              const _ = 1 / d
              ;(h *= _),
                (p *= _),
                (v = h * (h + a * p + 2 * s) + p * (a * h + p + 2 * l) + c)
            } else
              (p = o),
                (h = Math.max(0, -(a * p + s))),
                (v = -h * h + p * (p + 2 * l) + c)
          else
            (p = -o),
              (h = Math.max(0, -(a * p + s))),
              (v = -h * h + p * (p + 2 * l) + c)
        else
          p <= -g
            ? ((h = Math.max(0, -(-a * o + s))),
              (p = h > 0 ? -o : Math.min(Math.max(-o, -l), o)),
              (v = -h * h + p * (p + 2 * l) + c))
            : p <= g
            ? ((h = 0),
              (p = Math.min(Math.max(-o, -l), o)),
              (v = p * (p + 2 * l) + c))
            : ((h = Math.max(0, -(a * o + s))),
              (p = h > 0 ? o : Math.min(Math.max(-o, -l), o)),
              (v = -h * h + p * (p + 2 * l) + c))
      else
        (p = a > 0 ? -o : o),
          (h = Math.max(0, -(a * p + s))),
          (v = -h * h + p * (p + 2 * l) + c)
      return (
        r && r.copy(this.origin).addScaledVector(this.direction, h),
        i && i.copy($1).addScaledVector(bh, p),
        v
      )
    }
    intersectSphere(t, n) {
      xa.subVectors(t.center, this.origin)
      const r = xa.dot(this.direction),
        i = xa.dot(xa) - r * r,
        o = t.radius * t.radius
      if (i > o) return null
      const a = Math.sqrt(o - i),
        s = r - a,
        l = r + a
      return l < 0 ? null : s < 0 ? this.at(l, n) : this.at(s, n)
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }
    distanceToPlane(t) {
      const n = t.normal.dot(this.direction)
      if (n === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null
      const r = -(this.origin.dot(t.normal) + t.constant) / n
      return r >= 0 ? r : null
    }
    intersectPlane(t, n) {
      const r = this.distanceToPlane(t)
      return r === null ? null : this.at(r, n)
    }
    intersectsPlane(t) {
      const n = t.distanceToPoint(this.origin)
      return n === 0 || t.normal.dot(this.direction) * n < 0
    }
    intersectBox(t, n) {
      let r, i, o, a, s, l
      const c = 1 / this.direction.x,
        d = 1 / this.direction.y,
        h = 1 / this.direction.z,
        p = this.origin
      return (
        c >= 0
          ? ((r = (t.min.x - p.x) * c), (i = (t.max.x - p.x) * c))
          : ((r = (t.max.x - p.x) * c), (i = (t.min.x - p.x) * c)),
        d >= 0
          ? ((o = (t.min.y - p.y) * d), (a = (t.max.y - p.y) * d))
          : ((o = (t.max.y - p.y) * d), (a = (t.min.y - p.y) * d)),
        r > a ||
        o > i ||
        ((o > r || isNaN(r)) && (r = o),
        (a < i || isNaN(i)) && (i = a),
        h >= 0
          ? ((s = (t.min.z - p.z) * h), (l = (t.max.z - p.z) * h))
          : ((s = (t.max.z - p.z) * h), (l = (t.min.z - p.z) * h)),
        r > l || s > i) ||
        ((s > r || r !== r) && (r = s), (l < i || i !== i) && (i = l), i < 0)
          ? null
          : this.at(r >= 0 ? r : i, n)
      )
    }
    intersectsBox(t) {
      return this.intersectBox(t, xa) !== null
    }
    intersectTriangle(t, n, r, i, o) {
      O1.subVectors(n, t), _h.subVectors(r, t), L1.crossVectors(O1, _h)
      let a = this.direction.dot(L1),
        s
      if (a > 0) {
        if (i) return null
        s = 1
      } else if (a < 0) (s = -1), (a = -a)
      else return null
      fs.subVectors(this.origin, t)
      const l = s * this.direction.dot(_h.crossVectors(fs, _h))
      if (l < 0) return null
      const c = s * this.direction.dot(O1.cross(fs))
      if (c < 0 || l + c > a) return null
      const d = -s * fs.dot(L1)
      return d < 0 ? null : this.at(d / a, o)
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      )
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  class qn {
    constructor(t, n, r, i, o, a, s, l, c, d, h, p, v, g, _, b) {
      ;(qn.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        t !== void 0 && this.set(t, n, r, i, o, a, s, l, c, d, h, p, v, g, _, b)
    }
    set(t, n, r, i, o, a, s, l, c, d, h, p, v, g, _, b) {
      const y = this.elements
      return (
        (y[0] = t),
        (y[4] = n),
        (y[8] = r),
        (y[12] = i),
        (y[1] = o),
        (y[5] = a),
        (y[9] = s),
        (y[13] = l),
        (y[2] = c),
        (y[6] = d),
        (y[10] = h),
        (y[14] = p),
        (y[3] = v),
        (y[7] = g),
        (y[11] = _),
        (y[15] = b),
        this
      )
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
      return new qn().fromArray(this.elements)
    }
    copy(t) {
      const n = this.elements,
        r = t.elements
      return (
        (n[0] = r[0]),
        (n[1] = r[1]),
        (n[2] = r[2]),
        (n[3] = r[3]),
        (n[4] = r[4]),
        (n[5] = r[5]),
        (n[6] = r[6]),
        (n[7] = r[7]),
        (n[8] = r[8]),
        (n[9] = r[9]),
        (n[10] = r[10]),
        (n[11] = r[11]),
        (n[12] = r[12]),
        (n[13] = r[13]),
        (n[14] = r[14]),
        (n[15] = r[15]),
        this
      )
    }
    copyPosition(t) {
      const n = this.elements,
        r = t.elements
      return (n[12] = r[12]), (n[13] = r[13]), (n[14] = r[14]), this
    }
    setFromMatrix3(t) {
      const n = t.elements
      return (
        this.set(
          n[0],
          n[3],
          n[6],
          0,
          n[1],
          n[4],
          n[7],
          0,
          n[2],
          n[5],
          n[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      )
    }
    extractBasis(t, n, r) {
      return (
        t.setFromMatrixColumn(this, 0),
        n.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
      )
    }
    makeBasis(t, n, r) {
      return (
        this.set(
          t.x,
          n.x,
          r.x,
          0,
          t.y,
          n.y,
          r.y,
          0,
          t.z,
          n.z,
          r.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      )
    }
    extractRotation(t) {
      const n = this.elements,
        r = t.elements,
        i = 1 / du.setFromMatrixColumn(t, 0).length(),
        o = 1 / du.setFromMatrixColumn(t, 1).length(),
        a = 1 / du.setFromMatrixColumn(t, 2).length()
      return (
        (n[0] = r[0] * i),
        (n[1] = r[1] * i),
        (n[2] = r[2] * i),
        (n[3] = 0),
        (n[4] = r[4] * o),
        (n[5] = r[5] * o),
        (n[6] = r[6] * o),
        (n[7] = 0),
        (n[8] = r[8] * a),
        (n[9] = r[9] * a),
        (n[10] = r[10] * a),
        (n[11] = 0),
        (n[12] = 0),
        (n[13] = 0),
        (n[14] = 0),
        (n[15] = 1),
        this
      )
    }
    makeRotationFromEuler(t) {
      const n = this.elements,
        r = t.x,
        i = t.y,
        o = t.z,
        a = Math.cos(r),
        s = Math.sin(r),
        l = Math.cos(i),
        c = Math.sin(i),
        d = Math.cos(o),
        h = Math.sin(o)
      if (t.order === 'XYZ') {
        const p = a * d,
          v = a * h,
          g = s * d,
          _ = s * h
        ;(n[0] = l * d),
          (n[4] = -l * h),
          (n[8] = c),
          (n[1] = v + g * c),
          (n[5] = p - _ * c),
          (n[9] = -s * l),
          (n[2] = _ - p * c),
          (n[6] = g + v * c),
          (n[10] = a * l)
      } else if (t.order === 'YXZ') {
        const p = l * d,
          v = l * h,
          g = c * d,
          _ = c * h
        ;(n[0] = p + _ * s),
          (n[4] = g * s - v),
          (n[8] = a * c),
          (n[1] = a * h),
          (n[5] = a * d),
          (n[9] = -s),
          (n[2] = v * s - g),
          (n[6] = _ + p * s),
          (n[10] = a * l)
      } else if (t.order === 'ZXY') {
        const p = l * d,
          v = l * h,
          g = c * d,
          _ = c * h
        ;(n[0] = p - _ * s),
          (n[4] = -a * h),
          (n[8] = g + v * s),
          (n[1] = v + g * s),
          (n[5] = a * d),
          (n[9] = _ - p * s),
          (n[2] = -a * c),
          (n[6] = s),
          (n[10] = a * l)
      } else if (t.order === 'ZYX') {
        const p = a * d,
          v = a * h,
          g = s * d,
          _ = s * h
        ;(n[0] = l * d),
          (n[4] = g * c - v),
          (n[8] = p * c + _),
          (n[1] = l * h),
          (n[5] = _ * c + p),
          (n[9] = v * c - g),
          (n[2] = -c),
          (n[6] = s * l),
          (n[10] = a * l)
      } else if (t.order === 'YZX') {
        const p = a * l,
          v = a * c,
          g = s * l,
          _ = s * c
        ;(n[0] = l * d),
          (n[4] = _ - p * h),
          (n[8] = g * h + v),
          (n[1] = h),
          (n[5] = a * d),
          (n[9] = -s * d),
          (n[2] = -c * d),
          (n[6] = v * h + g),
          (n[10] = p - _ * h)
      } else if (t.order === 'XZY') {
        const p = a * l,
          v = a * c,
          g = s * l,
          _ = s * c
        ;(n[0] = l * d),
          (n[4] = -h),
          (n[8] = c * d),
          (n[1] = p * h + _),
          (n[5] = a * d),
          (n[9] = v * h - g),
          (n[2] = g * h - v),
          (n[6] = s * d),
          (n[10] = _ * h + p)
      }
      return (
        (n[3] = 0),
        (n[7] = 0),
        (n[11] = 0),
        (n[12] = 0),
        (n[13] = 0),
        (n[14] = 0),
        (n[15] = 1),
        this
      )
    }
    makeRotationFromQuaternion(t) {
      return this.compose(rle, t, ile)
    }
    lookAt(t, n, r) {
      const i = this.elements
      return (
        Di.subVectors(t, n),
        Di.lengthSq() === 0 && (Di.z = 1),
        Di.normalize(),
        hs.crossVectors(r, Di),
        hs.lengthSq() === 0 &&
          (Math.abs(r.z) === 1 ? (Di.x += 1e-4) : (Di.z += 1e-4),
          Di.normalize(),
          hs.crossVectors(r, Di)),
        hs.normalize(),
        Sh.crossVectors(Di, hs),
        (i[0] = hs.x),
        (i[4] = Sh.x),
        (i[8] = Di.x),
        (i[1] = hs.y),
        (i[5] = Sh.y),
        (i[9] = Di.y),
        (i[2] = hs.z),
        (i[6] = Sh.z),
        (i[10] = Di.z),
        this
      )
    }
    multiply(t) {
      return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, n) {
      const r = t.elements,
        i = n.elements,
        o = this.elements,
        a = r[0],
        s = r[4],
        l = r[8],
        c = r[12],
        d = r[1],
        h = r[5],
        p = r[9],
        v = r[13],
        g = r[2],
        _ = r[6],
        b = r[10],
        y = r[14],
        M = r[3],
        x = r[7],
        w = r[11],
        E = r[15],
        P = i[0],
        A = i[4],
        F = i[8],
        T = i[12],
        k = i[1],
        R = i[5],
        j = i[9],
        N = i[13],
        I = i[2],
        B = i[6],
        V = i[10],
        L = i[14],
        W = i[3],
        Y = i[7],
        U = i[11],
        le = i[15]
      return (
        (o[0] = a * P + s * k + l * I + c * W),
        (o[4] = a * A + s * R + l * B + c * Y),
        (o[8] = a * F + s * j + l * V + c * U),
        (o[12] = a * T + s * N + l * L + c * le),
        (o[1] = d * P + h * k + p * I + v * W),
        (o[5] = d * A + h * R + p * B + v * Y),
        (o[9] = d * F + h * j + p * V + v * U),
        (o[13] = d * T + h * N + p * L + v * le),
        (o[2] = g * P + _ * k + b * I + y * W),
        (o[6] = g * A + _ * R + b * B + y * Y),
        (o[10] = g * F + _ * j + b * V + y * U),
        (o[14] = g * T + _ * N + b * L + y * le),
        (o[3] = M * P + x * k + w * I + E * W),
        (o[7] = M * A + x * R + w * B + E * Y),
        (o[11] = M * F + x * j + w * V + E * U),
        (o[15] = M * T + x * N + w * L + E * le),
        this
      )
    }
    multiplyScalar(t) {
      const n = this.elements
      return (
        (n[0] *= t),
        (n[4] *= t),
        (n[8] *= t),
        (n[12] *= t),
        (n[1] *= t),
        (n[5] *= t),
        (n[9] *= t),
        (n[13] *= t),
        (n[2] *= t),
        (n[6] *= t),
        (n[10] *= t),
        (n[14] *= t),
        (n[3] *= t),
        (n[7] *= t),
        (n[11] *= t),
        (n[15] *= t),
        this
      )
    }
    determinant() {
      const t = this.elements,
        n = t[0],
        r = t[4],
        i = t[8],
        o = t[12],
        a = t[1],
        s = t[5],
        l = t[9],
        c = t[13],
        d = t[2],
        h = t[6],
        p = t[10],
        v = t[14],
        g = t[3],
        _ = t[7],
        b = t[11],
        y = t[15]
      return (
        g *
          (+o * l * h -
            i * c * h -
            o * s * p +
            r * c * p +
            i * s * v -
            r * l * v) +
        _ *
          (+n * l * v -
            n * c * p +
            o * a * p -
            i * a * v +
            i * c * d -
            o * l * d) +
        b *
          (+n * c * h -
            n * s * v -
            o * a * h +
            r * a * v +
            o * s * d -
            r * c * d) +
        y *
          (-i * s * d -
            n * l * h +
            n * s * p +
            i * a * h -
            r * a * p +
            r * l * d)
      )
    }
    transpose() {
      const t = this.elements
      let n
      return (
        (n = t[1]),
        (t[1] = t[4]),
        (t[4] = n),
        (n = t[2]),
        (t[2] = t[8]),
        (t[8] = n),
        (n = t[6]),
        (t[6] = t[9]),
        (t[9] = n),
        (n = t[3]),
        (t[3] = t[12]),
        (t[12] = n),
        (n = t[7]),
        (t[7] = t[13]),
        (t[13] = n),
        (n = t[11]),
        (t[11] = t[14]),
        (t[14] = n),
        this
      )
    }
    setPosition(t, n, r) {
      const i = this.elements
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = n), (i[14] = r)),
        this
      )
    }
    invert() {
      const t = this.elements,
        n = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        a = t[4],
        s = t[5],
        l = t[6],
        c = t[7],
        d = t[8],
        h = t[9],
        p = t[10],
        v = t[11],
        g = t[12],
        _ = t[13],
        b = t[14],
        y = t[15],
        M =
          h * b * c - _ * p * c + _ * l * v - s * b * v - h * l * y + s * p * y,
        x =
          g * p * c - d * b * c - g * l * v + a * b * v + d * l * y - a * p * y,
        w =
          d * _ * c - g * h * c + g * s * v - a * _ * v - d * s * y + a * h * y,
        E =
          g * h * l - d * _ * l - g * s * p + a * _ * p + d * s * b - a * h * b,
        P = n * M + r * x + i * w + o * E
      if (P === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
      const A = 1 / P
      return (
        (t[0] = M * A),
        (t[1] =
          (_ * p * o -
            h * b * o -
            _ * i * v +
            r * b * v +
            h * i * y -
            r * p * y) *
          A),
        (t[2] =
          (s * b * o -
            _ * l * o +
            _ * i * c -
            r * b * c -
            s * i * y +
            r * l * y) *
          A),
        (t[3] =
          (h * l * o -
            s * p * o -
            h * i * c +
            r * p * c +
            s * i * v -
            r * l * v) *
          A),
        (t[4] = x * A),
        (t[5] =
          (d * b * o -
            g * p * o +
            g * i * v -
            n * b * v -
            d * i * y +
            n * p * y) *
          A),
        (t[6] =
          (g * l * o -
            a * b * o -
            g * i * c +
            n * b * c +
            a * i * y -
            n * l * y) *
          A),
        (t[7] =
          (a * p * o -
            d * l * o +
            d * i * c -
            n * p * c -
            a * i * v +
            n * l * v) *
          A),
        (t[8] = w * A),
        (t[9] =
          (g * h * o -
            d * _ * o -
            g * r * v +
            n * _ * v +
            d * r * y -
            n * h * y) *
          A),
        (t[10] =
          (a * _ * o -
            g * s * o +
            g * r * c -
            n * _ * c -
            a * r * y +
            n * s * y) *
          A),
        (t[11] =
          (d * s * o -
            a * h * o -
            d * r * c +
            n * h * c +
            a * r * v -
            n * s * v) *
          A),
        (t[12] = E * A),
        (t[13] =
          (d * _ * i -
            g * h * i +
            g * r * p -
            n * _ * p -
            d * r * b +
            n * h * b) *
          A),
        (t[14] =
          (g * s * i -
            a * _ * i -
            g * r * l +
            n * _ * l +
            a * r * b -
            n * s * b) *
          A),
        (t[15] =
          (a * h * i -
            d * s * i +
            d * r * l -
            n * h * l -
            a * r * p +
            n * s * p) *
          A),
        this
      )
    }
    scale(t) {
      const n = this.elements,
        r = t.x,
        i = t.y,
        o = t.z
      return (
        (n[0] *= r),
        (n[4] *= i),
        (n[8] *= o),
        (n[1] *= r),
        (n[5] *= i),
        (n[9] *= o),
        (n[2] *= r),
        (n[6] *= i),
        (n[10] *= o),
        (n[3] *= r),
        (n[7] *= i),
        (n[11] *= o),
        this
      )
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        n = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
      return Math.sqrt(Math.max(n, r, i))
    }
    makeTranslation(t, n, r) {
      return (
        t.isVector3
          ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
          : this.set(1, 0, 0, t, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1),
        this
      )
    }
    makeRotationX(t) {
      const n = Math.cos(t),
        r = Math.sin(t)
      return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this
    }
    makeRotationY(t) {
      const n = Math.cos(t),
        r = Math.sin(t)
      return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(t) {
      const n = Math.cos(t),
        r = Math.sin(t)
      return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(t, n) {
      const r = Math.cos(n),
        i = Math.sin(n),
        o = 1 - r,
        a = t.x,
        s = t.y,
        l = t.z,
        c = o * a,
        d = o * s
      return (
        this.set(
          c * a + r,
          c * s - i * l,
          c * l + i * s,
          0,
          c * s + i * l,
          d * s + r,
          d * l - i * a,
          0,
          c * l - i * s,
          d * l + i * a,
          o * l * l + r,
          0,
          0,
          0,
          0,
          1
        ),
        this
      )
    }
    makeScale(t, n, r) {
      return this.set(t, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
    }
    makeShear(t, n, r, i, o, a) {
      return this.set(1, r, o, 0, t, 1, a, 0, n, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(t, n, r) {
      const i = this.elements,
        o = n._x,
        a = n._y,
        s = n._z,
        l = n._w,
        c = o + o,
        d = a + a,
        h = s + s,
        p = o * c,
        v = o * d,
        g = o * h,
        _ = a * d,
        b = a * h,
        y = s * h,
        M = l * c,
        x = l * d,
        w = l * h,
        E = r.x,
        P = r.y,
        A = r.z
      return (
        (i[0] = (1 - (_ + y)) * E),
        (i[1] = (v + w) * E),
        (i[2] = (g - x) * E),
        (i[3] = 0),
        (i[4] = (v - w) * P),
        (i[5] = (1 - (p + y)) * P),
        (i[6] = (b + M) * P),
        (i[7] = 0),
        (i[8] = (g + x) * A),
        (i[9] = (b - M) * A),
        (i[10] = (1 - (p + _)) * A),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      )
    }
    decompose(t, n, r) {
      const i = this.elements
      let o = du.set(i[0], i[1], i[2]).length()
      const a = du.set(i[4], i[5], i[6]).length(),
        s = du.set(i[8], i[9], i[10]).length()
      this.determinant() < 0 && (o = -o),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        _o.copy(this)
      const c = 1 / o,
        d = 1 / a,
        h = 1 / s
      return (
        (_o.elements[0] *= c),
        (_o.elements[1] *= c),
        (_o.elements[2] *= c),
        (_o.elements[4] *= d),
        (_o.elements[5] *= d),
        (_o.elements[6] *= d),
        (_o.elements[8] *= h),
        (_o.elements[9] *= h),
        (_o.elements[10] *= h),
        n.setFromRotationMatrix(_o),
        (r.x = o),
        (r.y = a),
        (r.z = s),
        this
      )
    }
    makePerspective(t, n, r, i, o, a, s = Ia) {
      const l = this.elements,
        c = (2 * o) / (n - t),
        d = (2 * o) / (r - i),
        h = (n + t) / (n - t),
        p = (r + i) / (r - i)
      let v, g
      if (s === Ia) (v = -(a + o) / (a - o)), (g = (-2 * a * o) / (a - o))
      else if (s === Sv) (v = -a / (a - o)), (g = (-a * o) / (a - o))
      else
        throw new Error(
          'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + s
        )
      return (
        (l[0] = c),
        (l[4] = 0),
        (l[8] = h),
        (l[12] = 0),
        (l[1] = 0),
        (l[5] = d),
        (l[9] = p),
        (l[13] = 0),
        (l[2] = 0),
        (l[6] = 0),
        (l[10] = v),
        (l[14] = g),
        (l[3] = 0),
        (l[7] = 0),
        (l[11] = -1),
        (l[15] = 0),
        this
      )
    }
    makeOrthographic(t, n, r, i, o, a, s = Ia) {
      const l = this.elements,
        c = 1 / (n - t),
        d = 1 / (r - i),
        h = 1 / (a - o),
        p = (n + t) * c,
        v = (r + i) * d
      let g, _
      if (s === Ia) (g = (a + o) * h), (_ = -2 * h)
      else if (s === Sv) (g = o * h), (_ = -1 * h)
      else
        throw new Error(
          'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + s
        )
      return (
        (l[0] = 2 * c),
        (l[4] = 0),
        (l[8] = 0),
        (l[12] = -p),
        (l[1] = 0),
        (l[5] = 2 * d),
        (l[9] = 0),
        (l[13] = -v),
        (l[2] = 0),
        (l[6] = 0),
        (l[10] = _),
        (l[14] = -g),
        (l[3] = 0),
        (l[7] = 0),
        (l[11] = 0),
        (l[15] = 1),
        this
      )
    }
    equals(t) {
      const n = this.elements,
        r = t.elements
      for (let i = 0; i < 16; i++) if (n[i] !== r[i]) return !1
      return !0
    }
    fromArray(t, n = 0) {
      for (let r = 0; r < 16; r++) this.elements[r] = t[r + n]
      return this
    }
    toArray(t = [], n = 0) {
      const r = this.elements
      return (
        (t[n] = r[0]),
        (t[n + 1] = r[1]),
        (t[n + 2] = r[2]),
        (t[n + 3] = r[3]),
        (t[n + 4] = r[4]),
        (t[n + 5] = r[5]),
        (t[n + 6] = r[6]),
        (t[n + 7] = r[7]),
        (t[n + 8] = r[8]),
        (t[n + 9] = r[9]),
        (t[n + 10] = r[10]),
        (t[n + 11] = r[11]),
        (t[n + 12] = r[12]),
        (t[n + 13] = r[13]),
        (t[n + 14] = r[14]),
        (t[n + 15] = r[15]),
        t
      )
    }
  }
  const du = new Pe(),
    _o = new qn(),
    rle = new Pe(0, 0, 0),
    ile = new Pe(1, 1, 1),
    hs = new Pe(),
    Sh = new Pe(),
    Di = new Pe(),
    tP = new qn(),
    nP = new Pl()
  class fm {
    constructor(t = 0, n = 0, r = 0, i = fm.DEFAULT_ORDER) {
      ;(this.isEuler = !0),
        (this._x = t),
        (this._y = n),
        (this._z = r),
        (this._order = i)
    }
    get x() {
      return this._x
    }
    set x(t) {
      ;(this._x = t), this._onChangeCallback()
    }
    get y() {
      return this._y
    }
    set y(t) {
      ;(this._y = t), this._onChangeCallback()
    }
    get z() {
      return this._z
    }
    set z(t) {
      ;(this._z = t), this._onChangeCallback()
    }
    get order() {
      return this._order
    }
    set order(t) {
      ;(this._order = t), this._onChangeCallback()
    }
    set(t, n, r, i = this._order) {
      return (
        (this._x = t),
        (this._y = n),
        (this._z = r),
        (this._order = i),
        this._onChangeCallback(),
        this
      )
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      )
    }
    setFromRotationMatrix(t, n = this._order, r = !0) {
      const i = t.elements,
        o = i[0],
        a = i[4],
        s = i[8],
        l = i[1],
        c = i[5],
        d = i[9],
        h = i[2],
        p = i[6],
        v = i[10]
      switch (n) {
        case 'XYZ':
          ;(this._y = Math.asin(hr(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(-d, v)), (this._z = Math.atan2(-a, o)))
              : ((this._x = Math.atan2(p, c)), (this._z = 0))
          break
        case 'YXZ':
          ;(this._x = Math.asin(-hr(d, -1, 1))),
            Math.abs(d) < 0.9999999
              ? ((this._y = Math.atan2(s, v)), (this._z = Math.atan2(l, c)))
              : ((this._y = Math.atan2(-h, o)), (this._z = 0))
          break
        case 'ZXY':
          ;(this._x = Math.asin(hr(p, -1, 1))),
            Math.abs(p) < 0.9999999
              ? ((this._y = Math.atan2(-h, v)), (this._z = Math.atan2(-a, c)))
              : ((this._y = 0), (this._z = Math.atan2(l, o)))
          break
        case 'ZYX':
          ;(this._y = Math.asin(-hr(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._x = Math.atan2(p, v)), (this._z = Math.atan2(l, o)))
              : ((this._x = 0), (this._z = Math.atan2(-a, c)))
          break
        case 'YZX':
          ;(this._z = Math.asin(hr(l, -1, 1))),
            Math.abs(l) < 0.9999999
              ? ((this._x = Math.atan2(-d, c)), (this._y = Math.atan2(-h, o)))
              : ((this._x = 0), (this._y = Math.atan2(s, v)))
          break
        case 'XZY':
          ;(this._z = Math.asin(-hr(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(s, o)))
              : ((this._x = Math.atan2(-d, v)), (this._y = 0))
          break
        default:
          console.warn(
            'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
              n
          )
      }
      return (this._order = n), r === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(t, n, r) {
      return (
        tP.makeRotationFromQuaternion(t), this.setFromRotationMatrix(tP, n, r)
      )
    }
    setFromVector3(t, n = this._order) {
      return this.set(t.x, t.y, t.z, n)
    }
    reorder(t) {
      return nP.setFromEuler(this), this.setFromQuaternion(nP, t)
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      )
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        t[3] !== void 0 && (this._order = t[3]),
        this._onChangeCallback(),
        this
      )
    }
    toArray(t = [], n = 0) {
      return (
        (t[n] = this._x),
        (t[n + 1] = this._y),
        (t[n + 2] = this._z),
        (t[n + 3] = this._order),
        t
      )
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order
    }
  }
  fm.DEFAULT_ORDER = 'XYZ'
  class $S {
    constructor() {
      this.mask = 1
    }
    set(t) {
      this.mask = ((1 << t) | 0) >>> 0
    }
    enable(t) {
      this.mask |= (1 << t) | 0
    }
    enableAll() {
      this.mask = -1
    }
    toggle(t) {
      this.mask ^= (1 << t) | 0
    }
    disable(t) {
      this.mask &= ~((1 << t) | 0)
    }
    disableAll() {
      this.mask = 0
    }
    test(t) {
      return (this.mask & t.mask) !== 0
    }
    isEnabled(t) {
      return (this.mask & ((1 << t) | 0)) !== 0
    }
  }
  let ole = 0
  const rP = new Pe(),
    fu = new Pl(),
    Ma = new qn(),
    Ch = new Pe(),
    Kc = new Pe(),
    ale = new Pe(),
    sle = new Pl(),
    iP = new Pe(1, 0, 0),
    oP = new Pe(0, 1, 0),
    aP = new Pe(0, 0, 1),
    lle = { type: 'added' },
    sP = { type: 'removed' }
  class Br extends Rl {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, 'id', { value: ole++ }),
        (this.uuid = ta()),
        (this.name = ''),
        (this.type = 'Object3D'),
        (this.parent = null),
        (this.children = []),
        (this.up = Br.DEFAULT_UP.clone())
      const t = new Pe(),
        n = new fm(),
        r = new Pl(),
        i = new Pe(1, 1, 1)
      function o() {
        r.setFromEuler(n, !1)
      }
      function a() {
        n.setFromQuaternion(r, void 0, !1)
      }
      n._onChange(o),
        r._onChange(a),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: n },
          quaternion: { configurable: !0, enumerable: !0, value: r },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new qn() },
          normalMatrix: { value: new cn() },
        }),
        (this.matrix = new qn()),
        (this.matrixWorld = new qn()),
        (this.matrixAutoUpdate = Br.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.matrixWorldAutoUpdate = Br.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.layers = new $S()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {})
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this
    }
    setRotationFromAxisAngle(t, n) {
      this.quaternion.setFromAxisAngle(t, n)
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0)
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t)
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t)
    }
    rotateOnAxis(t, n) {
      return fu.setFromAxisAngle(t, n), this.quaternion.multiply(fu), this
    }
    rotateOnWorldAxis(t, n) {
      return fu.setFromAxisAngle(t, n), this.quaternion.premultiply(fu), this
    }
    rotateX(t) {
      return this.rotateOnAxis(iP, t)
    }
    rotateY(t) {
      return this.rotateOnAxis(oP, t)
    }
    rotateZ(t) {
      return this.rotateOnAxis(aP, t)
    }
    translateOnAxis(t, n) {
      return (
        rP.copy(t).applyQuaternion(this.quaternion),
        this.position.add(rP.multiplyScalar(n)),
        this
      )
    }
    translateX(t) {
      return this.translateOnAxis(iP, t)
    }
    translateY(t) {
      return this.translateOnAxis(oP, t)
    }
    translateZ(t) {
      return this.translateOnAxis(aP, t)
    }
    localToWorld(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.applyMatrix4(Ma.copy(this.matrixWorld).invert())
      )
    }
    lookAt(t, n, r) {
      t.isVector3 ? Ch.copy(t) : Ch.set(t, n, r)
      const i = this.parent
      this.updateWorldMatrix(!0, !1),
        Kc.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? Ma.lookAt(Kc, Ch, this.up)
          : Ma.lookAt(Ch, Kc, this.up),
        this.quaternion.setFromRotationMatrix(Ma),
        i &&
          (Ma.extractRotation(i.matrixWorld),
          fu.setFromRotationMatrix(Ma),
          this.quaternion.premultiply(fu.invert()))
    }
    add(t) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.add(arguments[n])
        return this
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (t.parent !== null && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(lle))
            : console.error(
                'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                t
              ),
          this)
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let r = 0; r < arguments.length; r++) this.remove(arguments[r])
        return this
      }
      const n = this.children.indexOf(t)
      return (
        n !== -1 &&
          ((t.parent = null), this.children.splice(n, 1), t.dispatchEvent(sP)),
        this
      )
    }
    removeFromParent() {
      const t = this.parent
      return t !== null && t.remove(this), this
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const n = this.children[t]
        ;(n.parent = null), n.dispatchEvent(sP)
      }
      return (this.children.length = 0), this
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        Ma.copy(this.matrixWorld).invert(),
        t.parent !== null &&
          (t.parent.updateWorldMatrix(!0, !1),
          Ma.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(Ma),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      )
    }
    getObjectById(t) {
      return this.getObjectByProperty('id', t)
    }
    getObjectByName(t) {
      return this.getObjectByProperty('name', t)
    }
    getObjectByProperty(t, n) {
      if (this[t] === n) return this
      for (let r = 0, i = this.children.length; r < i; r++) {
        const a = this.children[r].getObjectByProperty(t, n)
        if (a !== void 0) return a
      }
    }
    getObjectsByProperty(t, n) {
      let r = []
      this[t] === n && r.push(this)
      for (let i = 0, o = this.children.length; i < o; i++) {
        const a = this.children[i].getObjectsByProperty(t, n)
        a.length > 0 && (r = r.concat(a))
      }
      return r
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      )
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Kc, t, ale),
        t
      )
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Kc, sle, t),
        t
      )
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1)
      const n = this.matrixWorld.elements
      return t.set(n[8], n[9], n[10]).normalize()
    }
    raycast() {}
    traverse(t) {
      t(this)
      const n = this.children
      for (let r = 0, i = n.length; r < i; r++) n[r].traverse(t)
    }
    traverseVisible(t) {
      if (this.visible === !1) return
      t(this)
      const n = this.children
      for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(t)
    }
    traverseAncestors(t) {
      const n = this.parent
      n !== null && (t(n), n.traverseAncestors(t))
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0)
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0))
      const n = this.children
      for (let r = 0, i = n.length; r < i; r++) {
        const o = n[r]
        ;(o.matrixWorldAutoUpdate === !0 || t === !0) && o.updateMatrixWorld(t)
      }
    }
    updateWorldMatrix(t, n) {
      const r = this.parent
      if (
        (t === !0 &&
          r !== null &&
          r.matrixWorldAutoUpdate === !0 &&
          r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        n === !0)
      ) {
        const i = this.children
        for (let o = 0, a = i.length; o < a; o++) {
          const s = i[o]
          s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!1, !0)
        }
      }
    }
    toJSON(t) {
      const n = t === void 0 || typeof t == 'string',
        r = {}
      n &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (r.metadata = {
          version: 4.6,
          type: 'Object',
          generator: 'Object3D.toJSON',
        }))
      const i = {}
      ;(i.uuid = this.uuid),
        (i.type = this.type),
        this.name !== '' && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        (i.up = this.up.toArray()),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = 'InstancedMesh'),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON()),
          this.instanceColor !== null &&
            (i.instanceColor = this.instanceColor.toJSON()))
      function o(s, l) {
        return s[l.uuid] === void 0 && (s[l.uuid] = l.toJSON(t)), l.uuid
      }
      if (this.isScene)
        this.background &&
          (this.background.isColor
            ? (i.background = this.background.toJSON())
            : this.background.isTexture &&
              (i.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            this.environment.isRenderTargetTexture !== !0 &&
            (i.environment = this.environment.toJSON(t).uuid)
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = o(t.geometries, this.geometry)
        const s = this.geometry.parameters
        if (s !== void 0 && s.shapes !== void 0) {
          const l = s.shapes
          if (Array.isArray(l))
            for (let c = 0, d = l.length; c < d; c++) {
              const h = l[c]
              o(t.shapes, h)
            }
          else o(t.shapes, l)
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((i.bindMode = this.bindMode),
          (i.bindMatrix = this.bindMatrix.toArray()),
          this.skeleton !== void 0 &&
            (o(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
        this.material !== void 0)
      )
        if (Array.isArray(this.material)) {
          const s = []
          for (let l = 0, c = this.material.length; l < c; l++)
            s.push(o(t.materials, this.material[l]))
          i.material = s
        } else i.material = o(t.materials, this.material)
      if (this.children.length > 0) {
        i.children = []
        for (let s = 0; s < this.children.length; s++)
          i.children.push(this.children[s].toJSON(t).object)
      }
      if (this.animations.length > 0) {
        i.animations = []
        for (let s = 0; s < this.animations.length; s++) {
          const l = this.animations[s]
          i.animations.push(o(t.animations, l))
        }
      }
      if (n) {
        const s = a(t.geometries),
          l = a(t.materials),
          c = a(t.textures),
          d = a(t.images),
          h = a(t.shapes),
          p = a(t.skeletons),
          v = a(t.animations),
          g = a(t.nodes)
        s.length > 0 && (r.geometries = s),
          l.length > 0 && (r.materials = l),
          c.length > 0 && (r.textures = c),
          d.length > 0 && (r.images = d),
          h.length > 0 && (r.shapes = h),
          p.length > 0 && (r.skeletons = p),
          v.length > 0 && (r.animations = v),
          g.length > 0 && (r.nodes = g)
      }
      return (r.object = i), r
      function a(s) {
        const l = []
        for (const c in s) {
          const d = s[c]
          delete d.metadata, l.push(d)
        }
        return l
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t)
    }
    copy(t, n = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.animations = t.animations),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        n === !0)
      )
        for (let r = 0; r < t.children.length; r++) {
          const i = t.children[r]
          this.add(i.clone())
        }
      return this
    }
  }
  Br.DEFAULT_UP = new Pe(0, 1, 0)
  Br.DEFAULT_MATRIX_AUTO_UPDATE = !0
  Br.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0
  const So = new Pe(),
    Ea = new Pe(),
    I1 = new Pe(),
    Pa = new Pe(),
    hu = new Pe(),
    pu = new Pe(),
    lP = new Pe(),
    R1 = new Pe(),
    D1 = new Pe(),
    N1 = new Pe()
  let wh = !1
  class Eo {
    constructor(t = new Pe(), n = new Pe(), r = new Pe()) {
      ;(this.a = t), (this.b = n), (this.c = r)
    }
    static getNormal(t, n, r, i) {
      i.subVectors(r, n), So.subVectors(t, n), i.cross(So)
      const o = i.lengthSq()
      return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0)
    }
    static getBarycoord(t, n, r, i, o) {
      So.subVectors(i, n), Ea.subVectors(r, n), I1.subVectors(t, n)
      const a = So.dot(So),
        s = So.dot(Ea),
        l = So.dot(I1),
        c = Ea.dot(Ea),
        d = Ea.dot(I1),
        h = a * c - s * s
      if (h === 0) return o.set(-2, -1, -1)
      const p = 1 / h,
        v = (c * l - s * d) * p,
        g = (a * d - s * l) * p
      return o.set(1 - v - g, g, v)
    }
    static containsPoint(t, n, r, i) {
      return (
        this.getBarycoord(t, n, r, i, Pa),
        Pa.x >= 0 && Pa.y >= 0 && Pa.x + Pa.y <= 1
      )
    }
    static getUV(t, n, r, i, o, a, s, l) {
      return (
        wh === !1 &&
          (console.warn(
            'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
          ),
          (wh = !0)),
        this.getInterpolation(t, n, r, i, o, a, s, l)
      )
    }
    static getInterpolation(t, n, r, i, o, a, s, l) {
      return (
        this.getBarycoord(t, n, r, i, Pa),
        l.setScalar(0),
        l.addScaledVector(o, Pa.x),
        l.addScaledVector(a, Pa.y),
        l.addScaledVector(s, Pa.z),
        l
      )
    }
    static isFrontFacing(t, n, r, i) {
      return So.subVectors(r, n), Ea.subVectors(t, n), So.cross(Ea).dot(i) < 0
    }
    set(t, n, r) {
      return this.a.copy(t), this.b.copy(n), this.c.copy(r), this
    }
    setFromPointsAndIndices(t, n, r, i) {
      return this.a.copy(t[n]), this.b.copy(t[r]), this.c.copy(t[i]), this
    }
    setFromAttributeAndIndices(t, n, r, i) {
      return (
        this.a.fromBufferAttribute(t, n),
        this.b.fromBufferAttribute(t, r),
        this.c.fromBufferAttribute(t, i),
        this
      )
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }
    getArea() {
      return (
        So.subVectors(this.c, this.b),
        Ea.subVectors(this.a, this.b),
        So.cross(Ea).length() * 0.5
      )
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3)
    }
    getNormal(t) {
      return Eo.getNormal(this.a, this.b, this.c, t)
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(t, n) {
      return Eo.getBarycoord(t, this.a, this.b, this.c, n)
    }
    getUV(t, n, r, i, o) {
      return (
        wh === !1 &&
          (console.warn(
            'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
          ),
          (wh = !0)),
        Eo.getInterpolation(t, this.a, this.b, this.c, n, r, i, o)
      )
    }
    getInterpolation(t, n, r, i, o) {
      return Eo.getInterpolation(t, this.a, this.b, this.c, n, r, i, o)
    }
    containsPoint(t) {
      return Eo.containsPoint(t, this.a, this.b, this.c)
    }
    isFrontFacing(t) {
      return Eo.isFrontFacing(this.a, this.b, this.c, t)
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this)
    }
    closestPointToPoint(t, n) {
      const r = this.a,
        i = this.b,
        o = this.c
      let a, s
      hu.subVectors(i, r), pu.subVectors(o, r), R1.subVectors(t, r)
      const l = hu.dot(R1),
        c = pu.dot(R1)
      if (l <= 0 && c <= 0) return n.copy(r)
      D1.subVectors(t, i)
      const d = hu.dot(D1),
        h = pu.dot(D1)
      if (d >= 0 && h <= d) return n.copy(i)
      const p = l * h - d * c
      if (p <= 0 && l >= 0 && d <= 0)
        return (a = l / (l - d)), n.copy(r).addScaledVector(hu, a)
      N1.subVectors(t, o)
      const v = hu.dot(N1),
        g = pu.dot(N1)
      if (g >= 0 && v <= g) return n.copy(o)
      const _ = v * c - l * g
      if (_ <= 0 && c >= 0 && g <= 0)
        return (s = c / (c - g)), n.copy(r).addScaledVector(pu, s)
      const b = d * g - v * h
      if (b <= 0 && h - d >= 0 && v - g >= 0)
        return (
          lP.subVectors(o, i),
          (s = (h - d) / (h - d + (v - g))),
          n.copy(i).addScaledVector(lP, s)
        )
      const y = 1 / (b + _ + p)
      return (
        (a = _ * y),
        (s = p * y),
        n.copy(r).addScaledVector(hu, a).addScaledVector(pu, s)
      )
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
  }
  let ule = 0
  class cc extends Rl {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, 'id', { value: ule++ }),
        (this.uuid = ta()),
        (this.name = ''),
        (this.type = 'Material'),
        (this.blending = zu),
        (this.side = $s),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = XA),
        (this.blendDst = YA),
        (this.blendEquation = wu),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = Wb),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = xse),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = x1),
        (this.stencilZFail = x1),
        (this.stencilZPass = x1),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0)
    }
    get alphaTest() {
      return this._alphaTest
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t)
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString()
    }
    setValues(t) {
      if (t !== void 0)
        for (const n in t) {
          const r = t[n]
          if (r === void 0) {
            console.warn(
              `THREE.Material: parameter '${n}' has value of undefined.`
            )
            continue
          }
          const i = this[n]
          if (i === void 0) {
            console.warn(
              `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
            )
            continue
          }
          i && i.isColor
            ? i.set(r)
            : i && i.isVector3 && r && r.isVector3
            ? i.copy(r)
            : (this[n] = r)
        }
    }
    toJSON(t) {
      const n = t === void 0 || typeof t == 'string'
      n && (t = { textures: {}, images: {} })
      const r = {
        metadata: {
          version: 4.6,
          type: 'Material',
          generator: 'Material.toJSON',
        },
      }
      ;(r.uuid = this.uuid),
        (r.type = this.type),
        this.name !== '' && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 &&
          (r.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          this.emissiveIntensity !== 1 &&
          (r.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 &&
          (r.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 &&
          (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (r.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 &&
          (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 &&
          (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (r.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (r.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(t).uuid),
        this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 &&
          (r.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap &&
          this.anisotropyMap.isTexture &&
          (r.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (r.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (r.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((r.lightMap = this.lightMap.toJSON(t).uuid),
          (r.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((r.aoMap = this.aoMap.toJSON(t).uuid),
          (r.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((r.bumpMap = this.bumpMap.toJSON(t).uuid),
          (r.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((r.normalMap = this.normalMap.toJSON(t).uuid),
          (r.normalMapType = this.normalMapType),
          (r.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((r.displacementMap = this.displacementMap.toJSON(t).uuid),
          (r.displacementScale = this.displacementScale),
          (r.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (r.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (r.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (r.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (r.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (r.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (r.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((r.envMap = this.envMap.toJSON(t).uuid),
          this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapIntensity !== void 0 &&
          (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 &&
          (r.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (r.gradientMap = this.gradientMap.toJSON(t).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (r.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (r.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        this.attenuationDistance !== void 0 &&
          this.attenuationDistance !== 1 / 0 &&
          (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 &&
          (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 &&
          (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== zu && (r.blending = this.blending),
        this.side !== $s && (r.side = this.side),
        this.vertexColors && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = this.transparent),
        (r.depthFunc = this.depthFunc),
        (r.depthTest = this.depthTest),
        (r.depthWrite = this.depthWrite),
        (r.colorWrite = this.colorWrite),
        (r.stencilWrite = this.stencilWrite),
        (r.stencilWriteMask = this.stencilWriteMask),
        (r.stencilFunc = this.stencilFunc),
        (r.stencilRef = this.stencilRef),
        (r.stencilFuncMask = this.stencilFuncMask),
        (r.stencilFail = this.stencilFail),
        (r.stencilZFail = this.stencilZFail),
        (r.stencilZPass = this.stencilZPass),
        this.rotation !== void 0 &&
          this.rotation !== 0 &&
          (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 &&
          (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 &&
          (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 &&
          this.linewidth !== 1 &&
          (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 &&
          (r.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 &&
          (r.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 &&
          (r.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (r.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== 'round' &&
          (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== 'round' &&
          (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = this.flatShading),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData)
      function i(o) {
        const a = []
        for (const s in o) {
          const l = o[s]
          delete l.metadata, a.push(l)
        }
        return a
      }
      if (n) {
        const o = i(t.textures),
          a = i(t.images)
        o.length > 0 && (r.textures = o), a.length > 0 && (r.images = a)
      }
      return r
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      ;(this.name = t.name),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite)
      const n = t.clippingPlanes
      let r = null
      if (n !== null) {
        const i = n.length
        r = new Array(i)
        for (let o = 0; o !== i; ++o) r[o] = n[o].clone()
      }
      return (
        (this.clippingPlanes = r),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.forceSinglePass = t.forceSinglePass),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      )
    }
    dispose() {
      this.dispatchEvent({ type: 'dispose' })
    }
    set needsUpdate(t) {
      t === !0 && this.version++
    }
  }
  const f$ = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    Co = { h: 0, s: 0, l: 0 },
    xh = { h: 0, s: 0, l: 0 }
  function B1(e, t, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? e + (t - e) * 6 * n
        : n < 1 / 2
        ? t
        : n < 2 / 3
        ? e + (t - e) * 6 * (2 / 3 - n)
        : e
    )
  }
  class xn {
    constructor(t, n, r) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        this.set(t, n, r)
      )
    }
    set(t, n, r) {
      if (n === void 0 && r === void 0) {
        const i = t
        i && i.isColor
          ? this.copy(i)
          : typeof i == 'number'
          ? this.setHex(i)
          : typeof i == 'string' && this.setStyle(i)
      } else this.setRGB(t, n, r)
      return this
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this
    }
    setHex(t, n = rn) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (t & 255) / 255),
        bo.toWorkingColorSpace(this, n),
        this
      )
    }
    setRGB(t, n, r, i = bo.workingColorSpace) {
      return (
        (this.r = t),
        (this.g = n),
        (this.b = r),
        bo.toWorkingColorSpace(this, i),
        this
      )
    }
    setHSL(t, n, r, i = bo.workingColorSpace) {
      if (((t = AS(t, 1)), (n = hr(n, 0, 1)), (r = hr(r, 0, 1)), n === 0))
        this.r = this.g = this.b = r
      else {
        const o = r <= 0.5 ? r * (1 + n) : r + n - r * n,
          a = 2 * r - o
        ;(this.r = B1(a, o, t + 1 / 3)),
          (this.g = B1(a, o, t)),
          (this.b = B1(a, o, t - 1 / 3))
      }
      return bo.toWorkingColorSpace(this, i), this
    }
    setStyle(t, n = rn) {
      function r(o) {
        o !== void 0 &&
          parseFloat(o) < 1 &&
          console.warn(
            'THREE.Color: Alpha component of ' + t + ' will be ignored.'
          )
      }
      let i
      if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
        let o
        const a = i[1],
          s = i[2]
        switch (a) {
          case 'rgb':
          case 'rgba':
            if (
              (o =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(o[4]),
                this.setRGB(
                  Math.min(255, parseInt(o[1], 10)) / 255,
                  Math.min(255, parseInt(o[2], 10)) / 255,
                  Math.min(255, parseInt(o[3], 10)) / 255,
                  n
                )
              )
            if (
              (o =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(o[4]),
                this.setRGB(
                  Math.min(100, parseInt(o[1], 10)) / 100,
                  Math.min(100, parseInt(o[2], 10)) / 100,
                  Math.min(100, parseInt(o[3], 10)) / 100,
                  n
                )
              )
            break
          case 'hsl':
          case 'hsla':
            if (
              (o =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(o[4]),
                this.setHSL(
                  parseFloat(o[1]) / 360,
                  parseFloat(o[2]) / 100,
                  parseFloat(o[3]) / 100,
                  n
                )
              )
            break
          default:
            console.warn('THREE.Color: Unknown color model ' + t)
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const o = i[1],
          a = o.length
        if (a === 3)
          return this.setRGB(
            parseInt(o.charAt(0), 16) / 15,
            parseInt(o.charAt(1), 16) / 15,
            parseInt(o.charAt(2), 16) / 15,
            n
          )
        if (a === 6) return this.setHex(parseInt(o, 16), n)
        console.warn('THREE.Color: Invalid hex color ' + t)
      } else if (t && t.length > 0) return this.setColorName(t, n)
      return this
    }
    setColorName(t, n = rn) {
      const r = f$[t.toLowerCase()]
      return (
        r !== void 0
          ? this.setHex(r, n)
          : console.warn('THREE.Color: Unknown color ' + t),
        this
      )
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b)
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
    }
    copySRGBToLinear(t) {
      return (this.r = Vu(t.r)), (this.g = Vu(t.g)), (this.b = Vu(t.b)), this
    }
    copyLinearToSRGB(t) {
      return (this.r = E1(t.r)), (this.g = E1(t.g)), (this.b = E1(t.b)), this
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this
    }
    getHex(t = rn) {
      return (
        bo.fromWorkingColorSpace(Gr.copy(this), t),
        Math.round(hr(Gr.r * 255, 0, 255)) * 65536 +
          Math.round(hr(Gr.g * 255, 0, 255)) * 256 +
          Math.round(hr(Gr.b * 255, 0, 255))
      )
    }
    getHexString(t = rn) {
      return ('000000' + this.getHex(t).toString(16)).slice(-6)
    }
    getHSL(t, n = bo.workingColorSpace) {
      bo.fromWorkingColorSpace(Gr.copy(this), n)
      const r = Gr.r,
        i = Gr.g,
        o = Gr.b,
        a = Math.max(r, i, o),
        s = Math.min(r, i, o)
      let l, c
      const d = (s + a) / 2
      if (s === a) (l = 0), (c = 0)
      else {
        const h = a - s
        switch (((c = d <= 0.5 ? h / (a + s) : h / (2 - a - s)), a)) {
          case r:
            l = (i - o) / h + (i < o ? 6 : 0)
            break
          case i:
            l = (o - r) / h + 2
            break
          case o:
            l = (r - i) / h + 4
            break
        }
        l /= 6
      }
      return (t.h = l), (t.s = c), (t.l = d), t
    }
    getRGB(t, n = bo.workingColorSpace) {
      return (
        bo.fromWorkingColorSpace(Gr.copy(this), n),
        (t.r = Gr.r),
        (t.g = Gr.g),
        (t.b = Gr.b),
        t
      )
    }
    getStyle(t = rn) {
      bo.fromWorkingColorSpace(Gr.copy(this), t)
      const n = Gr.r,
        r = Gr.g,
        i = Gr.b
      return t !== rn
        ? `color(${t} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
        : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(
            i * 255
          )})`
    }
    offsetHSL(t, n, r) {
      return (
        this.getHSL(Co),
        (Co.h += t),
        (Co.s += n),
        (Co.l += r),
        this.setHSL(Co.h, Co.s, Co.l),
        this
      )
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
    }
    addColors(t, n) {
      return (
        (this.r = t.r + n.r), (this.g = t.g + n.g), (this.b = t.b + n.b), this
      )
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      )
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this
    }
    lerp(t, n) {
      return (
        (this.r += (t.r - this.r) * n),
        (this.g += (t.g - this.g) * n),
        (this.b += (t.b - this.b) * n),
        this
      )
    }
    lerpColors(t, n, r) {
      return (
        (this.r = t.r + (n.r - t.r) * r),
        (this.g = t.g + (n.g - t.g) * r),
        (this.b = t.b + (n.b - t.b) * r),
        this
      )
    }
    lerpHSL(t, n) {
      this.getHSL(Co), t.getHSL(xh)
      const r = _d(Co.h, xh.h, n),
        i = _d(Co.s, xh.s, n),
        o = _d(Co.l, xh.l, n)
      return this.setHSL(r, i, o), this
    }
    setFromVector3(t) {
      return (this.r = t.x), (this.g = t.y), (this.b = t.z), this
    }
    applyMatrix3(t) {
      const n = this.r,
        r = this.g,
        i = this.b,
        o = t.elements
      return (
        (this.r = o[0] * n + o[3] * r + o[6] * i),
        (this.g = o[1] * n + o[4] * r + o[7] * i),
        (this.b = o[2] * n + o[5] * r + o[8] * i),
        this
      )
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, n = 0) {
      return (this.r = t[n]), (this.g = t[n + 1]), (this.b = t[n + 2]), this
    }
    toArray(t = [], n = 0) {
      return (t[n] = this.r), (t[n + 1] = this.g), (t[n + 2] = this.b), t
    }
    fromBufferAttribute(t, n) {
      return (
        (this.r = t.getX(n)), (this.g = t.getY(n)), (this.b = t.getZ(n)), this
      )
    }
    toJSON() {
      return this.getHex()
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b
    }
  }
  const Gr = new xn()
  xn.NAMES = f$
  class Eu extends cc {
    constructor(t) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = 'MeshBasicMaterial'),
        (this.color = new xn(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = nf),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = 'round'),
        (this.wireframeLinejoin = 'round'),
        (this.fog = !0),
        this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      )
    }
  }
  const sr = new Pe(),
    Mh = new Ct()
  class Io {
    constructor(t, n, r = !1) {
      if (Array.isArray(t))
        throw new TypeError(
          'THREE.BufferAttribute: array should be a Typed Array.'
        )
      ;(this.isBufferAttribute = !0),
        (this.name = ''),
        (this.array = t),
        (this.itemSize = n),
        (this.count = t !== void 0 ? t.length / n : 0),
        (this.normalized = r),
        (this.usage = qb),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.gpuType = Ss),
        (this.version = 0)
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      t === !0 && this.version++
    }
    setUsage(t) {
      return (this.usage = t), this
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        (this.gpuType = t.gpuType),
        this
      )
    }
    copyAt(t, n, r) {
      ;(t *= this.itemSize), (r *= n.itemSize)
      for (let i = 0, o = this.itemSize; i < o; i++)
        this.array[t + i] = n.array[r + i]
      return this
    }
    copyArray(t) {
      return this.array.set(t), this
    }
    applyMatrix3(t) {
      if (this.itemSize === 2)
        for (let n = 0, r = this.count; n < r; n++)
          Mh.fromBufferAttribute(this, n),
            Mh.applyMatrix3(t),
            this.setXY(n, Mh.x, Mh.y)
      else if (this.itemSize === 3)
        for (let n = 0, r = this.count; n < r; n++)
          sr.fromBufferAttribute(this, n),
            sr.applyMatrix3(t),
            this.setXYZ(n, sr.x, sr.y, sr.z)
      return this
    }
    applyMatrix4(t) {
      for (let n = 0, r = this.count; n < r; n++)
        sr.fromBufferAttribute(this, n),
          sr.applyMatrix4(t),
          this.setXYZ(n, sr.x, sr.y, sr.z)
      return this
    }
    applyNormalMatrix(t) {
      for (let n = 0, r = this.count; n < r; n++)
        sr.fromBufferAttribute(this, n),
          sr.applyNormalMatrix(t),
          this.setXYZ(n, sr.x, sr.y, sr.z)
      return this
    }
    transformDirection(t) {
      for (let n = 0, r = this.count; n < r; n++)
        sr.fromBufferAttribute(this, n),
          sr.transformDirection(t),
          this.setXYZ(n, sr.x, sr.y, sr.z)
      return this
    }
    set(t, n = 0) {
      return this.array.set(t, n), this
    }
    getX(t) {
      let n = this.array[t * this.itemSize]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    setX(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.array[t * this.itemSize] = n),
        this
      )
    }
    getY(t) {
      let n = this.array[t * this.itemSize + 1]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    setY(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.array[t * this.itemSize + 1] = n),
        this
      )
    }
    getZ(t) {
      let n = this.array[t * this.itemSize + 2]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    setZ(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.array[t * this.itemSize + 2] = n),
        this
      )
    }
    getW(t) {
      let n = this.array[t * this.itemSize + 3]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    setW(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.array[t * this.itemSize + 3] = n),
        this
      )
    }
    setXY(t, n, r) {
      return (
        (t *= this.itemSize),
        this.normalized && ((n = Ln(n, this.array)), (r = Ln(r, this.array))),
        (this.array[t + 0] = n),
        (this.array[t + 1] = r),
        this
      )
    }
    setXYZ(t, n, r, i) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((n = Ln(n, this.array)),
          (r = Ln(r, this.array)),
          (i = Ln(i, this.array))),
        (this.array[t + 0] = n),
        (this.array[t + 1] = r),
        (this.array[t + 2] = i),
        this
      )
    }
    setXYZW(t, n, r, i, o) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((n = Ln(n, this.array)),
          (r = Ln(r, this.array)),
          (i = Ln(i, this.array)),
          (o = Ln(o, this.array))),
        (this.array[t + 0] = n),
        (this.array[t + 1] = r),
        (this.array[t + 2] = i),
        (this.array[t + 3] = o),
        this
      )
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      }
      return (
        this.name !== '' && (t.name = this.name),
        this.usage !== qb && (t.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
          (t.updateRange = this.updateRange),
        t
      )
    }
    copyColorsArray() {
      console.error(
        'THREE.BufferAttribute: copyColorsArray() was removed in r144.'
      )
    }
    copyVector2sArray() {
      console.error(
        'THREE.BufferAttribute: copyVector2sArray() was removed in r144.'
      )
    }
    copyVector3sArray() {
      console.error(
        'THREE.BufferAttribute: copyVector3sArray() was removed in r144.'
      )
    }
    copyVector4sArray() {
      console.error(
        'THREE.BufferAttribute: copyVector4sArray() was removed in r144.'
      )
    }
  }
  class h$ extends Io {
    constructor(t, n, r) {
      super(new Uint16Array(t), n, r)
    }
  }
  class p$ extends Io {
    constructor(t, n, r) {
      super(new Uint32Array(t), n, r)
    }
  }
  class so extends Io {
    constructor(t, n, r) {
      super(new Float32Array(t), n, r)
    }
  }
  let cle = 0
  const Qi = new qn(),
    F1 = new Br(),
    vu = new Pe(),
    Ni = new Is(),
    qc = new Is(),
    Sr = new Pe()
  class la extends Rl {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, 'id', { value: cle++ }),
        (this.uuid = ta()),
        (this.name = ''),
        (this.type = 'BufferGeometry'),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {})
    }
    getIndex() {
      return this.index
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (s$(t) ? p$ : h$)(t, 1))
          : (this.index = t),
        this
      )
    }
    getAttribute(t) {
      return this.attributes[t]
    }
    setAttribute(t, n) {
      return (this.attributes[t] = n), this
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this
    }
    hasAttribute(t) {
      return this.attributes[t] !== void 0
    }
    addGroup(t, n, r = 0) {
      this.groups.push({ start: t, count: n, materialIndex: r })
    }
    clearGroups() {
      this.groups = []
    }
    setDrawRange(t, n) {
      ;(this.drawRange.start = t), (this.drawRange.count = n)
    }
    applyMatrix4(t) {
      const n = this.attributes.position
      n !== void 0 && (n.applyMatrix4(t), (n.needsUpdate = !0))
      const r = this.attributes.normal
      if (r !== void 0) {
        const o = new cn().getNormalMatrix(t)
        r.applyNormalMatrix(o), (r.needsUpdate = !0)
      }
      const i = this.attributes.tangent
      return (
        i !== void 0 && (i.transformDirection(t), (i.needsUpdate = !0)),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
      )
    }
    applyQuaternion(t) {
      return Qi.makeRotationFromQuaternion(t), this.applyMatrix4(Qi), this
    }
    rotateX(t) {
      return Qi.makeRotationX(t), this.applyMatrix4(Qi), this
    }
    rotateY(t) {
      return Qi.makeRotationY(t), this.applyMatrix4(Qi), this
    }
    rotateZ(t) {
      return Qi.makeRotationZ(t), this.applyMatrix4(Qi), this
    }
    translate(t, n, r) {
      return Qi.makeTranslation(t, n, r), this.applyMatrix4(Qi), this
    }
    scale(t, n, r) {
      return Qi.makeScale(t, n, r), this.applyMatrix4(Qi), this
    }
    lookAt(t) {
      return F1.lookAt(t), F1.updateMatrix(), this.applyMatrix4(F1.matrix), this
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(vu).negate(),
        this.translate(vu.x, vu.y, vu.z),
        this
      )
    }
    setFromPoints(t) {
      const n = []
      for (let r = 0, i = t.length; r < i; r++) {
        const o = t[r]
        n.push(o.x, o.y, o.z || 0)
      }
      return this.setAttribute('position', new so(n, 3)), this
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Is())
      const t = this.attributes.position,
        n = this.morphAttributes.position
      if (t && t.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
          this.boundingBox.set(
            new Pe(-1 / 0, -1 / 0, -1 / 0),
            new Pe(1 / 0, 1 / 0, 1 / 0)
          )
        return
      }
      if (t !== void 0) {
        if ((this.boundingBox.setFromBufferAttribute(t), n))
          for (let r = 0, i = n.length; r < i; r++) {
            const o = n[r]
            Ni.setFromBufferAttribute(o),
              this.morphTargetsRelative
                ? (Sr.addVectors(this.boundingBox.min, Ni.min),
                  this.boundingBox.expandByPoint(Sr),
                  Sr.addVectors(this.boundingBox.max, Ni.max),
                  this.boundingBox.expandByPoint(Sr))
                : (this.boundingBox.expandByPoint(Ni.min),
                  this.boundingBox.expandByPoint(Ni.max))
          }
      } else this.boundingBox.makeEmpty()
      ;(isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        )
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new rf())
      const t = this.attributes.position,
        n = this.morphAttributes.position
      if (t && t.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
          this.boundingSphere.set(new Pe(), 1 / 0)
        return
      }
      if (t) {
        const r = this.boundingSphere.center
        if ((Ni.setFromBufferAttribute(t), n))
          for (let o = 0, a = n.length; o < a; o++) {
            const s = n[o]
            qc.setFromBufferAttribute(s),
              this.morphTargetsRelative
                ? (Sr.addVectors(Ni.min, qc.min),
                  Ni.expandByPoint(Sr),
                  Sr.addVectors(Ni.max, qc.max),
                  Ni.expandByPoint(Sr))
                : (Ni.expandByPoint(qc.min), Ni.expandByPoint(qc.max))
          }
        Ni.getCenter(r)
        let i = 0
        for (let o = 0, a = t.count; o < a; o++)
          Sr.fromBufferAttribute(t, o),
            (i = Math.max(i, r.distanceToSquared(Sr)))
        if (n)
          for (let o = 0, a = n.length; o < a; o++) {
            const s = n[o],
              l = this.morphTargetsRelative
            for (let c = 0, d = s.count; c < d; c++)
              Sr.fromBufferAttribute(s, c),
                l && (vu.fromBufferAttribute(t, c), Sr.add(vu)),
                (i = Math.max(i, r.distanceToSquared(Sr)))
          }
        ;(this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            )
      }
    }
    computeTangents() {
      const t = this.index,
        n = this.attributes
      if (
        t === null ||
        n.position === void 0 ||
        n.normal === void 0 ||
        n.uv === void 0
      ) {
        console.error(
          'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
        )
        return
      }
      const r = t.array,
        i = n.position.array,
        o = n.normal.array,
        a = n.uv.array,
        s = i.length / 3
      this.hasAttribute('tangent') === !1 &&
        this.setAttribute('tangent', new Io(new Float32Array(4 * s), 4))
      const l = this.getAttribute('tangent').array,
        c = [],
        d = []
      for (let k = 0; k < s; k++) (c[k] = new Pe()), (d[k] = new Pe())
      const h = new Pe(),
        p = new Pe(),
        v = new Pe(),
        g = new Ct(),
        _ = new Ct(),
        b = new Ct(),
        y = new Pe(),
        M = new Pe()
      function x(k, R, j) {
        h.fromArray(i, k * 3),
          p.fromArray(i, R * 3),
          v.fromArray(i, j * 3),
          g.fromArray(a, k * 2),
          _.fromArray(a, R * 2),
          b.fromArray(a, j * 2),
          p.sub(h),
          v.sub(h),
          _.sub(g),
          b.sub(g)
        const N = 1 / (_.x * b.y - b.x * _.y)
        isFinite(N) &&
          (y
            .copy(p)
            .multiplyScalar(b.y)
            .addScaledVector(v, -_.y)
            .multiplyScalar(N),
          M.copy(v)
            .multiplyScalar(_.x)
            .addScaledVector(p, -b.x)
            .multiplyScalar(N),
          c[k].add(y),
          c[R].add(y),
          c[j].add(y),
          d[k].add(M),
          d[R].add(M),
          d[j].add(M))
      }
      let w = this.groups
      w.length === 0 && (w = [{ start: 0, count: r.length }])
      for (let k = 0, R = w.length; k < R; ++k) {
        const j = w[k],
          N = j.start,
          I = j.count
        for (let B = N, V = N + I; B < V; B += 3)
          x(r[B + 0], r[B + 1], r[B + 2])
      }
      const E = new Pe(),
        P = new Pe(),
        A = new Pe(),
        F = new Pe()
      function T(k) {
        A.fromArray(o, k * 3), F.copy(A)
        const R = c[k]
        E.copy(R),
          E.sub(A.multiplyScalar(A.dot(R))).normalize(),
          P.crossVectors(F, R)
        const N = P.dot(d[k]) < 0 ? -1 : 1
        ;(l[k * 4] = E.x),
          (l[k * 4 + 1] = E.y),
          (l[k * 4 + 2] = E.z),
          (l[k * 4 + 3] = N)
      }
      for (let k = 0, R = w.length; k < R; ++k) {
        const j = w[k],
          N = j.start,
          I = j.count
        for (let B = N, V = N + I; B < V; B += 3)
          T(r[B + 0]), T(r[B + 1]), T(r[B + 2])
      }
    }
    computeVertexNormals() {
      const t = this.index,
        n = this.getAttribute('position')
      if (n !== void 0) {
        let r = this.getAttribute('normal')
        if (r === void 0)
          (r = new Io(new Float32Array(n.count * 3), 3)),
            this.setAttribute('normal', r)
        else for (let p = 0, v = r.count; p < v; p++) r.setXYZ(p, 0, 0, 0)
        const i = new Pe(),
          o = new Pe(),
          a = new Pe(),
          s = new Pe(),
          l = new Pe(),
          c = new Pe(),
          d = new Pe(),
          h = new Pe()
        if (t)
          for (let p = 0, v = t.count; p < v; p += 3) {
            const g = t.getX(p + 0),
              _ = t.getX(p + 1),
              b = t.getX(p + 2)
            i.fromBufferAttribute(n, g),
              o.fromBufferAttribute(n, _),
              a.fromBufferAttribute(n, b),
              d.subVectors(a, o),
              h.subVectors(i, o),
              d.cross(h),
              s.fromBufferAttribute(r, g),
              l.fromBufferAttribute(r, _),
              c.fromBufferAttribute(r, b),
              s.add(d),
              l.add(d),
              c.add(d),
              r.setXYZ(g, s.x, s.y, s.z),
              r.setXYZ(_, l.x, l.y, l.z),
              r.setXYZ(b, c.x, c.y, c.z)
          }
        else
          for (let p = 0, v = n.count; p < v; p += 3)
            i.fromBufferAttribute(n, p + 0),
              o.fromBufferAttribute(n, p + 1),
              a.fromBufferAttribute(n, p + 2),
              d.subVectors(a, o),
              h.subVectors(i, o),
              d.cross(h),
              r.setXYZ(p + 0, d.x, d.y, d.z),
              r.setXYZ(p + 1, d.x, d.y, d.z),
              r.setXYZ(p + 2, d.x, d.y, d.z)
        this.normalizeNormals(), (r.needsUpdate = !0)
      }
    }
    merge() {
      return (
        console.error(
          'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead.'
        ),
        this
      )
    }
    normalizeNormals() {
      const t = this.attributes.normal
      for (let n = 0, r = t.count; n < r; n++)
        Sr.fromBufferAttribute(t, n),
          Sr.normalize(),
          t.setXYZ(n, Sr.x, Sr.y, Sr.z)
    }
    toNonIndexed() {
      function t(s, l) {
        const c = s.array,
          d = s.itemSize,
          h = s.normalized,
          p = new c.constructor(l.length * d)
        let v = 0,
          g = 0
        for (let _ = 0, b = l.length; _ < b; _++) {
          s.isInterleavedBufferAttribute
            ? (v = l[_] * s.data.stride + s.offset)
            : (v = l[_] * d)
          for (let y = 0; y < d; y++) p[g++] = c[v++]
        }
        return new Io(p, d, h)
      }
      if (this.index === null)
        return (
          console.warn(
            'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
          ),
          this
        )
      const n = new la(),
        r = this.index.array,
        i = this.attributes
      for (const s in i) {
        const l = i[s],
          c = t(l, r)
        n.setAttribute(s, c)
      }
      const o = this.morphAttributes
      for (const s in o) {
        const l = [],
          c = o[s]
        for (let d = 0, h = c.length; d < h; d++) {
          const p = c[d],
            v = t(p, r)
          l.push(v)
        }
        n.morphAttributes[s] = l
      }
      n.morphTargetsRelative = this.morphTargetsRelative
      const a = this.groups
      for (let s = 0, l = a.length; s < l; s++) {
        const c = a[s]
        n.addGroup(c.start, c.count, c.materialIndex)
      }
      return n
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON',
        },
      }
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        this.name !== '' && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        this.parameters !== void 0)
      ) {
        const l = this.parameters
        for (const c in l) l[c] !== void 0 && (t[c] = l[c])
        return t
      }
      t.data = { attributes: {} }
      const n = this.index
      n !== null &&
        (t.data.index = {
          type: n.array.constructor.name,
          array: Array.prototype.slice.call(n.array),
        })
      const r = this.attributes
      for (const l in r) {
        const c = r[l]
        t.data.attributes[l] = c.toJSON(t.data)
      }
      const i = {}
      let o = !1
      for (const l in this.morphAttributes) {
        const c = this.morphAttributes[l],
          d = []
        for (let h = 0, p = c.length; h < p; h++) {
          const v = c[h]
          d.push(v.toJSON(t.data))
        }
        d.length > 0 && ((i[l] = d), (o = !0))
      }
      o &&
        ((t.data.morphAttributes = i),
        (t.data.morphTargetsRelative = this.morphTargetsRelative))
      const a = this.groups
      a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)))
      const s = this.boundingSphere
      return (
        s !== null &&
          (t.data.boundingSphere = {
            center: s.center.toArray(),
            radius: s.radius,
          }),
        t
      )
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      ;(this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null)
      const n = {}
      this.name = t.name
      const r = t.index
      r !== null && this.setIndex(r.clone(n))
      const i = t.attributes
      for (const c in i) {
        const d = i[c]
        this.setAttribute(c, d.clone(n))
      }
      const o = t.morphAttributes
      for (const c in o) {
        const d = [],
          h = o[c]
        for (let p = 0, v = h.length; p < v; p++) d.push(h[p].clone(n))
        this.morphAttributes[c] = d
      }
      this.morphTargetsRelative = t.morphTargetsRelative
      const a = t.groups
      for (let c = 0, d = a.length; c < d; c++) {
        const h = a[c]
        this.addGroup(h.start, h.count, h.materialIndex)
      }
      const s = t.boundingBox
      s !== null && (this.boundingBox = s.clone())
      const l = t.boundingSphere
      return (
        l !== null && (this.boundingSphere = l.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      )
    }
    dispose() {
      this.dispatchEvent({ type: 'dispose' })
    }
  }
  const uP = new qn(),
    el = new d$(),
    Eh = new rf(),
    cP = new Pe(),
    mu = new Pe(),
    gu = new Pe(),
    yu = new Pe(),
    z1 = new Pe(),
    Ph = new Pe(),
    Th = new Ct(),
    kh = new Ct(),
    Ah = new Ct(),
    dP = new Pe(),
    fP = new Pe(),
    hP = new Pe(),
    $h = new Pe(),
    Oh = new Pe()
  class Ci extends Br {
    constructor(t = new la(), n = new Eu()) {
      super(),
        (this.isMesh = !0),
        (this.type = 'Mesh'),
        (this.geometry = t),
        (this.material = n),
        this.updateMorphTargets()
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        t.morphTargetInfluences !== void 0 &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        t.morphTargetDictionary !== void 0 &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary
          )),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      )
    }
    updateMorphTargets() {
      const n = this.geometry.morphAttributes,
        r = Object.keys(n)
      if (r.length > 0) {
        const i = n[r[0]]
        if (i !== void 0) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let o = 0, a = i.length; o < a; o++) {
            const s = i[o].name || String(o)
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[s] = o)
          }
        }
      }
    }
    getVertexPosition(t, n) {
      const r = this.geometry,
        i = r.attributes.position,
        o = r.morphAttributes.position,
        a = r.morphTargetsRelative
      n.fromBufferAttribute(i, t)
      const s = this.morphTargetInfluences
      if (o && s) {
        Ph.set(0, 0, 0)
        for (let l = 0, c = o.length; l < c; l++) {
          const d = s[l],
            h = o[l]
          d !== 0 &&
            (z1.fromBufferAttribute(h, t),
            a ? Ph.addScaledVector(z1, d) : Ph.addScaledVector(z1.sub(n), d))
        }
        n.add(Ph)
      }
      return n
    }
    raycast(t, n) {
      const r = this.geometry,
        i = this.material,
        o = this.matrixWorld
      i !== void 0 &&
        (r.boundingSphere === null && r.computeBoundingSphere(),
        Eh.copy(r.boundingSphere),
        Eh.applyMatrix4(o),
        el.copy(t.ray).recast(t.near),
        !(
          Eh.containsPoint(el.origin) === !1 &&
          (el.intersectSphere(Eh, cP) === null ||
            el.origin.distanceToSquared(cP) > (t.far - t.near) ** 2)
        ) &&
          (uP.copy(o).invert(),
          el.copy(t.ray).applyMatrix4(uP),
          !(r.boundingBox !== null && el.intersectsBox(r.boundingBox) === !1) &&
            this._computeIntersections(t, n, el)))
    }
    _computeIntersections(t, n, r) {
      let i
      const o = this.geometry,
        a = this.material,
        s = o.index,
        l = o.attributes.position,
        c = o.attributes.uv,
        d = o.attributes.uv1,
        h = o.attributes.normal,
        p = o.groups,
        v = o.drawRange
      if (s !== null)
        if (Array.isArray(a))
          for (let g = 0, _ = p.length; g < _; g++) {
            const b = p[g],
              y = a[b.materialIndex],
              M = Math.max(b.start, v.start),
              x = Math.min(
                s.count,
                Math.min(b.start + b.count, v.start + v.count)
              )
            for (let w = M, E = x; w < E; w += 3) {
              const P = s.getX(w),
                A = s.getX(w + 1),
                F = s.getX(w + 2)
              ;(i = Lh(this, y, t, r, c, d, h, P, A, F)),
                i &&
                  ((i.faceIndex = Math.floor(w / 3)),
                  (i.face.materialIndex = b.materialIndex),
                  n.push(i))
            }
          }
        else {
          const g = Math.max(0, v.start),
            _ = Math.min(s.count, v.start + v.count)
          for (let b = g, y = _; b < y; b += 3) {
            const M = s.getX(b),
              x = s.getX(b + 1),
              w = s.getX(b + 2)
            ;(i = Lh(this, a, t, r, c, d, h, M, x, w)),
              i && ((i.faceIndex = Math.floor(b / 3)), n.push(i))
          }
        }
      else if (l !== void 0)
        if (Array.isArray(a))
          for (let g = 0, _ = p.length; g < _; g++) {
            const b = p[g],
              y = a[b.materialIndex],
              M = Math.max(b.start, v.start),
              x = Math.min(
                l.count,
                Math.min(b.start + b.count, v.start + v.count)
              )
            for (let w = M, E = x; w < E; w += 3) {
              const P = w,
                A = w + 1,
                F = w + 2
              ;(i = Lh(this, y, t, r, c, d, h, P, A, F)),
                i &&
                  ((i.faceIndex = Math.floor(w / 3)),
                  (i.face.materialIndex = b.materialIndex),
                  n.push(i))
            }
          }
        else {
          const g = Math.max(0, v.start),
            _ = Math.min(l.count, v.start + v.count)
          for (let b = g, y = _; b < y; b += 3) {
            const M = b,
              x = b + 1,
              w = b + 2
            ;(i = Lh(this, a, t, r, c, d, h, M, x, w)),
              i && ((i.faceIndex = Math.floor(b / 3)), n.push(i))
          }
        }
    }
  }
  function dle(e, t, n, r, i, o, a, s) {
    let l
    if (
      (t.side === Mi
        ? (l = r.intersectTriangle(a, o, i, !0, s))
        : (l = r.intersectTriangle(i, o, a, t.side === $s, s)),
      l === null)
    )
      return null
    Oh.copy(s), Oh.applyMatrix4(e.matrixWorld)
    const c = n.ray.origin.distanceTo(Oh)
    return c < n.near || c > n.far
      ? null
      : { distance: c, point: Oh.clone(), object: e }
  }
  function Lh(e, t, n, r, i, o, a, s, l, c) {
    e.getVertexPosition(s, mu),
      e.getVertexPosition(l, gu),
      e.getVertexPosition(c, yu)
    const d = dle(e, t, n, r, mu, gu, yu, $h)
    if (d) {
      i &&
        (Th.fromBufferAttribute(i, s),
        kh.fromBufferAttribute(i, l),
        Ah.fromBufferAttribute(i, c),
        (d.uv = Eo.getInterpolation($h, mu, gu, yu, Th, kh, Ah, new Ct()))),
        o &&
          (Th.fromBufferAttribute(o, s),
          kh.fromBufferAttribute(o, l),
          Ah.fromBufferAttribute(o, c),
          (d.uv1 = Eo.getInterpolation($h, mu, gu, yu, Th, kh, Ah, new Ct())),
          (d.uv2 = d.uv1)),
        a &&
          (dP.fromBufferAttribute(a, s),
          fP.fromBufferAttribute(a, l),
          hP.fromBufferAttribute(a, c),
          (d.normal = Eo.getInterpolation(
            $h,
            mu,
            gu,
            yu,
            dP,
            fP,
            hP,
            new Pe()
          )),
          d.normal.dot(r.direction) > 0 && d.normal.multiplyScalar(-1))
      const h = { a: s, b: l, c, normal: new Pe(), materialIndex: 0 }
      Eo.getNormal(mu, gu, yu, h.normal), (d.face = h)
    }
    return d
  }
  class of extends la {
    constructor(t = 1, n = 1, r = 1, i = 1, o = 1, a = 1) {
      super(),
        (this.type = 'BoxGeometry'),
        (this.parameters = {
          width: t,
          height: n,
          depth: r,
          widthSegments: i,
          heightSegments: o,
          depthSegments: a,
        })
      const s = this
      ;(i = Math.floor(i)), (o = Math.floor(o)), (a = Math.floor(a))
      const l = [],
        c = [],
        d = [],
        h = []
      let p = 0,
        v = 0
      g('z', 'y', 'x', -1, -1, r, n, t, a, o, 0),
        g('z', 'y', 'x', 1, -1, r, n, -t, a, o, 1),
        g('x', 'z', 'y', 1, 1, t, r, n, i, a, 2),
        g('x', 'z', 'y', 1, -1, t, r, -n, i, a, 3),
        g('x', 'y', 'z', 1, -1, t, n, r, i, o, 4),
        g('x', 'y', 'z', -1, -1, t, n, -r, i, o, 5),
        this.setIndex(l),
        this.setAttribute('position', new so(c, 3)),
        this.setAttribute('normal', new so(d, 3)),
        this.setAttribute('uv', new so(h, 2))
      function g(_, b, y, M, x, w, E, P, A, F, T) {
        const k = w / A,
          R = E / F,
          j = w / 2,
          N = E / 2,
          I = P / 2,
          B = A + 1,
          V = F + 1
        let L = 0,
          W = 0
        const Y = new Pe()
        for (let U = 0; U < V; U++) {
          const le = U * R - N
          for (let q = 0; q < B; q++) {
            const oe = q * k - j
            ;(Y[_] = oe * M),
              (Y[b] = le * x),
              (Y[y] = I),
              c.push(Y.x, Y.y, Y.z),
              (Y[_] = 0),
              (Y[b] = 0),
              (Y[y] = P > 0 ? 1 : -1),
              d.push(Y.x, Y.y, Y.z),
              h.push(q / A),
              h.push(1 - U / F),
              (L += 1)
          }
        }
        for (let U = 0; U < F; U++)
          for (let le = 0; le < A; le++) {
            const q = p + le + B * U,
              oe = p + le + B * (U + 1),
              te = p + (le + 1) + B * (U + 1),
              ue = p + (le + 1) + B * U
            l.push(q, oe, ue), l.push(oe, te, ue), (W += 6)
          }
        s.addGroup(v, W, T), (v += W), (p += L)
      }
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      )
    }
    static fromJSON(t) {
      return new of(
        t.width,
        t.height,
        t.depth,
        t.widthSegments,
        t.heightSegments,
        t.depthSegments
      )
    }
  }
  function Qu(e) {
    const t = {}
    for (const n in e) {
      t[n] = {}
      for (const r in e[n]) {
        const i = e[n][r]
        i &&
        (i.isColor ||
          i.isMatrix3 ||
          i.isMatrix4 ||
          i.isVector2 ||
          i.isVector3 ||
          i.isVector4 ||
          i.isTexture ||
          i.isQuaternion)
          ? i.isRenderTargetTexture
            ? (console.warn(
                'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
              ),
              (t[n][r] = null))
            : (t[n][r] = i.clone())
          : Array.isArray(i)
          ? (t[n][r] = i.slice())
          : (t[n][r] = i)
      }
    }
    return t
  }
  function si(e) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const r = Qu(e[n])
      for (const i in r) t[i] = r[i]
    }
    return t
  }
  function fle(e) {
    const t = []
    for (let n = 0; n < e.length; n++) t.push(e[n].clone())
    return t
  }
  function v$(e) {
    return e.getRenderTarget() === null ? e.outputColorSpace : aa
  }
  const OS = { clone: Qu, merge: si }
  var hle = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    ple = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
  class Os extends cc {
    constructor(t) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = 'ShaderMaterial'),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader = hle),
        (this.fragmentShader = ple),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.forceSinglePass = !0),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv1: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        t !== void 0 && this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = Qu(t.uniforms)),
        (this.uniformsGroups = fle(t.uniformsGroups)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.extensions = Object.assign({}, t.extensions)),
        (this.glslVersion = t.glslVersion),
        this
      )
    }
    toJSON(t) {
      const n = super.toJSON(t)
      ;(n.glslVersion = this.glslVersion), (n.uniforms = {})
      for (const i in this.uniforms) {
        const a = this.uniforms[i].value
        a && a.isTexture
          ? (n.uniforms[i] = { type: 't', value: a.toJSON(t).uuid })
          : a && a.isColor
          ? (n.uniforms[i] = { type: 'c', value: a.getHex() })
          : a && a.isVector2
          ? (n.uniforms[i] = { type: 'v2', value: a.toArray() })
          : a && a.isVector3
          ? (n.uniforms[i] = { type: 'v3', value: a.toArray() })
          : a && a.isVector4
          ? (n.uniforms[i] = { type: 'v4', value: a.toArray() })
          : a && a.isMatrix3
          ? (n.uniforms[i] = { type: 'm3', value: a.toArray() })
          : a && a.isMatrix4
          ? (n.uniforms[i] = { type: 'm4', value: a.toArray() })
          : (n.uniforms[i] = { value: a })
      }
      Object.keys(this.defines).length > 0 && (n.defines = this.defines),
        (n.vertexShader = this.vertexShader),
        (n.fragmentShader = this.fragmentShader),
        (n.lights = this.lights),
        (n.clipping = this.clipping)
      const r = {}
      for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0)
      return Object.keys(r).length > 0 && (n.extensions = r), n
    }
  }
  class m$ extends Br {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = 'Camera'),
        (this.matrixWorldInverse = new qn()),
        (this.projectionMatrix = new qn()),
        (this.projectionMatrixInverse = new qn()),
        (this.coordinateSystem = Ia)
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        (this.coordinateSystem = t.coordinateSystem),
        this
      )
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1)
      const n = this.matrixWorld.elements
      return t.set(-n[8], -n[9], -n[10]).normalize()
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(t, n) {
      super.updateWorldMatrix(t, n),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  class to extends m$ {
    constructor(t = 50, n = 1, r = 0.1, i = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = 'PerspectiveCamera'),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = r),
        (this.far = i),
        (this.focus = 10),
        (this.aspect = n),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix()
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = t.view === null ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      )
    }
    setFocalLength(t) {
      const n = (0.5 * this.getFilmHeight()) / t
      ;(this.fov = Bd * 2 * Math.atan(n)), this.updateProjectionMatrix()
    }
    getFocalLength() {
      const t = Math.tan(bd * 0.5 * this.fov)
      return (0.5 * this.getFilmHeight()) / t
    }
    getEffectiveFOV() {
      return Bd * 2 * Math.atan(Math.tan(bd * 0.5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(t, n, r, i, o, a) {
      ;(this.aspect = t / n),
        this.view === null &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = n),
        (this.view.offsetX = r),
        (this.view.offsetY = i),
        (this.view.width = o),
        (this.view.height = a),
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
      const t = this.near
      let n = (t * Math.tan(bd * 0.5 * this.fov)) / this.zoom,
        r = 2 * n,
        i = this.aspect * r,
        o = -0.5 * i
      const a = this.view
      if (this.view !== null && this.view.enabled) {
        const l = a.fullWidth,
          c = a.fullHeight
        ;(o += (a.offsetX * i) / l),
          (n -= (a.offsetY * r) / c),
          (i *= a.width / l),
          (r *= a.height / c)
      }
      const s = this.filmOffset
      s !== 0 && (o += (t * s) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          o,
          o + i,
          n,
          n - r,
          t,
          this.far,
          this.coordinateSystem
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        (n.object.fov = this.fov),
        (n.object.zoom = this.zoom),
        (n.object.near = this.near),
        (n.object.far = this.far),
        (n.object.focus = this.focus),
        (n.object.aspect = this.aspect),
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        (n.object.filmGauge = this.filmGauge),
        (n.object.filmOffset = this.filmOffset),
        n
      )
    }
  }
  const bu = -90,
    _u = 1
  class vle extends Br {
    constructor(t, n, r) {
      super(),
        (this.type = 'CubeCamera'),
        (this.renderTarget = r),
        (this.coordinateSystem = null)
      const i = new to(bu, _u, t, n)
      ;(i.layers = this.layers), this.add(i)
      const o = new to(bu, _u, t, n)
      ;(o.layers = this.layers), this.add(o)
      const a = new to(bu, _u, t, n)
      ;(a.layers = this.layers), this.add(a)
      const s = new to(bu, _u, t, n)
      ;(s.layers = this.layers), this.add(s)
      const l = new to(bu, _u, t, n)
      ;(l.layers = this.layers), this.add(l)
      const c = new to(bu, _u, t, n)
      ;(c.layers = this.layers), this.add(c)
    }
    updateCoordinateSystem() {
      const t = this.coordinateSystem,
        n = this.children.concat(),
        [r, i, o, a, s, l] = n
      for (const c of n) this.remove(c)
      if (t === Ia)
        r.up.set(0, 1, 0),
          r.lookAt(1, 0, 0),
          i.up.set(0, 1, 0),
          i.lookAt(-1, 0, 0),
          o.up.set(0, 0, -1),
          o.lookAt(0, 1, 0),
          a.up.set(0, 0, 1),
          a.lookAt(0, -1, 0),
          s.up.set(0, 1, 0),
          s.lookAt(0, 0, 1),
          l.up.set(0, 1, 0),
          l.lookAt(0, 0, -1)
      else if (t === Sv)
        r.up.set(0, -1, 0),
          r.lookAt(-1, 0, 0),
          i.up.set(0, -1, 0),
          i.lookAt(1, 0, 0),
          o.up.set(0, 0, 1),
          o.lookAt(0, 1, 0),
          a.up.set(0, 0, -1),
          a.lookAt(0, -1, 0),
          s.up.set(0, -1, 0),
          s.lookAt(0, 0, 1),
          l.up.set(0, -1, 0),
          l.lookAt(0, 0, -1)
      else
        throw new Error(
          'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
            t
        )
      for (const c of n) this.add(c), c.updateMatrixWorld()
    }
    update(t, n) {
      this.parent === null && this.updateMatrixWorld()
      const r = this.renderTarget
      this.coordinateSystem !== t.coordinateSystem &&
        ((this.coordinateSystem = t.coordinateSystem),
        this.updateCoordinateSystem())
      const [i, o, a, s, l, c] = this.children,
        d = t.getRenderTarget(),
        h = t.toneMapping,
        p = t.xr.enabled
      ;(t.toneMapping = Ba), (t.xr.enabled = !1)
      const v = r.texture.generateMipmaps
      ;(r.texture.generateMipmaps = !1),
        t.setRenderTarget(r, 0),
        t.render(n, i),
        t.setRenderTarget(r, 1),
        t.render(n, o),
        t.setRenderTarget(r, 2),
        t.render(n, a),
        t.setRenderTarget(r, 3),
        t.render(n, s),
        t.setRenderTarget(r, 4),
        t.render(n, l),
        (r.texture.generateMipmaps = v),
        t.setRenderTarget(r, 5),
        t.render(n, c),
        t.setRenderTarget(d),
        (t.toneMapping = h),
        (t.xr.enabled = p),
        (r.texture.needsPMREMUpdate = !0)
    }
  }
  class g$ extends Ei {
    constructor(t, n, r, i, o, a, s, l, c, d) {
      ;(t = t !== void 0 ? t : []),
        (n = n !== void 0 ? n : Yu),
        super(t, n, r, i, o, a, s, l, c, d),
        (this.isCubeTexture = !0),
        (this.flipY = !1)
    }
    get images() {
      return this.image
    }
    set images(t) {
      this.image = t
    }
  }
  class mle extends El {
    constructor(t = 1, n = {}) {
      super(t, t, n), (this.isWebGLCubeRenderTarget = !0)
      const r = { width: t, height: t, depth: 1 },
        i = [r, r, r, r, r, r]
      n.encoding !== void 0 &&
        (Sd(
          'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.'
        ),
        (n.colorSpace = n.encoding === Fa ? rn : Cl)),
        (this.texture = new g$(
          i,
          n.mapping,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
        (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : eo)
    }
    fromEquirectangularTexture(t, n) {
      ;(this.texture.type = n.type),
        (this.texture.colorSpace = n.colorSpace),
        (this.texture.generateMipmaps = n.generateMipmaps),
        (this.texture.minFilter = n.minFilter),
        (this.texture.magFilter = n.magFilter)
      const r = {
          uniforms: { tEquirect: { value: null } },
          vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
        },
        i = new of(5, 5, 5),
        o = new Os({
          name: 'CubemapFromEquirect',
          uniforms: Qu(r.uniforms),
          vertexShader: r.vertexShader,
          fragmentShader: r.fragmentShader,
          side: Mi,
          blending: Ms,
        })
      o.uniforms.tEquirect.value = n
      const a = new Ci(i, o),
        s = n.minFilter
      return (
        n.minFilter === Dd && (n.minFilter = eo),
        new vle(1, 10, this).update(t, a),
        (n.minFilter = s),
        a.geometry.dispose(),
        a.material.dispose(),
        this
      )
    }
    clear(t, n, r, i) {
      const o = t.getRenderTarget()
      for (let a = 0; a < 6; a++) t.setRenderTarget(this, a), t.clear(n, r, i)
      t.setRenderTarget(o)
    }
  }
  const V1 = new Pe(),
    gle = new Pe(),
    yle = new cn()
  class rl {
    constructor(t = new Pe(1, 0, 0), n = 0) {
      ;(this.isPlane = !0), (this.normal = t), (this.constant = n)
    }
    set(t, n) {
      return this.normal.copy(t), (this.constant = n), this
    }
    setComponents(t, n, r, i) {
      return this.normal.set(t, n, r), (this.constant = i), this
    }
    setFromNormalAndCoplanarPoint(t, n) {
      return this.normal.copy(t), (this.constant = -n.dot(this.normal)), this
    }
    setFromCoplanarPoints(t, n, r) {
      const i = V1.subVectors(r, n).cross(gle.subVectors(t, n)).normalize()
      return this.setFromNormalAndCoplanarPoint(i, t), this
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this
    }
    normalize() {
      const t = 1 / this.normal.length()
      return this.normal.multiplyScalar(t), (this.constant *= t), this
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius
    }
    projectPoint(t, n) {
      return n.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
    }
    intersectLine(t, n) {
      const r = t.delta(V1),
        i = this.normal.dot(r)
      if (i === 0)
        return this.distanceToPoint(t.start) === 0 ? n.copy(t.start) : null
      const o = -(t.start.dot(this.normal) + this.constant) / i
      return o < 0 || o > 1 ? null : n.copy(t.start).addScaledVector(r, o)
    }
    intersectsLine(t) {
      const n = this.distanceToPoint(t.start),
        r = this.distanceToPoint(t.end)
      return (n < 0 && r > 0) || (r < 0 && n > 0)
    }
    intersectsBox(t) {
      return t.intersectsPlane(this)
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this)
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(t, n) {
      const r = n || yle.getNormalMatrix(t),
        i = this.coplanarPoint(V1).applyMatrix4(t),
        o = this.normal.applyMatrix3(r).normalize()
      return (this.constant = -i.dot(o)), this
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  const tl = new rf(),
    Ih = new Pe()
  class LS {
    constructor(
      t = new rl(),
      n = new rl(),
      r = new rl(),
      i = new rl(),
      o = new rl(),
      a = new rl()
    ) {
      this.planes = [t, n, r, i, o, a]
    }
    set(t, n, r, i, o, a) {
      const s = this.planes
      return (
        s[0].copy(t),
        s[1].copy(n),
        s[2].copy(r),
        s[3].copy(i),
        s[4].copy(o),
        s[5].copy(a),
        this
      )
    }
    copy(t) {
      const n = this.planes
      for (let r = 0; r < 6; r++) n[r].copy(t.planes[r])
      return this
    }
    setFromProjectionMatrix(t, n = Ia) {
      const r = this.planes,
        i = t.elements,
        o = i[0],
        a = i[1],
        s = i[2],
        l = i[3],
        c = i[4],
        d = i[5],
        h = i[6],
        p = i[7],
        v = i[8],
        g = i[9],
        _ = i[10],
        b = i[11],
        y = i[12],
        M = i[13],
        x = i[14],
        w = i[15]
      if (
        (r[0].setComponents(l - o, p - c, b - v, w - y).normalize(),
        r[1].setComponents(l + o, p + c, b + v, w + y).normalize(),
        r[2].setComponents(l + a, p + d, b + g, w + M).normalize(),
        r[3].setComponents(l - a, p - d, b - g, w - M).normalize(),
        r[4].setComponents(l - s, p - h, b - _, w - x).normalize(),
        n === Ia)
      )
        r[5].setComponents(l + s, p + h, b + _, w + x).normalize()
      else if (n === Sv) r[5].setComponents(s, h, _, x).normalize()
      else
        throw new Error(
          'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
            n
        )
      return this
    }
    intersectsObject(t) {
      if (t.boundingSphere !== void 0)
        t.boundingSphere === null && t.computeBoundingSphere(),
          tl.copy(t.boundingSphere).applyMatrix4(t.matrixWorld)
      else {
        const n = t.geometry
        n.boundingSphere === null && n.computeBoundingSphere(),
          tl.copy(n.boundingSphere).applyMatrix4(t.matrixWorld)
      }
      return this.intersectsSphere(tl)
    }
    intersectsSprite(t) {
      return (
        tl.center.set(0, 0, 0),
        (tl.radius = 0.7071067811865476),
        tl.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(tl)
      )
    }
    intersectsSphere(t) {
      const n = this.planes,
        r = t.center,
        i = -t.radius
      for (let o = 0; o < 6; o++) if (n[o].distanceToPoint(r) < i) return !1
      return !0
    }
    intersectsBox(t) {
      const n = this.planes
      for (let r = 0; r < 6; r++) {
        const i = n[r]
        if (
          ((Ih.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (Ih.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (Ih.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(Ih) < 0)
        )
          return !1
      }
      return !0
    }
    containsPoint(t) {
      const n = this.planes
      for (let r = 0; r < 6; r++) if (n[r].distanceToPoint(t) < 0) return !1
      return !0
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  function y$() {
    let e = null,
      t = !1,
      n = null,
      r = null
    function i(o, a) {
      n(o, a), (r = e.requestAnimationFrame(i))
    }
    return {
      start: function () {
        t !== !0 && n !== null && ((r = e.requestAnimationFrame(i)), (t = !0))
      },
      stop: function () {
        e.cancelAnimationFrame(r), (t = !1)
      },
      setAnimationLoop: function (o) {
        n = o
      },
      setContext: function (o) {
        e = o
      },
    }
  }
  function ble(e, t) {
    const n = t.isWebGL2,
      r = new WeakMap()
    function i(c, d) {
      const h = c.array,
        p = c.usage,
        v = e.createBuffer()
      e.bindBuffer(d, v), e.bufferData(d, h, p), c.onUploadCallback()
      let g
      if (h instanceof Float32Array) g = e.FLOAT
      else if (h instanceof Uint16Array)
        if (c.isFloat16BufferAttribute)
          if (n) g = e.HALF_FLOAT
          else
            throw new Error(
              'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
            )
        else g = e.UNSIGNED_SHORT
      else if (h instanceof Int16Array) g = e.SHORT
      else if (h instanceof Uint32Array) g = e.UNSIGNED_INT
      else if (h instanceof Int32Array) g = e.INT
      else if (h instanceof Int8Array) g = e.BYTE
      else if (h instanceof Uint8Array) g = e.UNSIGNED_BYTE
      else if (h instanceof Uint8ClampedArray) g = e.UNSIGNED_BYTE
      else
        throw new Error(
          'THREE.WebGLAttributes: Unsupported buffer data format: ' + h
        )
      return {
        buffer: v,
        type: g,
        bytesPerElement: h.BYTES_PER_ELEMENT,
        version: c.version,
      }
    }
    function o(c, d, h) {
      const p = d.array,
        v = d.updateRange
      e.bindBuffer(h, c),
        v.count === -1
          ? e.bufferSubData(h, 0, p)
          : (n
              ? e.bufferSubData(
                  h,
                  v.offset * p.BYTES_PER_ELEMENT,
                  p,
                  v.offset,
                  v.count
                )
              : e.bufferSubData(
                  h,
                  v.offset * p.BYTES_PER_ELEMENT,
                  p.subarray(v.offset, v.offset + v.count)
                ),
            (v.count = -1)),
        d.onUploadCallback()
    }
    function a(c) {
      return c.isInterleavedBufferAttribute && (c = c.data), r.get(c)
    }
    function s(c) {
      c.isInterleavedBufferAttribute && (c = c.data)
      const d = r.get(c)
      d && (e.deleteBuffer(d.buffer), r.delete(c))
    }
    function l(c, d) {
      if (c.isGLBufferAttribute) {
        const p = r.get(c)
        ;(!p || p.version < c.version) &&
          r.set(c, {
            buffer: c.buffer,
            type: c.type,
            bytesPerElement: c.elementSize,
            version: c.version,
          })
        return
      }
      c.isInterleavedBufferAttribute && (c = c.data)
      const h = r.get(c)
      h === void 0
        ? r.set(c, i(c, d))
        : h.version < c.version && (o(h.buffer, c, d), (h.version = c.version))
    }
    return { get: a, remove: s, update: l }
  }
  class cl extends la {
    constructor(t = 1, n = 1, r = 1, i = 1) {
      super(),
        (this.type = 'PlaneGeometry'),
        (this.parameters = {
          width: t,
          height: n,
          widthSegments: r,
          heightSegments: i,
        })
      const o = t / 2,
        a = n / 2,
        s = Math.floor(r),
        l = Math.floor(i),
        c = s + 1,
        d = l + 1,
        h = t / s,
        p = n / l,
        v = [],
        g = [],
        _ = [],
        b = []
      for (let y = 0; y < d; y++) {
        const M = y * p - a
        for (let x = 0; x < c; x++) {
          const w = x * h - o
          g.push(w, -M, 0), _.push(0, 0, 1), b.push(x / s), b.push(1 - y / l)
        }
      }
      for (let y = 0; y < l; y++)
        for (let M = 0; M < s; M++) {
          const x = M + c * y,
            w = M + c * (y + 1),
            E = M + 1 + c * (y + 1),
            P = M + 1 + c * y
          v.push(x, w, P), v.push(w, E, P)
        }
      this.setIndex(v),
        this.setAttribute('position', new so(g, 3)),
        this.setAttribute('normal', new so(_, 3)),
        this.setAttribute('uv', new so(b, 2))
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      )
    }
    static fromJSON(t) {
      return new cl(t.width, t.height, t.widthSegments, t.heightSegments)
    }
  }
  var _le = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    Sle = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Cle = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    wle = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    xle = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    Mle = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    Ele = 'vec3 transformed = vec3( position );',
    Ple = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    Tle = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    kle = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    Ale = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    $le = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    Ole = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    Lle = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    Ile = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    Rle = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    Dle = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    Nle = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    Ble = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    Fle = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    zle = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    Vle = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    Ule = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    Hle = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    Wle = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    jle = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    Gle = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
    Kle = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    qle = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    Xle = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    Yle = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    Zle = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    Jle = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    Qle = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    eue = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    tue = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    nue = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    rue = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    iue = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    oue = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    aue = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    sue = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    lue = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    uue = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    cue = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    due = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    fue = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    hue = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    pue = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
    vue = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    mue = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    gue = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    yue = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
    bue = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    _ue = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    Sue = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    Cue = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    wue = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
    xue = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    Mue = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    Eue = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Pue = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    Tue = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    kue = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    Aue = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    $ue = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    Oue = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    Lue = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
    Iue = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    Rue = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    Due = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    Nue = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    Bue = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    Fue = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
    zue = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    Vue = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    Uue = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    Hue = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    Wue = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    jue = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    Gue = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    Kue = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    que = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    Xue = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    Yue = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    Zue = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    Jue = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    Que = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    ece = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    tce = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    nce = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
    rce = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    ice = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    oce = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    ace = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    sce = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    lce = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    uce = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    cce = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    dce = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    fce = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    hce = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    pce = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
  const vce = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    mce = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    gce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    yce = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    bce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    _ce = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    Sce = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    Cce = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    wce = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    xce = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    Mce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    Ece = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    Pce = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    Tce = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    kce = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    Ace = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    $ce = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Oce = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Lce = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    Ice = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Rce = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    Dce = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    Nce = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Bce = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Fce = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    zce = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Vce = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Uce = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Hce = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    Wce = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    jce = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Gce = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    Kce = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    qce = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    an = {
      alphamap_fragment: _le,
      alphamap_pars_fragment: Sle,
      alphatest_fragment: Cle,
      alphatest_pars_fragment: wle,
      aomap_fragment: xle,
      aomap_pars_fragment: Mle,
      begin_vertex: Ele,
      beginnormal_vertex: Ple,
      bsdfs: Tle,
      iridescence_fragment: kle,
      bumpmap_pars_fragment: Ale,
      clipping_planes_fragment: $le,
      clipping_planes_pars_fragment: Ole,
      clipping_planes_pars_vertex: Lle,
      clipping_planes_vertex: Ile,
      color_fragment: Rle,
      color_pars_fragment: Dle,
      color_pars_vertex: Nle,
      color_vertex: Ble,
      common: Fle,
      cube_uv_reflection_fragment: zle,
      defaultnormal_vertex: Vle,
      displacementmap_pars_vertex: Ule,
      displacementmap_vertex: Hle,
      emissivemap_fragment: Wle,
      emissivemap_pars_fragment: jle,
      encodings_fragment: Gle,
      encodings_pars_fragment: Kle,
      envmap_fragment: qle,
      envmap_common_pars_fragment: Xle,
      envmap_pars_fragment: Yle,
      envmap_pars_vertex: Zle,
      envmap_physical_pars_fragment: uue,
      envmap_vertex: Jle,
      fog_vertex: Qle,
      fog_pars_vertex: eue,
      fog_fragment: tue,
      fog_pars_fragment: nue,
      gradientmap_pars_fragment: rue,
      lightmap_fragment: iue,
      lightmap_pars_fragment: oue,
      lights_lambert_fragment: aue,
      lights_lambert_pars_fragment: sue,
      lights_pars_begin: lue,
      lights_toon_fragment: cue,
      lights_toon_pars_fragment: due,
      lights_phong_fragment: fue,
      lights_phong_pars_fragment: hue,
      lights_physical_fragment: pue,
      lights_physical_pars_fragment: vue,
      lights_fragment_begin: mue,
      lights_fragment_maps: gue,
      lights_fragment_end: yue,
      logdepthbuf_fragment: bue,
      logdepthbuf_pars_fragment: _ue,
      logdepthbuf_pars_vertex: Sue,
      logdepthbuf_vertex: Cue,
      map_fragment: wue,
      map_pars_fragment: xue,
      map_particle_fragment: Mue,
      map_particle_pars_fragment: Eue,
      metalnessmap_fragment: Pue,
      metalnessmap_pars_fragment: Tue,
      morphcolor_vertex: kue,
      morphnormal_vertex: Aue,
      morphtarget_pars_vertex: $ue,
      morphtarget_vertex: Oue,
      normal_fragment_begin: Lue,
      normal_fragment_maps: Iue,
      normal_pars_fragment: Rue,
      normal_pars_vertex: Due,
      normal_vertex: Nue,
      normalmap_pars_fragment: Bue,
      clearcoat_normal_fragment_begin: Fue,
      clearcoat_normal_fragment_maps: zue,
      clearcoat_pars_fragment: Vue,
      iridescence_pars_fragment: Uue,
      output_fragment: Hue,
      packing: Wue,
      premultiplied_alpha_fragment: jue,
      project_vertex: Gue,
      dithering_fragment: Kue,
      dithering_pars_fragment: que,
      roughnessmap_fragment: Xue,
      roughnessmap_pars_fragment: Yue,
      shadowmap_pars_fragment: Zue,
      shadowmap_pars_vertex: Jue,
      shadowmap_vertex: Que,
      shadowmask_pars_fragment: ece,
      skinbase_vertex: tce,
      skinning_pars_vertex: nce,
      skinning_vertex: rce,
      skinnormal_vertex: ice,
      specularmap_fragment: oce,
      specularmap_pars_fragment: ace,
      tonemapping_fragment: sce,
      tonemapping_pars_fragment: lce,
      transmission_fragment: uce,
      transmission_pars_fragment: cce,
      uv_pars_fragment: dce,
      uv_pars_vertex: fce,
      uv_vertex: hce,
      worldpos_vertex: pce,
      background_vert: vce,
      background_frag: mce,
      backgroundCube_vert: gce,
      backgroundCube_frag: yce,
      cube_vert: bce,
      cube_frag: _ce,
      depth_vert: Sce,
      depth_frag: Cce,
      distanceRGBA_vert: wce,
      distanceRGBA_frag: xce,
      equirect_vert: Mce,
      equirect_frag: Ece,
      linedashed_vert: Pce,
      linedashed_frag: Tce,
      meshbasic_vert: kce,
      meshbasic_frag: Ace,
      meshlambert_vert: $ce,
      meshlambert_frag: Oce,
      meshmatcap_vert: Lce,
      meshmatcap_frag: Ice,
      meshnormal_vert: Rce,
      meshnormal_frag: Dce,
      meshphong_vert: Nce,
      meshphong_frag: Bce,
      meshphysical_vert: Fce,
      meshphysical_frag: zce,
      meshtoon_vert: Vce,
      meshtoon_frag: Uce,
      points_vert: Hce,
      points_frag: Wce,
      shadow_vert: jce,
      shadow_frag: Gce,
      sprite_vert: Kce,
      sprite_frag: qce,
    },
    Pt = {
      common: {
        diffuse: { value: new xn(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: new cn() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new cn() },
        alphaTest: { value: 0 },
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: new cn() },
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: new cn() },
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: new cn() },
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: new cn() },
        bumpScale: { value: 1 },
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: new cn() },
        normalScale: { value: new Ct(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: new cn() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: new cn() },
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: new cn() },
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: new cn() },
      },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new xn(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new xn(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: new cn() },
        alphaTest: { value: 0 },
        uvTransform: { value: new cn() },
      },
      sprite: {
        diffuse: { value: new xn(16777215) },
        opacity: { value: 1 },
        center: { value: new Ct(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: new cn() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new cn() },
        alphaTest: { value: 0 },
      },
    },
    Si = {
      basic: {
        uniforms: si([
          Pt.common,
          Pt.specularmap,
          Pt.envmap,
          Pt.aomap,
          Pt.lightmap,
          Pt.fog,
        ]),
        vertexShader: an.meshbasic_vert,
        fragmentShader: an.meshbasic_frag,
      },
      lambert: {
        uniforms: si([
          Pt.common,
          Pt.specularmap,
          Pt.envmap,
          Pt.aomap,
          Pt.lightmap,
          Pt.emissivemap,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          Pt.fog,
          Pt.lights,
          { emissive: { value: new xn(0) } },
        ]),
        vertexShader: an.meshlambert_vert,
        fragmentShader: an.meshlambert_frag,
      },
      phong: {
        uniforms: si([
          Pt.common,
          Pt.specularmap,
          Pt.envmap,
          Pt.aomap,
          Pt.lightmap,
          Pt.emissivemap,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          Pt.fog,
          Pt.lights,
          {
            emissive: { value: new xn(0) },
            specular: { value: new xn(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: an.meshphong_vert,
        fragmentShader: an.meshphong_frag,
      },
      standard: {
        uniforms: si([
          Pt.common,
          Pt.envmap,
          Pt.aomap,
          Pt.lightmap,
          Pt.emissivemap,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          Pt.roughnessmap,
          Pt.metalnessmap,
          Pt.fog,
          Pt.lights,
          {
            emissive: { value: new xn(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: an.meshphysical_vert,
        fragmentShader: an.meshphysical_frag,
      },
      toon: {
        uniforms: si([
          Pt.common,
          Pt.aomap,
          Pt.lightmap,
          Pt.emissivemap,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          Pt.gradientmap,
          Pt.fog,
          Pt.lights,
          { emissive: { value: new xn(0) } },
        ]),
        vertexShader: an.meshtoon_vert,
        fragmentShader: an.meshtoon_frag,
      },
      matcap: {
        uniforms: si([
          Pt.common,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          Pt.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: an.meshmatcap_vert,
        fragmentShader: an.meshmatcap_frag,
      },
      points: {
        uniforms: si([Pt.points, Pt.fog]),
        vertexShader: an.points_vert,
        fragmentShader: an.points_frag,
      },
      dashed: {
        uniforms: si([
          Pt.common,
          Pt.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: an.linedashed_vert,
        fragmentShader: an.linedashed_frag,
      },
      depth: {
        uniforms: si([Pt.common, Pt.displacementmap]),
        vertexShader: an.depth_vert,
        fragmentShader: an.depth_frag,
      },
      normal: {
        uniforms: si([
          Pt.common,
          Pt.bumpmap,
          Pt.normalmap,
          Pt.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: an.meshnormal_vert,
        fragmentShader: an.meshnormal_frag,
      },
      sprite: {
        uniforms: si([Pt.sprite, Pt.fog]),
        vertexShader: an.sprite_vert,
        fragmentShader: an.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new cn() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: an.background_vert,
        fragmentShader: an.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: an.backgroundCube_vert,
        fragmentShader: an.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: an.cube_vert,
        fragmentShader: an.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: an.equirect_vert,
        fragmentShader: an.equirect_frag,
      },
      distanceRGBA: {
        uniforms: si([
          Pt.common,
          Pt.displacementmap,
          {
            referencePosition: { value: new Pe() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: an.distanceRGBA_vert,
        fragmentShader: an.distanceRGBA_frag,
      },
      shadow: {
        uniforms: si([
          Pt.lights,
          Pt.fog,
          { color: { value: new xn(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: an.shadow_vert,
        fragmentShader: an.shadow_frag,
      },
    }
  Si.physical = {
    uniforms: si([
      Si.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: new cn() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: new cn() },
        clearcoatNormalScale: { value: new Ct(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: new cn() },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: new cn() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: new cn() },
        sheen: { value: 0 },
        sheenColor: { value: new xn(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: new cn() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: new cn() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: new cn() },
        transmissionSamplerSize: { value: new Ct() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: new cn() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new xn(0) },
        specularColor: { value: new xn(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: new cn() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: new cn() },
        anisotropyVector: { value: new Ct() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: new cn() },
      },
    ]),
    vertexShader: an.meshphysical_vert,
    fragmentShader: an.meshphysical_frag,
  }
  const Rh = { r: 0, b: 0, g: 0 }
  function Xce(e, t, n, r, i, o, a) {
    const s = new xn(0)
    let l = o === !0 ? 0 : 1,
      c,
      d,
      h = null,
      p = 0,
      v = null
    function g(b, y) {
      let M = !1,
        x = y.isScene === !0 ? y.background : null
      switch (
        (x && x.isTexture && (x = (y.backgroundBlurriness > 0 ? n : t).get(x)),
        x === null ? _(s, l) : x && x.isColor && (_(x, 1), (M = !0)),
        e.xr.getEnvironmentBlendMode())
      ) {
        case 'opaque':
          M = !0
          break
        case 'additive':
          r.buffers.color.setClear(0, 0, 0, 1, a), (M = !0)
          break
        case 'alpha-blend':
          r.buffers.color.setClear(0, 0, 0, 0, a), (M = !0)
          break
      }
      ;(e.autoClear || M) &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
        x && (x.isCubeTexture || x.mapping === dm)
          ? (d === void 0 &&
              ((d = new Ci(
                new of(1, 1, 1),
                new Os({
                  name: 'BackgroundCubeMaterial',
                  uniforms: Qu(Si.backgroundCube.uniforms),
                  vertexShader: Si.backgroundCube.vertexShader,
                  fragmentShader: Si.backgroundCube.fragmentShader,
                  side: Mi,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              d.geometry.deleteAttribute('normal'),
              d.geometry.deleteAttribute('uv'),
              (d.onBeforeRender = function (P, A, F) {
                this.matrixWorld.copyPosition(F.matrixWorld)
              }),
              Object.defineProperty(d.material, 'envMap', {
                get: function () {
                  return this.uniforms.envMap.value
                },
              }),
              i.update(d)),
            (d.material.uniforms.envMap.value = x),
            (d.material.uniforms.flipEnvMap.value =
              x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
            (d.material.uniforms.backgroundBlurriness.value =
              y.backgroundBlurriness),
            (d.material.uniforms.backgroundIntensity.value =
              y.backgroundIntensity),
            (d.material.toneMapped = x.colorSpace !== rn),
            (h !== x || p !== x.version || v !== e.toneMapping) &&
              ((d.material.needsUpdate = !0),
              (h = x),
              (p = x.version),
              (v = e.toneMapping)),
            d.layers.enableAll(),
            b.unshift(d, d.geometry, d.material, 0, 0, null))
          : x &&
            x.isTexture &&
            (c === void 0 &&
              ((c = new Ci(
                new cl(2, 2),
                new Os({
                  name: 'BackgroundMaterial',
                  uniforms: Qu(Si.background.uniforms),
                  vertexShader: Si.background.vertexShader,
                  fragmentShader: Si.background.fragmentShader,
                  side: $s,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              c.geometry.deleteAttribute('normal'),
              Object.defineProperty(c.material, 'map', {
                get: function () {
                  return this.uniforms.t2D.value
                },
              }),
              i.update(c)),
            (c.material.uniforms.t2D.value = x),
            (c.material.uniforms.backgroundIntensity.value =
              y.backgroundIntensity),
            (c.material.toneMapped = x.colorSpace !== rn),
            x.matrixAutoUpdate === !0 && x.updateMatrix(),
            c.material.uniforms.uvTransform.value.copy(x.matrix),
            (h !== x || p !== x.version || v !== e.toneMapping) &&
              ((c.material.needsUpdate = !0),
              (h = x),
              (p = x.version),
              (v = e.toneMapping)),
            c.layers.enableAll(),
            b.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function _(b, y) {
      b.getRGB(Rh, v$(e)), r.buffers.color.setClear(Rh.r, Rh.g, Rh.b, y, a)
    }
    return {
      getClearColor: function () {
        return s
      },
      setClearColor: function (b, y = 1) {
        s.set(b), (l = y), _(s, l)
      },
      getClearAlpha: function () {
        return l
      },
      setClearAlpha: function (b) {
        ;(l = b), _(s, l)
      },
      render: g,
    }
  }
  function Yce(e, t, n, r) {
    const i = e.getParameter(e.MAX_VERTEX_ATTRIBS),
      o = r.isWebGL2 ? null : t.get('OES_vertex_array_object'),
      a = r.isWebGL2 || o !== null,
      s = {},
      l = b(null)
    let c = l,
      d = !1
    function h(I, B, V, L, W) {
      let Y = !1
      if (a) {
        const U = _(L, V, B)
        c !== U && ((c = U), v(c.object)),
          (Y = y(I, L, V, W)),
          Y && M(I, L, V, W)
      } else {
        const U = B.wireframe === !0
        ;(c.geometry !== L.id || c.program !== V.id || c.wireframe !== U) &&
          ((c.geometry = L.id), (c.program = V.id), (c.wireframe = U), (Y = !0))
      }
      W !== null && n.update(W, e.ELEMENT_ARRAY_BUFFER),
        (Y || d) &&
          ((d = !1),
          F(I, B, V, L),
          W !== null && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(W).buffer))
    }
    function p() {
      return r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()
    }
    function v(I) {
      return r.isWebGL2 ? e.bindVertexArray(I) : o.bindVertexArrayOES(I)
    }
    function g(I) {
      return r.isWebGL2 ? e.deleteVertexArray(I) : o.deleteVertexArrayOES(I)
    }
    function _(I, B, V) {
      const L = V.wireframe === !0
      let W = s[I.id]
      W === void 0 && ((W = {}), (s[I.id] = W))
      let Y = W[B.id]
      Y === void 0 && ((Y = {}), (W[B.id] = Y))
      let U = Y[L]
      return U === void 0 && ((U = b(p())), (Y[L] = U)), U
    }
    function b(I) {
      const B = [],
        V = [],
        L = []
      for (let W = 0; W < i; W++) (B[W] = 0), (V[W] = 0), (L[W] = 0)
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: B,
        enabledAttributes: V,
        attributeDivisors: L,
        object: I,
        attributes: {},
        index: null,
      }
    }
    function y(I, B, V, L) {
      const W = c.attributes,
        Y = B.attributes
      let U = 0
      const le = V.getAttributes()
      for (const q in le)
        if (le[q].location >= 0) {
          const te = W[q]
          let ue = Y[q]
          if (
            (ue === void 0 &&
              (q === 'instanceMatrix' &&
                I.instanceMatrix &&
                (ue = I.instanceMatrix),
              q === 'instanceColor' &&
                I.instanceColor &&
                (ue = I.instanceColor)),
            te === void 0 || te.attribute !== ue || (ue && te.data !== ue.data))
          )
            return !0
          U++
        }
      return c.attributesNum !== U || c.index !== L
    }
    function M(I, B, V, L) {
      const W = {},
        Y = B.attributes
      let U = 0
      const le = V.getAttributes()
      for (const q in le)
        if (le[q].location >= 0) {
          let te = Y[q]
          te === void 0 &&
            (q === 'instanceMatrix' &&
              I.instanceMatrix &&
              (te = I.instanceMatrix),
            q === 'instanceColor' && I.instanceColor && (te = I.instanceColor))
          const ue = {}
          ;(ue.attribute = te),
            te && te.data && (ue.data = te.data),
            (W[q] = ue),
            U++
        }
      ;(c.attributes = W), (c.attributesNum = U), (c.index = L)
    }
    function x() {
      const I = c.newAttributes
      for (let B = 0, V = I.length; B < V; B++) I[B] = 0
    }
    function w(I) {
      E(I, 0)
    }
    function E(I, B) {
      const V = c.newAttributes,
        L = c.enabledAttributes,
        W = c.attributeDivisors
      ;(V[I] = 1),
        L[I] === 0 && (e.enableVertexAttribArray(I), (L[I] = 1)),
        W[I] !== B &&
          ((r.isWebGL2 ? e : t.get('ANGLE_instanced_arrays'))[
            r.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
          ](I, B),
          (W[I] = B))
    }
    function P() {
      const I = c.newAttributes,
        B = c.enabledAttributes
      for (let V = 0, L = B.length; V < L; V++)
        B[V] !== I[V] && (e.disableVertexAttribArray(V), (B[V] = 0))
    }
    function A(I, B, V, L, W, Y, U) {
      U === !0
        ? e.vertexAttribIPointer(I, B, V, W, Y)
        : e.vertexAttribPointer(I, B, V, L, W, Y)
    }
    function F(I, B, V, L) {
      if (
        r.isWebGL2 === !1 &&
        (I.isInstancedMesh || L.isInstancedBufferGeometry) &&
        t.get('ANGLE_instanced_arrays') === null
      )
        return
      x()
      const W = L.attributes,
        Y = V.getAttributes(),
        U = B.defaultAttributeValues
      for (const le in Y) {
        const q = Y[le]
        if (q.location >= 0) {
          let oe = W[le]
          if (
            (oe === void 0 &&
              (le === 'instanceMatrix' &&
                I.instanceMatrix &&
                (oe = I.instanceMatrix),
              le === 'instanceColor' &&
                I.instanceColor &&
                (oe = I.instanceColor)),
            oe !== void 0)
          ) {
            const te = oe.normalized,
              ue = oe.itemSize,
              me = n.get(oe)
            if (me === void 0) continue
            const Re = me.buffer,
              qe = me.type,
              Ve = me.bytesPerElement,
              nt =
                r.isWebGL2 === !0 &&
                (qe === e.INT || qe === e.UNSIGNED_INT || oe.gpuType === JA)
            if (oe.isInterleavedBufferAttribute) {
              const We = oe.data,
                D = We.stride,
                G = oe.offset
              if (We.isInstancedInterleavedBuffer) {
                for (let z = 0; z < q.locationSize; z++)
                  E(q.location + z, We.meshPerAttribute)
                I.isInstancedMesh !== !0 &&
                  L._maxInstanceCount === void 0 &&
                  (L._maxInstanceCount = We.meshPerAttribute * We.count)
              } else for (let z = 0; z < q.locationSize; z++) w(q.location + z)
              e.bindBuffer(e.ARRAY_BUFFER, Re)
              for (let z = 0; z < q.locationSize; z++)
                A(
                  q.location + z,
                  ue / q.locationSize,
                  qe,
                  te,
                  D * Ve,
                  (G + (ue / q.locationSize) * z) * Ve,
                  nt
                )
            } else {
              if (oe.isInstancedBufferAttribute) {
                for (let We = 0; We < q.locationSize; We++)
                  E(q.location + We, oe.meshPerAttribute)
                I.isInstancedMesh !== !0 &&
                  L._maxInstanceCount === void 0 &&
                  (L._maxInstanceCount = oe.meshPerAttribute * oe.count)
              } else
                for (let We = 0; We < q.locationSize; We++) w(q.location + We)
              e.bindBuffer(e.ARRAY_BUFFER, Re)
              for (let We = 0; We < q.locationSize; We++)
                A(
                  q.location + We,
                  ue / q.locationSize,
                  qe,
                  te,
                  ue * Ve,
                  (ue / q.locationSize) * We * Ve,
                  nt
                )
            }
          } else if (U !== void 0) {
            const te = U[le]
            if (te !== void 0)
              switch (te.length) {
                case 2:
                  e.vertexAttrib2fv(q.location, te)
                  break
                case 3:
                  e.vertexAttrib3fv(q.location, te)
                  break
                case 4:
                  e.vertexAttrib4fv(q.location, te)
                  break
                default:
                  e.vertexAttrib1fv(q.location, te)
              }
          }
        }
      }
      P()
    }
    function T() {
      j()
      for (const I in s) {
        const B = s[I]
        for (const V in B) {
          const L = B[V]
          for (const W in L) g(L[W].object), delete L[W]
          delete B[V]
        }
        delete s[I]
      }
    }
    function k(I) {
      if (s[I.id] === void 0) return
      const B = s[I.id]
      for (const V in B) {
        const L = B[V]
        for (const W in L) g(L[W].object), delete L[W]
        delete B[V]
      }
      delete s[I.id]
    }
    function R(I) {
      for (const B in s) {
        const V = s[B]
        if (V[I.id] === void 0) continue
        const L = V[I.id]
        for (const W in L) g(L[W].object), delete L[W]
        delete V[I.id]
      }
    }
    function j() {
      N(), (d = !0), c !== l && ((c = l), v(c.object))
    }
    function N() {
      ;(l.geometry = null), (l.program = null), (l.wireframe = !1)
    }
    return {
      setup: h,
      reset: j,
      resetDefaultState: N,
      dispose: T,
      releaseStatesOfGeometry: k,
      releaseStatesOfProgram: R,
      initAttributes: x,
      enableAttribute: w,
      disableUnusedAttributes: P,
    }
  }
  function Zce(e, t, n, r) {
    const i = r.isWebGL2
    let o
    function a(c) {
      o = c
    }
    function s(c, d) {
      e.drawArrays(o, c, d), n.update(d, o, 1)
    }
    function l(c, d, h) {
      if (h === 0) return
      let p, v
      if (i) (p = e), (v = 'drawArraysInstanced')
      else if (
        ((p = t.get('ANGLE_instanced_arrays')),
        (v = 'drawArraysInstancedANGLE'),
        p === null)
      ) {
        console.error(
          'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
        )
        return
      }
      p[v](o, c, d, h), n.update(d, o, h)
    }
    ;(this.setMode = a), (this.render = s), (this.renderInstances = l)
  }
  function Jce(e, t, n) {
    let r
    function i() {
      if (r !== void 0) return r
      if (t.has('EXT_texture_filter_anisotropic') === !0) {
        const A = t.get('EXT_texture_filter_anisotropic')
        r = e.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      } else r = 0
      return r
    }
    function o(A) {
      if (A === 'highp') {
        if (
          e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision >
            0 &&
          e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT)
            .precision > 0
        )
          return 'highp'
        A = 'mediump'
      }
      return A === 'mediump' &&
        e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision >
          0 &&
        e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT)
          .precision > 0
        ? 'mediump'
        : 'lowp'
    }
    const a =
      typeof WebGL2RenderingContext < 'u' &&
      e.constructor.name === 'WebGL2RenderingContext'
    let s = n.precision !== void 0 ? n.precision : 'highp'
    const l = o(s)
    l !== s &&
      (console.warn(
        'THREE.WebGLRenderer:',
        s,
        'not supported, using',
        l,
        'instead.'
      ),
      (s = l))
    const c = a || t.has('WEBGL_draw_buffers'),
      d = n.logarithmicDepthBuffer === !0,
      h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
      p = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      v = e.getParameter(e.MAX_TEXTURE_SIZE),
      g = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
      _ = e.getParameter(e.MAX_VERTEX_ATTRIBS),
      b = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
      y = e.getParameter(e.MAX_VARYING_VECTORS),
      M = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
      x = p > 0,
      w = a || t.has('OES_texture_float'),
      E = x && w,
      P = a ? e.getParameter(e.MAX_SAMPLES) : 0
    return {
      isWebGL2: a,
      drawBuffers: c,
      getMaxAnisotropy: i,
      getMaxPrecision: o,
      precision: s,
      logarithmicDepthBuffer: d,
      maxTextures: h,
      maxVertexTextures: p,
      maxTextureSize: v,
      maxCubemapSize: g,
      maxAttributes: _,
      maxVertexUniforms: b,
      maxVaryings: y,
      maxFragmentUniforms: M,
      vertexTextures: x,
      floatFragmentTextures: w,
      floatVertexTextures: E,
      maxSamples: P,
    }
  }
  function Qce(e) {
    const t = this
    let n = null,
      r = 0,
      i = !1,
      o = !1
    const a = new rl(),
      s = new cn(),
      l = { value: null, needsUpdate: !1 }
    ;(this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (h, p) {
        const v = h.length !== 0 || p || r !== 0 || i
        return (i = p), (r = h.length), v
      }),
      (this.beginShadows = function () {
        ;(o = !0), d(null)
      }),
      (this.endShadows = function () {
        o = !1
      }),
      (this.setGlobalState = function (h, p) {
        n = d(h, p, 0)
      }),
      (this.setState = function (h, p, v) {
        const g = h.clippingPlanes,
          _ = h.clipIntersection,
          b = h.clipShadows,
          y = e.get(h)
        if (!i || g === null || g.length === 0 || (o && !b)) o ? d(null) : c()
        else {
          const M = o ? 0 : r,
            x = M * 4
          let w = y.clippingState || null
          ;(l.value = w), (w = d(g, p, x, v))
          for (let E = 0; E !== x; ++E) w[E] = n[E]
          ;(y.clippingState = w),
            (this.numIntersection = _ ? this.numPlanes : 0),
            (this.numPlanes += M)
        }
      })
    function c() {
      l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
        (t.numPlanes = r),
        (t.numIntersection = 0)
    }
    function d(h, p, v, g) {
      const _ = h !== null ? h.length : 0
      let b = null
      if (_ !== 0) {
        if (((b = l.value), g !== !0 || b === null)) {
          const y = v + _ * 4,
            M = p.matrixWorldInverse
          s.getNormalMatrix(M),
            (b === null || b.length < y) && (b = new Float32Array(y))
          for (let x = 0, w = v; x !== _; ++x, w += 4)
            a.copy(h[x]).applyMatrix4(M, s),
              a.normal.toArray(b, w),
              (b[w + 3] = a.constant)
        }
        ;(l.value = b), (l.needsUpdate = !0)
      }
      return (t.numPlanes = _), (t.numIntersection = 0), b
    }
  }
  function ede(e) {
    let t = new WeakMap()
    function n(a, s) {
      return s === jb ? (a.mapping = Yu) : s === Gb && (a.mapping = Zu), a
    }
    function r(a) {
      if (a && a.isTexture && a.isRenderTargetTexture === !1) {
        const s = a.mapping
        if (s === jb || s === Gb)
          if (t.has(a)) {
            const l = t.get(a).texture
            return n(l, a.mapping)
          } else {
            const l = a.image
            if (l && l.height > 0) {
              const c = new mle(l.height / 2)
              return (
                c.fromEquirectangularTexture(e, a),
                t.set(a, c),
                a.addEventListener('dispose', i),
                n(c.texture, a.mapping)
              )
            } else return null
          }
      }
      return a
    }
    function i(a) {
      const s = a.target
      s.removeEventListener('dispose', i)
      const l = t.get(s)
      l !== void 0 && (t.delete(s), l.dispose())
    }
    function o() {
      t = new WeakMap()
    }
    return { get: r, dispose: o }
  }
  class b$ extends m$ {
    constructor(t = -1, n = 1, r = 1, i = -1, o = 0.1, a = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = 'OrthographicCamera'),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = n),
        (this.top = r),
        (this.bottom = i),
        (this.near = o),
        (this.far = a),
        this.updateProjectionMatrix()
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = t.view === null ? null : Object.assign({}, t.view)),
        this
      )
    }
    setViewOffset(t, n, r, i, o, a) {
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = n),
        (this.view.offsetX = r),
        (this.view.offsetY = i),
        (this.view.width = o),
        (this.view.height = a),
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        n = (this.top - this.bottom) / (2 * this.zoom),
        r = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2
      let o = r - t,
        a = r + t,
        s = i + n,
        l = i - n
      if (this.view !== null && this.view.enabled) {
        const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
          d = (this.top - this.bottom) / this.view.fullHeight / this.zoom
        ;(o += c * this.view.offsetX),
          (a = o + c * this.view.width),
          (s -= d * this.view.offsetY),
          (l = s - d * this.view.height)
      }
      this.projectionMatrix.makeOrthographic(
        o,
        a,
        s,
        l,
        this.near,
        this.far,
        this.coordinateSystem
      ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        (n.object.zoom = this.zoom),
        (n.object.left = this.left),
        (n.object.right = this.right),
        (n.object.top = this.top),
        (n.object.bottom = this.bottom),
        (n.object.near = this.near),
        (n.object.far = this.far),
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        n
      )
    }
  }
  const Pu = 4,
    pP = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    ll = 20,
    U1 = new b$(),
    vP = new xn()
  let H1 = null
  const il = (1 + Math.sqrt(5)) / 2,
    Su = 1 / il,
    mP = [
      new Pe(1, 1, 1),
      new Pe(-1, 1, 1),
      new Pe(1, 1, -1),
      new Pe(-1, 1, -1),
      new Pe(0, il, Su),
      new Pe(0, il, -Su),
      new Pe(Su, 0, il),
      new Pe(-Su, 0, il),
      new Pe(il, Su, 0),
      new Pe(-il, Su, 0),
    ]
  class gP {
    constructor(t) {
      ;(this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(t, n = 0, r = 0.1, i = 100) {
      ;(H1 = this._renderer.getRenderTarget()), this._setSize(256)
      const o = this._allocateTargets()
      return (
        (o.depthBuffer = !0),
        this._sceneToCubeUV(t, r, i, o),
        n > 0 && this._blur(o, 0, 0, n),
        this._applyPMREM(o),
        this._cleanup(o),
        o
      )
    }
    fromEquirectangular(t, n = null) {
      return this._fromTexture(t, n)
    }
    fromCubemap(t, n = null) {
      return this._fromTexture(t, n)
    }
    compileCubemapShader() {
      this._cubemapMaterial === null &&
        ((this._cubemapMaterial = _P()),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null &&
        ((this._equirectMaterial = bP()),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
      this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(t) {
      ;(this._lodMax = Math.floor(Math.log2(t))),
        (this._cubeSize = Math.pow(2, this._lodMax))
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null &&
          this._pingPongRenderTarget.dispose()
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose()
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(H1),
        (t.scissorTest = !1),
        Dh(t, 0, 0, t.width, t.height)
    }
    _fromTexture(t, n) {
      t.mapping === Yu || t.mapping === Zu
        ? this._setSize(
            t.image.length === 0
              ? 16
              : t.image[0].width || t.image[0].image.width
          )
        : this._setSize(t.image.width / 4),
        (H1 = this._renderer.getRenderTarget())
      const r = n || this._allocateTargets()
      return (
        this._textureToCubeUV(t, r), this._applyPMREM(r), this._cleanup(r), r
      )
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112),
        n = 4 * this._cubeSize,
        r = {
          magFilter: eo,
          minFilter: eo,
          generateMipmaps: !1,
          type: Nd,
          format: ko,
          colorSpace: aa,
          depthBuffer: !1,
        },
        i = yP(t, n, r)
      if (
        this._pingPongRenderTarget === null ||
        this._pingPongRenderTarget.width !== t ||
        this._pingPongRenderTarget.height !== n
      ) {
        this._pingPongRenderTarget !== null && this._dispose(),
          (this._pingPongRenderTarget = yP(t, n, r))
        const { _lodMax: o } = this
        ;({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = tde(o)),
          (this._blurMaterial = nde(o, t, n))
      }
      return i
    }
    _compileMaterial(t) {
      const n = new Ci(this._lodPlanes[0], t)
      this._renderer.compile(n, U1)
    }
    _sceneToCubeUV(t, n, r, i) {
      const s = new to(90, 1, n, r),
        l = [1, -1, 1, 1, 1, 1],
        c = [1, 1, 1, -1, -1, -1],
        d = this._renderer,
        h = d.autoClear,
        p = d.toneMapping
      d.getClearColor(vP), (d.toneMapping = Ba), (d.autoClear = !1)
      const v = new Eu({
          name: 'PMREM.Background',
          side: Mi,
          depthWrite: !1,
          depthTest: !1,
        }),
        g = new Ci(new of(), v)
      let _ = !1
      const b = t.background
      b
        ? b.isColor && (v.color.copy(b), (t.background = null), (_ = !0))
        : (v.color.copy(vP), (_ = !0))
      for (let y = 0; y < 6; y++) {
        const M = y % 3
        M === 0
          ? (s.up.set(0, l[y], 0), s.lookAt(c[y], 0, 0))
          : M === 1
          ? (s.up.set(0, 0, l[y]), s.lookAt(0, c[y], 0))
          : (s.up.set(0, l[y], 0), s.lookAt(0, 0, c[y]))
        const x = this._cubeSize
        Dh(i, M * x, y > 2 ? x : 0, x, x),
          d.setRenderTarget(i),
          _ && d.render(g, s),
          d.render(t, s)
      }
      g.geometry.dispose(),
        g.material.dispose(),
        (d.toneMapping = p),
        (d.autoClear = h),
        (t.background = b)
    }
    _textureToCubeUV(t, n) {
      const r = this._renderer,
        i = t.mapping === Yu || t.mapping === Zu
      i
        ? (this._cubemapMaterial === null && (this._cubemapMaterial = _P()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            t.isRenderTargetTexture === !1 ? -1 : 1))
        : this._equirectMaterial === null && (this._equirectMaterial = bP())
      const o = i ? this._cubemapMaterial : this._equirectMaterial,
        a = new Ci(this._lodPlanes[0], o),
        s = o.uniforms
      s.envMap.value = t
      const l = this._cubeSize
      Dh(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(a, U1)
    }
    _applyPMREM(t) {
      const n = this._renderer,
        r = n.autoClear
      n.autoClear = !1
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const o = Math.sqrt(
            this._sigmas[i] * this._sigmas[i] -
              this._sigmas[i - 1] * this._sigmas[i - 1]
          ),
          a = mP[(i - 1) % mP.length]
        this._blur(t, i - 1, i, o, a)
      }
      n.autoClear = r
    }
    _blur(t, n, r, i, o) {
      const a = this._pingPongRenderTarget
      this._halfBlur(t, a, n, r, i, 'latitudinal', o),
        this._halfBlur(a, t, r, r, i, 'longitudinal', o)
    }
    _halfBlur(t, n, r, i, o, a, s) {
      const l = this._renderer,
        c = this._blurMaterial
      a !== 'latitudinal' &&
        a !== 'longitudinal' &&
        console.error(
          'blur direction must be either latitudinal or longitudinal!'
        )
      const d = 3,
        h = new Ci(this._lodPlanes[i], c),
        p = c.uniforms,
        v = this._sizeLods[r] - 1,
        g = isFinite(o) ? Math.PI / (2 * v) : (2 * Math.PI) / (2 * ll - 1),
        _ = o / g,
        b = isFinite(o) ? 1 + Math.floor(d * _) : ll
      b > ll &&
        console.warn(
          `sigmaRadians, ${o}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${ll}`
        )
      const y = []
      let M = 0
      for (let A = 0; A < ll; ++A) {
        const F = A / _,
          T = Math.exp((-F * F) / 2)
        y.push(T), A === 0 ? (M += T) : A < b && (M += 2 * T)
      }
      for (let A = 0; A < y.length; A++) y[A] = y[A] / M
      ;(p.envMap.value = t.texture),
        (p.samples.value = b),
        (p.weights.value = y),
        (p.latitudinal.value = a === 'latitudinal'),
        s && (p.poleAxis.value = s)
      const { _lodMax: x } = this
      ;(p.dTheta.value = g), (p.mipInt.value = x - r)
      const w = this._sizeLods[i],
        E = 3 * w * (i > x - Pu ? i - x + Pu : 0),
        P = 4 * (this._cubeSize - w)
      Dh(n, E, P, 3 * w, 2 * w), l.setRenderTarget(n), l.render(h, U1)
    }
  }
  function tde(e) {
    const t = [],
      n = [],
      r = []
    let i = e
    const o = e - Pu + 1 + pP.length
    for (let a = 0; a < o; a++) {
      const s = Math.pow(2, i)
      n.push(s)
      let l = 1 / s
      a > e - Pu ? (l = pP[a - e + Pu - 1]) : a === 0 && (l = 0), r.push(l)
      const c = 1 / (s - 2),
        d = -c,
        h = 1 + c,
        p = [d, d, h, d, h, h, d, d, h, h, d, h],
        v = 6,
        g = 6,
        _ = 3,
        b = 2,
        y = 1,
        M = new Float32Array(_ * g * v),
        x = new Float32Array(b * g * v),
        w = new Float32Array(y * g * v)
      for (let P = 0; P < v; P++) {
        const A = ((P % 3) * 2) / 3 - 1,
          F = P > 2 ? 0 : -1,
          T = [
            A,
            F,
            0,
            A + 2 / 3,
            F,
            0,
            A + 2 / 3,
            F + 1,
            0,
            A,
            F,
            0,
            A + 2 / 3,
            F + 1,
            0,
            A,
            F + 1,
            0,
          ]
        M.set(T, _ * g * P), x.set(p, b * g * P)
        const k = [P, P, P, P, P, P]
        w.set(k, y * g * P)
      }
      const E = new la()
      E.setAttribute('position', new Io(M, _)),
        E.setAttribute('uv', new Io(x, b)),
        E.setAttribute('faceIndex', new Io(w, y)),
        t.push(E),
        i > Pu && i--
    }
    return { lodPlanes: t, sizeLods: n, sigmas: r }
  }
  function yP(e, t, n) {
    const r = new El(e, t, n)
    return (
      (r.texture.mapping = dm),
      (r.texture.name = 'PMREM.cubeUv'),
      (r.scissorTest = !0),
      r
    )
  }
  function Dh(e, t, n, r, i) {
    e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
  }
  function nde(e, t, n) {
    const r = new Float32Array(ll),
      i = new Pe(0, 1, 0)
    return new Os({
      name: 'SphericalGaussianBlur',
      defines: {
        n: ll,
        CUBEUV_TEXEL_WIDTH: 1 / t,
        CUBEUV_TEXEL_HEIGHT: 1 / n,
        CUBEUV_MAX_MIP: `${e}.0`,
      },
      uniforms: {
        envMap: { value: null },
        samples: { value: 1 },
        weights: { value: r },
        latitudinal: { value: !1 },
        dTheta: { value: 0 },
        mipInt: { value: 0 },
        poleAxis: { value: i },
      },
      vertexShader: IS(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: Ms,
      depthTest: !1,
      depthWrite: !1,
    })
  }
  function bP() {
    return new Os({
      name: 'EquirectangularToCubeUV',
      uniforms: { envMap: { value: null } },
      vertexShader: IS(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: Ms,
      depthTest: !1,
      depthWrite: !1,
    })
  }
  function _P() {
    return new Os({
      name: 'CubemapToCubeUV',
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader: IS(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: Ms,
      depthTest: !1,
      depthWrite: !1,
    })
  }
  function IS() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  }
  function rde(e) {
    let t = new WeakMap(),
      n = null
    function r(s) {
      if (s && s.isTexture) {
        const l = s.mapping,
          c = l === jb || l === Gb,
          d = l === Yu || l === Zu
        if (c || d)
          if (s.isRenderTargetTexture && s.needsPMREMUpdate === !0) {
            s.needsPMREMUpdate = !1
            let h = t.get(s)
            return (
              n === null && (n = new gP(e)),
              (h = c ? n.fromEquirectangular(s, h) : n.fromCubemap(s, h)),
              t.set(s, h),
              h.texture
            )
          } else {
            if (t.has(s)) return t.get(s).texture
            {
              const h = s.image
              if ((c && h && h.height > 0) || (d && h && i(h))) {
                n === null && (n = new gP(e))
                const p = c ? n.fromEquirectangular(s) : n.fromCubemap(s)
                return t.set(s, p), s.addEventListener('dispose', o), p.texture
              } else return null
            }
          }
      }
      return s
    }
    function i(s) {
      let l = 0
      const c = 6
      for (let d = 0; d < c; d++) s[d] !== void 0 && l++
      return l === c
    }
    function o(s) {
      const l = s.target
      l.removeEventListener('dispose', o)
      const c = t.get(l)
      c !== void 0 && (t.delete(l), c.dispose())
    }
    function a() {
      ;(t = new WeakMap()), n !== null && (n.dispose(), (n = null))
    }
    return { get: r, dispose: a }
  }
  function ide(e) {
    const t = {}
    function n(r) {
      if (t[r] !== void 0) return t[r]
      let i
      switch (r) {
        case 'WEBGL_depth_texture':
          i =
            e.getExtension('WEBGL_depth_texture') ||
            e.getExtension('MOZ_WEBGL_depth_texture') ||
            e.getExtension('WEBKIT_WEBGL_depth_texture')
          break
        case 'EXT_texture_filter_anisotropic':
          i =
            e.getExtension('EXT_texture_filter_anisotropic') ||
            e.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
            e.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
          break
        case 'WEBGL_compressed_texture_s3tc':
          i =
            e.getExtension('WEBGL_compressed_texture_s3tc') ||
            e.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
            e.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
          break
        case 'WEBGL_compressed_texture_pvrtc':
          i =
            e.getExtension('WEBGL_compressed_texture_pvrtc') ||
            e.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
          break
        default:
          i = e.getExtension(r)
      }
      return (t[r] = i), i
    }
    return {
      has: function (r) {
        return n(r) !== null
      },
      init: function (r) {
        r.isWebGL2
          ? n('EXT_color_buffer_float')
          : (n('WEBGL_depth_texture'),
            n('OES_texture_float'),
            n('OES_texture_half_float'),
            n('OES_texture_half_float_linear'),
            n('OES_standard_derivatives'),
            n('OES_element_index_uint'),
            n('OES_vertex_array_object'),
            n('ANGLE_instanced_arrays')),
          n('OES_texture_float_linear'),
          n('EXT_color_buffer_half_float'),
          n('WEBGL_multisampled_render_to_texture')
      },
      get: function (r) {
        const i = n(r)
        return (
          i === null &&
            console.warn(
              'THREE.WebGLRenderer: ' + r + ' extension not supported.'
            ),
          i
        )
      },
    }
  }
  function ode(e, t, n, r) {
    const i = {},
      o = new WeakMap()
    function a(h) {
      const p = h.target
      p.index !== null && t.remove(p.index)
      for (const g in p.attributes) t.remove(p.attributes[g])
      for (const g in p.morphAttributes) {
        const _ = p.morphAttributes[g]
        for (let b = 0, y = _.length; b < y; b++) t.remove(_[b])
      }
      p.removeEventListener('dispose', a), delete i[p.id]
      const v = o.get(p)
      v && (t.remove(v), o.delete(p)),
        r.releaseStatesOfGeometry(p),
        p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
        n.memory.geometries--
    }
    function s(h, p) {
      return (
        i[p.id] === !0 ||
          (p.addEventListener('dispose', a),
          (i[p.id] = !0),
          n.memory.geometries++),
        p
      )
    }
    function l(h) {
      const p = h.attributes
      for (const g in p) t.update(p[g], e.ARRAY_BUFFER)
      const v = h.morphAttributes
      for (const g in v) {
        const _ = v[g]
        for (let b = 0, y = _.length; b < y; b++) t.update(_[b], e.ARRAY_BUFFER)
      }
    }
    function c(h) {
      const p = [],
        v = h.index,
        g = h.attributes.position
      let _ = 0
      if (v !== null) {
        const M = v.array
        _ = v.version
        for (let x = 0, w = M.length; x < w; x += 3) {
          const E = M[x + 0],
            P = M[x + 1],
            A = M[x + 2]
          p.push(E, P, P, A, A, E)
        }
      } else {
        const M = g.array
        _ = g.version
        for (let x = 0, w = M.length / 3 - 1; x < w; x += 3) {
          const E = x + 0,
            P = x + 1,
            A = x + 2
          p.push(E, P, P, A, A, E)
        }
      }
      const b = new (s$(p) ? p$ : h$)(p, 1)
      b.version = _
      const y = o.get(h)
      y && t.remove(y), o.set(h, b)
    }
    function d(h) {
      const p = o.get(h)
      if (p) {
        const v = h.index
        v !== null && p.version < v.version && c(h)
      } else c(h)
      return o.get(h)
    }
    return { get: s, update: l, getWireframeAttribute: d }
  }
  function ade(e, t, n, r) {
    const i = r.isWebGL2
    let o
    function a(p) {
      o = p
    }
    let s, l
    function c(p) {
      ;(s = p.type), (l = p.bytesPerElement)
    }
    function d(p, v) {
      e.drawElements(o, v, s, p * l), n.update(v, o, 1)
    }
    function h(p, v, g) {
      if (g === 0) return
      let _, b
      if (i) (_ = e), (b = 'drawElementsInstanced')
      else if (
        ((_ = t.get('ANGLE_instanced_arrays')),
        (b = 'drawElementsInstancedANGLE'),
        _ === null)
      ) {
        console.error(
          'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
        )
        return
      }
      _[b](o, v, s, p * l, g), n.update(v, o, g)
    }
    ;(this.setMode = a),
      (this.setIndex = c),
      (this.render = d),
      (this.renderInstances = h)
  }
  function sde(e) {
    const t = { geometries: 0, textures: 0 },
      n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
    function r(o, a, s) {
      switch ((n.calls++, a)) {
        case e.TRIANGLES:
          n.triangles += s * (o / 3)
          break
        case e.LINES:
          n.lines += s * (o / 2)
          break
        case e.LINE_STRIP:
          n.lines += s * (o - 1)
          break
        case e.LINE_LOOP:
          n.lines += s * o
          break
        case e.POINTS:
          n.points += s * o
          break
        default:
          console.error('THREE.WebGLInfo: Unknown draw mode:', a)
          break
      }
    }
    function i() {
      ;(n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0)
    }
    return {
      memory: t,
      render: n,
      programs: null,
      autoReset: !0,
      reset: i,
      update: r,
    }
  }
  function lde(e, t) {
    return e[0] - t[0]
  }
  function ude(e, t) {
    return Math.abs(t[1]) - Math.abs(e[1])
  }
  function cde(e, t, n) {
    const r = {},
      i = new Float32Array(8),
      o = new WeakMap(),
      a = new Jn(),
      s = []
    for (let c = 0; c < 8; c++) s[c] = [c, 0]
    function l(c, d, h) {
      const p = c.morphTargetInfluences
      if (t.isWebGL2 === !0) {
        const g =
            d.morphAttributes.position ||
            d.morphAttributes.normal ||
            d.morphAttributes.color,
          _ = g !== void 0 ? g.length : 0
        let b = o.get(d)
        if (b === void 0 || b.count !== _) {
          let B = function () {
            N.dispose(), o.delete(d), d.removeEventListener('dispose', B)
          }
          var v = B
          b !== void 0 && b.texture.dispose()
          const x = d.morphAttributes.position !== void 0,
            w = d.morphAttributes.normal !== void 0,
            E = d.morphAttributes.color !== void 0,
            P = d.morphAttributes.position || [],
            A = d.morphAttributes.normal || [],
            F = d.morphAttributes.color || []
          let T = 0
          x === !0 && (T = 1), w === !0 && (T = 2), E === !0 && (T = 3)
          let k = d.attributes.position.count * T,
            R = 1
          k > t.maxTextureSize &&
            ((R = Math.ceil(k / t.maxTextureSize)), (k = t.maxTextureSize))
          const j = new Float32Array(k * R * 4 * _),
            N = new c$(j, k, R, _)
          ;(N.type = Ss), (N.needsUpdate = !0)
          const I = T * 4
          for (let V = 0; V < _; V++) {
            const L = P[V],
              W = A[V],
              Y = F[V],
              U = k * R * 4 * V
            for (let le = 0; le < L.count; le++) {
              const q = le * I
              x === !0 &&
                (a.fromBufferAttribute(L, le),
                (j[U + q + 0] = a.x),
                (j[U + q + 1] = a.y),
                (j[U + q + 2] = a.z),
                (j[U + q + 3] = 0)),
                w === !0 &&
                  (a.fromBufferAttribute(W, le),
                  (j[U + q + 4] = a.x),
                  (j[U + q + 5] = a.y),
                  (j[U + q + 6] = a.z),
                  (j[U + q + 7] = 0)),
                E === !0 &&
                  (a.fromBufferAttribute(Y, le),
                  (j[U + q + 8] = a.x),
                  (j[U + q + 9] = a.y),
                  (j[U + q + 10] = a.z),
                  (j[U + q + 11] = Y.itemSize === 4 ? a.w : 1))
            }
          }
          ;(b = { count: _, texture: N, size: new Ct(k, R) }),
            o.set(d, b),
            d.addEventListener('dispose', B)
        }
        let y = 0
        for (let x = 0; x < p.length; x++) y += p[x]
        const M = d.morphTargetsRelative ? 1 : 1 - y
        h.getUniforms().setValue(e, 'morphTargetBaseInfluence', M),
          h.getUniforms().setValue(e, 'morphTargetInfluences', p),
          h.getUniforms().setValue(e, 'morphTargetsTexture', b.texture, n),
          h.getUniforms().setValue(e, 'morphTargetsTextureSize', b.size)
      } else {
        const g = p === void 0 ? 0 : p.length
        let _ = r[d.id]
        if (_ === void 0 || _.length !== g) {
          _ = []
          for (let w = 0; w < g; w++) _[w] = [w, 0]
          r[d.id] = _
        }
        for (let w = 0; w < g; w++) {
          const E = _[w]
          ;(E[0] = w), (E[1] = p[w])
        }
        _.sort(ude)
        for (let w = 0; w < 8; w++)
          w < g && _[w][1]
            ? ((s[w][0] = _[w][0]), (s[w][1] = _[w][1]))
            : ((s[w][0] = Number.MAX_SAFE_INTEGER), (s[w][1] = 0))
        s.sort(lde)
        const b = d.morphAttributes.position,
          y = d.morphAttributes.normal
        let M = 0
        for (let w = 0; w < 8; w++) {
          const E = s[w],
            P = E[0],
            A = E[1]
          P !== Number.MAX_SAFE_INTEGER && A
            ? (b &&
                d.getAttribute('morphTarget' + w) !== b[P] &&
                d.setAttribute('morphTarget' + w, b[P]),
              y &&
                d.getAttribute('morphNormal' + w) !== y[P] &&
                d.setAttribute('morphNormal' + w, y[P]),
              (i[w] = A),
              (M += A))
            : (b &&
                d.hasAttribute('morphTarget' + w) === !0 &&
                d.deleteAttribute('morphTarget' + w),
              y &&
                d.hasAttribute('morphNormal' + w) === !0 &&
                d.deleteAttribute('morphNormal' + w),
              (i[w] = 0))
        }
        const x = d.morphTargetsRelative ? 1 : 1 - M
        h.getUniforms().setValue(e, 'morphTargetBaseInfluence', x),
          h.getUniforms().setValue(e, 'morphTargetInfluences', i)
      }
    }
    return { update: l }
  }
  function dde(e, t, n, r) {
    let i = new WeakMap()
    function o(l) {
      const c = r.render.frame,
        d = l.geometry,
        h = t.get(l, d)
      return (
        i.get(h) !== c && (t.update(h), i.set(h, c)),
        l.isInstancedMesh &&
          (l.hasEventListener('dispose', s) === !1 &&
            l.addEventListener('dispose', s),
          n.update(l.instanceMatrix, e.ARRAY_BUFFER),
          l.instanceColor !== null &&
            n.update(l.instanceColor, e.ARRAY_BUFFER)),
        h
      )
    }
    function a() {
      i = new WeakMap()
    }
    function s(l) {
      const c = l.target
      c.removeEventListener('dispose', s),
        n.remove(c.instanceMatrix),
        c.instanceColor !== null && n.remove(c.instanceColor)
    }
    return { update: o, dispose: a }
  }
  const _$ = new Ei(),
    S$ = new c$(),
    C$ = new tle(),
    w$ = new g$(),
    SP = [],
    CP = [],
    wP = new Float32Array(16),
    xP = new Float32Array(9),
    MP = new Float32Array(4)
  function dc(e, t, n) {
    const r = e[0]
    if (r <= 0 || r > 0) return e
    const i = t * n
    let o = SP[i]
    if ((o === void 0 && ((o = new Float32Array(i)), (SP[i] = o)), t !== 0)) {
      r.toArray(o, 0)
      for (let a = 1, s = 0; a !== t; ++a) (s += n), e[a].toArray(o, s)
    }
    return o
  }
  function vr(e, t) {
    if (e.length !== t.length) return !1
    for (let n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1
    return !0
  }
  function mr(e, t) {
    for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
  }
  function hm(e, t) {
    let n = CP[t]
    n === void 0 && ((n = new Int32Array(t)), (CP[t] = n))
    for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit()
    return n
  }
  function fde(e, t) {
    const n = this.cache
    n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t))
  }
  function hde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y) &&
        (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y))
    else {
      if (vr(n, t)) return
      e.uniform2fv(this.addr, t), mr(n, t)
    }
  }
  function pde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) &&
        (e.uniform3f(this.addr, t.x, t.y, t.z),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z))
    else if (t.r !== void 0)
      (n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) &&
        (e.uniform3f(this.addr, t.r, t.g, t.b),
        (n[0] = t.r),
        (n[1] = t.g),
        (n[2] = t.b))
    else {
      if (vr(n, t)) return
      e.uniform3fv(this.addr, t), mr(n, t)
    }
  }
  function vde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) &&
        (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z),
        (n[3] = t.w))
    else {
      if (vr(n, t)) return
      e.uniform4fv(this.addr, t), mr(n, t)
    }
  }
  function mde(e, t) {
    const n = this.cache,
      r = t.elements
    if (r === void 0) {
      if (vr(n, t)) return
      e.uniformMatrix2fv(this.addr, !1, t), mr(n, t)
    } else {
      if (vr(n, r)) return
      MP.set(r), e.uniformMatrix2fv(this.addr, !1, MP), mr(n, r)
    }
  }
  function gde(e, t) {
    const n = this.cache,
      r = t.elements
    if (r === void 0) {
      if (vr(n, t)) return
      e.uniformMatrix3fv(this.addr, !1, t), mr(n, t)
    } else {
      if (vr(n, r)) return
      xP.set(r), e.uniformMatrix3fv(this.addr, !1, xP), mr(n, r)
    }
  }
  function yde(e, t) {
    const n = this.cache,
      r = t.elements
    if (r === void 0) {
      if (vr(n, t)) return
      e.uniformMatrix4fv(this.addr, !1, t), mr(n, t)
    } else {
      if (vr(n, r)) return
      wP.set(r), e.uniformMatrix4fv(this.addr, !1, wP), mr(n, r)
    }
  }
  function bde(e, t) {
    const n = this.cache
    n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t))
  }
  function _de(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y) &&
        (e.uniform2i(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y))
    else {
      if (vr(n, t)) return
      e.uniform2iv(this.addr, t), mr(n, t)
    }
  }
  function Sde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) &&
        (e.uniform3i(this.addr, t.x, t.y, t.z),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z))
    else {
      if (vr(n, t)) return
      e.uniform3iv(this.addr, t), mr(n, t)
    }
  }
  function Cde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) &&
        (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z),
        (n[3] = t.w))
    else {
      if (vr(n, t)) return
      e.uniform4iv(this.addr, t), mr(n, t)
    }
  }
  function wde(e, t) {
    const n = this.cache
    n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t))
  }
  function xde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y) &&
        (e.uniform2ui(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y))
    else {
      if (vr(n, t)) return
      e.uniform2uiv(this.addr, t), mr(n, t)
    }
  }
  function Mde(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) &&
        (e.uniform3ui(this.addr, t.x, t.y, t.z),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z))
    else {
      if (vr(n, t)) return
      e.uniform3uiv(this.addr, t), mr(n, t)
    }
  }
  function Ede(e, t) {
    const n = this.cache
    if (t.x !== void 0)
      (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) &&
        (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z),
        (n[3] = t.w))
    else {
      if (vr(n, t)) return
      e.uniform4uiv(this.addr, t), mr(n, t)
    }
  }
  function Pde(e, t, n) {
    const r = this.cache,
      i = n.allocateTextureUnit()
    r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
      n.setTexture2D(t || _$, i)
  }
  function Tde(e, t, n) {
    const r = this.cache,
      i = n.allocateTextureUnit()
    r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
      n.setTexture3D(t || C$, i)
  }
  function kde(e, t, n) {
    const r = this.cache,
      i = n.allocateTextureUnit()
    r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
      n.setTextureCube(t || w$, i)
  }
  function Ade(e, t, n) {
    const r = this.cache,
      i = n.allocateTextureUnit()
    r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
      n.setTexture2DArray(t || S$, i)
  }
  function $de(e) {
    switch (e) {
      case 5126:
        return fde
      case 35664:
        return hde
      case 35665:
        return pde
      case 35666:
        return vde
      case 35674:
        return mde
      case 35675:
        return gde
      case 35676:
        return yde
      case 5124:
      case 35670:
        return bde
      case 35667:
      case 35671:
        return _de
      case 35668:
      case 35672:
        return Sde
      case 35669:
      case 35673:
        return Cde
      case 5125:
        return wde
      case 36294:
        return xde
      case 36295:
        return Mde
      case 36296:
        return Ede
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Pde
      case 35679:
      case 36299:
      case 36307:
        return Tde
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return kde
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Ade
    }
  }
  function Ode(e, t) {
    e.uniform1fv(this.addr, t)
  }
  function Lde(e, t) {
    const n = dc(t, this.size, 2)
    e.uniform2fv(this.addr, n)
  }
  function Ide(e, t) {
    const n = dc(t, this.size, 3)
    e.uniform3fv(this.addr, n)
  }
  function Rde(e, t) {
    const n = dc(t, this.size, 4)
    e.uniform4fv(this.addr, n)
  }
  function Dde(e, t) {
    const n = dc(t, this.size, 4)
    e.uniformMatrix2fv(this.addr, !1, n)
  }
  function Nde(e, t) {
    const n = dc(t, this.size, 9)
    e.uniformMatrix3fv(this.addr, !1, n)
  }
  function Bde(e, t) {
    const n = dc(t, this.size, 16)
    e.uniformMatrix4fv(this.addr, !1, n)
  }
  function Fde(e, t) {
    e.uniform1iv(this.addr, t)
  }
  function zde(e, t) {
    e.uniform2iv(this.addr, t)
  }
  function Vde(e, t) {
    e.uniform3iv(this.addr, t)
  }
  function Ude(e, t) {
    e.uniform4iv(this.addr, t)
  }
  function Hde(e, t) {
    e.uniform1uiv(this.addr, t)
  }
  function Wde(e, t) {
    e.uniform2uiv(this.addr, t)
  }
  function jde(e, t) {
    e.uniform3uiv(this.addr, t)
  }
  function Gde(e, t) {
    e.uniform4uiv(this.addr, t)
  }
  function Kde(e, t, n) {
    const r = this.cache,
      i = t.length,
      o = hm(n, i)
    vr(r, o) || (e.uniform1iv(this.addr, o), mr(r, o))
    for (let a = 0; a !== i; ++a) n.setTexture2D(t[a] || _$, o[a])
  }
  function qde(e, t, n) {
    const r = this.cache,
      i = t.length,
      o = hm(n, i)
    vr(r, o) || (e.uniform1iv(this.addr, o), mr(r, o))
    for (let a = 0; a !== i; ++a) n.setTexture3D(t[a] || C$, o[a])
  }
  function Xde(e, t, n) {
    const r = this.cache,
      i = t.length,
      o = hm(n, i)
    vr(r, o) || (e.uniform1iv(this.addr, o), mr(r, o))
    for (let a = 0; a !== i; ++a) n.setTextureCube(t[a] || w$, o[a])
  }
  function Yde(e, t, n) {
    const r = this.cache,
      i = t.length,
      o = hm(n, i)
    vr(r, o) || (e.uniform1iv(this.addr, o), mr(r, o))
    for (let a = 0; a !== i; ++a) n.setTexture2DArray(t[a] || S$, o[a])
  }
  function Zde(e) {
    switch (e) {
      case 5126:
        return Ode
      case 35664:
        return Lde
      case 35665:
        return Ide
      case 35666:
        return Rde
      case 35674:
        return Dde
      case 35675:
        return Nde
      case 35676:
        return Bde
      case 5124:
      case 35670:
        return Fde
      case 35667:
      case 35671:
        return zde
      case 35668:
      case 35672:
        return Vde
      case 35669:
      case 35673:
        return Ude
      case 5125:
        return Hde
      case 36294:
        return Wde
      case 36295:
        return jde
      case 36296:
        return Gde
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Kde
      case 35679:
      case 36299:
      case 36307:
        return qde
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Xde
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Yde
    }
  }
  class Jde {
    constructor(t, n, r) {
      ;(this.id = t),
        (this.addr = r),
        (this.cache = []),
        (this.setValue = $de(n.type))
    }
  }
  class Qde {
    constructor(t, n, r) {
      ;(this.id = t),
        (this.addr = r),
        (this.cache = []),
        (this.size = n.size),
        (this.setValue = Zde(n.type))
    }
  }
  class efe {
    constructor(t) {
      ;(this.id = t), (this.seq = []), (this.map = {})
    }
    setValue(t, n, r) {
      const i = this.seq
      for (let o = 0, a = i.length; o !== a; ++o) {
        const s = i[o]
        s.setValue(t, n[s.id], r)
      }
    }
  }
  const W1 = /(\w+)(\])?(\[|\.)?/g
  function EP(e, t) {
    e.seq.push(t), (e.map[t.id] = t)
  }
  function tfe(e, t, n) {
    const r = e.name,
      i = r.length
    for (W1.lastIndex = 0; ; ) {
      const o = W1.exec(r),
        a = W1.lastIndex
      let s = o[1]
      const l = o[2] === ']',
        c = o[3]
      if ((l && (s = s | 0), c === void 0 || (c === '[' && a + 2 === i))) {
        EP(n, c === void 0 ? new Jde(s, e, t) : new Qde(s, e, t))
        break
      } else {
        let h = n.map[s]
        h === void 0 && ((h = new efe(s)), EP(n, h)), (n = h)
      }
    }
  }
  class jp {
    constructor(t, n) {
      ;(this.seq = []), (this.map = {})
      const r = t.getProgramParameter(n, t.ACTIVE_UNIFORMS)
      for (let i = 0; i < r; ++i) {
        const o = t.getActiveUniform(n, i),
          a = t.getUniformLocation(n, o.name)
        tfe(o, a, this)
      }
    }
    setValue(t, n, r, i) {
      const o = this.map[n]
      o !== void 0 && o.setValue(t, r, i)
    }
    setOptional(t, n, r) {
      const i = n[r]
      i !== void 0 && this.setValue(t, r, i)
    }
    static upload(t, n, r, i) {
      for (let o = 0, a = n.length; o !== a; ++o) {
        const s = n[o],
          l = r[s.id]
        l.needsUpdate !== !1 && s.setValue(t, l.value, i)
      }
    }
    static seqWithValue(t, n) {
      const r = []
      for (let i = 0, o = t.length; i !== o; ++i) {
        const a = t[i]
        a.id in n && r.push(a)
      }
      return r
    }
  }
  function PP(e, t, n) {
    const r = e.createShader(t)
    return e.shaderSource(r, n), e.compileShader(r), r
  }
  let nfe = 0
  function rfe(e, t) {
    const n = e.split(`
`),
      r = [],
      i = Math.max(t - 6, 0),
      o = Math.min(t + 6, n.length)
    for (let a = i; a < o; a++) {
      const s = a + 1
      r.push(`${s === t ? '>' : ' '} ${s}: ${n[a]}`)
    }
    return r.join(`
`)
  }
  function ife(e) {
    switch (e) {
      case aa:
        return ['Linear', '( value )']
      case rn:
        return ['sRGB', '( value )']
      default:
        return (
          console.warn('THREE.WebGLProgram: Unsupported color space:', e),
          ['Linear', '( value )']
        )
    }
  }
  function TP(e, t, n) {
    const r = e.getShaderParameter(t, e.COMPILE_STATUS),
      i = e.getShaderInfoLog(t).trim()
    if (r && i === '') return ''
    const o = /ERROR: 0:(\d+)/.exec(i)
    if (o) {
      const a = parseInt(o[1])
      return (
        n.toUpperCase() +
        `

` +
        i +
        `

` +
        rfe(e.getShaderSource(t), a)
      )
    } else return i
  }
  function ofe(e, t) {
    const n = ife(t)
    return (
      'vec4 ' + e + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }'
    )
  }
  function afe(e, t) {
    let n
    switch (t) {
      case ase:
        n = 'Linear'
        break
      case sse:
        n = 'Reinhard'
        break
      case lse:
        n = 'OptimizedCineon'
        break
      case use:
        n = 'ACESFilmic'
        break
      case cse:
        n = 'Custom'
        break
      default:
        console.warn('THREE.WebGLProgram: Unsupported toneMapping:', t),
          (n = 'Linear')
    }
    return (
      'vec3 ' + e + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
    )
  }
  function sfe(e) {
    return [
      e.extensionDerivatives ||
      e.envMapCubeUVHeight ||
      e.bumpMap ||
      e.normalMapTangentSpace ||
      e.clearcoatNormalMap ||
      e.flatShading ||
      e.shaderID === 'physical'
        ? '#extension GL_OES_standard_derivatives : enable'
        : '',
      (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
      e.rendererExtensionFragDepth
        ? '#extension GL_EXT_frag_depth : enable'
        : '',
      e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
        ? '#extension GL_EXT_draw_buffers : require'
        : '',
      (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
      e.rendererExtensionShaderTextureLod
        ? '#extension GL_EXT_shader_texture_lod : enable'
        : '',
    ].filter(nd).join(`
`)
  }
  function lfe(e) {
    const t = []
    for (const n in e) {
      const r = e[n]
      r !== !1 && t.push('#define ' + n + ' ' + r)
    }
    return t.join(`
`)
  }
  function ufe(e, t) {
    const n = {},
      r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES)
    for (let i = 0; i < r; i++) {
      const o = e.getActiveAttrib(t, i),
        a = o.name
      let s = 1
      o.type === e.FLOAT_MAT2 && (s = 2),
        o.type === e.FLOAT_MAT3 && (s = 3),
        o.type === e.FLOAT_MAT4 && (s = 4),
        (n[a] = {
          type: o.type,
          location: e.getAttribLocation(t, a),
          locationSize: s,
        })
    }
    return n
  }
  function nd(e) {
    return e !== ''
  }
  function kP(e, t) {
    const n =
      t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps
    return e
      .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
      .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        t.numSpotLightShadowsWithMaps
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
  }
  function AP(e, t) {
    return e
      .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        t.numClippingPlanes - t.numClipIntersection
      )
  }
  const cfe = /^[ \t]*#include +<([\w\d./]+)>/gm
  function Zb(e) {
    return e.replace(cfe, dfe)
  }
  function dfe(e, t) {
    const n = an[t]
    if (n === void 0) throw new Error('Can not resolve #include <' + t + '>')
    return Zb(n)
  }
  const ffe =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
  function $P(e) {
    return e.replace(ffe, hfe)
  }
  function hfe(e, t, n, r) {
    let i = ''
    for (let o = parseInt(t); o < parseInt(n); o++)
      i += r
        .replace(/\[\s*i\s*\]/g, '[ ' + o + ' ]')
        .replace(/UNROLLED_LOOP_INDEX/g, o)
    return i
  }
  function OP(e) {
    let t =
      'precision ' +
      e.precision +
      ` float;
precision ` +
      e.precision +
      ' int;'
    return (
      e.precision === 'highp'
        ? (t += `
#define HIGH_PRECISION`)
        : e.precision === 'mediump'
        ? (t += `
#define MEDIUM_PRECISION`)
        : e.precision === 'lowp' &&
          (t += `
#define LOW_PRECISION`),
      t
    )
  }
  function pfe(e) {
    let t = 'SHADOWMAP_TYPE_BASIC'
    return (
      e.shadowMapType === qA
        ? (t = 'SHADOWMAP_TYPE_PCF')
        : e.shadowMapType === Bae
        ? (t = 'SHADOWMAP_TYPE_PCF_SOFT')
        : e.shadowMapType === ka && (t = 'SHADOWMAP_TYPE_VSM'),
      t
    )
  }
  function vfe(e) {
    let t = 'ENVMAP_TYPE_CUBE'
    if (e.envMap)
      switch (e.envMapMode) {
        case Yu:
        case Zu:
          t = 'ENVMAP_TYPE_CUBE'
          break
        case dm:
          t = 'ENVMAP_TYPE_CUBE_UV'
          break
      }
    return t
  }
  function mfe(e) {
    let t = 'ENVMAP_MODE_REFLECTION'
    if (e.envMap)
      switch (e.envMapMode) {
        case Zu:
          t = 'ENVMAP_MODE_REFRACTION'
          break
      }
    return t
  }
  function gfe(e) {
    let t = 'ENVMAP_BLENDING_NONE'
    if (e.envMap)
      switch (e.combine) {
        case nf:
          t = 'ENVMAP_BLENDING_MULTIPLY'
          break
        case ise:
          t = 'ENVMAP_BLENDING_MIX'
          break
        case ose:
          t = 'ENVMAP_BLENDING_ADD'
          break
      }
    return t
  }
  function yfe(e) {
    const t = e.envMapCubeUVHeight
    if (t === null) return null
    const n = Math.log2(t) - 2,
      r = 1 / t
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
      texelHeight: r,
      maxMip: n,
    }
  }
  function bfe(e, t, n, r) {
    const i = e.getContext(),
      o = n.defines
    let a = n.vertexShader,
      s = n.fragmentShader
    const l = pfe(n),
      c = vfe(n),
      d = mfe(n),
      h = gfe(n),
      p = yfe(n),
      v = n.isWebGL2 ? '' : sfe(n),
      g = lfe(o),
      _ = i.createProgram()
    let b,
      y,
      M = n.glslVersion
        ? '#version ' +
          n.glslVersion +
          `
`
        : ''
    n.isRawShaderMaterial
      ? ((b = [
          '#define SHADER_TYPE ' + n.shaderType,
          '#define SHADER_NAME ' + n.shaderName,
          g,
        ].filter(nd).join(`
`)),
        b.length > 0 &&
          (b += `
`),
        (y = [
          v,
          '#define SHADER_TYPE ' + n.shaderType,
          '#define SHADER_NAME ' + n.shaderName,
          g,
        ].filter(nd).join(`
`)),
        y.length > 0 &&
          (y += `
`))
      : ((b = [
          OP(n),
          '#define SHADER_TYPE ' + n.shaderType,
          '#define SHADER_NAME ' + n.shaderName,
          g,
          n.instancing ? '#define USE_INSTANCING' : '',
          n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
          n.useFog && n.fog ? '#define USE_FOG' : '',
          n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
          n.map ? '#define USE_MAP' : '',
          n.envMap ? '#define USE_ENVMAP' : '',
          n.envMap ? '#define ' + d : '',
          n.lightMap ? '#define USE_LIGHTMAP' : '',
          n.aoMap ? '#define USE_AOMAP' : '',
          n.bumpMap ? '#define USE_BUMPMAP' : '',
          n.normalMap ? '#define USE_NORMALMAP' : '',
          n.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
          n.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
          n.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
          n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
          n.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
          n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
          n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
          n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
          n.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
          n.iridescenceThicknessMap
            ? '#define USE_IRIDESCENCE_THICKNESSMAP'
            : '',
          n.specularMap ? '#define USE_SPECULARMAP' : '',
          n.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
          n.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
          n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
          n.metalnessMap ? '#define USE_METALNESSMAP' : '',
          n.alphaMap ? '#define USE_ALPHAMAP' : '',
          n.transmission ? '#define USE_TRANSMISSION' : '',
          n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
          n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
          n.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
          n.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
          n.mapUv ? '#define MAP_UV ' + n.mapUv : '',
          n.alphaMapUv ? '#define ALPHAMAP_UV ' + n.alphaMapUv : '',
          n.lightMapUv ? '#define LIGHTMAP_UV ' + n.lightMapUv : '',
          n.aoMapUv ? '#define AOMAP_UV ' + n.aoMapUv : '',
          n.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + n.emissiveMapUv : '',
          n.bumpMapUv ? '#define BUMPMAP_UV ' + n.bumpMapUv : '',
          n.normalMapUv ? '#define NORMALMAP_UV ' + n.normalMapUv : '',
          n.displacementMapUv
            ? '#define DISPLACEMENTMAP_UV ' + n.displacementMapUv
            : '',
          n.metalnessMapUv ? '#define METALNESSMAP_UV ' + n.metalnessMapUv : '',
          n.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + n.roughnessMapUv : '',
          n.anisotropyMapUv
            ? '#define ANISOTROPYMAP_UV ' + n.anisotropyMapUv
            : '',
          n.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + n.clearcoatMapUv : '',
          n.clearcoatNormalMapUv
            ? '#define CLEARCOAT_NORMALMAP_UV ' + n.clearcoatNormalMapUv
            : '',
          n.clearcoatRoughnessMapUv
            ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + n.clearcoatRoughnessMapUv
            : '',
          n.iridescenceMapUv
            ? '#define IRIDESCENCEMAP_UV ' + n.iridescenceMapUv
            : '',
          n.iridescenceThicknessMapUv
            ? '#define IRIDESCENCE_THICKNESSMAP_UV ' +
              n.iridescenceThicknessMapUv
            : '',
          n.sheenColorMapUv
            ? '#define SHEEN_COLORMAP_UV ' + n.sheenColorMapUv
            : '',
          n.sheenRoughnessMapUv
            ? '#define SHEEN_ROUGHNESSMAP_UV ' + n.sheenRoughnessMapUv
            : '',
          n.specularMapUv ? '#define SPECULARMAP_UV ' + n.specularMapUv : '',
          n.specularColorMapUv
            ? '#define SPECULAR_COLORMAP_UV ' + n.specularColorMapUv
            : '',
          n.specularIntensityMapUv
            ? '#define SPECULAR_INTENSITYMAP_UV ' + n.specularIntensityMapUv
            : '',
          n.transmissionMapUv
            ? '#define TRANSMISSIONMAP_UV ' + n.transmissionMapUv
            : '',
          n.thicknessMapUv ? '#define THICKNESSMAP_UV ' + n.thicknessMapUv : '',
          n.vertexTangents ? '#define USE_TANGENT' : '',
          n.vertexColors ? '#define USE_COLOR' : '',
          n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
          n.vertexUv1s ? '#define USE_UV1' : '',
          n.vertexUv2s ? '#define USE_UV2' : '',
          n.vertexUv3s ? '#define USE_UV3' : '',
          n.pointsUvs ? '#define USE_POINTS_UV' : '',
          n.flatShading ? '#define FLAT_SHADED' : '',
          n.skinning ? '#define USE_SKINNING' : '',
          n.morphTargets ? '#define USE_MORPHTARGETS' : '',
          n.morphNormals && n.flatShading === !1
            ? '#define USE_MORPHNORMALS'
            : '',
          n.morphColors && n.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
          n.morphTargetsCount > 0 && n.isWebGL2
            ? '#define MORPHTARGETS_TEXTURE'
            : '',
          n.morphTargetsCount > 0 && n.isWebGL2
            ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + n.morphTextureStride
            : '',
          n.morphTargetsCount > 0 && n.isWebGL2
            ? '#define MORPHTARGETS_COUNT ' + n.morphTargetsCount
            : '',
          n.doubleSided ? '#define DOUBLE_SIDED' : '',
          n.flipSided ? '#define FLIP_SIDED' : '',
          n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
          n.shadowMapEnabled ? '#define ' + l : '',
          n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
          n.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
          n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? '#define USE_LOGDEPTHBUF_EXT'
            : '',
          'uniform mat4 modelMatrix;',
          'uniform mat4 modelViewMatrix;',
          'uniform mat4 projectionMatrix;',
          'uniform mat4 viewMatrix;',
          'uniform mat3 normalMatrix;',
          'uniform vec3 cameraPosition;',
          'uniform bool isOrthographic;',
          '#ifdef USE_INSTANCING',
          '	attribute mat4 instanceMatrix;',
          '#endif',
          '#ifdef USE_INSTANCING_COLOR',
          '	attribute vec3 instanceColor;',
          '#endif',
          'attribute vec3 position;',
          'attribute vec3 normal;',
          'attribute vec2 uv;',
          '#ifdef USE_UV1',
          '	attribute vec2 uv1;',
          '#endif',
          '#ifdef USE_UV2',
          '	attribute vec2 uv2;',
          '#endif',
          '#ifdef USE_UV3',
          '	attribute vec2 uv3;',
          '#endif',
          '#ifdef USE_TANGENT',
          '	attribute vec4 tangent;',
          '#endif',
          '#if defined( USE_COLOR_ALPHA )',
          '	attribute vec4 color;',
          '#elif defined( USE_COLOR )',
          '	attribute vec3 color;',
          '#endif',
          '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
          '	attribute vec3 morphTarget0;',
          '	attribute vec3 morphTarget1;',
          '	attribute vec3 morphTarget2;',
          '	attribute vec3 morphTarget3;',
          '	#ifdef USE_MORPHNORMALS',
          '		attribute vec3 morphNormal0;',
          '		attribute vec3 morphNormal1;',
          '		attribute vec3 morphNormal2;',
          '		attribute vec3 morphNormal3;',
          '	#else',
          '		attribute vec3 morphTarget4;',
          '		attribute vec3 morphTarget5;',
          '		attribute vec3 morphTarget6;',
          '		attribute vec3 morphTarget7;',
          '	#endif',
          '#endif',
          '#ifdef USE_SKINNING',
          '	attribute vec4 skinIndex;',
          '	attribute vec4 skinWeight;',
          '#endif',
          `
`,
        ].filter(nd).join(`
`)),
        (y = [
          v,
          OP(n),
          '#define SHADER_TYPE ' + n.shaderType,
          '#define SHADER_NAME ' + n.shaderName,
          g,
          n.useFog && n.fog ? '#define USE_FOG' : '',
          n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
          n.map ? '#define USE_MAP' : '',
          n.matcap ? '#define USE_MATCAP' : '',
          n.envMap ? '#define USE_ENVMAP' : '',
          n.envMap ? '#define ' + c : '',
          n.envMap ? '#define ' + d : '',
          n.envMap ? '#define ' + h : '',
          p ? '#define CUBEUV_TEXEL_WIDTH ' + p.texelWidth : '',
          p ? '#define CUBEUV_TEXEL_HEIGHT ' + p.texelHeight : '',
          p ? '#define CUBEUV_MAX_MIP ' + p.maxMip + '.0' : '',
          n.lightMap ? '#define USE_LIGHTMAP' : '',
          n.aoMap ? '#define USE_AOMAP' : '',
          n.bumpMap ? '#define USE_BUMPMAP' : '',
          n.normalMap ? '#define USE_NORMALMAP' : '',
          n.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
          n.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
          n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
          n.anisotropy ? '#define USE_ANISOTROPY' : '',
          n.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
          n.clearcoat ? '#define USE_CLEARCOAT' : '',
          n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
          n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
          n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
          n.iridescence ? '#define USE_IRIDESCENCE' : '',
          n.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
          n.iridescenceThicknessMap
            ? '#define USE_IRIDESCENCE_THICKNESSMAP'
            : '',
          n.specularMap ? '#define USE_SPECULARMAP' : '',
          n.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
          n.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
          n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
          n.metalnessMap ? '#define USE_METALNESSMAP' : '',
          n.alphaMap ? '#define USE_ALPHAMAP' : '',
          n.alphaTest ? '#define USE_ALPHATEST' : '',
          n.sheen ? '#define USE_SHEEN' : '',
          n.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
          n.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
          n.transmission ? '#define USE_TRANSMISSION' : '',
          n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
          n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
          n.vertexTangents ? '#define USE_TANGENT' : '',
          n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
          n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
          n.vertexUv1s ? '#define USE_UV1' : '',
          n.vertexUv2s ? '#define USE_UV2' : '',
          n.vertexUv3s ? '#define USE_UV3' : '',
          n.pointsUvs ? '#define USE_POINTS_UV' : '',
          n.gradientMap ? '#define USE_GRADIENTMAP' : '',
          n.flatShading ? '#define FLAT_SHADED' : '',
          n.doubleSided ? '#define DOUBLE_SIDED' : '',
          n.flipSided ? '#define FLIP_SIDED' : '',
          n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
          n.shadowMapEnabled ? '#define ' + l : '',
          n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
          n.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
          n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? '#define USE_LOGDEPTHBUF_EXT'
            : '',
          'uniform mat4 viewMatrix;',
          'uniform vec3 cameraPosition;',
          'uniform bool isOrthographic;',
          n.toneMapping !== Ba ? '#define TONE_MAPPING' : '',
          n.toneMapping !== Ba ? an.tonemapping_pars_fragment : '',
          n.toneMapping !== Ba ? afe('toneMapping', n.toneMapping) : '',
          n.dithering ? '#define DITHERING' : '',
          n.opaque ? '#define OPAQUE' : '',
          an.encodings_pars_fragment,
          ofe('linearToOutputTexel', n.outputColorSpace),
          n.useDepthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
          `
`,
        ].filter(nd).join(`
`))),
      (a = Zb(a)),
      (a = kP(a, n)),
      (a = AP(a, n)),
      (s = Zb(s)),
      (s = kP(s, n)),
      (s = AP(s, n)),
      (a = $P(a)),
      (s = $P(s)),
      n.isWebGL2 &&
        n.isRawShaderMaterial !== !0 &&
        ((M = `#version 300 es
`),
        (b =
          [
            'precision mediump sampler2DArray;',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture',
          ].join(`
`) +
          `
` +
          b),
        (y =
          [
            '#define varying in',
            n.glslVersion === Z3
              ? ''
              : 'layout(location = 0) out highp vec4 pc_fragColor;',
            n.glslVersion === Z3 ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad',
          ].join(`
`) +
          `
` +
          y))
    const x = M + b + a,
      w = M + y + s,
      E = PP(i, i.VERTEX_SHADER, x),
      P = PP(i, i.FRAGMENT_SHADER, w)
    if (
      (i.attachShader(_, E),
      i.attachShader(_, P),
      n.index0AttributeName !== void 0
        ? i.bindAttribLocation(_, 0, n.index0AttributeName)
        : n.morphTargets === !0 && i.bindAttribLocation(_, 0, 'position'),
      i.linkProgram(_),
      e.debug.checkShaderErrors)
    ) {
      const T = i.getProgramInfoLog(_).trim(),
        k = i.getShaderInfoLog(E).trim(),
        R = i.getShaderInfoLog(P).trim()
      let j = !0,
        N = !0
      if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
        if (((j = !1), typeof e.debug.onShaderError == 'function'))
          e.debug.onShaderError(i, _, E, P)
        else {
          const I = TP(i, E, 'vertex'),
            B = TP(i, P, 'fragment')
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              i.getError() +
              ' - VALIDATE_STATUS ' +
              i.getProgramParameter(_, i.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              T +
              `
` +
              I +
              `
` +
              B
          )
        }
      else
        T !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', T)
          : (k === '' || R === '') && (N = !1)
      N &&
        (this.diagnostics = {
          runnable: j,
          programLog: T,
          vertexShader: { log: k, prefix: b },
          fragmentShader: { log: R, prefix: y },
        })
    }
    i.deleteShader(E), i.deleteShader(P)
    let A
    this.getUniforms = function () {
      return A === void 0 && (A = new jp(i, _)), A
    }
    let F
    return (
      (this.getAttributes = function () {
        return F === void 0 && (F = ufe(i, _)), F
      }),
      (this.destroy = function () {
        r.releaseStatesOfProgram(this),
          i.deleteProgram(_),
          (this.program = void 0)
      }),
      (this.type = n.shaderType),
      (this.name = n.shaderName),
      (this.id = nfe++),
      (this.cacheKey = t),
      (this.usedTimes = 1),
      (this.program = _),
      (this.vertexShader = E),
      (this.fragmentShader = P),
      this
    )
  }
  let _fe = 0
  class Sfe {
    constructor() {
      ;(this.shaderCache = new Map()), (this.materialCache = new Map())
    }
    update(t) {
      const n = t.vertexShader,
        r = t.fragmentShader,
        i = this._getShaderStage(n),
        o = this._getShaderStage(r),
        a = this._getShaderCacheForMaterial(t)
      return (
        a.has(i) === !1 && (a.add(i), i.usedTimes++),
        a.has(o) === !1 && (a.add(o), o.usedTimes++),
        this
      )
    }
    remove(t) {
      const n = this.materialCache.get(t)
      for (const r of n)
        r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code)
      return this.materialCache.delete(t), this
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(t) {
      const n = this.materialCache
      let r = n.get(t)
      return r === void 0 && ((r = new Set()), n.set(t, r)), r
    }
    _getShaderStage(t) {
      const n = this.shaderCache
      let r = n.get(t)
      return r === void 0 && ((r = new Cfe(t)), n.set(t, r)), r
    }
  }
  class Cfe {
    constructor(t) {
      ;(this.id = _fe++), (this.code = t), (this.usedTimes = 0)
    }
  }
  function wfe(e, t, n, r, i, o, a) {
    const s = new $S(),
      l = new Sfe(),
      c = [],
      d = i.isWebGL2,
      h = i.logarithmicDepthBuffer,
      p = i.vertexTextures
    let v = i.precision
    const g = {
      MeshDepthMaterial: 'depth',
      MeshDistanceMaterial: 'distanceRGBA',
      MeshNormalMaterial: 'normal',
      MeshBasicMaterial: 'basic',
      MeshLambertMaterial: 'lambert',
      MeshPhongMaterial: 'phong',
      MeshToonMaterial: 'toon',
      MeshStandardMaterial: 'physical',
      MeshPhysicalMaterial: 'physical',
      MeshMatcapMaterial: 'matcap',
      LineBasicMaterial: 'basic',
      LineDashedMaterial: 'dashed',
      PointsMaterial: 'points',
      ShadowMaterial: 'shadow',
      SpriteMaterial: 'sprite',
    }
    function _(T) {
      return T === 0 ? 'uv' : `uv${T}`
    }
    function b(T, k, R, j, N) {
      const I = j.fog,
        B = N.geometry,
        V = T.isMeshStandardMaterial ? j.environment : null,
        L = (T.isMeshStandardMaterial ? n : t).get(T.envMap || V),
        W = L && L.mapping === dm ? L.image.height : null,
        Y = g[T.type]
      T.precision !== null &&
        ((v = i.getMaxPrecision(T.precision)),
        v !== T.precision &&
          console.warn(
            'THREE.WebGLProgram.getParameters:',
            T.precision,
            'not supported, using',
            v,
            'instead.'
          ))
      const U =
          B.morphAttributes.position ||
          B.morphAttributes.normal ||
          B.morphAttributes.color,
        le = U !== void 0 ? U.length : 0
      let q = 0
      B.morphAttributes.position !== void 0 && (q = 1),
        B.morphAttributes.normal !== void 0 && (q = 2),
        B.morphAttributes.color !== void 0 && (q = 3)
      let oe, te, ue, me
      if (Y) {
        const Pn = Si[Y]
        ;(oe = Pn.vertexShader), (te = Pn.fragmentShader)
      } else
        (oe = T.vertexShader),
          (te = T.fragmentShader),
          l.update(T),
          (ue = l.getVertexShaderID(T)),
          (me = l.getFragmentShaderID(T))
      const Re = e.getRenderTarget(),
        qe = N.isInstancedMesh === !0,
        Ve = !!T.map,
        nt = !!T.matcap,
        We = !!L,
        D = !!T.aoMap,
        G = !!T.lightMap,
        z = !!T.bumpMap,
        ie = !!T.normalMap,
        ae = !!T.displacementMap,
        re = !!T.emissiveMap,
        pe = !!T.metalnessMap,
        we = !!T.roughnessMap,
        $e = T.anisotropy > 0,
        Ae = T.clearcoat > 0,
        ft = T.iridescence > 0,
        Q = T.sheen > 0,
        X = T.transmission > 0,
        he = $e && !!T.anisotropyMap,
        de = Ae && !!T.clearcoatMap,
        xe = Ae && !!T.clearcoatNormalMap,
        ne = Ae && !!T.clearcoatRoughnessMap,
        Le = ft && !!T.iridescenceMap,
        et = ft && !!T.iridescenceThicknessMap,
        Ne = Q && !!T.sheenColorMap,
        Et = Q && !!T.sheenRoughnessMap,
        kt = !!T.specularMap,
        je = !!T.specularColorMap,
        Ge = !!T.specularIntensityMap,
        Ye = X && !!T.transmissionMap,
        lt = X && !!T.thicknessMap,
        gt = !!T.gradientMap,
        _e = !!T.alphaMap,
        bt = T.alphaTest > 0,
        He = !!T.extensions,
        _t = !!B.attributes.uv1,
        wt = !!B.attributes.uv2,
        Zt = !!B.attributes.uv3
      return {
        isWebGL2: d,
        shaderID: Y,
        shaderType: T.type,
        shaderName: T.name,
        vertexShader: oe,
        fragmentShader: te,
        defines: T.defines,
        customVertexShaderID: ue,
        customFragmentShaderID: me,
        isRawShaderMaterial: T.isRawShaderMaterial === !0,
        glslVersion: T.glslVersion,
        precision: v,
        instancing: qe,
        instancingColor: qe && N.instanceColor !== null,
        supportsVertexTextures: p,
        outputColorSpace:
          Re === null
            ? e.outputColorSpace
            : Re.isXRRenderTarget === !0
            ? Re.texture.colorSpace
            : aa,
        map: Ve,
        matcap: nt,
        envMap: We,
        envMapMode: We && L.mapping,
        envMapCubeUVHeight: W,
        aoMap: D,
        lightMap: G,
        bumpMap: z,
        normalMap: ie,
        displacementMap: p && ae,
        emissiveMap: re,
        normalMapObjectSpace: ie && T.normalMapType === wse,
        normalMapTangentSpace: ie && T.normalMapType === kS,
        metalnessMap: pe,
        roughnessMap: we,
        anisotropy: $e,
        anisotropyMap: he,
        clearcoat: Ae,
        clearcoatMap: de,
        clearcoatNormalMap: xe,
        clearcoatRoughnessMap: ne,
        iridescence: ft,
        iridescenceMap: Le,
        iridescenceThicknessMap: et,
        sheen: Q,
        sheenColorMap: Ne,
        sheenRoughnessMap: Et,
        specularMap: kt,
        specularColorMap: je,
        specularIntensityMap: Ge,
        transmission: X,
        transmissionMap: Ye,
        thicknessMap: lt,
        gradientMap: gt,
        opaque: T.transparent === !1 && T.blending === zu,
        alphaMap: _e,
        alphaTest: bt,
        combine: T.combine,
        mapUv: Ve && _(T.map.channel),
        aoMapUv: D && _(T.aoMap.channel),
        lightMapUv: G && _(T.lightMap.channel),
        bumpMapUv: z && _(T.bumpMap.channel),
        normalMapUv: ie && _(T.normalMap.channel),
        displacementMapUv: ae && _(T.displacementMap.channel),
        emissiveMapUv: re && _(T.emissiveMap.channel),
        metalnessMapUv: pe && _(T.metalnessMap.channel),
        roughnessMapUv: we && _(T.roughnessMap.channel),
        anisotropyMapUv: he && _(T.anisotropyMap.channel),
        clearcoatMapUv: de && _(T.clearcoatMap.channel),
        clearcoatNormalMapUv: xe && _(T.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: ne && _(T.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Le && _(T.iridescenceMap.channel),
        iridescenceThicknessMapUv: et && _(T.iridescenceThicknessMap.channel),
        sheenColorMapUv: Ne && _(T.sheenColorMap.channel),
        sheenRoughnessMapUv: Et && _(T.sheenRoughnessMap.channel),
        specularMapUv: kt && _(T.specularMap.channel),
        specularColorMapUv: je && _(T.specularColorMap.channel),
        specularIntensityMapUv: Ge && _(T.specularIntensityMap.channel),
        transmissionMapUv: Ye && _(T.transmissionMap.channel),
        thicknessMapUv: lt && _(T.thicknessMap.channel),
        alphaMapUv: _e && _(T.alphaMap.channel),
        vertexTangents: !!B.attributes.tangent && (ie || $e),
        vertexColors: T.vertexColors,
        vertexAlphas:
          T.vertexColors === !0 &&
          !!B.attributes.color &&
          B.attributes.color.itemSize === 4,
        vertexUv1s: _t,
        vertexUv2s: wt,
        vertexUv3s: Zt,
        pointsUvs: N.isPoints === !0 && !!B.attributes.uv && (Ve || _e),
        fog: !!I,
        useFog: T.fog === !0,
        fogExp2: I && I.isFogExp2,
        flatShading: T.flatShading === !0,
        sizeAttenuation: T.sizeAttenuation === !0,
        logarithmicDepthBuffer: h,
        skinning: N.isSkinnedMesh === !0,
        morphTargets: B.morphAttributes.position !== void 0,
        morphNormals: B.morphAttributes.normal !== void 0,
        morphColors: B.morphAttributes.color !== void 0,
        morphTargetsCount: le,
        morphTextureStride: q,
        numDirLights: k.directional.length,
        numPointLights: k.point.length,
        numSpotLights: k.spot.length,
        numSpotLightMaps: k.spotLightMap.length,
        numRectAreaLights: k.rectArea.length,
        numHemiLights: k.hemi.length,
        numDirLightShadows: k.directionalShadowMap.length,
        numPointLightShadows: k.pointShadowMap.length,
        numSpotLightShadows: k.spotShadowMap.length,
        numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: T.dithering,
        shadowMapEnabled: e.shadowMap.enabled && R.length > 0,
        shadowMapType: e.shadowMap.type,
        toneMapping: T.toneMapped ? e.toneMapping : Ba,
        useLegacyLights: e.useLegacyLights,
        premultipliedAlpha: T.premultipliedAlpha,
        doubleSided: T.side === Oa,
        flipSided: T.side === Mi,
        useDepthPacking: T.depthPacking >= 0,
        depthPacking: T.depthPacking || 0,
        index0AttributeName: T.index0AttributeName,
        extensionDerivatives: He && T.extensions.derivatives === !0,
        extensionFragDepth: He && T.extensions.fragDepth === !0,
        extensionDrawBuffers: He && T.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: He && T.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: d || r.has('EXT_frag_depth'),
        rendererExtensionDrawBuffers: d || r.has('WEBGL_draw_buffers'),
        rendererExtensionShaderTextureLod: d || r.has('EXT_shader_texture_lod'),
        customProgramCacheKey: T.customProgramCacheKey(),
      }
    }
    function y(T) {
      const k = []
      if (
        (T.shaderID
          ? k.push(T.shaderID)
          : (k.push(T.customVertexShaderID), k.push(T.customFragmentShaderID)),
        T.defines !== void 0)
      )
        for (const R in T.defines) k.push(R), k.push(T.defines[R])
      return (
        T.isRawShaderMaterial === !1 &&
          (M(k, T), x(k, T), k.push(e.outputColorSpace)),
        k.push(T.customProgramCacheKey),
        k.join()
      )
    }
    function M(T, k) {
      T.push(k.precision),
        T.push(k.outputColorSpace),
        T.push(k.envMapMode),
        T.push(k.envMapCubeUVHeight),
        T.push(k.mapUv),
        T.push(k.alphaMapUv),
        T.push(k.lightMapUv),
        T.push(k.aoMapUv),
        T.push(k.bumpMapUv),
        T.push(k.normalMapUv),
        T.push(k.displacementMapUv),
        T.push(k.emissiveMapUv),
        T.push(k.metalnessMapUv),
        T.push(k.roughnessMapUv),
        T.push(k.anisotropyMapUv),
        T.push(k.clearcoatMapUv),
        T.push(k.clearcoatNormalMapUv),
        T.push(k.clearcoatRoughnessMapUv),
        T.push(k.iridescenceMapUv),
        T.push(k.iridescenceThicknessMapUv),
        T.push(k.sheenColorMapUv),
        T.push(k.sheenRoughnessMapUv),
        T.push(k.specularMapUv),
        T.push(k.specularColorMapUv),
        T.push(k.specularIntensityMapUv),
        T.push(k.transmissionMapUv),
        T.push(k.thicknessMapUv),
        T.push(k.combine),
        T.push(k.fogExp2),
        T.push(k.sizeAttenuation),
        T.push(k.morphTargetsCount),
        T.push(k.morphAttributeCount),
        T.push(k.numDirLights),
        T.push(k.numPointLights),
        T.push(k.numSpotLights),
        T.push(k.numSpotLightMaps),
        T.push(k.numHemiLights),
        T.push(k.numRectAreaLights),
        T.push(k.numDirLightShadows),
        T.push(k.numPointLightShadows),
        T.push(k.numSpotLightShadows),
        T.push(k.numSpotLightShadowsWithMaps),
        T.push(k.shadowMapType),
        T.push(k.toneMapping),
        T.push(k.numClippingPlanes),
        T.push(k.numClipIntersection),
        T.push(k.depthPacking)
    }
    function x(T, k) {
      s.disableAll(),
        k.isWebGL2 && s.enable(0),
        k.supportsVertexTextures && s.enable(1),
        k.instancing && s.enable(2),
        k.instancingColor && s.enable(3),
        k.matcap && s.enable(4),
        k.envMap && s.enable(5),
        k.normalMapObjectSpace && s.enable(6),
        k.normalMapTangentSpace && s.enable(7),
        k.clearcoat && s.enable(8),
        k.iridescence && s.enable(9),
        k.alphaTest && s.enable(10),
        k.vertexColors && s.enable(11),
        k.vertexAlphas && s.enable(12),
        k.vertexUv1s && s.enable(13),
        k.vertexUv2s && s.enable(14),
        k.vertexUv3s && s.enable(15),
        k.vertexTangents && s.enable(16),
        k.anisotropy && s.enable(17),
        T.push(s.mask),
        s.disableAll(),
        k.fog && s.enable(0),
        k.useFog && s.enable(1),
        k.flatShading && s.enable(2),
        k.logarithmicDepthBuffer && s.enable(3),
        k.skinning && s.enable(4),
        k.morphTargets && s.enable(5),
        k.morphNormals && s.enable(6),
        k.morphColors && s.enable(7),
        k.premultipliedAlpha && s.enable(8),
        k.shadowMapEnabled && s.enable(9),
        k.useLegacyLights && s.enable(10),
        k.doubleSided && s.enable(11),
        k.flipSided && s.enable(12),
        k.useDepthPacking && s.enable(13),
        k.dithering && s.enable(14),
        k.transmission && s.enable(15),
        k.sheen && s.enable(16),
        k.opaque && s.enable(17),
        k.pointsUvs && s.enable(18),
        T.push(s.mask)
    }
    function w(T) {
      const k = g[T.type]
      let R
      if (k) {
        const j = Si[k]
        R = OS.clone(j.uniforms)
      } else R = T.uniforms
      return R
    }
    function E(T, k) {
      let R
      for (let j = 0, N = c.length; j < N; j++) {
        const I = c[j]
        if (I.cacheKey === k) {
          ;(R = I), ++R.usedTimes
          break
        }
      }
      return R === void 0 && ((R = new bfe(e, k, T, o)), c.push(R)), R
    }
    function P(T) {
      if (--T.usedTimes === 0) {
        const k = c.indexOf(T)
        ;(c[k] = c[c.length - 1]), c.pop(), T.destroy()
      }
    }
    function A(T) {
      l.remove(T)
    }
    function F() {
      l.dispose()
    }
    return {
      getParameters: b,
      getProgramCacheKey: y,
      getUniforms: w,
      acquireProgram: E,
      releaseProgram: P,
      releaseShaderCache: A,
      programs: c,
      dispose: F,
    }
  }
  function xfe() {
    let e = new WeakMap()
    function t(o) {
      let a = e.get(o)
      return a === void 0 && ((a = {}), e.set(o, a)), a
    }
    function n(o) {
      e.delete(o)
    }
    function r(o, a, s) {
      e.get(o)[a] = s
    }
    function i() {
      e = new WeakMap()
    }
    return { get: t, remove: n, update: r, dispose: i }
  }
  function Mfe(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.material.id !== t.material.id
      ? e.material.id - t.material.id
      : e.z !== t.z
      ? e.z - t.z
      : e.id - t.id
  }
  function LP(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.z !== t.z
      ? t.z - e.z
      : e.id - t.id
  }
  function IP() {
    const e = []
    let t = 0
    const n = [],
      r = [],
      i = []
    function o() {
      ;(t = 0), (n.length = 0), (r.length = 0), (i.length = 0)
    }
    function a(h, p, v, g, _, b) {
      let y = e[t]
      return (
        y === void 0
          ? ((y = {
              id: h.id,
              object: h,
              geometry: p,
              material: v,
              groupOrder: g,
              renderOrder: h.renderOrder,
              z: _,
              group: b,
            }),
            (e[t] = y))
          : ((y.id = h.id),
            (y.object = h),
            (y.geometry = p),
            (y.material = v),
            (y.groupOrder = g),
            (y.renderOrder = h.renderOrder),
            (y.z = _),
            (y.group = b)),
        t++,
        y
      )
    }
    function s(h, p, v, g, _, b) {
      const y = a(h, p, v, g, _, b)
      v.transmission > 0
        ? r.push(y)
        : v.transparent === !0
        ? i.push(y)
        : n.push(y)
    }
    function l(h, p, v, g, _, b) {
      const y = a(h, p, v, g, _, b)
      v.transmission > 0
        ? r.unshift(y)
        : v.transparent === !0
        ? i.unshift(y)
        : n.unshift(y)
    }
    function c(h, p) {
      n.length > 1 && n.sort(h || Mfe),
        r.length > 1 && r.sort(p || LP),
        i.length > 1 && i.sort(p || LP)
    }
    function d() {
      for (let h = t, p = e.length; h < p; h++) {
        const v = e[h]
        if (v.id === null) break
        ;(v.id = null),
          (v.object = null),
          (v.geometry = null),
          (v.material = null),
          (v.group = null)
      }
    }
    return {
      opaque: n,
      transmissive: r,
      transparent: i,
      init: o,
      push: s,
      unshift: l,
      finish: d,
      sort: c,
    }
  }
  function Efe() {
    let e = new WeakMap()
    function t(r, i) {
      const o = e.get(r)
      let a
      return (
        o === void 0
          ? ((a = new IP()), e.set(r, [a]))
          : i >= o.length
          ? ((a = new IP()), o.push(a))
          : (a = o[i]),
        a
      )
    }
    function n() {
      e = new WeakMap()
    }
    return { get: t, dispose: n }
  }
  function Pfe() {
    const e = {}
    return {
      get: function (t) {
        if (e[t.id] !== void 0) return e[t.id]
        let n
        switch (t.type) {
          case 'DirectionalLight':
            n = { direction: new Pe(), color: new xn() }
            break
          case 'SpotLight':
            n = {
              position: new Pe(),
              direction: new Pe(),
              color: new xn(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            }
            break
          case 'PointLight':
            n = { position: new Pe(), color: new xn(), distance: 0, decay: 0 }
            break
          case 'HemisphereLight':
            n = {
              direction: new Pe(),
              skyColor: new xn(),
              groundColor: new xn(),
            }
            break
          case 'RectAreaLight':
            n = {
              color: new xn(),
              position: new Pe(),
              halfWidth: new Pe(),
              halfHeight: new Pe(),
            }
            break
        }
        return (e[t.id] = n), n
      },
    }
  }
  function Tfe() {
    const e = {}
    return {
      get: function (t) {
        if (e[t.id] !== void 0) return e[t.id]
        let n
        switch (t.type) {
          case 'DirectionalLight':
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Ct(),
            }
            break
          case 'SpotLight':
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Ct(),
            }
            break
          case 'PointLight':
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Ct(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3,
            }
            break
        }
        return (e[t.id] = n), n
      },
    }
  }
  let kfe = 0
  function Afe(e, t) {
    return (
      (t.castShadow ? 2 : 0) -
      (e.castShadow ? 2 : 0) +
      (t.map ? 1 : 0) -
      (e.map ? 1 : 0)
    )
  }
  function $fe(e, t) {
    const n = new Pfe(),
      r = Tfe(),
      i = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
      }
    for (let d = 0; d < 9; d++) i.probe.push(new Pe())
    const o = new Pe(),
      a = new qn(),
      s = new qn()
    function l(d, h) {
      let p = 0,
        v = 0,
        g = 0
      for (let R = 0; R < 9; R++) i.probe[R].set(0, 0, 0)
      let _ = 0,
        b = 0,
        y = 0,
        M = 0,
        x = 0,
        w = 0,
        E = 0,
        P = 0,
        A = 0,
        F = 0
      d.sort(Afe)
      const T = h === !0 ? Math.PI : 1
      for (let R = 0, j = d.length; R < j; R++) {
        const N = d[R],
          I = N.color,
          B = N.intensity,
          V = N.distance,
          L = N.shadow && N.shadow.map ? N.shadow.map.texture : null
        if (N.isAmbientLight)
          (p += I.r * B * T), (v += I.g * B * T), (g += I.b * B * T)
        else if (N.isLightProbe)
          for (let W = 0; W < 9; W++)
            i.probe[W].addScaledVector(N.sh.coefficients[W], B)
        else if (N.isDirectionalLight) {
          const W = n.get(N)
          if (
            (W.color.copy(N.color).multiplyScalar(N.intensity * T),
            N.castShadow)
          ) {
            const Y = N.shadow,
              U = r.get(N)
            ;(U.shadowBias = Y.bias),
              (U.shadowNormalBias = Y.normalBias),
              (U.shadowRadius = Y.radius),
              (U.shadowMapSize = Y.mapSize),
              (i.directionalShadow[_] = U),
              (i.directionalShadowMap[_] = L),
              (i.directionalShadowMatrix[_] = N.shadow.matrix),
              w++
          }
          ;(i.directional[_] = W), _++
        } else if (N.isSpotLight) {
          const W = n.get(N)
          W.position.setFromMatrixPosition(N.matrixWorld),
            W.color.copy(I).multiplyScalar(B * T),
            (W.distance = V),
            (W.coneCos = Math.cos(N.angle)),
            (W.penumbraCos = Math.cos(N.angle * (1 - N.penumbra))),
            (W.decay = N.decay),
            (i.spot[y] = W)
          const Y = N.shadow
          if (
            (N.map &&
              ((i.spotLightMap[A] = N.map),
              A++,
              Y.updateMatrices(N),
              N.castShadow && F++),
            (i.spotLightMatrix[y] = Y.matrix),
            N.castShadow)
          ) {
            const U = r.get(N)
            ;(U.shadowBias = Y.bias),
              (U.shadowNormalBias = Y.normalBias),
              (U.shadowRadius = Y.radius),
              (U.shadowMapSize = Y.mapSize),
              (i.spotShadow[y] = U),
              (i.spotShadowMap[y] = L),
              P++
          }
          y++
        } else if (N.isRectAreaLight) {
          const W = n.get(N)
          W.color.copy(I).multiplyScalar(B),
            W.halfWidth.set(N.width * 0.5, 0, 0),
            W.halfHeight.set(0, N.height * 0.5, 0),
            (i.rectArea[M] = W),
            M++
        } else if (N.isPointLight) {
          const W = n.get(N)
          if (
            (W.color.copy(N.color).multiplyScalar(N.intensity * T),
            (W.distance = N.distance),
            (W.decay = N.decay),
            N.castShadow)
          ) {
            const Y = N.shadow,
              U = r.get(N)
            ;(U.shadowBias = Y.bias),
              (U.shadowNormalBias = Y.normalBias),
              (U.shadowRadius = Y.radius),
              (U.shadowMapSize = Y.mapSize),
              (U.shadowCameraNear = Y.camera.near),
              (U.shadowCameraFar = Y.camera.far),
              (i.pointShadow[b] = U),
              (i.pointShadowMap[b] = L),
              (i.pointShadowMatrix[b] = N.shadow.matrix),
              E++
          }
          ;(i.point[b] = W), b++
        } else if (N.isHemisphereLight) {
          const W = n.get(N)
          W.skyColor.copy(N.color).multiplyScalar(B * T),
            W.groundColor.copy(N.groundColor).multiplyScalar(B * T),
            (i.hemi[x] = W),
            x++
        }
      }
      M > 0 &&
        (t.isWebGL2 || e.has('OES_texture_float_linear') === !0
          ? ((i.rectAreaLTC1 = Pt.LTC_FLOAT_1),
            (i.rectAreaLTC2 = Pt.LTC_FLOAT_2))
          : e.has('OES_texture_half_float_linear') === !0
          ? ((i.rectAreaLTC1 = Pt.LTC_HALF_1), (i.rectAreaLTC2 = Pt.LTC_HALF_2))
          : console.error(
              'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
            )),
        (i.ambient[0] = p),
        (i.ambient[1] = v),
        (i.ambient[2] = g)
      const k = i.hash
      ;(k.directionalLength !== _ ||
        k.pointLength !== b ||
        k.spotLength !== y ||
        k.rectAreaLength !== M ||
        k.hemiLength !== x ||
        k.numDirectionalShadows !== w ||
        k.numPointShadows !== E ||
        k.numSpotShadows !== P ||
        k.numSpotMaps !== A) &&
        ((i.directional.length = _),
        (i.spot.length = y),
        (i.rectArea.length = M),
        (i.point.length = b),
        (i.hemi.length = x),
        (i.directionalShadow.length = w),
        (i.directionalShadowMap.length = w),
        (i.pointShadow.length = E),
        (i.pointShadowMap.length = E),
        (i.spotShadow.length = P),
        (i.spotShadowMap.length = P),
        (i.directionalShadowMatrix.length = w),
        (i.pointShadowMatrix.length = E),
        (i.spotLightMatrix.length = P + A - F),
        (i.spotLightMap.length = A),
        (i.numSpotLightShadowsWithMaps = F),
        (k.directionalLength = _),
        (k.pointLength = b),
        (k.spotLength = y),
        (k.rectAreaLength = M),
        (k.hemiLength = x),
        (k.numDirectionalShadows = w),
        (k.numPointShadows = E),
        (k.numSpotShadows = P),
        (k.numSpotMaps = A),
        (i.version = kfe++))
    }
    function c(d, h) {
      let p = 0,
        v = 0,
        g = 0,
        _ = 0,
        b = 0
      const y = h.matrixWorldInverse
      for (let M = 0, x = d.length; M < x; M++) {
        const w = d[M]
        if (w.isDirectionalLight) {
          const E = i.directional[p]
          E.direction.setFromMatrixPosition(w.matrixWorld),
            o.setFromMatrixPosition(w.target.matrixWorld),
            E.direction.sub(o),
            E.direction.transformDirection(y),
            p++
        } else if (w.isSpotLight) {
          const E = i.spot[g]
          E.position.setFromMatrixPosition(w.matrixWorld),
            E.position.applyMatrix4(y),
            E.direction.setFromMatrixPosition(w.matrixWorld),
            o.setFromMatrixPosition(w.target.matrixWorld),
            E.direction.sub(o),
            E.direction.transformDirection(y),
            g++
        } else if (w.isRectAreaLight) {
          const E = i.rectArea[_]
          E.position.setFromMatrixPosition(w.matrixWorld),
            E.position.applyMatrix4(y),
            s.identity(),
            a.copy(w.matrixWorld),
            a.premultiply(y),
            s.extractRotation(a),
            E.halfWidth.set(w.width * 0.5, 0, 0),
            E.halfHeight.set(0, w.height * 0.5, 0),
            E.halfWidth.applyMatrix4(s),
            E.halfHeight.applyMatrix4(s),
            _++
        } else if (w.isPointLight) {
          const E = i.point[v]
          E.position.setFromMatrixPosition(w.matrixWorld),
            E.position.applyMatrix4(y),
            v++
        } else if (w.isHemisphereLight) {
          const E = i.hemi[b]
          E.direction.setFromMatrixPosition(w.matrixWorld),
            E.direction.transformDirection(y),
            b++
        }
      }
    }
    return { setup: l, setupView: c, state: i }
  }
  function RP(e, t) {
    const n = new $fe(e, t),
      r = [],
      i = []
    function o() {
      ;(r.length = 0), (i.length = 0)
    }
    function a(h) {
      r.push(h)
    }
    function s(h) {
      i.push(h)
    }
    function l(h) {
      n.setup(r, h)
    }
    function c(h) {
      n.setupView(r, h)
    }
    return {
      init: o,
      state: { lightsArray: r, shadowsArray: i, lights: n },
      setupLights: l,
      setupLightsView: c,
      pushLight: a,
      pushShadow: s,
    }
  }
  function Ofe(e, t) {
    let n = new WeakMap()
    function r(o, a = 0) {
      const s = n.get(o)
      let l
      return (
        s === void 0
          ? ((l = new RP(e, t)), n.set(o, [l]))
          : a >= s.length
          ? ((l = new RP(e, t)), s.push(l))
          : (l = s[a]),
        l
      )
    }
    function i() {
      n = new WeakMap()
    }
    return { get: r, dispose: i }
  }
  class Lfe extends cc {
    constructor(t) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = 'MeshDepthMaterial'),
        (this.depthPacking = Sse),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        (this.depthPacking = t.depthPacking),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      )
    }
  }
  class Ife extends cc {
    constructor(t) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = 'MeshDistanceMaterial'),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      )
    }
  }
  const Rfe = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    Dfe = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
  function Nfe(e, t, n) {
    let r = new LS()
    const i = new Ct(),
      o = new Ct(),
      a = new Jn(),
      s = new Lfe({ depthPacking: Cse }),
      l = new Ife(),
      c = {},
      d = n.maxTextureSize,
      h = { [$s]: Mi, [Mi]: $s, [Oa]: Oa },
      p = new Os({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new Ct() },
          radius: { value: 4 },
        },
        vertexShader: Rfe,
        fragmentShader: Dfe,
      }),
      v = p.clone()
    v.defines.HORIZONTAL_PASS = 1
    const g = new la()
    g.setAttribute(
      'position',
      new Io(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    )
    const _ = new Ci(g, p),
      b = this
    ;(this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = qA)
    let y = this.type
    this.render = function (E, P, A) {
      if (
        b.enabled === !1 ||
        (b.autoUpdate === !1 && b.needsUpdate === !1) ||
        E.length === 0
      )
        return
      const F = e.getRenderTarget(),
        T = e.getActiveCubeFace(),
        k = e.getActiveMipmapLevel(),
        R = e.state
      R.setBlending(Ms),
        R.buffers.color.setClear(1, 1, 1, 1),
        R.buffers.depth.setTest(!0),
        R.setScissorTest(!1)
      const j = y !== ka && this.type === ka,
        N = y === ka && this.type !== ka
      for (let I = 0, B = E.length; I < B; I++) {
        const V = E[I],
          L = V.shadow
        if (L === void 0) {
          console.warn('THREE.WebGLShadowMap:', V, 'has no shadow.')
          continue
        }
        if (L.autoUpdate === !1 && L.needsUpdate === !1) continue
        i.copy(L.mapSize)
        const W = L.getFrameExtents()
        if (
          (i.multiply(W),
          o.copy(L.mapSize),
          (i.x > d || i.y > d) &&
            (i.x > d &&
              ((o.x = Math.floor(d / W.x)),
              (i.x = o.x * W.x),
              (L.mapSize.x = o.x)),
            i.y > d &&
              ((o.y = Math.floor(d / W.y)),
              (i.y = o.y * W.y),
              (L.mapSize.y = o.y))),
          L.map === null || j === !0 || N === !0)
        ) {
          const U = this.type !== ka ? { minFilter: li, magFilter: li } : {}
          L.map !== null && L.map.dispose(),
            (L.map = new El(i.x, i.y, U)),
            (L.map.texture.name = V.name + '.shadowMap'),
            L.camera.updateProjectionMatrix()
        }
        e.setRenderTarget(L.map), e.clear()
        const Y = L.getViewportCount()
        for (let U = 0; U < Y; U++) {
          const le = L.getViewport(U)
          a.set(o.x * le.x, o.y * le.y, o.x * le.z, o.y * le.w),
            R.viewport(a),
            L.updateMatrices(V, U),
            (r = L.getFrustum()),
            w(P, A, L.camera, V, this.type)
        }
        L.isPointLightShadow !== !0 && this.type === ka && M(L, A),
          (L.needsUpdate = !1)
      }
      ;(y = this.type), (b.needsUpdate = !1), e.setRenderTarget(F, T, k)
    }
    function M(E, P) {
      const A = t.update(_)
      p.defines.VSM_SAMPLES !== E.blurSamples &&
        ((p.defines.VSM_SAMPLES = E.blurSamples),
        (v.defines.VSM_SAMPLES = E.blurSamples),
        (p.needsUpdate = !0),
        (v.needsUpdate = !0)),
        E.mapPass === null && (E.mapPass = new El(i.x, i.y)),
        (p.uniforms.shadow_pass.value = E.map.texture),
        (p.uniforms.resolution.value = E.mapSize),
        (p.uniforms.radius.value = E.radius),
        e.setRenderTarget(E.mapPass),
        e.clear(),
        e.renderBufferDirect(P, null, A, p, _, null),
        (v.uniforms.shadow_pass.value = E.mapPass.texture),
        (v.uniforms.resolution.value = E.mapSize),
        (v.uniforms.radius.value = E.radius),
        e.setRenderTarget(E.map),
        e.clear(),
        e.renderBufferDirect(P, null, A, v, _, null)
    }
    function x(E, P, A, F) {
      let T = null
      const k =
        A.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial
      if (k !== void 0) T = k
      else if (
        ((T = A.isPointLight === !0 ? l : s),
        (e.localClippingEnabled &&
          P.clipShadows === !0 &&
          Array.isArray(P.clippingPlanes) &&
          P.clippingPlanes.length !== 0) ||
          (P.displacementMap && P.displacementScale !== 0) ||
          (P.alphaMap && P.alphaTest > 0) ||
          (P.map && P.alphaTest > 0))
      ) {
        const R = T.uuid,
          j = P.uuid
        let N = c[R]
        N === void 0 && ((N = {}), (c[R] = N))
        let I = N[j]
        I === void 0 && ((I = T.clone()), (N[j] = I)), (T = I)
      }
      if (
        ((T.visible = P.visible),
        (T.wireframe = P.wireframe),
        F === ka
          ? (T.side = P.shadowSide !== null ? P.shadowSide : P.side)
          : (T.side = P.shadowSide !== null ? P.shadowSide : h[P.side]),
        (T.alphaMap = P.alphaMap),
        (T.alphaTest = P.alphaTest),
        (T.map = P.map),
        (T.clipShadows = P.clipShadows),
        (T.clippingPlanes = P.clippingPlanes),
        (T.clipIntersection = P.clipIntersection),
        (T.displacementMap = P.displacementMap),
        (T.displacementScale = P.displacementScale),
        (T.displacementBias = P.displacementBias),
        (T.wireframeLinewidth = P.wireframeLinewidth),
        (T.linewidth = P.linewidth),
        A.isPointLight === !0 && T.isMeshDistanceMaterial === !0)
      ) {
        const R = e.properties.get(T)
        R.light = A
      }
      return T
    }
    function w(E, P, A, F, T) {
      if (E.visible === !1) return
      if (
        E.layers.test(P.layers) &&
        (E.isMesh || E.isLine || E.isPoints) &&
        (E.castShadow || (E.receiveShadow && T === ka)) &&
        (!E.frustumCulled || r.intersectsObject(E))
      ) {
        E.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, E.matrixWorld)
        const j = t.update(E),
          N = E.material
        if (Array.isArray(N)) {
          const I = j.groups
          for (let B = 0, V = I.length; B < V; B++) {
            const L = I[B],
              W = N[L.materialIndex]
            if (W && W.visible) {
              const Y = x(E, W, F, T)
              e.renderBufferDirect(A, null, j, Y, E, L)
            }
          }
        } else if (N.visible) {
          const I = x(E, N, F, T)
          e.renderBufferDirect(A, null, j, I, E, null)
        }
      }
      const R = E.children
      for (let j = 0, N = R.length; j < N; j++) w(R[j], P, A, F, T)
    }
  }
  function Bfe(e, t, n) {
    const r = n.isWebGL2
    function i() {
      let _e = !1
      const bt = new Jn()
      let He = null
      const _t = new Jn(0, 0, 0, 0)
      return {
        setMask: function (wt) {
          He !== wt && !_e && (e.colorMask(wt, wt, wt, wt), (He = wt))
        },
        setLocked: function (wt) {
          _e = wt
        },
        setClear: function (wt, Zt, ln, Pn, Tr) {
          Tr === !0 && ((wt *= Pn), (Zt *= Pn), (ln *= Pn)),
            bt.set(wt, Zt, ln, Pn),
            _t.equals(bt) === !1 && (e.clearColor(wt, Zt, ln, Pn), _t.copy(bt))
        },
        reset: function () {
          ;(_e = !1), (He = null), _t.set(-1, 0, 0, 0)
        },
      }
    }
    function o() {
      let _e = !1,
        bt = null,
        He = null,
        _t = null
      return {
        setTest: function (wt) {
          wt ? Re(e.DEPTH_TEST) : qe(e.DEPTH_TEST)
        },
        setMask: function (wt) {
          bt !== wt && !_e && (e.depthMask(wt), (bt = wt))
        },
        setFunc: function (wt) {
          if (He !== wt) {
            switch (wt) {
              case Zae:
                e.depthFunc(e.NEVER)
                break
              case Jae:
                e.depthFunc(e.ALWAYS)
                break
              case Qae:
                e.depthFunc(e.LESS)
                break
              case Wb:
                e.depthFunc(e.LEQUAL)
                break
              case ese:
                e.depthFunc(e.EQUAL)
                break
              case tse:
                e.depthFunc(e.GEQUAL)
                break
              case nse:
                e.depthFunc(e.GREATER)
                break
              case rse:
                e.depthFunc(e.NOTEQUAL)
                break
              default:
                e.depthFunc(e.LEQUAL)
            }
            He = wt
          }
        },
        setLocked: function (wt) {
          _e = wt
        },
        setClear: function (wt) {
          _t !== wt && (e.clearDepth(wt), (_t = wt))
        },
        reset: function () {
          ;(_e = !1), (bt = null), (He = null), (_t = null)
        },
      }
    }
    function a() {
      let _e = !1,
        bt = null,
        He = null,
        _t = null,
        wt = null,
        Zt = null,
        ln = null,
        Pn = null,
        Tr = null
      return {
        setTest: function (vt) {
          _e || (vt ? Re(e.STENCIL_TEST) : qe(e.STENCIL_TEST))
        },
        setMask: function (vt) {
          bt !== vt && !_e && (e.stencilMask(vt), (bt = vt))
        },
        setFunc: function (vt, Gt, pn) {
          ;(He !== vt || _t !== Gt || wt !== pn) &&
            (e.stencilFunc(vt, Gt, pn), (He = vt), (_t = Gt), (wt = pn))
        },
        setOp: function (vt, Gt, pn) {
          ;(Zt !== vt || ln !== Gt || Pn !== pn) &&
            (e.stencilOp(vt, Gt, pn), (Zt = vt), (ln = Gt), (Pn = pn))
        },
        setLocked: function (vt) {
          _e = vt
        },
        setClear: function (vt) {
          Tr !== vt && (e.clearStencil(vt), (Tr = vt))
        },
        reset: function () {
          ;(_e = !1),
            (bt = null),
            (He = null),
            (_t = null),
            (wt = null),
            (Zt = null),
            (ln = null),
            (Pn = null),
            (Tr = null)
        },
      }
    }
    const s = new i(),
      l = new o(),
      c = new a(),
      d = new WeakMap(),
      h = new WeakMap()
    let p = {},
      v = {},
      g = new WeakMap(),
      _ = [],
      b = null,
      y = !1,
      M = null,
      x = null,
      w = null,
      E = null,
      P = null,
      A = null,
      F = null,
      T = !1,
      k = null,
      R = null,
      j = null,
      N = null,
      I = null
    const B = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
    let V = !1,
      L = 0
    const W = e.getParameter(e.VERSION)
    W.indexOf('WebGL') !== -1
      ? ((L = parseFloat(/^WebGL (\d)/.exec(W)[1])), (V = L >= 1))
      : W.indexOf('OpenGL ES') !== -1 &&
        ((L = parseFloat(/^OpenGL ES (\d)/.exec(W)[1])), (V = L >= 2))
    let Y = null,
      U = {}
    const le = e.getParameter(e.SCISSOR_BOX),
      q = e.getParameter(e.VIEWPORT),
      oe = new Jn().fromArray(le),
      te = new Jn().fromArray(q)
    function ue(_e, bt, He, _t) {
      const wt = new Uint8Array(4),
        Zt = e.createTexture()
      e.bindTexture(_e, Zt),
        e.texParameteri(_e, e.TEXTURE_MIN_FILTER, e.NEAREST),
        e.texParameteri(_e, e.TEXTURE_MAG_FILTER, e.NEAREST)
      for (let ln = 0; ln < He; ln++)
        r && (_e === e.TEXTURE_3D || _e === e.TEXTURE_2D_ARRAY)
          ? e.texImage3D(
              bt,
              0,
              e.RGBA,
              1,
              1,
              _t,
              0,
              e.RGBA,
              e.UNSIGNED_BYTE,
              wt
            )
          : e.texImage2D(
              bt + ln,
              0,
              e.RGBA,
              1,
              1,
              0,
              e.RGBA,
              e.UNSIGNED_BYTE,
              wt
            )
      return Zt
    }
    const me = {}
    ;(me[e.TEXTURE_2D] = ue(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
      (me[e.TEXTURE_CUBE_MAP] = ue(
        e.TEXTURE_CUBE_MAP,
        e.TEXTURE_CUBE_MAP_POSITIVE_X,
        6
      )),
      r &&
        ((me[e.TEXTURE_2D_ARRAY] = ue(
          e.TEXTURE_2D_ARRAY,
          e.TEXTURE_2D_ARRAY,
          1,
          1
        )),
        (me[e.TEXTURE_3D] = ue(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1))),
      s.setClear(0, 0, 0, 1),
      l.setClear(1),
      c.setClear(0),
      Re(e.DEPTH_TEST),
      l.setFunc(Wb),
      ae(!1),
      re(S3),
      Re(e.CULL_FACE),
      z(Ms)
    function Re(_e) {
      p[_e] !== !0 && (e.enable(_e), (p[_e] = !0))
    }
    function qe(_e) {
      p[_e] !== !1 && (e.disable(_e), (p[_e] = !1))
    }
    function Ve(_e, bt) {
      return v[_e] !== bt
        ? (e.bindFramebuffer(_e, bt),
          (v[_e] = bt),
          r &&
            (_e === e.DRAW_FRAMEBUFFER && (v[e.FRAMEBUFFER] = bt),
            _e === e.FRAMEBUFFER && (v[e.DRAW_FRAMEBUFFER] = bt)),
          !0)
        : !1
    }
    function nt(_e, bt) {
      let He = _,
        _t = !1
      if (_e)
        if (
          ((He = g.get(bt)),
          He === void 0 && ((He = []), g.set(bt, He)),
          _e.isWebGLMultipleRenderTargets)
        ) {
          const wt = _e.texture
          if (He.length !== wt.length || He[0] !== e.COLOR_ATTACHMENT0) {
            for (let Zt = 0, ln = wt.length; Zt < ln; Zt++)
              He[Zt] = e.COLOR_ATTACHMENT0 + Zt
            ;(He.length = wt.length), (_t = !0)
          }
        } else
          He[0] !== e.COLOR_ATTACHMENT0 &&
            ((He[0] = e.COLOR_ATTACHMENT0), (_t = !0))
      else He[0] !== e.BACK && ((He[0] = e.BACK), (_t = !0))
      _t &&
        (n.isWebGL2
          ? e.drawBuffers(He)
          : t.get('WEBGL_draw_buffers').drawBuffersWEBGL(He))
    }
    function We(_e) {
      return b !== _e ? (e.useProgram(_e), (b = _e), !0) : !1
    }
    const D = {
      [wu]: e.FUNC_ADD,
      [zae]: e.FUNC_SUBTRACT,
      [Vae]: e.FUNC_REVERSE_SUBTRACT,
    }
    if (r) (D[M3] = e.MIN), (D[E3] = e.MAX)
    else {
      const _e = t.get('EXT_blend_minmax')
      _e !== null && ((D[M3] = _e.MIN_EXT), (D[E3] = _e.MAX_EXT))
    }
    const G = {
      [Uae]: e.ZERO,
      [Hae]: e.ONE,
      [Wae]: e.SRC_COLOR,
      [XA]: e.SRC_ALPHA,
      [Yae]: e.SRC_ALPHA_SATURATE,
      [qae]: e.DST_COLOR,
      [Gae]: e.DST_ALPHA,
      [jae]: e.ONE_MINUS_SRC_COLOR,
      [YA]: e.ONE_MINUS_SRC_ALPHA,
      [Xae]: e.ONE_MINUS_DST_COLOR,
      [Kae]: e.ONE_MINUS_DST_ALPHA,
    }
    function z(_e, bt, He, _t, wt, Zt, ln, Pn) {
      if (_e === Ms) {
        y === !0 && (qe(e.BLEND), (y = !1))
        return
      }
      if ((y === !1 && (Re(e.BLEND), (y = !0)), _e !== Fae)) {
        if (_e !== M || Pn !== T) {
          if (
            ((x !== wu || P !== wu) &&
              (e.blendEquation(e.FUNC_ADD), (x = wu), (P = wu)),
            Pn)
          )
            switch (_e) {
              case zu:
                e.blendFuncSeparate(
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA,
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA
                )
                break
              case C3:
                e.blendFunc(e.ONE, e.ONE)
                break
              case w3:
                e.blendFuncSeparate(
                  e.ZERO,
                  e.ONE_MINUS_SRC_COLOR,
                  e.ZERO,
                  e.ONE
                )
                break
              case x3:
                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)
                break
              default:
                console.error('THREE.WebGLState: Invalid blending: ', _e)
                break
            }
          else
            switch (_e) {
              case zu:
                e.blendFuncSeparate(
                  e.SRC_ALPHA,
                  e.ONE_MINUS_SRC_ALPHA,
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA
                )
                break
              case C3:
                e.blendFunc(e.SRC_ALPHA, e.ONE)
                break
              case w3:
                e.blendFuncSeparate(
                  e.ZERO,
                  e.ONE_MINUS_SRC_COLOR,
                  e.ZERO,
                  e.ONE
                )
                break
              case x3:
                e.blendFunc(e.ZERO, e.SRC_COLOR)
                break
              default:
                console.error('THREE.WebGLState: Invalid blending: ', _e)
                break
            }
          ;(w = null), (E = null), (A = null), (F = null), (M = _e), (T = Pn)
        }
        return
      }
      ;(wt = wt || bt),
        (Zt = Zt || He),
        (ln = ln || _t),
        (bt !== x || wt !== P) &&
          (e.blendEquationSeparate(D[bt], D[wt]), (x = bt), (P = wt)),
        (He !== w || _t !== E || Zt !== A || ln !== F) &&
          (e.blendFuncSeparate(G[He], G[_t], G[Zt], G[ln]),
          (w = He),
          (E = _t),
          (A = Zt),
          (F = ln)),
        (M = _e),
        (T = !1)
    }
    function ie(_e, bt) {
      _e.side === Oa ? qe(e.CULL_FACE) : Re(e.CULL_FACE)
      let He = _e.side === Mi
      bt && (He = !He),
        ae(He),
        _e.blending === zu && _e.transparent === !1
          ? z(Ms)
          : z(
              _e.blending,
              _e.blendEquation,
              _e.blendSrc,
              _e.blendDst,
              _e.blendEquationAlpha,
              _e.blendSrcAlpha,
              _e.blendDstAlpha,
              _e.premultipliedAlpha
            ),
        l.setFunc(_e.depthFunc),
        l.setTest(_e.depthTest),
        l.setMask(_e.depthWrite),
        s.setMask(_e.colorWrite)
      const _t = _e.stencilWrite
      c.setTest(_t),
        _t &&
          (c.setMask(_e.stencilWriteMask),
          c.setFunc(_e.stencilFunc, _e.stencilRef, _e.stencilFuncMask),
          c.setOp(_e.stencilFail, _e.stencilZFail, _e.stencilZPass)),
        we(_e.polygonOffset, _e.polygonOffsetFactor, _e.polygonOffsetUnits),
        _e.alphaToCoverage === !0
          ? Re(e.SAMPLE_ALPHA_TO_COVERAGE)
          : qe(e.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function ae(_e) {
      k !== _e && (_e ? e.frontFace(e.CW) : e.frontFace(e.CCW), (k = _e))
    }
    function re(_e) {
      _e !== Dae
        ? (Re(e.CULL_FACE),
          _e !== R &&
            (_e === S3
              ? e.cullFace(e.BACK)
              : _e === Nae
              ? e.cullFace(e.FRONT)
              : e.cullFace(e.FRONT_AND_BACK)))
        : qe(e.CULL_FACE),
        (R = _e)
    }
    function pe(_e) {
      _e !== j && (V && e.lineWidth(_e), (j = _e))
    }
    function we(_e, bt, He) {
      _e
        ? (Re(e.POLYGON_OFFSET_FILL),
          (N !== bt || I !== He) &&
            (e.polygonOffset(bt, He), (N = bt), (I = He)))
        : qe(e.POLYGON_OFFSET_FILL)
    }
    function $e(_e) {
      _e ? Re(e.SCISSOR_TEST) : qe(e.SCISSOR_TEST)
    }
    function Ae(_e) {
      _e === void 0 && (_e = e.TEXTURE0 + B - 1),
        Y !== _e && (e.activeTexture(_e), (Y = _e))
    }
    function ft(_e, bt, He) {
      He === void 0 && (Y === null ? (He = e.TEXTURE0 + B - 1) : (He = Y))
      let _t = U[He]
      _t === void 0 && ((_t = { type: void 0, texture: void 0 }), (U[He] = _t)),
        (_t.type !== _e || _t.texture !== bt) &&
          (Y !== He && (e.activeTexture(He), (Y = He)),
          e.bindTexture(_e, bt || me[_e]),
          (_t.type = _e),
          (_t.texture = bt))
    }
    function Q() {
      const _e = U[Y]
      _e !== void 0 &&
        _e.type !== void 0 &&
        (e.bindTexture(_e.type, null),
        (_e.type = void 0),
        (_e.texture = void 0))
    }
    function X() {
      try {
        e.compressedTexImage2D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function he() {
      try {
        e.compressedTexImage3D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function de() {
      try {
        e.texSubImage2D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function xe() {
      try {
        e.texSubImage3D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function ne() {
      try {
        e.compressedTexSubImage2D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function Le() {
      try {
        e.compressedTexSubImage3D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function et() {
      try {
        e.texStorage2D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function Ne() {
      try {
        e.texStorage3D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function Et() {
      try {
        e.texImage2D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function kt() {
      try {
        e.texImage3D.apply(e, arguments)
      } catch (_e) {
        console.error('THREE.WebGLState:', _e)
      }
    }
    function je(_e) {
      oe.equals(_e) === !1 && (e.scissor(_e.x, _e.y, _e.z, _e.w), oe.copy(_e))
    }
    function Ge(_e) {
      te.equals(_e) === !1 && (e.viewport(_e.x, _e.y, _e.z, _e.w), te.copy(_e))
    }
    function Ye(_e, bt) {
      let He = h.get(bt)
      He === void 0 && ((He = new WeakMap()), h.set(bt, He))
      let _t = He.get(_e)
      _t === void 0 &&
        ((_t = e.getUniformBlockIndex(bt, _e.name)), He.set(_e, _t))
    }
    function lt(_e, bt) {
      const _t = h.get(bt).get(_e)
      d.get(bt) !== _t &&
        (e.uniformBlockBinding(bt, _t, _e.__bindingPointIndex), d.set(bt, _t))
    }
    function gt() {
      e.disable(e.BLEND),
        e.disable(e.CULL_FACE),
        e.disable(e.DEPTH_TEST),
        e.disable(e.POLYGON_OFFSET_FILL),
        e.disable(e.SCISSOR_TEST),
        e.disable(e.STENCIL_TEST),
        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
        e.blendEquation(e.FUNC_ADD),
        e.blendFunc(e.ONE, e.ZERO),
        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
        e.colorMask(!0, !0, !0, !0),
        e.clearColor(0, 0, 0, 0),
        e.depthMask(!0),
        e.depthFunc(e.LESS),
        e.clearDepth(1),
        e.stencilMask(4294967295),
        e.stencilFunc(e.ALWAYS, 0, 4294967295),
        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
        e.clearStencil(0),
        e.cullFace(e.BACK),
        e.frontFace(e.CCW),
        e.polygonOffset(0, 0),
        e.activeTexture(e.TEXTURE0),
        e.bindFramebuffer(e.FRAMEBUFFER, null),
        r === !0 &&
          (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
        e.useProgram(null),
        e.lineWidth(1),
        e.scissor(0, 0, e.canvas.width, e.canvas.height),
        e.viewport(0, 0, e.canvas.width, e.canvas.height),
        (p = {}),
        (Y = null),
        (U = {}),
        (v = {}),
        (g = new WeakMap()),
        (_ = []),
        (b = null),
        (y = !1),
        (M = null),
        (x = null),
        (w = null),
        (E = null),
        (P = null),
        (A = null),
        (F = null),
        (T = !1),
        (k = null),
        (R = null),
        (j = null),
        (N = null),
        (I = null),
        oe.set(0, 0, e.canvas.width, e.canvas.height),
        te.set(0, 0, e.canvas.width, e.canvas.height),
        s.reset(),
        l.reset(),
        c.reset()
    }
    return {
      buffers: { color: s, depth: l, stencil: c },
      enable: Re,
      disable: qe,
      bindFramebuffer: Ve,
      drawBuffers: nt,
      useProgram: We,
      setBlending: z,
      setMaterial: ie,
      setFlipSided: ae,
      setCullFace: re,
      setLineWidth: pe,
      setPolygonOffset: we,
      setScissorTest: $e,
      activeTexture: Ae,
      bindTexture: ft,
      unbindTexture: Q,
      compressedTexImage2D: X,
      compressedTexImage3D: he,
      texImage2D: Et,
      texImage3D: kt,
      updateUBOMapping: Ye,
      uniformBlockBinding: lt,
      texStorage2D: et,
      texStorage3D: Ne,
      texSubImage2D: de,
      texSubImage3D: xe,
      compressedTexSubImage2D: ne,
      compressedTexSubImage3D: Le,
      scissor: je,
      viewport: Ge,
      reset: gt,
    }
  }
  function Ffe(e, t, n, r, i, o, a) {
    const s = i.isWebGL2,
      l = i.maxTextures,
      c = i.maxCubemapSize,
      d = i.maxTextureSize,
      h = i.maxSamples,
      p = t.has('WEBGL_multisampled_render_to_texture')
        ? t.get('WEBGL_multisampled_render_to_texture')
        : null,
      v =
        typeof navigator > 'u'
          ? !1
          : /OculusBrowser/g.test(navigator.userAgent),
      g = new WeakMap()
    let _
    const b = new WeakMap()
    let y = !1
    try {
      y =
        typeof OffscreenCanvas < 'u' &&
        new OffscreenCanvas(1, 1).getContext('2d') !== null
    } catch {}
    function M(Q, X) {
      return y ? new OffscreenCanvas(Q, X) : Fd('canvas')
    }
    function x(Q, X, he, de) {
      let xe = 1
      if (
        ((Q.width > de || Q.height > de) &&
          (xe = de / Math.max(Q.width, Q.height)),
        xe < 1 || X === !0)
      )
        if (
          (typeof HTMLImageElement < 'u' && Q instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement < 'u' && Q instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap < 'u' && Q instanceof ImageBitmap)
        ) {
          const ne = X ? Cv : Math.floor,
            Le = ne(xe * Q.width),
            et = ne(xe * Q.height)
          _ === void 0 && (_ = M(Le, et))
          const Ne = he ? M(Le, et) : _
          return (
            (Ne.width = Le),
            (Ne.height = et),
            Ne.getContext('2d').drawImage(Q, 0, 0, Le, et),
            console.warn(
              'THREE.WebGLRenderer: Texture has been resized from (' +
                Q.width +
                'x' +
                Q.height +
                ') to (' +
                Le +
                'x' +
                et +
                ').'
            ),
            Ne
          )
        } else
          return (
            'data' in Q &&
              console.warn(
                'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                  Q.width +
                  'x' +
                  Q.height +
                  ').'
              ),
            Q
          )
      return Q
    }
    function w(Q) {
      return Yb(Q.width) && Yb(Q.height)
    }
    function E(Q) {
      return s
        ? !1
        : Q.wrapS !== To ||
            Q.wrapT !== To ||
            (Q.minFilter !== li && Q.minFilter !== eo)
    }
    function P(Q, X) {
      return Q.generateMipmaps && X && Q.minFilter !== li && Q.minFilter !== eo
    }
    function A(Q) {
      e.generateMipmap(Q)
    }
    function F(Q, X, he, de, xe = !1) {
      if (s === !1) return X
      if (Q !== null) {
        if (e[Q] !== void 0) return e[Q]
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            Q +
            "'"
        )
      }
      let ne = X
      return (
        X === e.RED &&
          (he === e.FLOAT && (ne = e.R32F),
          he === e.HALF_FLOAT && (ne = e.R16F),
          he === e.UNSIGNED_BYTE && (ne = e.R8)),
        X === e.RG &&
          (he === e.FLOAT && (ne = e.RG32F),
          he === e.HALF_FLOAT && (ne = e.RG16F),
          he === e.UNSIGNED_BYTE && (ne = e.RG8)),
        X === e.RGBA &&
          (he === e.FLOAT && (ne = e.RGBA32F),
          he === e.HALF_FLOAT && (ne = e.RGBA16F),
          he === e.UNSIGNED_BYTE &&
            (ne = de === rn && xe === !1 ? e.SRGB8_ALPHA8 : e.RGBA8),
          he === e.UNSIGNED_SHORT_4_4_4_4 && (ne = e.RGBA4),
          he === e.UNSIGNED_SHORT_5_5_5_1 && (ne = e.RGB5_A1)),
        (ne === e.R16F ||
          ne === e.R32F ||
          ne === e.RG16F ||
          ne === e.RG32F ||
          ne === e.RGBA16F ||
          ne === e.RGBA32F) &&
          t.get('EXT_color_buffer_float'),
        ne
      )
    }
    function T(Q, X, he) {
      return P(Q, he) === !0 ||
        (Q.isFramebufferTexture && Q.minFilter !== li && Q.minFilter !== eo)
        ? Math.log2(Math.max(X.width, X.height)) + 1
        : Q.mipmaps !== void 0 && Q.mipmaps.length > 0
        ? Q.mipmaps.length
        : Q.isCompressedTexture && Array.isArray(Q.image)
        ? X.mipmaps.length
        : 1
    }
    function k(Q) {
      return Q === li || Q === P3 || Q === y1 ? e.NEAREST : e.LINEAR
    }
    function R(Q) {
      const X = Q.target
      X.removeEventListener('dispose', R), N(X), X.isVideoTexture && g.delete(X)
    }
    function j(Q) {
      const X = Q.target
      X.removeEventListener('dispose', j), B(X)
    }
    function N(Q) {
      const X = r.get(Q)
      if (X.__webglInit === void 0) return
      const he = Q.source,
        de = b.get(he)
      if (de) {
        const xe = de[X.__cacheKey]
        xe.usedTimes--,
          xe.usedTimes === 0 && I(Q),
          Object.keys(de).length === 0 && b.delete(he)
      }
      r.remove(Q)
    }
    function I(Q) {
      const X = r.get(Q)
      e.deleteTexture(X.__webglTexture)
      const he = Q.source,
        de = b.get(he)
      delete de[X.__cacheKey], a.memory.textures--
    }
    function B(Q) {
      const X = Q.texture,
        he = r.get(Q),
        de = r.get(X)
      if (
        (de.__webglTexture !== void 0 &&
          (e.deleteTexture(de.__webglTexture), a.memory.textures--),
        Q.depthTexture && Q.depthTexture.dispose(),
        Q.isWebGLCubeRenderTarget)
      )
        for (let xe = 0; xe < 6; xe++)
          e.deleteFramebuffer(he.__webglFramebuffer[xe]),
            he.__webglDepthbuffer &&
              e.deleteRenderbuffer(he.__webglDepthbuffer[xe])
      else {
        if (
          (e.deleteFramebuffer(he.__webglFramebuffer),
          he.__webglDepthbuffer && e.deleteRenderbuffer(he.__webglDepthbuffer),
          he.__webglMultisampledFramebuffer &&
            e.deleteFramebuffer(he.__webglMultisampledFramebuffer),
          he.__webglColorRenderbuffer)
        )
          for (let xe = 0; xe < he.__webglColorRenderbuffer.length; xe++)
            he.__webglColorRenderbuffer[xe] &&
              e.deleteRenderbuffer(he.__webglColorRenderbuffer[xe])
        he.__webglDepthRenderbuffer &&
          e.deleteRenderbuffer(he.__webglDepthRenderbuffer)
      }
      if (Q.isWebGLMultipleRenderTargets)
        for (let xe = 0, ne = X.length; xe < ne; xe++) {
          const Le = r.get(X[xe])
          Le.__webglTexture &&
            (e.deleteTexture(Le.__webglTexture), a.memory.textures--),
            r.remove(X[xe])
        }
      r.remove(X), r.remove(Q)
    }
    let V = 0
    function L() {
      V = 0
    }
    function W() {
      const Q = V
      return (
        Q >= l &&
          console.warn(
            'THREE.WebGLTextures: Trying to use ' +
              Q +
              ' texture units while this GPU supports only ' +
              l
          ),
        (V += 1),
        Q
      )
    }
    function Y(Q) {
      const X = []
      return (
        X.push(Q.wrapS),
        X.push(Q.wrapT),
        X.push(Q.wrapR || 0),
        X.push(Q.magFilter),
        X.push(Q.minFilter),
        X.push(Q.anisotropy),
        X.push(Q.internalFormat),
        X.push(Q.format),
        X.push(Q.type),
        X.push(Q.generateMipmaps),
        X.push(Q.premultiplyAlpha),
        X.push(Q.flipY),
        X.push(Q.unpackAlignment),
        X.push(Q.colorSpace),
        X.join()
      )
    }
    function U(Q, X) {
      const he = r.get(Q)
      if (
        (Q.isVideoTexture && Ae(Q),
        Q.isRenderTargetTexture === !1 &&
          Q.version > 0 &&
          he.__version !== Q.version)
      ) {
        const de = Q.image
        if (de === null)
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but no image data found.'
          )
        else if (de.complete === !1)
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
          )
        else {
          Ve(he, Q, X)
          return
        }
      }
      n.bindTexture(e.TEXTURE_2D, he.__webglTexture, e.TEXTURE0 + X)
    }
    function le(Q, X) {
      const he = r.get(Q)
      if (Q.version > 0 && he.__version !== Q.version) {
        Ve(he, Q, X)
        return
      }
      n.bindTexture(e.TEXTURE_2D_ARRAY, he.__webglTexture, e.TEXTURE0 + X)
    }
    function q(Q, X) {
      const he = r.get(Q)
      if (Q.version > 0 && he.__version !== Q.version) {
        Ve(he, Q, X)
        return
      }
      n.bindTexture(e.TEXTURE_3D, he.__webglTexture, e.TEXTURE0 + X)
    }
    function oe(Q, X) {
      const he = r.get(Q)
      if (Q.version > 0 && he.__version !== Q.version) {
        nt(he, Q, X)
        return
      }
      n.bindTexture(e.TEXTURE_CUBE_MAP, he.__webglTexture, e.TEXTURE0 + X)
    }
    const te = {
        [Rd]: e.REPEAT,
        [To]: e.CLAMP_TO_EDGE,
        [Kb]: e.MIRRORED_REPEAT,
      },
      ue = {
        [li]: e.NEAREST,
        [P3]: e.NEAREST_MIPMAP_NEAREST,
        [y1]: e.NEAREST_MIPMAP_LINEAR,
        [eo]: e.LINEAR,
        [dse]: e.LINEAR_MIPMAP_NEAREST,
        [Dd]: e.LINEAR_MIPMAP_LINEAR,
      },
      me = {
        [Mse]: e.NEVER,
        [Ose]: e.ALWAYS,
        [Ese]: e.LESS,
        [Tse]: e.LEQUAL,
        [Pse]: e.EQUAL,
        [$se]: e.GEQUAL,
        [kse]: e.GREATER,
        [Ase]: e.NOTEQUAL,
      }
    function Re(Q, X, he) {
      if (
        (he
          ? (e.texParameteri(Q, e.TEXTURE_WRAP_S, te[X.wrapS]),
            e.texParameteri(Q, e.TEXTURE_WRAP_T, te[X.wrapT]),
            (Q === e.TEXTURE_3D || Q === e.TEXTURE_2D_ARRAY) &&
              e.texParameteri(Q, e.TEXTURE_WRAP_R, te[X.wrapR]),
            e.texParameteri(Q, e.TEXTURE_MAG_FILTER, ue[X.magFilter]),
            e.texParameteri(Q, e.TEXTURE_MIN_FILTER, ue[X.minFilter]))
          : (e.texParameteri(Q, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(Q, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            (Q === e.TEXTURE_3D || Q === e.TEXTURE_2D_ARRAY) &&
              e.texParameteri(Q, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
            (X.wrapS !== To || X.wrapT !== To) &&
              console.warn(
                'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
              ),
            e.texParameteri(Q, e.TEXTURE_MAG_FILTER, k(X.magFilter)),
            e.texParameteri(Q, e.TEXTURE_MIN_FILTER, k(X.minFilter)),
            X.minFilter !== li &&
              X.minFilter !== eo &&
              console.warn(
                'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
              )),
        X.compareFunction &&
          (e.texParameteri(Q, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
          e.texParameteri(Q, e.TEXTURE_COMPARE_FUNC, me[X.compareFunction])),
        t.has('EXT_texture_filter_anisotropic') === !0)
      ) {
        const de = t.get('EXT_texture_filter_anisotropic')
        if (
          X.magFilter === li ||
          (X.minFilter !== y1 && X.minFilter !== Dd) ||
          (X.type === Ss && t.has('OES_texture_float_linear') === !1) ||
          (s === !1 &&
            X.type === Nd &&
            t.has('OES_texture_half_float_linear') === !1)
        )
          return
        ;(X.anisotropy > 1 || r.get(X).__currentAnisotropy) &&
          (e.texParameterf(
            Q,
            de.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(X.anisotropy, i.getMaxAnisotropy())
          ),
          (r.get(X).__currentAnisotropy = X.anisotropy))
      }
    }
    function qe(Q, X) {
      let he = !1
      Q.__webglInit === void 0 &&
        ((Q.__webglInit = !0), X.addEventListener('dispose', R))
      const de = X.source
      let xe = b.get(de)
      xe === void 0 && ((xe = {}), b.set(de, xe))
      const ne = Y(X)
      if (ne !== Q.__cacheKey) {
        xe[ne] === void 0 &&
          ((xe[ne] = { texture: e.createTexture(), usedTimes: 0 }),
          a.memory.textures++,
          (he = !0)),
          xe[ne].usedTimes++
        const Le = xe[Q.__cacheKey]
        Le !== void 0 &&
          (xe[Q.__cacheKey].usedTimes--, Le.usedTimes === 0 && I(X)),
          (Q.__cacheKey = ne),
          (Q.__webglTexture = xe[ne].texture)
      }
      return he
    }
    function Ve(Q, X, he) {
      let de = e.TEXTURE_2D
      ;(X.isDataArrayTexture || X.isCompressedArrayTexture) &&
        (de = e.TEXTURE_2D_ARRAY),
        X.isData3DTexture && (de = e.TEXTURE_3D)
      const xe = qe(Q, X),
        ne = X.source
      n.bindTexture(de, Q.__webglTexture, e.TEXTURE0 + he)
      const Le = r.get(ne)
      if (ne.version !== Le.__version || xe === !0) {
        n.activeTexture(e.TEXTURE0 + he),
          e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, X.flipY),
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, X.premultiplyAlpha),
          e.pixelStorei(e.UNPACK_ALIGNMENT, X.unpackAlignment),
          e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE)
        const et = E(X) && w(X.image) === !1
        let Ne = x(X.image, et, !1, d)
        Ne = ft(X, Ne)
        const Et = w(Ne) || s,
          kt = o.convert(X.format, X.colorSpace)
        let je = o.convert(X.type),
          Ge = F(X.internalFormat, kt, je, X.colorSpace)
        Re(de, X, Et)
        let Ye
        const lt = X.mipmaps,
          gt = s && X.isVideoTexture !== !0,
          _e = Le.__version === void 0 || xe === !0,
          bt = T(X, Ne, Et)
        if (X.isDepthTexture)
          (Ge = e.DEPTH_COMPONENT),
            s
              ? X.type === Ss
                ? (Ge = e.DEPTH_COMPONENT32F)
                : X.type === _s
                ? (Ge = e.DEPTH_COMPONENT24)
                : X.type === _l
                ? (Ge = e.DEPTH24_STENCIL8)
                : (Ge = e.DEPTH_COMPONENT16)
              : X.type === Ss &&
                console.error(
                  'WebGLRenderer: Floating point depth texture requires WebGL2.'
                ),
            X.format === Sl &&
              Ge === e.DEPTH_COMPONENT &&
              X.type !== TS &&
              X.type !== _s &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
              ),
              (X.type = _s),
              (je = o.convert(X.type))),
            X.format === Ju &&
              Ge === e.DEPTH_COMPONENT &&
              ((Ge = e.DEPTH_STENCIL),
              X.type !== _l &&
                (console.warn(
                  'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
                ),
                (X.type = _l),
                (je = o.convert(X.type)))),
            _e &&
              (gt
                ? n.texStorage2D(e.TEXTURE_2D, 1, Ge, Ne.width, Ne.height)
                : n.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    Ge,
                    Ne.width,
                    Ne.height,
                    0,
                    kt,
                    je,
                    null
                  ))
        else if (X.isDataTexture)
          if (lt.length > 0 && Et) {
            gt &&
              _e &&
              n.texStorage2D(e.TEXTURE_2D, bt, Ge, lt[0].width, lt[0].height)
            for (let He = 0, _t = lt.length; He < _t; He++)
              (Ye = lt[He]),
                gt
                  ? n.texSubImage2D(
                      e.TEXTURE_2D,
                      He,
                      0,
                      0,
                      Ye.width,
                      Ye.height,
                      kt,
                      je,
                      Ye.data
                    )
                  : n.texImage2D(
                      e.TEXTURE_2D,
                      He,
                      Ge,
                      Ye.width,
                      Ye.height,
                      0,
                      kt,
                      je,
                      Ye.data
                    )
            X.generateMipmaps = !1
          } else
            gt
              ? (_e &&
                  n.texStorage2D(e.TEXTURE_2D, bt, Ge, Ne.width, Ne.height),
                n.texSubImage2D(
                  e.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ne.width,
                  Ne.height,
                  kt,
                  je,
                  Ne.data
                ))
              : n.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  Ge,
                  Ne.width,
                  Ne.height,
                  0,
                  kt,
                  je,
                  Ne.data
                )
        else if (X.isCompressedTexture)
          if (X.isCompressedArrayTexture) {
            gt &&
              _e &&
              n.texStorage3D(
                e.TEXTURE_2D_ARRAY,
                bt,
                Ge,
                lt[0].width,
                lt[0].height,
                Ne.depth
              )
            for (let He = 0, _t = lt.length; He < _t; He++)
              (Ye = lt[He]),
                X.format !== ko
                  ? kt !== null
                    ? gt
                      ? n.compressedTexSubImage3D(
                          e.TEXTURE_2D_ARRAY,
                          He,
                          0,
                          0,
                          0,
                          Ye.width,
                          Ye.height,
                          Ne.depth,
                          kt,
                          Ye.data,
                          0,
                          0
                        )
                      : n.compressedTexImage3D(
                          e.TEXTURE_2D_ARRAY,
                          He,
                          Ge,
                          Ye.width,
                          Ye.height,
                          Ne.depth,
                          0,
                          Ye.data,
                          0,
                          0
                        )
                    : console.warn(
                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                      )
                  : gt
                  ? n.texSubImage3D(
                      e.TEXTURE_2D_ARRAY,
                      He,
                      0,
                      0,
                      0,
                      Ye.width,
                      Ye.height,
                      Ne.depth,
                      kt,
                      je,
                      Ye.data
                    )
                  : n.texImage3D(
                      e.TEXTURE_2D_ARRAY,
                      He,
                      Ge,
                      Ye.width,
                      Ye.height,
                      Ne.depth,
                      0,
                      kt,
                      je,
                      Ye.data
                    )
          } else {
            gt &&
              _e &&
              n.texStorage2D(e.TEXTURE_2D, bt, Ge, lt[0].width, lt[0].height)
            for (let He = 0, _t = lt.length; He < _t; He++)
              (Ye = lt[He]),
                X.format !== ko
                  ? kt !== null
                    ? gt
                      ? n.compressedTexSubImage2D(
                          e.TEXTURE_2D,
                          He,
                          0,
                          0,
                          Ye.width,
                          Ye.height,
                          kt,
                          Ye.data
                        )
                      : n.compressedTexImage2D(
                          e.TEXTURE_2D,
                          He,
                          Ge,
                          Ye.width,
                          Ye.height,
                          0,
                          Ye.data
                        )
                    : console.warn(
                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                      )
                  : gt
                  ? n.texSubImage2D(
                      e.TEXTURE_2D,
                      He,
                      0,
                      0,
                      Ye.width,
                      Ye.height,
                      kt,
                      je,
                      Ye.data
                    )
                  : n.texImage2D(
                      e.TEXTURE_2D,
                      He,
                      Ge,
                      Ye.width,
                      Ye.height,
                      0,
                      kt,
                      je,
                      Ye.data
                    )
          }
        else if (X.isDataArrayTexture)
          gt
            ? (_e &&
                n.texStorage3D(
                  e.TEXTURE_2D_ARRAY,
                  bt,
                  Ge,
                  Ne.width,
                  Ne.height,
                  Ne.depth
                ),
              n.texSubImage3D(
                e.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ne.width,
                Ne.height,
                Ne.depth,
                kt,
                je,
                Ne.data
              ))
            : n.texImage3D(
                e.TEXTURE_2D_ARRAY,
                0,
                Ge,
                Ne.width,
                Ne.height,
                Ne.depth,
                0,
                kt,
                je,
                Ne.data
              )
        else if (X.isData3DTexture)
          gt
            ? (_e &&
                n.texStorage3D(
                  e.TEXTURE_3D,
                  bt,
                  Ge,
                  Ne.width,
                  Ne.height,
                  Ne.depth
                ),
              n.texSubImage3D(
                e.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ne.width,
                Ne.height,
                Ne.depth,
                kt,
                je,
                Ne.data
              ))
            : n.texImage3D(
                e.TEXTURE_3D,
                0,
                Ge,
                Ne.width,
                Ne.height,
                Ne.depth,
                0,
                kt,
                je,
                Ne.data
              )
        else if (X.isFramebufferTexture) {
          if (_e)
            if (gt) n.texStorage2D(e.TEXTURE_2D, bt, Ge, Ne.width, Ne.height)
            else {
              let He = Ne.width,
                _t = Ne.height
              for (let wt = 0; wt < bt; wt++)
                n.texImage2D(e.TEXTURE_2D, wt, Ge, He, _t, 0, kt, je, null),
                  (He >>= 1),
                  (_t >>= 1)
            }
        } else if (lt.length > 0 && Et) {
          gt &&
            _e &&
            n.texStorage2D(e.TEXTURE_2D, bt, Ge, lt[0].width, lt[0].height)
          for (let He = 0, _t = lt.length; He < _t; He++)
            (Ye = lt[He]),
              gt
                ? n.texSubImage2D(e.TEXTURE_2D, He, 0, 0, kt, je, Ye)
                : n.texImage2D(e.TEXTURE_2D, He, Ge, kt, je, Ye)
          X.generateMipmaps = !1
        } else
          gt
            ? (_e && n.texStorage2D(e.TEXTURE_2D, bt, Ge, Ne.width, Ne.height),
              n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, kt, je, Ne))
            : n.texImage2D(e.TEXTURE_2D, 0, Ge, kt, je, Ne)
        P(X, Et) && A(de),
          (Le.__version = ne.version),
          X.onUpdate && X.onUpdate(X)
      }
      Q.__version = X.version
    }
    function nt(Q, X, he) {
      if (X.image.length !== 6) return
      const de = qe(Q, X),
        xe = X.source
      n.bindTexture(e.TEXTURE_CUBE_MAP, Q.__webglTexture, e.TEXTURE0 + he)
      const ne = r.get(xe)
      if (xe.version !== ne.__version || de === !0) {
        n.activeTexture(e.TEXTURE0 + he),
          e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, X.flipY),
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, X.premultiplyAlpha),
          e.pixelStorei(e.UNPACK_ALIGNMENT, X.unpackAlignment),
          e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE)
        const Le = X.isCompressedTexture || X.image[0].isCompressedTexture,
          et = X.image[0] && X.image[0].isDataTexture,
          Ne = []
        for (let He = 0; He < 6; He++)
          !Le && !et
            ? (Ne[He] = x(X.image[He], !1, !0, c))
            : (Ne[He] = et ? X.image[He].image : X.image[He]),
            (Ne[He] = ft(X, Ne[He]))
        const Et = Ne[0],
          kt = w(Et) || s,
          je = o.convert(X.format, X.colorSpace),
          Ge = o.convert(X.type),
          Ye = F(X.internalFormat, je, Ge, X.colorSpace),
          lt = s && X.isVideoTexture !== !0,
          gt = ne.__version === void 0 || de === !0
        let _e = T(X, Et, kt)
        Re(e.TEXTURE_CUBE_MAP, X, kt)
        let bt
        if (Le) {
          lt &&
            gt &&
            n.texStorage2D(e.TEXTURE_CUBE_MAP, _e, Ye, Et.width, Et.height)
          for (let He = 0; He < 6; He++) {
            bt = Ne[He].mipmaps
            for (let _t = 0; _t < bt.length; _t++) {
              const wt = bt[_t]
              X.format !== ko
                ? je !== null
                  ? lt
                    ? n.compressedTexSubImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                        _t,
                        0,
                        0,
                        wt.width,
                        wt.height,
                        je,
                        wt.data
                      )
                    : n.compressedTexImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                        _t,
                        Ye,
                        wt.width,
                        wt.height,
                        0,
                        wt.data
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                    )
                : lt
                ? n.texSubImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    _t,
                    0,
                    0,
                    wt.width,
                    wt.height,
                    je,
                    Ge,
                    wt.data
                  )
                : n.texImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    _t,
                    Ye,
                    wt.width,
                    wt.height,
                    0,
                    je,
                    Ge,
                    wt.data
                  )
            }
          }
        } else {
          ;(bt = X.mipmaps),
            lt &&
              gt &&
              (bt.length > 0 && _e++,
              n.texStorage2D(
                e.TEXTURE_CUBE_MAP,
                _e,
                Ye,
                Ne[0].width,
                Ne[0].height
              ))
          for (let He = 0; He < 6; He++)
            if (et) {
              lt
                ? n.texSubImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    0,
                    0,
                    0,
                    Ne[He].width,
                    Ne[He].height,
                    je,
                    Ge,
                    Ne[He].data
                  )
                : n.texImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    0,
                    Ye,
                    Ne[He].width,
                    Ne[He].height,
                    0,
                    je,
                    Ge,
                    Ne[He].data
                  )
              for (let _t = 0; _t < bt.length; _t++) {
                const Zt = bt[_t].image[He].image
                lt
                  ? n.texSubImage2D(
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                      _t + 1,
                      0,
                      0,
                      Zt.width,
                      Zt.height,
                      je,
                      Ge,
                      Zt.data
                    )
                  : n.texImage2D(
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                      _t + 1,
                      Ye,
                      Zt.width,
                      Zt.height,
                      0,
                      je,
                      Ge,
                      Zt.data
                    )
              }
            } else {
              lt
                ? n.texSubImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    0,
                    0,
                    0,
                    je,
                    Ge,
                    Ne[He]
                  )
                : n.texImage2D(
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                    0,
                    Ye,
                    je,
                    Ge,
                    Ne[He]
                  )
              for (let _t = 0; _t < bt.length; _t++) {
                const wt = bt[_t]
                lt
                  ? n.texSubImage2D(
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                      _t + 1,
                      0,
                      0,
                      je,
                      Ge,
                      wt.image[He]
                    )
                  : n.texImage2D(
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + He,
                      _t + 1,
                      Ye,
                      je,
                      Ge,
                      wt.image[He]
                    )
              }
            }
        }
        P(X, kt) && A(e.TEXTURE_CUBE_MAP),
          (ne.__version = xe.version),
          X.onUpdate && X.onUpdate(X)
      }
      Q.__version = X.version
    }
    function We(Q, X, he, de, xe) {
      const ne = o.convert(he.format, he.colorSpace),
        Le = o.convert(he.type),
        et = F(he.internalFormat, ne, Le, he.colorSpace)
      r.get(X).__hasExternalTextures ||
        (xe === e.TEXTURE_3D || xe === e.TEXTURE_2D_ARRAY
          ? n.texImage3D(xe, 0, et, X.width, X.height, X.depth, 0, ne, Le, null)
          : n.texImage2D(xe, 0, et, X.width, X.height, 0, ne, Le, null)),
        n.bindFramebuffer(e.FRAMEBUFFER, Q),
        $e(X)
          ? p.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              de,
              xe,
              r.get(he).__webglTexture,
              0,
              we(X)
            )
          : (xe === e.TEXTURE_2D ||
              (xe >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
                xe <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
            e.framebufferTexture2D(
              e.FRAMEBUFFER,
              de,
              xe,
              r.get(he).__webglTexture,
              0
            ),
        n.bindFramebuffer(e.FRAMEBUFFER, null)
    }
    function D(Q, X, he) {
      if (
        (e.bindRenderbuffer(e.RENDERBUFFER, Q),
        X.depthBuffer && !X.stencilBuffer)
      ) {
        let de = e.DEPTH_COMPONENT16
        if (he || $e(X)) {
          const xe = X.depthTexture
          xe &&
            xe.isDepthTexture &&
            (xe.type === Ss
              ? (de = e.DEPTH_COMPONENT32F)
              : xe.type === _s && (de = e.DEPTH_COMPONENT24))
          const ne = we(X)
          $e(X)
            ? p.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                ne,
                de,
                X.width,
                X.height
              )
            : e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                ne,
                de,
                X.width,
                X.height
              )
        } else e.renderbufferStorage(e.RENDERBUFFER, de, X.width, X.height)
        e.framebufferRenderbuffer(
          e.FRAMEBUFFER,
          e.DEPTH_ATTACHMENT,
          e.RENDERBUFFER,
          Q
        )
      } else if (X.depthBuffer && X.stencilBuffer) {
        const de = we(X)
        he && $e(X) === !1
          ? e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              de,
              e.DEPTH24_STENCIL8,
              X.width,
              X.height
            )
          : $e(X)
          ? p.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              de,
              e.DEPTH24_STENCIL8,
              X.width,
              X.height
            )
          : e.renderbufferStorage(
              e.RENDERBUFFER,
              e.DEPTH_STENCIL,
              X.width,
              X.height
            ),
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_STENCIL_ATTACHMENT,
            e.RENDERBUFFER,
            Q
          )
      } else {
        const de =
          X.isWebGLMultipleRenderTargets === !0 ? X.texture : [X.texture]
        for (let xe = 0; xe < de.length; xe++) {
          const ne = de[xe],
            Le = o.convert(ne.format, ne.colorSpace),
            et = o.convert(ne.type),
            Ne = F(ne.internalFormat, Le, et, ne.colorSpace),
            Et = we(X)
          he && $e(X) === !1
            ? e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                Et,
                Ne,
                X.width,
                X.height
              )
            : $e(X)
            ? p.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                Et,
                Ne,
                X.width,
                X.height
              )
            : e.renderbufferStorage(e.RENDERBUFFER, Ne, X.width, X.height)
        }
      }
      e.bindRenderbuffer(e.RENDERBUFFER, null)
    }
    function G(Q, X) {
      if (X && X.isWebGLCubeRenderTarget)
        throw new Error(
          'Depth Texture with cube render targets is not supported'
        )
      if (
        (n.bindFramebuffer(e.FRAMEBUFFER, Q),
        !(X.depthTexture && X.depthTexture.isDepthTexture))
      )
        throw new Error(
          'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
        )
      ;(!r.get(X.depthTexture).__webglTexture ||
        X.depthTexture.image.width !== X.width ||
        X.depthTexture.image.height !== X.height) &&
        ((X.depthTexture.image.width = X.width),
        (X.depthTexture.image.height = X.height),
        (X.depthTexture.needsUpdate = !0)),
        U(X.depthTexture, 0)
      const de = r.get(X.depthTexture).__webglTexture,
        xe = we(X)
      if (X.depthTexture.format === Sl)
        $e(X)
          ? p.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              e.DEPTH_ATTACHMENT,
              e.TEXTURE_2D,
              de,
              0,
              xe
            )
          : e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.DEPTH_ATTACHMENT,
              e.TEXTURE_2D,
              de,
              0
            )
      else if (X.depthTexture.format === Ju)
        $e(X)
          ? p.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.TEXTURE_2D,
              de,
              0,
              xe
            )
          : e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.TEXTURE_2D,
              de,
              0
            )
      else throw new Error('Unknown depthTexture format')
    }
    function z(Q) {
      const X = r.get(Q),
        he = Q.isWebGLCubeRenderTarget === !0
      if (Q.depthTexture && !X.__autoAllocateDepthBuffer) {
        if (he)
          throw new Error(
            'target.depthTexture not supported in Cube render targets'
          )
        G(X.__webglFramebuffer, Q)
      } else if (he) {
        X.__webglDepthbuffer = []
        for (let de = 0; de < 6; de++)
          n.bindFramebuffer(e.FRAMEBUFFER, X.__webglFramebuffer[de]),
            (X.__webglDepthbuffer[de] = e.createRenderbuffer()),
            D(X.__webglDepthbuffer[de], Q, !1)
      } else
        n.bindFramebuffer(e.FRAMEBUFFER, X.__webglFramebuffer),
          (X.__webglDepthbuffer = e.createRenderbuffer()),
          D(X.__webglDepthbuffer, Q, !1)
      n.bindFramebuffer(e.FRAMEBUFFER, null)
    }
    function ie(Q, X, he) {
      const de = r.get(Q)
      X !== void 0 &&
        We(
          de.__webglFramebuffer,
          Q,
          Q.texture,
          e.COLOR_ATTACHMENT0,
          e.TEXTURE_2D
        ),
        he !== void 0 && z(Q)
    }
    function ae(Q) {
      const X = Q.texture,
        he = r.get(Q),
        de = r.get(X)
      Q.addEventListener('dispose', j),
        Q.isWebGLMultipleRenderTargets !== !0 &&
          (de.__webglTexture === void 0 &&
            (de.__webglTexture = e.createTexture()),
          (de.__version = X.version),
          a.memory.textures++)
      const xe = Q.isWebGLCubeRenderTarget === !0,
        ne = Q.isWebGLMultipleRenderTargets === !0,
        Le = w(Q) || s
      if (xe) {
        he.__webglFramebuffer = []
        for (let et = 0; et < 6; et++)
          he.__webglFramebuffer[et] = e.createFramebuffer()
      } else {
        if (((he.__webglFramebuffer = e.createFramebuffer()), ne))
          if (i.drawBuffers) {
            const et = Q.texture
            for (let Ne = 0, Et = et.length; Ne < Et; Ne++) {
              const kt = r.get(et[Ne])
              kt.__webglTexture === void 0 &&
                ((kt.__webglTexture = e.createTexture()), a.memory.textures++)
            }
          } else
            console.warn(
              'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
            )
        if (s && Q.samples > 0 && $e(Q) === !1) {
          const et = ne ? X : [X]
          ;(he.__webglMultisampledFramebuffer = e.createFramebuffer()),
            (he.__webglColorRenderbuffer = []),
            n.bindFramebuffer(e.FRAMEBUFFER, he.__webglMultisampledFramebuffer)
          for (let Ne = 0; Ne < et.length; Ne++) {
            const Et = et[Ne]
            ;(he.__webglColorRenderbuffer[Ne] = e.createRenderbuffer()),
              e.bindRenderbuffer(
                e.RENDERBUFFER,
                he.__webglColorRenderbuffer[Ne]
              )
            const kt = o.convert(Et.format, Et.colorSpace),
              je = o.convert(Et.type),
              Ge = F(
                Et.internalFormat,
                kt,
                je,
                Et.colorSpace,
                Q.isXRRenderTarget === !0
              ),
              Ye = we(Q)
            e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              Ye,
              Ge,
              Q.width,
              Q.height
            ),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + Ne,
                e.RENDERBUFFER,
                he.__webglColorRenderbuffer[Ne]
              )
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null),
            Q.depthBuffer &&
              ((he.__webglDepthRenderbuffer = e.createRenderbuffer()),
              D(he.__webglDepthRenderbuffer, Q, !0)),
            n.bindFramebuffer(e.FRAMEBUFFER, null)
        }
      }
      if (xe) {
        n.bindTexture(e.TEXTURE_CUBE_MAP, de.__webglTexture),
          Re(e.TEXTURE_CUBE_MAP, X, Le)
        for (let et = 0; et < 6; et++)
          We(
            he.__webglFramebuffer[et],
            Q,
            X,
            e.COLOR_ATTACHMENT0,
            e.TEXTURE_CUBE_MAP_POSITIVE_X + et
          )
        P(X, Le) && A(e.TEXTURE_CUBE_MAP), n.unbindTexture()
      } else if (ne) {
        const et = Q.texture
        for (let Ne = 0, Et = et.length; Ne < Et; Ne++) {
          const kt = et[Ne],
            je = r.get(kt)
          n.bindTexture(e.TEXTURE_2D, je.__webglTexture),
            Re(e.TEXTURE_2D, kt, Le),
            We(
              he.__webglFramebuffer,
              Q,
              kt,
              e.COLOR_ATTACHMENT0 + Ne,
              e.TEXTURE_2D
            ),
            P(kt, Le) && A(e.TEXTURE_2D)
        }
        n.unbindTexture()
      } else {
        let et = e.TEXTURE_2D
        ;(Q.isWebGL3DRenderTarget || Q.isWebGLArrayRenderTarget) &&
          (s
            ? (et = Q.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY)
            : console.error(
                'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
              )),
          n.bindTexture(et, de.__webglTexture),
          Re(et, X, Le),
          We(he.__webglFramebuffer, Q, X, e.COLOR_ATTACHMENT0, et),
          P(X, Le) && A(et),
          n.unbindTexture()
      }
      Q.depthBuffer && z(Q)
    }
    function re(Q) {
      const X = w(Q) || s,
        he = Q.isWebGLMultipleRenderTargets === !0 ? Q.texture : [Q.texture]
      for (let de = 0, xe = he.length; de < xe; de++) {
        const ne = he[de]
        if (P(ne, X)) {
          const Le = Q.isWebGLCubeRenderTarget
              ? e.TEXTURE_CUBE_MAP
              : e.TEXTURE_2D,
            et = r.get(ne).__webglTexture
          n.bindTexture(Le, et), A(Le), n.unbindTexture()
        }
      }
    }
    function pe(Q) {
      if (s && Q.samples > 0 && $e(Q) === !1) {
        const X = Q.isWebGLMultipleRenderTargets ? Q.texture : [Q.texture],
          he = Q.width,
          de = Q.height
        let xe = e.COLOR_BUFFER_BIT
        const ne = [],
          Le = Q.stencilBuffer
            ? e.DEPTH_STENCIL_ATTACHMENT
            : e.DEPTH_ATTACHMENT,
          et = r.get(Q),
          Ne = Q.isWebGLMultipleRenderTargets === !0
        if (Ne)
          for (let Et = 0; Et < X.length; Et++)
            n.bindFramebuffer(e.FRAMEBUFFER, et.__webglMultisampledFramebuffer),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + Et,
                e.RENDERBUFFER,
                null
              ),
              n.bindFramebuffer(e.FRAMEBUFFER, et.__webglFramebuffer),
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + Et,
                e.TEXTURE_2D,
                null,
                0
              )
        n.bindFramebuffer(
          e.READ_FRAMEBUFFER,
          et.__webglMultisampledFramebuffer
        ),
          n.bindFramebuffer(e.DRAW_FRAMEBUFFER, et.__webglFramebuffer)
        for (let Et = 0; Et < X.length; Et++) {
          ne.push(e.COLOR_ATTACHMENT0 + Et), Q.depthBuffer && ne.push(Le)
          const kt =
            et.__ignoreDepthValues !== void 0 ? et.__ignoreDepthValues : !1
          if (
            (kt === !1 &&
              (Q.depthBuffer && (xe |= e.DEPTH_BUFFER_BIT),
              Q.stencilBuffer && (xe |= e.STENCIL_BUFFER_BIT)),
            Ne &&
              e.framebufferRenderbuffer(
                e.READ_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0,
                e.RENDERBUFFER,
                et.__webglColorRenderbuffer[Et]
              ),
            kt === !0 &&
              (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [Le]),
              e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [Le])),
            Ne)
          ) {
            const je = r.get(X[Et]).__webglTexture
            e.framebufferTexture2D(
              e.DRAW_FRAMEBUFFER,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_2D,
              je,
              0
            )
          }
          e.blitFramebuffer(0, 0, he, de, 0, 0, he, de, xe, e.NEAREST),
            v && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, ne)
        }
        if (
          (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
          n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          Ne)
        )
          for (let Et = 0; Et < X.length; Et++) {
            n.bindFramebuffer(e.FRAMEBUFFER, et.__webglMultisampledFramebuffer),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + Et,
                e.RENDERBUFFER,
                et.__webglColorRenderbuffer[Et]
              )
            const kt = r.get(X[Et]).__webglTexture
            n.bindFramebuffer(e.FRAMEBUFFER, et.__webglFramebuffer),
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + Et,
                e.TEXTURE_2D,
                kt,
                0
              )
          }
        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, et.__webglMultisampledFramebuffer)
      }
    }
    function we(Q) {
      return Math.min(h, Q.samples)
    }
    function $e(Q) {
      const X = r.get(Q)
      return (
        s &&
        Q.samples > 0 &&
        t.has('WEBGL_multisampled_render_to_texture') === !0 &&
        X.__useRenderToTexture !== !1
      )
    }
    function Ae(Q) {
      const X = a.render.frame
      g.get(Q) !== X && (g.set(Q, X), Q.update())
    }
    function ft(Q, X) {
      const he = Q.colorSpace,
        de = Q.format,
        xe = Q.type
      return (
        Q.isCompressedTexture === !0 ||
          Q.format === Xb ||
          (he !== aa &&
            he !== Cl &&
            (he === rn
              ? s === !1
                ? t.has('EXT_sRGB') === !0 && de === ko
                  ? ((Q.format = Xb),
                    (Q.minFilter = eo),
                    (Q.generateMipmaps = !1))
                  : (X = l$.sRGBToLinear(X))
                : (de !== ko || xe !== Es) &&
                  console.warn(
                    'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                  )
              : console.error(
                  'THREE.WebGLTextures: Unsupported texture color space:',
                  he
                ))),
        X
      )
    }
    ;(this.allocateTextureUnit = W),
      (this.resetTextureUnits = L),
      (this.setTexture2D = U),
      (this.setTexture2DArray = le),
      (this.setTexture3D = q),
      (this.setTextureCube = oe),
      (this.rebindTextures = ie),
      (this.setupRenderTarget = ae),
      (this.updateRenderTargetMipmap = re),
      (this.updateMultisampleRenderTarget = pe),
      (this.setupDepthRenderbuffer = z),
      (this.setupFrameBufferTexture = We),
      (this.useMultisampledRTT = $e)
  }
  function zfe(e, t, n) {
    const r = n.isWebGL2
    function i(o, a = Cl) {
      let s
      if (o === Es) return e.UNSIGNED_BYTE
      if (o === QA) return e.UNSIGNED_SHORT_4_4_4_4
      if (o === e$) return e.UNSIGNED_SHORT_5_5_5_1
      if (o === fse) return e.BYTE
      if (o === hse) return e.SHORT
      if (o === TS) return e.UNSIGNED_SHORT
      if (o === JA) return e.INT
      if (o === _s) return e.UNSIGNED_INT
      if (o === Ss) return e.FLOAT
      if (o === Nd)
        return r
          ? e.HALF_FLOAT
          : ((s = t.get('OES_texture_half_float')),
            s !== null ? s.HALF_FLOAT_OES : null)
      if (o === pse) return e.ALPHA
      if (o === ko) return e.RGBA
      if (o === vse) return e.LUMINANCE
      if (o === mse) return e.LUMINANCE_ALPHA
      if (o === Sl) return e.DEPTH_COMPONENT
      if (o === Ju) return e.DEPTH_STENCIL
      if (o === Xb)
        return (s = t.get('EXT_sRGB')), s !== null ? s.SRGB_ALPHA_EXT : null
      if (o === gse) return e.RED
      if (o === t$) return e.RED_INTEGER
      if (o === yse) return e.RG
      if (o === n$) return e.RG_INTEGER
      if (o === r$) return e.RGBA_INTEGER
      if (o === b1 || o === _1 || o === S1 || o === C1)
        if (a === rn)
          if (((s = t.get('WEBGL_compressed_texture_s3tc_srgb')), s !== null)) {
            if (o === b1) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT
            if (o === _1) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
            if (o === S1) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
            if (o === C1) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
          } else return null
        else if (((s = t.get('WEBGL_compressed_texture_s3tc')), s !== null)) {
          if (o === b1) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
          if (o === _1) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
          if (o === S1) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
          if (o === C1) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null
      if (o === T3 || o === k3 || o === A3 || o === $3)
        if (((s = t.get('WEBGL_compressed_texture_pvrtc')), s !== null)) {
          if (o === T3) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
          if (o === k3) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
          if (o === A3) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
          if (o === $3) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        } else return null
      if (o === bse)
        return (
          (s = t.get('WEBGL_compressed_texture_etc1')),
          s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null
        )
      if (o === O3 || o === L3)
        if (((s = t.get('WEBGL_compressed_texture_etc')), s !== null)) {
          if (o === O3)
            return a === rn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2
          if (o === L3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : s.COMPRESSED_RGBA8_ETC2_EAC
        } else return null
      if (
        o === I3 ||
        o === R3 ||
        o === D3 ||
        o === N3 ||
        o === B3 ||
        o === F3 ||
        o === z3 ||
        o === V3 ||
        o === U3 ||
        o === H3 ||
        o === W3 ||
        o === j3 ||
        o === G3 ||
        o === K3
      )
        if (((s = t.get('WEBGL_compressed_texture_astc')), s !== null)) {
          if (o === I3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : s.COMPRESSED_RGBA_ASTC_4x4_KHR
          if (o === R3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : s.COMPRESSED_RGBA_ASTC_5x4_KHR
          if (o === D3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : s.COMPRESSED_RGBA_ASTC_5x5_KHR
          if (o === N3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : s.COMPRESSED_RGBA_ASTC_6x5_KHR
          if (o === B3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : s.COMPRESSED_RGBA_ASTC_6x6_KHR
          if (o === F3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : s.COMPRESSED_RGBA_ASTC_8x5_KHR
          if (o === z3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : s.COMPRESSED_RGBA_ASTC_8x6_KHR
          if (o === V3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : s.COMPRESSED_RGBA_ASTC_8x8_KHR
          if (o === U3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : s.COMPRESSED_RGBA_ASTC_10x5_KHR
          if (o === H3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : s.COMPRESSED_RGBA_ASTC_10x6_KHR
          if (o === W3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : s.COMPRESSED_RGBA_ASTC_10x8_KHR
          if (o === j3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : s.COMPRESSED_RGBA_ASTC_10x10_KHR
          if (o === G3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : s.COMPRESSED_RGBA_ASTC_12x10_KHR
          if (o === K3)
            return a === rn
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : s.COMPRESSED_RGBA_ASTC_12x12_KHR
        } else return null
      if (o === w1)
        if (((s = t.get('EXT_texture_compression_bptc')), s !== null)) {
          if (o === w1)
            return a === rn
              ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
        } else return null
      if (o === _se || o === q3 || o === X3 || o === Y3)
        if (((s = t.get('EXT_texture_compression_rgtc')), s !== null)) {
          if (o === w1) return s.COMPRESSED_RED_RGTC1_EXT
          if (o === q3) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT
          if (o === X3) return s.COMPRESSED_RED_GREEN_RGTC2_EXT
          if (o === Y3) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } else return null
      return o === _l
        ? r
          ? e.UNSIGNED_INT_24_8
          : ((s = t.get('WEBGL_depth_texture')),
            s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null)
        : e[o] !== void 0
        ? e[o]
        : null
    }
    return { convert: i }
  }
  class Vfe extends to {
    constructor(t = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = t)
    }
  }
  let La = class extends Br {
    constructor() {
      super(), (this.isGroup = !0), (this.type = 'Group')
    }
  }
  const Ufe = { type: 'move' }
  class j1 {
    constructor() {
      ;(this._targetRay = null), (this._grip = null), (this._hand = null)
    }
    getHandSpace() {
      return (
        this._hand === null &&
          ((this._hand = new La()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      )
    }
    getTargetRaySpace() {
      return (
        this._targetRay === null &&
          ((this._targetRay = new La()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new Pe()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new Pe())),
        this._targetRay
      )
    }
    getGripSpace() {
      return (
        this._grip === null &&
          ((this._grip = new La()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new Pe()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new Pe())),
        this._grip
      )
    }
    dispatchEvent(t) {
      return (
        this._targetRay !== null && this._targetRay.dispatchEvent(t),
        this._grip !== null && this._grip.dispatchEvent(t),
        this._hand !== null && this._hand.dispatchEvent(t),
        this
      )
    }
    connect(t) {
      if (t && t.hand) {
        const n = this._hand
        if (n) for (const r of t.hand.values()) this._getHandJoint(n, r)
      }
      return this.dispatchEvent({ type: 'connected', data: t }), this
    }
    disconnect(t) {
      return (
        this.dispatchEvent({ type: 'disconnected', data: t }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
      )
    }
    update(t, n, r) {
      let i = null,
        o = null,
        a = null
      const s = this._targetRay,
        l = this._grip,
        c = this._hand
      if (t && n.session.visibilityState !== 'visible-blurred') {
        if (c && t.hand) {
          a = !0
          for (const _ of t.hand.values()) {
            const b = n.getJointPose(_, r),
              y = this._getHandJoint(c, _)
            b !== null &&
              (y.matrix.fromArray(b.transform.matrix),
              y.matrix.decompose(y.position, y.rotation, y.scale),
              (y.matrixWorldNeedsUpdate = !0),
              (y.jointRadius = b.radius)),
              (y.visible = b !== null)
          }
          const d = c.joints['index-finger-tip'],
            h = c.joints['thumb-tip'],
            p = d.position.distanceTo(h.position),
            v = 0.02,
            g = 0.005
          c.inputState.pinching && p > v + g
            ? ((c.inputState.pinching = !1),
              this.dispatchEvent({
                type: 'pinchend',
                handedness: t.handedness,
                target: this,
              }))
            : !c.inputState.pinching &&
              p <= v - g &&
              ((c.inputState.pinching = !0),
              this.dispatchEvent({
                type: 'pinchstart',
                handedness: t.handedness,
                target: this,
              }))
        } else
          l !== null &&
            t.gripSpace &&
            ((o = n.getPose(t.gripSpace, r)),
            o !== null &&
              (l.matrix.fromArray(o.transform.matrix),
              l.matrix.decompose(l.position, l.rotation, l.scale),
              (l.matrixWorldNeedsUpdate = !0),
              o.linearVelocity
                ? ((l.hasLinearVelocity = !0),
                  l.linearVelocity.copy(o.linearVelocity))
                : (l.hasLinearVelocity = !1),
              o.angularVelocity
                ? ((l.hasAngularVelocity = !0),
                  l.angularVelocity.copy(o.angularVelocity))
                : (l.hasAngularVelocity = !1)))
        s !== null &&
          ((i = n.getPose(t.targetRaySpace, r)),
          i === null && o !== null && (i = o),
          i !== null &&
            (s.matrix.fromArray(i.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale),
            (s.matrixWorldNeedsUpdate = !0),
            i.linearVelocity
              ? ((s.hasLinearVelocity = !0),
                s.linearVelocity.copy(i.linearVelocity))
              : (s.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((s.hasAngularVelocity = !0),
                s.angularVelocity.copy(i.angularVelocity))
              : (s.hasAngularVelocity = !1),
            this.dispatchEvent(Ufe)))
      }
      return (
        s !== null && (s.visible = i !== null),
        l !== null && (l.visible = o !== null),
        c !== null && (c.visible = a !== null),
        this
      )
    }
    _getHandJoint(t, n) {
      if (t.joints[n.jointName] === void 0) {
        const r = new La()
        ;(r.matrixAutoUpdate = !1),
          (r.visible = !1),
          (t.joints[n.jointName] = r),
          t.add(r)
      }
      return t.joints[n.jointName]
    }
  }
  class Hfe extends Ei {
    constructor(t, n, r, i, o, a, s, l, c, d) {
      if (((d = d !== void 0 ? d : Sl), d !== Sl && d !== Ju))
        throw new Error(
          'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
        )
      r === void 0 && d === Sl && (r = _s),
        r === void 0 && d === Ju && (r = _l),
        super(null, i, o, a, s, l, d, r, c),
        (this.isDepthTexture = !0),
        (this.image = { width: t, height: n }),
        (this.magFilter = s !== void 0 ? s : li),
        (this.minFilter = l !== void 0 ? l : li),
        (this.flipY = !1),
        (this.generateMipmaps = !1),
        (this.compareFunction = null)
    }
    copy(t) {
      return super.copy(t), (this.compareFunction = t.compareFunction), this
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        this.compareFunction !== null &&
          (n.compareFunction = this.compareFunction),
        n
      )
    }
  }
  class Wfe extends Rl {
    constructor(t, n) {
      super()
      const r = this
      let i = null,
        o = 1,
        a = null,
        s = 'local-floor',
        l = 1,
        c = null,
        d = null,
        h = null,
        p = null,
        v = null,
        g = null
      const _ = n.getContextAttributes()
      let b = null,
        y = null
      const M = [],
        x = []
      let w = null
      const E = new to()
      E.layers.enable(1), (E.viewport = new Jn())
      const P = new to()
      P.layers.enable(2), (P.viewport = new Jn())
      const A = [E, P],
        F = new Vfe()
      F.layers.enable(1), F.layers.enable(2)
      let T = null,
        k = null
      ;(this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getCamera = function () {}),
        (this.setUserCamera = function (q) {
          w = q
        }),
        (this.getController = function (q) {
          let oe = M[q]
          return (
            oe === void 0 && ((oe = new j1()), (M[q] = oe)),
            oe.getTargetRaySpace()
          )
        }),
        (this.getControllerGrip = function (q) {
          let oe = M[q]
          return (
            oe === void 0 && ((oe = new j1()), (M[q] = oe)), oe.getGripSpace()
          )
        }),
        (this.getHand = function (q) {
          let oe = M[q]
          return (
            oe === void 0 && ((oe = new j1()), (M[q] = oe)), oe.getHandSpace()
          )
        })
      function R(q) {
        const oe = x.indexOf(q.inputSource)
        if (oe === -1) return
        const te = M[oe]
        te !== void 0 &&
          (te.update(q.inputSource, q.frame, c || a),
          te.dispatchEvent({ type: q.type, data: q.inputSource }))
      }
      function j() {
        i.removeEventListener('select', R),
          i.removeEventListener('selectstart', R),
          i.removeEventListener('selectend', R),
          i.removeEventListener('squeeze', R),
          i.removeEventListener('squeezestart', R),
          i.removeEventListener('squeezeend', R),
          i.removeEventListener('end', j),
          i.removeEventListener('inputsourceschange', N)
        for (let q = 0; q < M.length; q++) {
          const oe = x[q]
          oe !== null && ((x[q] = null), M[q].disconnect(oe))
        }
        ;(T = null),
          (k = null),
          t.setRenderTarget(b),
          (v = null),
          (p = null),
          (h = null),
          (i = null),
          (y = null),
          le.stop(),
          (r.isPresenting = !1),
          r.dispatchEvent({ type: 'sessionend' })
      }
      ;(this.setFramebufferScaleFactor = function (q) {
        ;(o = q),
          r.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
            )
      }),
        (this.setReferenceSpaceType = function (q) {
          ;(s = q),
            r.isPresenting === !0 &&
              console.warn(
                'THREE.WebXRManager: Cannot change reference space type while presenting.'
              )
        }),
        (this.getReferenceSpace = function () {
          return c || a
        }),
        (this.setReferenceSpace = function (q) {
          c = q
        }),
        (this.getBaseLayer = function () {
          return p !== null ? p : v
        }),
        (this.getBinding = function () {
          return h
        }),
        (this.getFrame = function () {
          return g
        }),
        (this.getSession = function () {
          return i
        }),
        (this.setSession = async function (q) {
          if (((i = q), i !== null)) {
            if (
              ((b = t.getRenderTarget()),
              i.addEventListener('select', R),
              i.addEventListener('selectstart', R),
              i.addEventListener('selectend', R),
              i.addEventListener('squeeze', R),
              i.addEventListener('squeezestart', R),
              i.addEventListener('squeezeend', R),
              i.addEventListener('end', j),
              i.addEventListener('inputsourceschange', N),
              _.xrCompatible !== !0 && (await n.makeXRCompatible()),
              i.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1)
            ) {
              const oe = {
                antialias: i.renderState.layers === void 0 ? _.antialias : !0,
                alpha: !0,
                depth: _.depth,
                stencil: _.stencil,
                framebufferScaleFactor: o,
              }
              ;(v = new XRWebGLLayer(i, n, oe)),
                i.updateRenderState({ baseLayer: v }),
                (y = new El(v.framebufferWidth, v.framebufferHeight, {
                  format: ko,
                  type: Es,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: _.stencil,
                }))
            } else {
              let oe = null,
                te = null,
                ue = null
              _.depth &&
                ((ue = _.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
                (oe = _.stencil ? Ju : Sl),
                (te = _.stencil ? _l : _s))
              const me = {
                colorFormat: n.RGBA8,
                depthFormat: ue,
                scaleFactor: o,
              }
              ;(h = new XRWebGLBinding(i, n)),
                (p = h.createProjectionLayer(me)),
                i.updateRenderState({ layers: [p] }),
                (y = new El(p.textureWidth, p.textureHeight, {
                  format: ko,
                  type: Es,
                  depthTexture: new Hfe(
                    p.textureWidth,
                    p.textureHeight,
                    te,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    oe
                  ),
                  stencilBuffer: _.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: _.antialias ? 4 : 0,
                }))
              const Re = t.properties.get(y)
              Re.__ignoreDepthValues = p.ignoreDepthValues
            }
            ;(y.isXRRenderTarget = !0),
              this.setFoveation(l),
              (c = null),
              (a = await i.requestReferenceSpace(s)),
              le.setContext(i),
              le.start(),
              (r.isPresenting = !0),
              r.dispatchEvent({ type: 'sessionstart' })
          }
        }),
        (this.getEnvironmentBlendMode = function () {
          if (i !== null) return i.environmentBlendMode
        })
      function N(q) {
        for (let oe = 0; oe < q.removed.length; oe++) {
          const te = q.removed[oe],
            ue = x.indexOf(te)
          ue >= 0 && ((x[ue] = null), M[ue].disconnect(te))
        }
        for (let oe = 0; oe < q.added.length; oe++) {
          const te = q.added[oe]
          let ue = x.indexOf(te)
          if (ue === -1) {
            for (let Re = 0; Re < M.length; Re++)
              if (Re >= x.length) {
                x.push(te), (ue = Re)
                break
              } else if (x[Re] === null) {
                ;(x[Re] = te), (ue = Re)
                break
              }
            if (ue === -1) break
          }
          const me = M[ue]
          me && me.connect(te)
        }
      }
      const I = new Pe(),
        B = new Pe()
      function V(q, oe, te) {
        I.setFromMatrixPosition(oe.matrixWorld),
          B.setFromMatrixPosition(te.matrixWorld)
        const ue = I.distanceTo(B),
          me = oe.projectionMatrix.elements,
          Re = te.projectionMatrix.elements,
          qe = me[14] / (me[10] - 1),
          Ve = me[14] / (me[10] + 1),
          nt = (me[9] + 1) / me[5],
          We = (me[9] - 1) / me[5],
          D = (me[8] - 1) / me[0],
          G = (Re[8] + 1) / Re[0],
          z = qe * D,
          ie = qe * G,
          ae = ue / (-D + G),
          re = ae * -D
        oe.matrixWorld.decompose(q.position, q.quaternion, q.scale),
          q.translateX(re),
          q.translateZ(ae),
          q.matrixWorld.compose(q.position, q.quaternion, q.scale),
          q.matrixWorldInverse.copy(q.matrixWorld).invert()
        const pe = qe + ae,
          we = Ve + ae,
          $e = z - re,
          Ae = ie + (ue - re),
          ft = ((nt * Ve) / we) * pe,
          Q = ((We * Ve) / we) * pe
        q.projectionMatrix.makePerspective($e, Ae, ft, Q, pe, we),
          q.projectionMatrixInverse.copy(q.projectionMatrix).invert()
      }
      function L(q, oe) {
        oe === null
          ? q.matrixWorld.copy(q.matrix)
          : q.matrixWorld.multiplyMatrices(oe.matrixWorld, q.matrix),
          q.matrixWorldInverse.copy(q.matrixWorld).invert()
      }
      this.updateCameraXR = function (q) {
        if (i === null) return q
        w && (q = w),
          (F.near = P.near = E.near = q.near),
          (F.far = P.far = E.far = q.far),
          (T !== F.near || k !== F.far) &&
            (i.updateRenderState({ depthNear: F.near, depthFar: F.far }),
            (T = F.near),
            (k = F.far))
        const oe = q.parent,
          te = F.cameras
        L(F, oe)
        for (let ue = 0; ue < te.length; ue++) L(te[ue], oe)
        return (
          te.length === 2
            ? V(F, E, P)
            : F.projectionMatrix.copy(E.projectionMatrix),
          w && W(F, oe),
          F
        )
      }
      function W(q, oe) {
        const te = w
        oe === null
          ? te.matrix.copy(q.matrixWorld)
          : (te.matrix.copy(oe.matrixWorld),
            te.matrix.invert(),
            te.matrix.multiply(q.matrixWorld)),
          te.matrix.decompose(te.position, te.quaternion, te.scale),
          te.updateMatrixWorld(!0)
        const ue = te.children
        for (let me = 0, Re = ue.length; me < Re; me++)
          ue[me].updateMatrixWorld(!0)
        te.projectionMatrix.copy(q.projectionMatrix),
          te.projectionMatrixInverse.copy(q.projectionMatrixInverse),
          te.isPerspectiveCamera &&
            ((te.fov = Bd * 2 * Math.atan(1 / te.projectionMatrix.elements[5])),
            (te.zoom = 1))
      }
      ;(this.getFoveation = function () {
        if (!(p === null && v === null)) return l
      }),
        (this.setFoveation = function (q) {
          ;(l = q),
            p !== null && (p.fixedFoveation = q),
            v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = q)
        })
      let Y = null
      function U(q, oe) {
        if (((d = oe.getViewerPose(c || a)), (g = oe), d !== null)) {
          const te = d.views
          v !== null &&
            (t.setRenderTargetFramebuffer(y, v.framebuffer),
            t.setRenderTarget(y))
          let ue = !1
          te.length !== F.cameras.length && ((F.cameras.length = 0), (ue = !0))
          for (let me = 0; me < te.length; me++) {
            const Re = te[me]
            let qe = null
            if (v !== null) qe = v.getViewport(Re)
            else {
              const nt = h.getViewSubImage(p, Re)
              ;(qe = nt.viewport),
                me === 0 &&
                  (t.setRenderTargetTextures(
                    y,
                    nt.colorTexture,
                    p.ignoreDepthValues ? void 0 : nt.depthStencilTexture
                  ),
                  t.setRenderTarget(y))
            }
            let Ve = A[me]
            Ve === void 0 &&
              ((Ve = new to()),
              Ve.layers.enable(me),
              (Ve.viewport = new Jn()),
              (A[me] = Ve)),
              Ve.matrix.fromArray(Re.transform.matrix),
              Ve.matrix.decompose(Ve.position, Ve.quaternion, Ve.scale),
              Ve.projectionMatrix.fromArray(Re.projectionMatrix),
              Ve.projectionMatrixInverse.copy(Ve.projectionMatrix).invert(),
              Ve.viewport.set(qe.x, qe.y, qe.width, qe.height),
              me === 0 &&
                (F.matrix.copy(Ve.matrix),
                F.matrix.decompose(F.position, F.quaternion, F.scale)),
              ue === !0 && F.cameras.push(Ve)
          }
        }
        for (let te = 0; te < M.length; te++) {
          const ue = x[te],
            me = M[te]
          ue !== null && me !== void 0 && me.update(ue, oe, c || a)
        }
        Y && Y(q, oe),
          oe.detectedPlanes &&
            r.dispatchEvent({ type: 'planesdetected', data: oe }),
          (g = null)
      }
      const le = new y$()
      le.setAnimationLoop(U),
        (this.setAnimationLoop = function (q) {
          Y = q
        }),
        (this.dispose = function () {})
    }
  }
  function jfe(e, t) {
    function n(b, y) {
      b.matrixAutoUpdate === !0 && b.updateMatrix(), y.value.copy(b.matrix)
    }
    function r(b, y) {
      y.color.getRGB(b.fogColor.value, v$(e)),
        y.isFog
          ? ((b.fogNear.value = y.near), (b.fogFar.value = y.far))
          : y.isFogExp2 && (b.fogDensity.value = y.density)
    }
    function i(b, y, M, x, w) {
      y.isMeshBasicMaterial || y.isMeshLambertMaterial
        ? o(b, y)
        : y.isMeshToonMaterial
        ? (o(b, y), h(b, y))
        : y.isMeshPhongMaterial
        ? (o(b, y), d(b, y))
        : y.isMeshStandardMaterial
        ? (o(b, y), p(b, y), y.isMeshPhysicalMaterial && v(b, y, w))
        : y.isMeshMatcapMaterial
        ? (o(b, y), g(b, y))
        : y.isMeshDepthMaterial
        ? o(b, y)
        : y.isMeshDistanceMaterial
        ? (o(b, y), _(b, y))
        : y.isMeshNormalMaterial
        ? o(b, y)
        : y.isLineBasicMaterial
        ? (a(b, y), y.isLineDashedMaterial && s(b, y))
        : y.isPointsMaterial
        ? l(b, y, M, x)
        : y.isSpriteMaterial
        ? c(b, y)
        : y.isShadowMaterial
        ? (b.color.value.copy(y.color), (b.opacity.value = y.opacity))
        : y.isShaderMaterial && (y.uniformsNeedUpdate = !1)
    }
    function o(b, y) {
      ;(b.opacity.value = y.opacity),
        y.color && b.diffuse.value.copy(y.color),
        y.emissive &&
          b.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),
        y.map && ((b.map.value = y.map), n(y.map, b.mapTransform)),
        y.alphaMap &&
          ((b.alphaMap.value = y.alphaMap), n(y.alphaMap, b.alphaMapTransform)),
        y.bumpMap &&
          ((b.bumpMap.value = y.bumpMap),
          n(y.bumpMap, b.bumpMapTransform),
          (b.bumpScale.value = y.bumpScale),
          y.side === Mi && (b.bumpScale.value *= -1)),
        y.normalMap &&
          ((b.normalMap.value = y.normalMap),
          n(y.normalMap, b.normalMapTransform),
          b.normalScale.value.copy(y.normalScale),
          y.side === Mi && b.normalScale.value.negate()),
        y.displacementMap &&
          ((b.displacementMap.value = y.displacementMap),
          n(y.displacementMap, b.displacementMapTransform),
          (b.displacementScale.value = y.displacementScale),
          (b.displacementBias.value = y.displacementBias)),
        y.emissiveMap &&
          ((b.emissiveMap.value = y.emissiveMap),
          n(y.emissiveMap, b.emissiveMapTransform)),
        y.specularMap &&
          ((b.specularMap.value = y.specularMap),
          n(y.specularMap, b.specularMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest)
      const M = t.get(y).envMap
      if (
        (M &&
          ((b.envMap.value = M),
          (b.flipEnvMap.value =
            M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
          (b.reflectivity.value = y.reflectivity),
          (b.ior.value = y.ior),
          (b.refractionRatio.value = y.refractionRatio)),
        y.lightMap)
      ) {
        b.lightMap.value = y.lightMap
        const x = e.useLegacyLights === !0 ? Math.PI : 1
        ;(b.lightMapIntensity.value = y.lightMapIntensity * x),
          n(y.lightMap, b.lightMapTransform)
      }
      y.aoMap &&
        ((b.aoMap.value = y.aoMap),
        (b.aoMapIntensity.value = y.aoMapIntensity),
        n(y.aoMap, b.aoMapTransform))
    }
    function a(b, y) {
      b.diffuse.value.copy(y.color),
        (b.opacity.value = y.opacity),
        y.map && ((b.map.value = y.map), n(y.map, b.mapTransform))
    }
    function s(b, y) {
      ;(b.dashSize.value = y.dashSize),
        (b.totalSize.value = y.dashSize + y.gapSize),
        (b.scale.value = y.scale)
    }
    function l(b, y, M, x) {
      b.diffuse.value.copy(y.color),
        (b.opacity.value = y.opacity),
        (b.size.value = y.size * M),
        (b.scale.value = x * 0.5),
        y.map && ((b.map.value = y.map), n(y.map, b.uvTransform)),
        y.alphaMap &&
          ((b.alphaMap.value = y.alphaMap), n(y.alphaMap, b.alphaMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest)
    }
    function c(b, y) {
      b.diffuse.value.copy(y.color),
        (b.opacity.value = y.opacity),
        (b.rotation.value = y.rotation),
        y.map && ((b.map.value = y.map), n(y.map, b.mapTransform)),
        y.alphaMap &&
          ((b.alphaMap.value = y.alphaMap), n(y.alphaMap, b.alphaMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest)
    }
    function d(b, y) {
      b.specular.value.copy(y.specular),
        (b.shininess.value = Math.max(y.shininess, 1e-4))
    }
    function h(b, y) {
      y.gradientMap && (b.gradientMap.value = y.gradientMap)
    }
    function p(b, y) {
      ;(b.metalness.value = y.metalness),
        y.metalnessMap &&
          ((b.metalnessMap.value = y.metalnessMap),
          n(y.metalnessMap, b.metalnessMapTransform)),
        (b.roughness.value = y.roughness),
        y.roughnessMap &&
          ((b.roughnessMap.value = y.roughnessMap),
          n(y.roughnessMap, b.roughnessMapTransform)),
        t.get(y).envMap && (b.envMapIntensity.value = y.envMapIntensity)
    }
    function v(b, y, M) {
      ;(b.ior.value = y.ior),
        y.sheen > 0 &&
          (b.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),
          (b.sheenRoughness.value = y.sheenRoughness),
          y.sheenColorMap &&
            ((b.sheenColorMap.value = y.sheenColorMap),
            n(y.sheenColorMap, b.sheenColorMapTransform)),
          y.sheenRoughnessMap &&
            ((b.sheenRoughnessMap.value = y.sheenRoughnessMap),
            n(y.sheenRoughnessMap, b.sheenRoughnessMapTransform))),
        y.clearcoat > 0 &&
          ((b.clearcoat.value = y.clearcoat),
          (b.clearcoatRoughness.value = y.clearcoatRoughness),
          y.clearcoatMap &&
            ((b.clearcoatMap.value = y.clearcoatMap),
            n(y.clearcoatMap, b.clearcoatMapTransform)),
          y.clearcoatRoughnessMap &&
            ((b.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap),
            n(y.clearcoatRoughnessMap, b.clearcoatRoughnessMapTransform)),
          y.clearcoatNormalMap &&
            ((b.clearcoatNormalMap.value = y.clearcoatNormalMap),
            n(y.clearcoatNormalMap, b.clearcoatNormalMapTransform),
            b.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),
            y.side === Mi && b.clearcoatNormalScale.value.negate())),
        y.iridescence > 0 &&
          ((b.iridescence.value = y.iridescence),
          (b.iridescenceIOR.value = y.iridescenceIOR),
          (b.iridescenceThicknessMinimum.value =
            y.iridescenceThicknessRange[0]),
          (b.iridescenceThicknessMaximum.value =
            y.iridescenceThicknessRange[1]),
          y.iridescenceMap &&
            ((b.iridescenceMap.value = y.iridescenceMap),
            n(y.iridescenceMap, b.iridescenceMapTransform)),
          y.iridescenceThicknessMap &&
            ((b.iridescenceThicknessMap.value = y.iridescenceThicknessMap),
            n(y.iridescenceThicknessMap, b.iridescenceThicknessMapTransform))),
        y.transmission > 0 &&
          ((b.transmission.value = y.transmission),
          (b.transmissionSamplerMap.value = M.texture),
          b.transmissionSamplerSize.value.set(M.width, M.height),
          y.transmissionMap &&
            ((b.transmissionMap.value = y.transmissionMap),
            n(y.transmissionMap, b.transmissionMapTransform)),
          (b.thickness.value = y.thickness),
          y.thicknessMap &&
            ((b.thicknessMap.value = y.thicknessMap),
            n(y.thicknessMap, b.thicknessMapTransform)),
          (b.attenuationDistance.value = y.attenuationDistance),
          b.attenuationColor.value.copy(y.attenuationColor)),
        y.anisotropy > 0 &&
          (b.anisotropyVector.value.set(
            y.anisotropy * Math.cos(y.anisotropyRotation),
            y.anisotropy * Math.sin(y.anisotropyRotation)
          ),
          y.anisotropyMap &&
            ((b.anisotropyMap.value = y.anisotropyMap),
            n(y.anisotropyMap, b.anisotropyMapTransform))),
        (b.specularIntensity.value = y.specularIntensity),
        b.specularColor.value.copy(y.specularColor),
        y.specularColorMap &&
          ((b.specularColorMap.value = y.specularColorMap),
          n(y.specularColorMap, b.specularColorMapTransform)),
        y.specularIntensityMap &&
          ((b.specularIntensityMap.value = y.specularIntensityMap),
          n(y.specularIntensityMap, b.specularIntensityMapTransform))
    }
    function g(b, y) {
      y.matcap && (b.matcap.value = y.matcap)
    }
    function _(b, y) {
      const M = t.get(y).light
      b.referencePosition.value.setFromMatrixPosition(M.matrixWorld),
        (b.nearDistance.value = M.shadow.camera.near),
        (b.farDistance.value = M.shadow.camera.far)
    }
    return { refreshFogUniforms: r, refreshMaterialUniforms: i }
  }
  function Gfe(e, t, n, r) {
    let i = {},
      o = {},
      a = []
    const s = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0
    function l(M, x) {
      const w = x.program
      r.uniformBlockBinding(M, w)
    }
    function c(M, x) {
      let w = i[M.id]
      w === void 0 &&
        (g(M), (w = d(M)), (i[M.id] = w), M.addEventListener('dispose', b))
      const E = x.program
      r.updateUBOMapping(M, E)
      const P = t.render.frame
      o[M.id] !== P && (p(M), (o[M.id] = P))
    }
    function d(M) {
      const x = h()
      M.__bindingPointIndex = x
      const w = e.createBuffer(),
        E = M.__size,
        P = M.usage
      return (
        e.bindBuffer(e.UNIFORM_BUFFER, w),
        e.bufferData(e.UNIFORM_BUFFER, E, P),
        e.bindBuffer(e.UNIFORM_BUFFER, null),
        e.bindBufferBase(e.UNIFORM_BUFFER, x, w),
        w
      )
    }
    function h() {
      for (let M = 0; M < s; M++) if (a.indexOf(M) === -1) return a.push(M), M
      return (
        console.error(
          'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
        ),
        0
      )
    }
    function p(M) {
      const x = i[M.id],
        w = M.uniforms,
        E = M.__cache
      e.bindBuffer(e.UNIFORM_BUFFER, x)
      for (let P = 0, A = w.length; P < A; P++) {
        const F = w[P]
        if (v(F, P, E) === !0) {
          const T = F.__offset,
            k = Array.isArray(F.value) ? F.value : [F.value]
          let R = 0
          for (let j = 0; j < k.length; j++) {
            const N = k[j],
              I = _(N)
            typeof N == 'number'
              ? ((F.__data[0] = N),
                e.bufferSubData(e.UNIFORM_BUFFER, T + R, F.__data))
              : N.isMatrix3
              ? ((F.__data[0] = N.elements[0]),
                (F.__data[1] = N.elements[1]),
                (F.__data[2] = N.elements[2]),
                (F.__data[3] = N.elements[0]),
                (F.__data[4] = N.elements[3]),
                (F.__data[5] = N.elements[4]),
                (F.__data[6] = N.elements[5]),
                (F.__data[7] = N.elements[0]),
                (F.__data[8] = N.elements[6]),
                (F.__data[9] = N.elements[7]),
                (F.__data[10] = N.elements[8]),
                (F.__data[11] = N.elements[0]))
              : (N.toArray(F.__data, R),
                (R += I.storage / Float32Array.BYTES_PER_ELEMENT))
          }
          e.bufferSubData(e.UNIFORM_BUFFER, T, F.__data)
        }
      }
      e.bindBuffer(e.UNIFORM_BUFFER, null)
    }
    function v(M, x, w) {
      const E = M.value
      if (w[x] === void 0) {
        if (typeof E == 'number') w[x] = E
        else {
          const P = Array.isArray(E) ? E : [E],
            A = []
          for (let F = 0; F < P.length; F++) A.push(P[F].clone())
          w[x] = A
        }
        return !0
      } else if (typeof E == 'number') {
        if (w[x] !== E) return (w[x] = E), !0
      } else {
        const P = Array.isArray(w[x]) ? w[x] : [w[x]],
          A = Array.isArray(E) ? E : [E]
        for (let F = 0; F < P.length; F++) {
          const T = P[F]
          if (T.equals(A[F]) === !1) return T.copy(A[F]), !0
        }
      }
      return !1
    }
    function g(M) {
      const x = M.uniforms
      let w = 0
      const E = 16
      let P = 0
      for (let A = 0, F = x.length; A < F; A++) {
        const T = x[A],
          k = { boundary: 0, storage: 0 },
          R = Array.isArray(T.value) ? T.value : [T.value]
        for (let j = 0, N = R.length; j < N; j++) {
          const I = R[j],
            B = _(I)
          ;(k.boundary += B.boundary), (k.storage += B.storage)
        }
        if (
          ((T.__data = new Float32Array(
            k.storage / Float32Array.BYTES_PER_ELEMENT
          )),
          (T.__offset = w),
          A > 0)
        ) {
          P = w % E
          const j = E - P
          P !== 0 && j - k.boundary < 0 && ((w += E - P), (T.__offset = w))
        }
        w += k.storage
      }
      return (
        (P = w % E),
        P > 0 && (w += E - P),
        (M.__size = w),
        (M.__cache = {}),
        this
      )
    }
    function _(M) {
      const x = { boundary: 0, storage: 0 }
      return (
        typeof M == 'number'
          ? ((x.boundary = 4), (x.storage = 4))
          : M.isVector2
          ? ((x.boundary = 8), (x.storage = 8))
          : M.isVector3 || M.isColor
          ? ((x.boundary = 16), (x.storage = 12))
          : M.isVector4
          ? ((x.boundary = 16), (x.storage = 16))
          : M.isMatrix3
          ? ((x.boundary = 48), (x.storage = 48))
          : M.isMatrix4
          ? ((x.boundary = 64), (x.storage = 64))
          : M.isTexture
          ? console.warn(
              'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
            )
          : console.warn(
              'THREE.WebGLRenderer: Unsupported uniform value type.',
              M
            ),
        x
      )
    }
    function b(M) {
      const x = M.target
      x.removeEventListener('dispose', b)
      const w = a.indexOf(x.__bindingPointIndex)
      a.splice(w, 1), e.deleteBuffer(i[x.id]), delete i[x.id], delete o[x.id]
    }
    function y() {
      for (const M in i) e.deleteBuffer(i[M])
      ;(a = []), (i = {}), (o = {})
    }
    return { bind: l, update: c, dispose: y }
  }
  function Kfe() {
    const e = Fd('canvas')
    return (e.style.display = 'block'), e
  }
  class x$ {
    constructor(t = {}) {
      const {
        canvas: n = Kfe(),
        context: r = null,
        depth: i = !0,
        stencil: o = !0,
        alpha: a = !1,
        antialias: s = !1,
        premultipliedAlpha: l = !0,
        preserveDrawingBuffer: c = !1,
        powerPreference: d = 'default',
        failIfMajorPerformanceCaveat: h = !1,
      } = t
      this.isWebGLRenderer = !0
      let p
      r !== null ? (p = r.getContextAttributes().alpha) : (p = a)
      const v = new Uint32Array(4),
        g = new Int32Array(4)
      let _ = null,
        b = null
      const y = [],
        M = []
      ;(this.domElement = n),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.outputColorSpace = rn),
        (this.useLegacyLights = !0),
        (this.toneMapping = Ba),
        (this.toneMappingExposure = 1)
      const x = this
      let w = !1,
        E = 0,
        P = 0,
        A = null,
        F = -1,
        T = null
      const k = new Jn(),
        R = new Jn()
      let j = null
      const N = new xn(0)
      let I = 0,
        B = n.width,
        V = n.height,
        L = 1,
        W = null,
        Y = null
      const U = new Jn(0, 0, B, V),
        le = new Jn(0, 0, B, V)
      let q = !1
      const oe = new LS()
      let te = !1,
        ue = !1,
        me = null
      const Re = new qn(),
        qe = new Ct(),
        Ve = new Pe(),
        nt = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        }
      function We() {
        return A === null ? L : 1
      }
      let D = r
      function G(fe, Ue) {
        for (let Xe = 0; Xe < fe.length; Xe++) {
          const De = fe[Xe],
            rt = n.getContext(De, Ue)
          if (rt !== null) return rt
        }
        return null
      }
      try {
        const fe = {
          alpha: !0,
          depth: i,
          stencil: o,
          antialias: s,
          premultipliedAlpha: l,
          preserveDrawingBuffer: c,
          powerPreference: d,
          failIfMajorPerformanceCaveat: h,
        }
        if (
          ('setAttribute' in n &&
            n.setAttribute('data-engine', `three.js r${PS}`),
          n.addEventListener('webglcontextlost', bt, !1),
          n.addEventListener('webglcontextrestored', He, !1),
          n.addEventListener('webglcontextcreationerror', _t, !1),
          D === null)
        ) {
          const Ue = ['webgl2', 'webgl', 'experimental-webgl']
          if (
            (x.isWebGL1Renderer === !0 && Ue.shift(),
            (D = G(Ue, fe)),
            D === null)
          )
            throw G(Ue)
              ? new Error(
                  'Error creating WebGL context with your selected attributes.'
                )
              : new Error('Error creating WebGL context.')
        }
        D instanceof WebGLRenderingContext &&
          console.warn(
            'THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.'
          ),
          D.getShaderPrecisionFormat === void 0 &&
            (D.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 }
            })
      } catch (fe) {
        throw (console.error('THREE.WebGLRenderer: ' + fe.message), fe)
      }
      let z,
        ie,
        ae,
        re,
        pe,
        we,
        $e,
        Ae,
        ft,
        Q,
        X,
        he,
        de,
        xe,
        ne,
        Le,
        et,
        Ne,
        Et,
        kt,
        je,
        Ge,
        Ye,
        lt
      function gt() {
        ;(z = new ide(D)),
          (ie = new Jce(D, z, t)),
          z.init(ie),
          (Ge = new zfe(D, z, ie)),
          (ae = new Bfe(D, z, ie)),
          (re = new sde(D)),
          (pe = new xfe()),
          (we = new Ffe(D, z, ae, pe, ie, Ge, re)),
          ($e = new ede(x)),
          (Ae = new rde(x)),
          (ft = new ble(D, ie)),
          (Ye = new Yce(D, z, ft, ie)),
          (Q = new ode(D, ft, re, Ye)),
          (X = new dde(D, Q, ft, re)),
          (Et = new cde(D, ie, we)),
          (Le = new Qce(pe)),
          (he = new wfe(x, $e, Ae, z, ie, Ye, Le)),
          (de = new jfe(x, pe)),
          (xe = new Efe()),
          (ne = new Ofe(z, ie)),
          (Ne = new Xce(x, $e, Ae, ae, X, p, l)),
          (et = new Nfe(x, X, ie)),
          (lt = new Gfe(D, re, ie, ae)),
          (kt = new Zce(D, z, re, ie)),
          (je = new ade(D, z, re, ie)),
          (re.programs = he.programs),
          (x.capabilities = ie),
          (x.extensions = z),
          (x.properties = pe),
          (x.renderLists = xe),
          (x.shadowMap = et),
          (x.state = ae),
          (x.info = re)
      }
      gt()
      const _e = new Wfe(x, D)
      ;(this.xr = _e),
        (this.getContext = function () {
          return D
        }),
        (this.getContextAttributes = function () {
          return D.getContextAttributes()
        }),
        (this.forceContextLoss = function () {
          const fe = z.get('WEBGL_lose_context')
          fe && fe.loseContext()
        }),
        (this.forceContextRestore = function () {
          const fe = z.get('WEBGL_lose_context')
          fe && fe.restoreContext()
        }),
        (this.getPixelRatio = function () {
          return L
        }),
        (this.setPixelRatio = function (fe) {
          fe !== void 0 && ((L = fe), this.setSize(B, V, !1))
        }),
        (this.getSize = function (fe) {
          return fe.set(B, V)
        }),
        (this.setSize = function (fe, Ue, Xe = !0) {
          if (_e.isPresenting) {
            console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
            return
          }
          ;(B = fe),
            (V = Ue),
            (n.width = Math.floor(fe * L)),
            (n.height = Math.floor(Ue * L)),
            Xe === !0 &&
              ((n.style.width = fe + 'px'), (n.style.height = Ue + 'px')),
            this.setViewport(0, 0, fe, Ue)
        }),
        (this.getDrawingBufferSize = function (fe) {
          return fe.set(B * L, V * L).floor()
        }),
        (this.setDrawingBufferSize = function (fe, Ue, Xe) {
          ;(B = fe),
            (V = Ue),
            (L = Xe),
            (n.width = Math.floor(fe * Xe)),
            (n.height = Math.floor(Ue * Xe)),
            this.setViewport(0, 0, fe, Ue)
        }),
        (this.getCurrentViewport = function (fe) {
          return fe.copy(k)
        }),
        (this.getViewport = function (fe) {
          return fe.copy(U)
        }),
        (this.setViewport = function (fe, Ue, Xe, De) {
          fe.isVector4 ? U.set(fe.x, fe.y, fe.z, fe.w) : U.set(fe, Ue, Xe, De),
            ae.viewport(k.copy(U).multiplyScalar(L).floor())
        }),
        (this.getScissor = function (fe) {
          return fe.copy(le)
        }),
        (this.setScissor = function (fe, Ue, Xe, De) {
          fe.isVector4
            ? le.set(fe.x, fe.y, fe.z, fe.w)
            : le.set(fe, Ue, Xe, De),
            ae.scissor(R.copy(le).multiplyScalar(L).floor())
        }),
        (this.getScissorTest = function () {
          return q
        }),
        (this.setScissorTest = function (fe) {
          ae.setScissorTest((q = fe))
        }),
        (this.setOpaqueSort = function (fe) {
          W = fe
        }),
        (this.setTransparentSort = function (fe) {
          Y = fe
        }),
        (this.getClearColor = function (fe) {
          return fe.copy(Ne.getClearColor())
        }),
        (this.setClearColor = function () {
          Ne.setClearColor.apply(Ne, arguments)
        }),
        (this.getClearAlpha = function () {
          return Ne.getClearAlpha()
        }),
        (this.setClearAlpha = function () {
          Ne.setClearAlpha.apply(Ne, arguments)
        }),
        (this.clear = function (fe = !0, Ue = !0, Xe = !0) {
          let De = 0
          if (fe) {
            let rt = !1
            if (A !== null) {
              const Ot = A.texture.format
              rt = Ot === r$ || Ot === n$ || Ot === t$
            }
            if (rt) {
              const Ot = A.texture.type,
                Ke =
                  Ot === Es ||
                  Ot === _s ||
                  Ot === TS ||
                  Ot === _l ||
                  Ot === QA ||
                  Ot === e$,
                ct = Ne.getClearColor(),
                Tt = Ne.getClearAlpha(),
                Bt = ct.r,
                Dt = ct.g,
                jt = ct.b,
                _n = pe.get(A).__webglFramebuffer
              Ke
                ? ((v[0] = Bt),
                  (v[1] = Dt),
                  (v[2] = jt),
                  (v[3] = Tt),
                  D.clearBufferuiv(D.COLOR, _n, v))
                : ((g[0] = Bt),
                  (g[1] = Dt),
                  (g[2] = jt),
                  (g[3] = Tt),
                  D.clearBufferiv(D.COLOR, _n, g))
            } else De |= D.COLOR_BUFFER_BIT
          }
          Ue && (De |= D.DEPTH_BUFFER_BIT),
            Xe && (De |= D.STENCIL_BUFFER_BIT),
            D.clear(De)
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1)
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1)
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0)
        }),
        (this.dispose = function () {
          n.removeEventListener('webglcontextlost', bt, !1),
            n.removeEventListener('webglcontextrestored', He, !1),
            n.removeEventListener('webglcontextcreationerror', _t, !1),
            xe.dispose(),
            ne.dispose(),
            pe.dispose(),
            $e.dispose(),
            Ae.dispose(),
            X.dispose(),
            Ye.dispose(),
            lt.dispose(),
            he.dispose(),
            _e.dispose(),
            _e.removeEventListener('sessionstart', vt),
            _e.removeEventListener('sessionend', Gt),
            me && (me.dispose(), (me = null)),
            pn.stop()
        })
      function bt(fe) {
        fe.preventDefault(),
          console.log('THREE.WebGLRenderer: Context Lost.'),
          (w = !0)
      }
      function He() {
        console.log('THREE.WebGLRenderer: Context Restored.'), (w = !1)
        const fe = re.autoReset,
          Ue = et.enabled,
          Xe = et.autoUpdate,
          De = et.needsUpdate,
          rt = et.type
        gt(),
          (re.autoReset = fe),
          (et.enabled = Ue),
          (et.autoUpdate = Xe),
          (et.needsUpdate = De),
          (et.type = rt)
      }
      function _t(fe) {
        console.error(
          'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
          fe.statusMessage
        )
      }
      function wt(fe) {
        const Ue = fe.target
        Ue.removeEventListener('dispose', wt), Zt(Ue)
      }
      function Zt(fe) {
        ln(fe), pe.remove(fe)
      }
      function ln(fe) {
        const Ue = pe.get(fe).programs
        Ue !== void 0 &&
          (Ue.forEach(function (Xe) {
            he.releaseProgram(Xe)
          }),
          fe.isShaderMaterial && he.releaseShaderCache(fe))
      }
      ;(this.renderBufferDirect = function (fe, Ue, Xe, De, rt, Ot) {
        Ue === null && (Ue = nt)
        const Ke = rt.isMesh && rt.matrixWorld.determinant() < 0,
          ct = fo(fe, Ue, Xe, De, rt)
        ae.setMaterial(De, Ke)
        let Tt = Xe.index,
          Bt = 1
        De.wireframe === !0 && ((Tt = Q.getWireframeAttribute(Xe)), (Bt = 2))
        const Dt = Xe.drawRange,
          jt = Xe.attributes.position
        let _n = Dt.start * Bt,
          Dn = (Dt.start + Dt.count) * Bt
        Ot !== null &&
          ((_n = Math.max(_n, Ot.start * Bt)),
          (Dn = Math.min(Dn, (Ot.start + Ot.count) * Bt))),
          Tt !== null
            ? ((_n = Math.max(_n, 0)), (Dn = Math.min(Dn, Tt.count)))
            : jt != null &&
              ((_n = Math.max(_n, 0)), (Dn = Math.min(Dn, jt.count)))
        const kr = Dn - _n
        if (kr < 0 || kr === 1 / 0) return
        Ye.setup(rt, De, ct, Xe, Tt)
        let ei,
          Fn = kt
        if (
          (Tt !== null && ((ei = ft.get(Tt)), (Fn = je), Fn.setIndex(ei)),
          rt.isMesh)
        )
          De.wireframe === !0
            ? (ae.setLineWidth(De.wireframeLinewidth * We()),
              Fn.setMode(D.LINES))
            : Fn.setMode(D.TRIANGLES)
        else if (rt.isLine) {
          let un = De.linewidth
          un === void 0 && (un = 1),
            ae.setLineWidth(un * We()),
            rt.isLineSegments
              ? Fn.setMode(D.LINES)
              : rt.isLineLoop
              ? Fn.setMode(D.LINE_LOOP)
              : Fn.setMode(D.LINE_STRIP)
        } else
          rt.isPoints
            ? Fn.setMode(D.POINTS)
            : rt.isSprite && Fn.setMode(D.TRIANGLES)
        if (rt.isInstancedMesh) Fn.renderInstances(_n, kr, rt.count)
        else if (Xe.isInstancedBufferGeometry) {
          const un =
              Xe._maxInstanceCount !== void 0 ? Xe._maxInstanceCount : 1 / 0,
            Ka = Math.min(Xe.instanceCount, un)
          Fn.renderInstances(_n, kr, Ka)
        } else Fn.render(_n, kr)
      }),
        (this.compile = function (fe, Ue) {
          function Xe(De, rt, Ot) {
            De.transparent === !0 && De.side === Oa && De.forceSinglePass === !1
              ? ((De.side = Mi),
                (De.needsUpdate = !0),
                co(De, rt, Ot),
                (De.side = $s),
                (De.needsUpdate = !0),
                co(De, rt, Ot),
                (De.side = Oa))
              : co(De, rt, Ot)
          }
          ;(b = ne.get(fe)),
            b.init(),
            M.push(b),
            fe.traverseVisible(function (De) {
              De.isLight &&
                De.layers.test(Ue.layers) &&
                (b.pushLight(De), De.castShadow && b.pushShadow(De))
            }),
            b.setupLights(x.useLegacyLights),
            fe.traverse(function (De) {
              const rt = De.material
              if (rt)
                if (Array.isArray(rt))
                  for (let Ot = 0; Ot < rt.length; Ot++) {
                    const Ke = rt[Ot]
                    Xe(Ke, fe, De)
                  }
                else Xe(rt, fe, De)
            }),
            M.pop(),
            (b = null)
        })
      let Pn = null
      function Tr(fe) {
        Pn && Pn(fe)
      }
      function vt() {
        pn.stop()
      }
      function Gt() {
        pn.start()
      }
      const pn = new y$()
      pn.setAnimationLoop(Tr),
        typeof self < 'u' && pn.setContext(self),
        (this.setAnimationLoop = function (fe) {
          ;(Pn = fe),
            _e.setAnimationLoop(fe),
            fe === null ? pn.stop() : pn.start()
        }),
        _e.addEventListener('sessionstart', vt),
        _e.addEventListener('sessionend', Gt),
        (this.render = function (fe, Ue) {
          if (Ue !== void 0 && Ue.isCamera !== !0) {
            console.error(
              'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
            )
            return
          }
          if (w === !0) return
          fe.matrixWorldAutoUpdate === !0 && fe.updateMatrixWorld(),
            Ue.parent === null &&
              Ue.matrixWorldAutoUpdate === !0 &&
              Ue.updateMatrixWorld(),
            _e.enabled === !0 &&
              _e.isPresenting === !0 &&
              (Ue = _e.updateCameraXR(Ue)),
            fe.isScene === !0 && fe.onBeforeRender(x, fe, Ue, A),
            (b = ne.get(fe, M.length)),
            b.init(),
            M.push(b),
            Re.multiplyMatrices(Ue.projectionMatrix, Ue.matrixWorldInverse),
            oe.setFromProjectionMatrix(Re),
            (ue = this.localClippingEnabled),
            (te = Le.init(this.clippingPlanes, ue)),
            (_ = xe.get(fe, y.length)),
            _.init(),
            y.push(_),
            yr(fe, Ue, 0, x.sortObjects),
            _.finish(),
            x.sortObjects === !0 && _.sort(W, Y),
            te === !0 && Le.beginShadows()
          const Xe = b.state.shadowsArray
          if (
            (et.render(Xe, fe, Ue),
            te === !0 && Le.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            this.info.render.frame++,
            Ne.render(_, fe),
            b.setupLights(x.useLegacyLights),
            Ue.isArrayCamera)
          ) {
            const De = Ue.cameras
            for (let rt = 0, Ot = De.length; rt < Ot; rt++) {
              const Ke = De[rt]
              hi(_, fe, Ke, Ke.viewport)
            }
          } else hi(_, fe, Ue)
          A !== null &&
            (we.updateMultisampleRenderTarget(A),
            we.updateRenderTargetMipmap(A)),
            fe.isScene === !0 && fe.onAfterRender(x, fe, Ue),
            Ye.resetDefaultState(),
            (F = -1),
            (T = null),
            M.pop(),
            M.length > 0 ? (b = M[M.length - 1]) : (b = null),
            y.pop(),
            y.length > 0 ? (_ = y[y.length - 1]) : (_ = null)
        })
      function yr(fe, Ue, Xe, De) {
        if (fe.visible === !1) return
        if (fe.layers.test(Ue.layers)) {
          if (fe.isGroup) Xe = fe.renderOrder
          else if (fe.isLOD) fe.autoUpdate === !0 && fe.update(Ue)
          else if (fe.isLight)
            b.pushLight(fe), fe.castShadow && b.pushShadow(fe)
          else if (fe.isSprite) {
            if (!fe.frustumCulled || oe.intersectsSprite(fe)) {
              De && Ve.setFromMatrixPosition(fe.matrixWorld).applyMatrix4(Re)
              const Ke = X.update(fe),
                ct = fe.material
              ct.visible && _.push(fe, Ke, ct, Xe, Ve.z, null)
            }
          } else if (
            (fe.isMesh || fe.isLine || fe.isPoints) &&
            (!fe.frustumCulled || oe.intersectsObject(fe))
          ) {
            fe.isSkinnedMesh &&
              fe.skeleton.frame !== re.render.frame &&
              (fe.skeleton.update(), (fe.skeleton.frame = re.render.frame))
            const Ke = X.update(fe),
              ct = fe.material
            if (
              (De &&
                (fe.boundingSphere !== void 0
                  ? (fe.boundingSphere === null && fe.computeBoundingSphere(),
                    Ve.copy(fe.boundingSphere.center))
                  : (Ke.boundingSphere === null && Ke.computeBoundingSphere(),
                    Ve.copy(Ke.boundingSphere.center)),
                Ve.applyMatrix4(fe.matrixWorld).applyMatrix4(Re)),
              Array.isArray(ct))
            ) {
              const Tt = Ke.groups
              for (let Bt = 0, Dt = Tt.length; Bt < Dt; Bt++) {
                const jt = Tt[Bt],
                  _n = ct[jt.materialIndex]
                _n && _n.visible && _.push(fe, Ke, _n, Xe, Ve.z, jt)
              }
            } else ct.visible && _.push(fe, Ke, ct, Xe, Ve.z, null)
          }
        }
        const Ot = fe.children
        for (let Ke = 0, ct = Ot.length; Ke < ct; Ke++) yr(Ot[Ke], Ue, Xe, De)
      }
      function hi(fe, Ue, Xe, De) {
        const rt = fe.opaque,
          Ot = fe.transmissive,
          Ke = fe.transparent
        b.setupLightsView(Xe),
          te === !0 && Le.setGlobalState(x.clippingPlanes, Xe),
          Ot.length > 0 && Qr(rt, Ot, Ue, Xe),
          De && ae.viewport(k.copy(De)),
          rt.length > 0 && Ur(rt, Ue, Xe),
          Ot.length > 0 && Ur(Ot, Ue, Xe),
          Ke.length > 0 && Ur(Ke, Ue, Xe),
          ae.buffers.depth.setTest(!0),
          ae.buffers.depth.setMask(!0),
          ae.buffers.color.setMask(!0),
          ae.setPolygonOffset(!1)
      }
      function Qr(fe, Ue, Xe, De) {
        const rt = ie.isWebGL2
        me === null &&
          (me = new El(1, 1, {
            generateMipmaps: !0,
            type: z.has('EXT_color_buffer_half_float') ? Nd : Es,
            minFilter: Dd,
            samples: rt && s === !0 ? 4 : 0,
          })),
          x.getDrawingBufferSize(qe),
          rt ? me.setSize(qe.x, qe.y) : me.setSize(Cv(qe.x), Cv(qe.y))
        const Ot = x.getRenderTarget()
        x.setRenderTarget(me),
          x.getClearColor(N),
          (I = x.getClearAlpha()),
          I < 1 && x.setClearColor(16777215, 0.5),
          x.clear()
        const Ke = x.toneMapping
        ;(x.toneMapping = Ba),
          Ur(fe, Xe, De),
          we.updateMultisampleRenderTarget(me),
          we.updateRenderTargetMipmap(me)
        let ct = !1
        for (let Tt = 0, Bt = Ue.length; Tt < Bt; Tt++) {
          const Dt = Ue[Tt],
            jt = Dt.object,
            _n = Dt.geometry,
            Dn = Dt.material,
            kr = Dt.group
          if (Dn.side === Oa && jt.layers.test(De.layers)) {
            const ei = Dn.side
            ;(Dn.side = Mi),
              (Dn.needsUpdate = !0),
              da(jt, Xe, De, _n, Dn, kr),
              (Dn.side = ei),
              (Dn.needsUpdate = !0),
              (ct = !0)
          }
        }
        ct === !0 &&
          (we.updateMultisampleRenderTarget(me),
          we.updateRenderTargetMipmap(me)),
          x.setRenderTarget(Ot),
          x.setClearColor(N, I),
          (x.toneMapping = Ke)
      }
      function Ur(fe, Ue, Xe) {
        const De = Ue.isScene === !0 ? Ue.overrideMaterial : null
        for (let rt = 0, Ot = fe.length; rt < Ot; rt++) {
          const Ke = fe[rt],
            ct = Ke.object,
            Tt = Ke.geometry,
            Bt = De === null ? Ke.material : De,
            Dt = Ke.group
          ct.layers.test(Xe.layers) && da(ct, Ue, Xe, Tt, Bt, Dt)
        }
      }
      function da(fe, Ue, Xe, De, rt, Ot) {
        fe.onBeforeRender(x, Ue, Xe, De, rt, Ot),
          fe.modelViewMatrix.multiplyMatrices(
            Xe.matrixWorldInverse,
            fe.matrixWorld
          ),
          fe.normalMatrix.getNormalMatrix(fe.modelViewMatrix),
          rt.onBeforeRender(x, Ue, Xe, De, fe, Ot),
          rt.transparent === !0 && rt.side === Oa && rt.forceSinglePass === !1
            ? ((rt.side = Mi),
              (rt.needsUpdate = !0),
              x.renderBufferDirect(Xe, Ue, De, rt, fe, Ot),
              (rt.side = $s),
              (rt.needsUpdate = !0),
              x.renderBufferDirect(Xe, Ue, De, rt, fe, Ot),
              (rt.side = Oa))
            : x.renderBufferDirect(Xe, Ue, De, rt, fe, Ot),
          fe.onAfterRender(x, Ue, Xe, De, rt, Ot)
      }
      function co(fe, Ue, Xe) {
        Ue.isScene !== !0 && (Ue = nt)
        const De = pe.get(fe),
          rt = b.state.lights,
          Ot = b.state.shadowsArray,
          Ke = rt.state.version,
          ct = he.getParameters(fe, rt.state, Ot, Ue, Xe),
          Tt = he.getProgramCacheKey(ct)
        let Bt = De.programs
        ;(De.environment = fe.isMeshStandardMaterial ? Ue.environment : null),
          (De.fog = Ue.fog),
          (De.envMap = (fe.isMeshStandardMaterial ? Ae : $e).get(
            fe.envMap || De.environment
          )),
          Bt === void 0 &&
            (fe.addEventListener('dispose', wt),
            (Bt = new Map()),
            (De.programs = Bt))
        let Dt = Bt.get(Tt)
        if (Dt !== void 0) {
          if (De.currentProgram === Dt && De.lightsStateVersion === Ke)
            return ki(fe, ct), Dt
        } else
          (ct.uniforms = he.getUniforms(fe)),
            fe.onBuild(Xe, ct, x),
            fe.onBeforeCompile(ct, x),
            (Dt = he.acquireProgram(ct, Tt)),
            Bt.set(Tt, Dt),
            (De.uniforms = ct.uniforms)
        const jt = De.uniforms
        ;((!fe.isShaderMaterial && !fe.isRawShaderMaterial) ||
          fe.clipping === !0) &&
          (jt.clippingPlanes = Le.uniform),
          ki(fe, ct),
          (De.needsLights = Rs(fe)),
          (De.lightsStateVersion = Ke),
          De.needsLights &&
            ((jt.ambientLightColor.value = rt.state.ambient),
            (jt.lightProbe.value = rt.state.probe),
            (jt.directionalLights.value = rt.state.directional),
            (jt.directionalLightShadows.value = rt.state.directionalShadow),
            (jt.spotLights.value = rt.state.spot),
            (jt.spotLightShadows.value = rt.state.spotShadow),
            (jt.rectAreaLights.value = rt.state.rectArea),
            (jt.ltc_1.value = rt.state.rectAreaLTC1),
            (jt.ltc_2.value = rt.state.rectAreaLTC2),
            (jt.pointLights.value = rt.state.point),
            (jt.pointLightShadows.value = rt.state.pointShadow),
            (jt.hemisphereLights.value = rt.state.hemi),
            (jt.directionalShadowMap.value = rt.state.directionalShadowMap),
            (jt.directionalShadowMatrix.value =
              rt.state.directionalShadowMatrix),
            (jt.spotShadowMap.value = rt.state.spotShadowMap),
            (jt.spotLightMatrix.value = rt.state.spotLightMatrix),
            (jt.spotLightMap.value = rt.state.spotLightMap),
            (jt.pointShadowMap.value = rt.state.pointShadowMap),
            (jt.pointShadowMatrix.value = rt.state.pointShadowMatrix))
        const _n = Dt.getUniforms(),
          Dn = jp.seqWithValue(_n.seq, jt)
        return (De.currentProgram = Dt), (De.uniformsList = Dn), Dt
      }
      function ki(fe, Ue) {
        const Xe = pe.get(fe)
        ;(Xe.outputColorSpace = Ue.outputColorSpace),
          (Xe.instancing = Ue.instancing),
          (Xe.skinning = Ue.skinning),
          (Xe.morphTargets = Ue.morphTargets),
          (Xe.morphNormals = Ue.morphNormals),
          (Xe.morphColors = Ue.morphColors),
          (Xe.morphTargetsCount = Ue.morphTargetsCount),
          (Xe.numClippingPlanes = Ue.numClippingPlanes),
          (Xe.numIntersection = Ue.numClipIntersection),
          (Xe.vertexAlphas = Ue.vertexAlphas),
          (Xe.vertexTangents = Ue.vertexTangents),
          (Xe.toneMapping = Ue.toneMapping)
      }
      function fo(fe, Ue, Xe, De, rt) {
        Ue.isScene !== !0 && (Ue = nt), we.resetTextureUnits()
        const Ot = Ue.fog,
          Ke = De.isMeshStandardMaterial ? Ue.environment : null,
          ct =
            A === null
              ? x.outputColorSpace
              : A.isXRRenderTarget === !0
              ? A.texture.colorSpace
              : aa,
          Tt = (De.isMeshStandardMaterial ? Ae : $e).get(De.envMap || Ke),
          Bt =
            De.vertexColors === !0 &&
            !!Xe.attributes.color &&
            Xe.attributes.color.itemSize === 4,
          Dt = !!Xe.attributes.tangent && (!!De.normalMap || De.anisotropy > 0),
          jt = !!Xe.morphAttributes.position,
          _n = !!Xe.morphAttributes.normal,
          Dn = !!Xe.morphAttributes.color,
          kr = De.toneMapped ? x.toneMapping : Ba,
          ei =
            Xe.morphAttributes.position ||
            Xe.morphAttributes.normal ||
            Xe.morphAttributes.color,
          Fn = ei !== void 0 ? ei.length : 0,
          un = pe.get(De),
          Ka = b.state.lights
        if (te === !0 && (ue === !0 || fe !== T)) {
          const Qn = fe === T && De.id === F
          Le.setState(De, fe, Qn)
        }
        let Wn = !1
        De.version === un.__version
          ? ((un.needsLights && un.lightsStateVersion !== Ka.state.version) ||
              un.outputColorSpace !== ct ||
              (rt.isInstancedMesh && un.instancing === !1) ||
              (!rt.isInstancedMesh && un.instancing === !0) ||
              (rt.isSkinnedMesh && un.skinning === !1) ||
              (!rt.isSkinnedMesh && un.skinning === !0) ||
              un.envMap !== Tt ||
              (De.fog === !0 && un.fog !== Ot) ||
              (un.numClippingPlanes !== void 0 &&
                (un.numClippingPlanes !== Le.numPlanes ||
                  un.numIntersection !== Le.numIntersection)) ||
              un.vertexAlphas !== Bt ||
              un.vertexTangents !== Dt ||
              un.morphTargets !== jt ||
              un.morphNormals !== _n ||
              un.morphColors !== Dn ||
              un.toneMapping !== kr ||
              (ie.isWebGL2 === !0 && un.morphTargetsCount !== Fn)) &&
            (Wn = !0)
          : ((Wn = !0), (un.__version = De.version))
        let Wi = un.currentProgram
        Wn === !0 && (Wi = co(De, Ue, rt))
        let Ds = !1,
          $n = !1,
          qa = !1
        const Un = Wi.getUniforms(),
          Fo = un.uniforms
        if (
          (ae.useProgram(Wi.program) && ((Ds = !0), ($n = !0), (qa = !0)),
          De.id !== F && ((F = De.id), ($n = !0)),
          Ds || T !== fe)
        ) {
          if (
            (Un.setValue(D, 'projectionMatrix', fe.projectionMatrix),
            ie.logarithmicDepthBuffer &&
              Un.setValue(
                D,
                'logDepthBufFC',
                2 / (Math.log(fe.far + 1) / Math.LN2)
              ),
            T !== fe && ((T = fe), ($n = !0), (qa = !0)),
            De.isShaderMaterial ||
              De.isMeshPhongMaterial ||
              De.isMeshToonMaterial ||
              De.isMeshStandardMaterial ||
              De.envMap)
          ) {
            const Qn = Un.map.cameraPosition
            Qn !== void 0 &&
              Qn.setValue(D, Ve.setFromMatrixPosition(fe.matrixWorld))
          }
          ;(De.isMeshPhongMaterial ||
            De.isMeshToonMaterial ||
            De.isMeshLambertMaterial ||
            De.isMeshBasicMaterial ||
            De.isMeshStandardMaterial ||
            De.isShaderMaterial) &&
            Un.setValue(D, 'isOrthographic', fe.isOrthographicCamera === !0),
            (De.isMeshPhongMaterial ||
              De.isMeshToonMaterial ||
              De.isMeshLambertMaterial ||
              De.isMeshBasicMaterial ||
              De.isMeshStandardMaterial ||
              De.isShaderMaterial ||
              De.isShadowMaterial ||
              rt.isSkinnedMesh) &&
              Un.setValue(D, 'viewMatrix', fe.matrixWorldInverse)
        }
        if (rt.isSkinnedMesh) {
          Un.setOptional(D, rt, 'bindMatrix'),
            Un.setOptional(D, rt, 'bindMatrixInverse')
          const Qn = rt.skeleton
          Qn &&
            (ie.floatVertexTextures
              ? (Qn.boneTexture === null && Qn.computeBoneTexture(),
                Un.setValue(D, 'boneTexture', Qn.boneTexture, we),
                Un.setValue(D, 'boneTextureSize', Qn.boneTextureSize))
              : console.warn(
                  'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.'
                ))
        }
        const Ns = Xe.morphAttributes
        if (
          ((Ns.position !== void 0 ||
            Ns.normal !== void 0 ||
            (Ns.color !== void 0 && ie.isWebGL2 === !0)) &&
            Et.update(rt, Xe, Wi),
          ($n || un.receiveShadow !== rt.receiveShadow) &&
            ((un.receiveShadow = rt.receiveShadow),
            Un.setValue(D, 'receiveShadow', rt.receiveShadow)),
          De.isMeshGouraudMaterial &&
            De.envMap !== null &&
            ((Fo.envMap.value = Tt),
            (Fo.flipEnvMap.value =
              Tt.isCubeTexture && Tt.isRenderTargetTexture === !1 ? -1 : 1)),
          $n &&
            (Un.setValue(D, 'toneMappingExposure', x.toneMappingExposure),
            un.needsLights && ho(Fo, qa),
            Ot && De.fog === !0 && de.refreshFogUniforms(Fo, Ot),
            de.refreshMaterialUniforms(Fo, De, L, V, me),
            jp.upload(D, un.uniformsList, Fo, we)),
          De.isShaderMaterial &&
            De.uniformsNeedUpdate === !0 &&
            (jp.upload(D, un.uniformsList, Fo, we),
            (De.uniformsNeedUpdate = !1)),
          De.isSpriteMaterial && Un.setValue(D, 'center', rt.center),
          Un.setValue(D, 'modelViewMatrix', rt.modelViewMatrix),
          Un.setValue(D, 'normalMatrix', rt.normalMatrix),
          Un.setValue(D, 'modelMatrix', rt.matrixWorld),
          De.isShaderMaterial || De.isRawShaderMaterial)
        ) {
          const Qn = De.uniformsGroups
          for (let Xa = 0, hc = Qn.length; Xa < hc; Xa++)
            if (ie.isWebGL2) {
              const zo = Qn[Xa]
              lt.update(zo, Wi), lt.bind(zo, Wi)
            } else
              console.warn(
                'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.'
              )
        }
        return Wi
      }
      function ho(fe, Ue) {
        ;(fe.ambientLightColor.needsUpdate = Ue),
          (fe.lightProbe.needsUpdate = Ue),
          (fe.directionalLights.needsUpdate = Ue),
          (fe.directionalLightShadows.needsUpdate = Ue),
          (fe.pointLights.needsUpdate = Ue),
          (fe.pointLightShadows.needsUpdate = Ue),
          (fe.spotLights.needsUpdate = Ue),
          (fe.spotLightShadows.needsUpdate = Ue),
          (fe.rectAreaLights.needsUpdate = Ue),
          (fe.hemisphereLights.needsUpdate = Ue)
      }
      function Rs(fe) {
        return (
          fe.isMeshLambertMaterial ||
          fe.isMeshToonMaterial ||
          fe.isMeshPhongMaterial ||
          fe.isMeshStandardMaterial ||
          fe.isShadowMaterial ||
          (fe.isShaderMaterial && fe.lights === !0)
        )
      }
      ;(this.getActiveCubeFace = function () {
        return E
      }),
        (this.getActiveMipmapLevel = function () {
          return P
        }),
        (this.getRenderTarget = function () {
          return A
        }),
        (this.setRenderTargetTextures = function (fe, Ue, Xe) {
          ;(pe.get(fe.texture).__webglTexture = Ue),
            (pe.get(fe.depthTexture).__webglTexture = Xe)
          const De = pe.get(fe)
          ;(De.__hasExternalTextures = !0),
            De.__hasExternalTextures &&
              ((De.__autoAllocateDepthBuffer = Xe === void 0),
              De.__autoAllocateDepthBuffer ||
                (z.has('WEBGL_multisampled_render_to_texture') === !0 &&
                  (console.warn(
                    'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                  ),
                  (De.__useRenderToTexture = !1))))
        }),
        (this.setRenderTargetFramebuffer = function (fe, Ue) {
          const Xe = pe.get(fe)
          ;(Xe.__webglFramebuffer = Ue),
            (Xe.__useDefaultFramebuffer = Ue === void 0)
        }),
        (this.setRenderTarget = function (fe, Ue = 0, Xe = 0) {
          ;(A = fe), (E = Ue), (P = Xe)
          let De = !0,
            rt = null,
            Ot = !1,
            Ke = !1
          if (fe) {
            const Tt = pe.get(fe)
            Tt.__useDefaultFramebuffer !== void 0
              ? (ae.bindFramebuffer(D.FRAMEBUFFER, null), (De = !1))
              : Tt.__webglFramebuffer === void 0
              ? we.setupRenderTarget(fe)
              : Tt.__hasExternalTextures &&
                we.rebindTextures(
                  fe,
                  pe.get(fe.texture).__webglTexture,
                  pe.get(fe.depthTexture).__webglTexture
                )
            const Bt = fe.texture
            ;(Bt.isData3DTexture ||
              Bt.isDataArrayTexture ||
              Bt.isCompressedArrayTexture) &&
              (Ke = !0)
            const Dt = pe.get(fe).__webglFramebuffer
            fe.isWebGLCubeRenderTarget
              ? ((rt = Dt[Ue]), (Ot = !0))
              : ie.isWebGL2 &&
                fe.samples > 0 &&
                we.useMultisampledRTT(fe) === !1
              ? (rt = pe.get(fe).__webglMultisampledFramebuffer)
              : (rt = Dt),
              k.copy(fe.viewport),
              R.copy(fe.scissor),
              (j = fe.scissorTest)
          } else
            k.copy(U).multiplyScalar(L).floor(),
              R.copy(le).multiplyScalar(L).floor(),
              (j = q)
          if (
            (ae.bindFramebuffer(D.FRAMEBUFFER, rt) &&
              ie.drawBuffers &&
              De &&
              ae.drawBuffers(fe, rt),
            ae.viewport(k),
            ae.scissor(R),
            ae.setScissorTest(j),
            Ot)
          ) {
            const Tt = pe.get(fe.texture)
            D.framebufferTexture2D(
              D.FRAMEBUFFER,
              D.COLOR_ATTACHMENT0,
              D.TEXTURE_CUBE_MAP_POSITIVE_X + Ue,
              Tt.__webglTexture,
              Xe
            )
          } else if (Ke) {
            const Tt = pe.get(fe.texture),
              Bt = Ue || 0
            D.framebufferTextureLayer(
              D.FRAMEBUFFER,
              D.COLOR_ATTACHMENT0,
              Tt.__webglTexture,
              Xe || 0,
              Bt
            )
          }
          F = -1
        }),
        (this.readRenderTargetPixels = function (fe, Ue, Xe, De, rt, Ot, Ke) {
          if (!(fe && fe.isWebGLRenderTarget)) {
            console.error(
              'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
            )
            return
          }
          let ct = pe.get(fe).__webglFramebuffer
          if (
            (fe.isWebGLCubeRenderTarget && Ke !== void 0 && (ct = ct[Ke]), ct)
          ) {
            ae.bindFramebuffer(D.FRAMEBUFFER, ct)
            try {
              const Tt = fe.texture,
                Bt = Tt.format,
                Dt = Tt.type
              if (
                Bt !== ko &&
                Ge.convert(Bt) !==
                  D.getParameter(D.IMPLEMENTATION_COLOR_READ_FORMAT)
              ) {
                console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                )
                return
              }
              const jt =
                Dt === Nd &&
                (z.has('EXT_color_buffer_half_float') ||
                  (ie.isWebGL2 && z.has('EXT_color_buffer_float')))
              if (
                Dt !== Es &&
                Ge.convert(Dt) !==
                  D.getParameter(D.IMPLEMENTATION_COLOR_READ_TYPE) &&
                !(
                  Dt === Ss &&
                  (ie.isWebGL2 ||
                    z.has('OES_texture_float') ||
                    z.has('WEBGL_color_buffer_float'))
                ) &&
                !jt
              ) {
                console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                )
                return
              }
              Ue >= 0 &&
                Ue <= fe.width - De &&
                Xe >= 0 &&
                Xe <= fe.height - rt &&
                D.readPixels(Ue, Xe, De, rt, Ge.convert(Bt), Ge.convert(Dt), Ot)
            } finally {
              const Tt = A !== null ? pe.get(A).__webglFramebuffer : null
              ae.bindFramebuffer(D.FRAMEBUFFER, Tt)
            }
          }
        }),
        (this.copyFramebufferToTexture = function (fe, Ue, Xe = 0) {
          const De = Math.pow(2, -Xe),
            rt = Math.floor(Ue.image.width * De),
            Ot = Math.floor(Ue.image.height * De)
          we.setTexture2D(Ue, 0),
            D.copyTexSubImage2D(D.TEXTURE_2D, Xe, 0, 0, fe.x, fe.y, rt, Ot),
            ae.unbindTexture()
        }),
        (this.copyTextureToTexture = function (fe, Ue, Xe, De = 0) {
          const rt = Ue.image.width,
            Ot = Ue.image.height,
            Ke = Ge.convert(Xe.format),
            ct = Ge.convert(Xe.type)
          we.setTexture2D(Xe, 0),
            D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, Xe.flipY),
            D.pixelStorei(
              D.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              Xe.premultiplyAlpha
            ),
            D.pixelStorei(D.UNPACK_ALIGNMENT, Xe.unpackAlignment),
            Ue.isDataTexture
              ? D.texSubImage2D(
                  D.TEXTURE_2D,
                  De,
                  fe.x,
                  fe.y,
                  rt,
                  Ot,
                  Ke,
                  ct,
                  Ue.image.data
                )
              : Ue.isCompressedTexture
              ? D.compressedTexSubImage2D(
                  D.TEXTURE_2D,
                  De,
                  fe.x,
                  fe.y,
                  Ue.mipmaps[0].width,
                  Ue.mipmaps[0].height,
                  Ke,
                  Ue.mipmaps[0].data
                )
              : D.texSubImage2D(D.TEXTURE_2D, De, fe.x, fe.y, Ke, ct, Ue.image),
            De === 0 && Xe.generateMipmaps && D.generateMipmap(D.TEXTURE_2D),
            ae.unbindTexture()
        }),
        (this.copyTextureToTexture3D = function (fe, Ue, Xe, De, rt = 0) {
          if (x.isWebGL1Renderer) {
            console.warn(
              'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
            )
            return
          }
          const Ot = fe.max.x - fe.min.x + 1,
            Ke = fe.max.y - fe.min.y + 1,
            ct = fe.max.z - fe.min.z + 1,
            Tt = Ge.convert(De.format),
            Bt = Ge.convert(De.type)
          let Dt
          if (De.isData3DTexture) we.setTexture3D(De, 0), (Dt = D.TEXTURE_3D)
          else if (De.isDataArrayTexture)
            we.setTexture2DArray(De, 0), (Dt = D.TEXTURE_2D_ARRAY)
          else {
            console.warn(
              'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
            )
            return
          }
          D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, De.flipY),
            D.pixelStorei(
              D.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              De.premultiplyAlpha
            ),
            D.pixelStorei(D.UNPACK_ALIGNMENT, De.unpackAlignment)
          const jt = D.getParameter(D.UNPACK_ROW_LENGTH),
            _n = D.getParameter(D.UNPACK_IMAGE_HEIGHT),
            Dn = D.getParameter(D.UNPACK_SKIP_PIXELS),
            kr = D.getParameter(D.UNPACK_SKIP_ROWS),
            ei = D.getParameter(D.UNPACK_SKIP_IMAGES),
            Fn = Xe.isCompressedTexture ? Xe.mipmaps[0] : Xe.image
          D.pixelStorei(D.UNPACK_ROW_LENGTH, Fn.width),
            D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Fn.height),
            D.pixelStorei(D.UNPACK_SKIP_PIXELS, fe.min.x),
            D.pixelStorei(D.UNPACK_SKIP_ROWS, fe.min.y),
            D.pixelStorei(D.UNPACK_SKIP_IMAGES, fe.min.z),
            Xe.isDataTexture || Xe.isData3DTexture
              ? D.texSubImage3D(
                  Dt,
                  rt,
                  Ue.x,
                  Ue.y,
                  Ue.z,
                  Ot,
                  Ke,
                  ct,
                  Tt,
                  Bt,
                  Fn.data
                )
              : Xe.isCompressedArrayTexture
              ? (console.warn(
                  'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
                ),
                D.compressedTexSubImage3D(
                  Dt,
                  rt,
                  Ue.x,
                  Ue.y,
                  Ue.z,
                  Ot,
                  Ke,
                  ct,
                  Tt,
                  Fn.data
                ))
              : D.texSubImage3D(
                  Dt,
                  rt,
                  Ue.x,
                  Ue.y,
                  Ue.z,
                  Ot,
                  Ke,
                  ct,
                  Tt,
                  Bt,
                  Fn
                ),
            D.pixelStorei(D.UNPACK_ROW_LENGTH, jt),
            D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, _n),
            D.pixelStorei(D.UNPACK_SKIP_PIXELS, Dn),
            D.pixelStorei(D.UNPACK_SKIP_ROWS, kr),
            D.pixelStorei(D.UNPACK_SKIP_IMAGES, ei),
            rt === 0 && De.generateMipmaps && D.generateMipmap(Dt),
            ae.unbindTexture()
        }),
        (this.initTexture = function (fe) {
          fe.isCubeTexture
            ? we.setTextureCube(fe, 0)
            : fe.isData3DTexture
            ? we.setTexture3D(fe, 0)
            : fe.isDataArrayTexture || fe.isCompressedArrayTexture
            ? we.setTexture2DArray(fe, 0)
            : we.setTexture2D(fe, 0),
            ae.unbindTexture()
        }),
        (this.resetState = function () {
          ;(E = 0), (P = 0), (A = null), ae.reset(), Ye.reset()
        }),
        typeof __THREE_DEVTOOLS__ < 'u' &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent('observe', { detail: this })
          )
    }
    get coordinateSystem() {
      return Ia
    }
    get physicallyCorrectLights() {
      return (
        console.warn(
          'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
        ),
        !this.useLegacyLights
      )
    }
    set physicallyCorrectLights(t) {
      console.warn(
        'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
      ),
        (this.useLegacyLights = !t)
    }
    get outputEncoding() {
      return (
        console.warn(
          'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
        ),
        this.outputColorSpace === rn ? Fa : i$
      )
    }
    set outputEncoding(t) {
      console.warn(
        'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
      ),
        (this.outputColorSpace = t === Fa ? rn : aa)
    }
  }
  class qfe extends x$ {}
  qfe.prototype.isWebGL1Renderer = !0
  class Xfe extends Br {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = 'Scene'),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.overrideMaterial = null),
        typeof __THREE_DEVTOOLS__ < 'u' &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent('observe', { detail: this })
          )
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        t.background !== null && (this.background = t.background.clone()),
        t.environment !== null && (this.environment = t.environment.clone()),
        t.fog !== null && (this.fog = t.fog.clone()),
        (this.backgroundBlurriness = t.backgroundBlurriness),
        (this.backgroundIntensity = t.backgroundIntensity),
        t.overrideMaterial !== null &&
          (this.overrideMaterial = t.overrideMaterial.clone()),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this
      )
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        this.fog !== null && (n.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (n.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 &&
          (n.object.backgroundIntensity = this.backgroundIntensity),
        n
      )
    }
    get autoUpdate() {
      return (
        console.warn(
          'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.'
        ),
        this.matrixWorldAutoUpdate
      )
    }
    set autoUpdate(t) {
      console.warn(
        'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.'
      ),
        (this.matrixWorldAutoUpdate = t)
    }
  }
  class Yfe {
    constructor(t, n) {
      ;(this.isInterleavedBuffer = !0),
        (this.array = t),
        (this.stride = n),
        (this.count = t !== void 0 ? t.length / n : 0),
        (this.usage = qb),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = ta())
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      t === !0 && this.version++
    }
    setUsage(t) {
      return (this.usage = t), this
    }
    copy(t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      )
    }
    copyAt(t, n, r) {
      ;(t *= this.stride), (r *= n.stride)
      for (let i = 0, o = this.stride; i < o; i++)
        this.array[t + i] = n.array[r + i]
      return this
    }
    set(t, n = 0) {
      return this.array.set(t, n), this
    }
    clone(t) {
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ta()),
        t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
          (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
      const n = new this.array.constructor(
          t.arrayBuffers[this.array.buffer._uuid]
        ),
        r = new this.constructor(n, this.stride)
      return r.setUsage(this.usage), r
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this
    }
    toJSON(t) {
      return (
        t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ta()),
        t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      )
    }
  }
  const oi = new Pe()
  class Cs {
    constructor(t, n, r, i = !1) {
      ;(this.isInterleavedBufferAttribute = !0),
        (this.name = ''),
        (this.data = t),
        (this.itemSize = n),
        (this.offset = r),
        (this.normalized = i)
    }
    get count() {
      return this.data.count
    }
    get array() {
      return this.data.array
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t
    }
    applyMatrix4(t) {
      for (let n = 0, r = this.data.count; n < r; n++)
        oi.fromBufferAttribute(this, n),
          oi.applyMatrix4(t),
          this.setXYZ(n, oi.x, oi.y, oi.z)
      return this
    }
    applyNormalMatrix(t) {
      for (let n = 0, r = this.count; n < r; n++)
        oi.fromBufferAttribute(this, n),
          oi.applyNormalMatrix(t),
          this.setXYZ(n, oi.x, oi.y, oi.z)
      return this
    }
    transformDirection(t) {
      for (let n = 0, r = this.count; n < r; n++)
        oi.fromBufferAttribute(this, n),
          oi.transformDirection(t),
          this.setXYZ(n, oi.x, oi.y, oi.z)
      return this
    }
    setX(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.data.array[t * this.data.stride + this.offset] = n),
        this
      )
    }
    setY(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 1] = n),
        this
      )
    }
    setZ(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 2] = n),
        this
      )
    }
    setW(t, n) {
      return (
        this.normalized && (n = Ln(n, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 3] = n),
        this
      )
    }
    getX(t) {
      let n = this.data.array[t * this.data.stride + this.offset]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    getY(t) {
      let n = this.data.array[t * this.data.stride + this.offset + 1]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    getZ(t) {
      let n = this.data.array[t * this.data.stride + this.offset + 2]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    getW(t) {
      let n = this.data.array[t * this.data.stride + this.offset + 3]
      return this.normalized && (n = Ra(n, this.array)), n
    }
    setXY(t, n, r) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized && ((n = Ln(n, this.array)), (r = Ln(r, this.array))),
        (this.data.array[t + 0] = n),
        (this.data.array[t + 1] = r),
        this
      )
    }
    setXYZ(t, n, r, i) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((n = Ln(n, this.array)),
          (r = Ln(r, this.array)),
          (i = Ln(i, this.array))),
        (this.data.array[t + 0] = n),
        (this.data.array[t + 1] = r),
        (this.data.array[t + 2] = i),
        this
      )
    }
    setXYZW(t, n, r, i, o) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((n = Ln(n, this.array)),
          (r = Ln(r, this.array)),
          (i = Ln(i, this.array)),
          (o = Ln(o, this.array))),
        (this.data.array[t + 0] = n),
        (this.data.array[t + 1] = r),
        (this.data.array[t + 2] = i),
        (this.data.array[t + 3] = o),
        this
      )
    }
    clone(t) {
      if (t === void 0) {
        console.log(
          'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
        )
        const n = []
        for (let r = 0; r < this.count; r++) {
          const i = r * this.data.stride + this.offset
          for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o])
        }
        return new Io(
          new this.array.constructor(n),
          this.itemSize,
          this.normalized
        )
      } else
        return (
          t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
          t.interleavedBuffers[this.data.uuid] === void 0 &&
            (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
          new Cs(
            t.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        )
    }
    toJSON(t) {
      if (t === void 0) {
        console.log(
          'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
        )
        const n = []
        for (let r = 0; r < this.count; r++) {
          const i = r * this.data.stride + this.offset
          for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o])
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: n,
          normalized: this.normalized,
        }
      } else
        return (
          t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
          t.interleavedBuffers[this.data.uuid] === void 0 &&
            (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        )
    }
  }
  class ua {
    constructor() {
      ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
    }
    getPoint() {
      return console.warn('THREE.Curve: .getPoint() not implemented.'), null
    }
    getPointAt(t, n) {
      const r = this.getUtoTmapping(t)
      return this.getPoint(r, n)
    }
    getPoints(t = 5) {
      const n = []
      for (let r = 0; r <= t; r++) n.push(this.getPoint(r / t))
      return n
    }
    getSpacedPoints(t = 5) {
      const n = []
      for (let r = 0; r <= t; r++) n.push(this.getPointAt(r / t))
      return n
    }
    getLength() {
      const t = this.getLengths()
      return t[t.length - 1]
    }
    getLengths(t = this.arcLengthDivisions) {
      if (
        this.cacheArcLengths &&
        this.cacheArcLengths.length === t + 1 &&
        !this.needsUpdate
      )
        return this.cacheArcLengths
      this.needsUpdate = !1
      const n = []
      let r,
        i = this.getPoint(0),
        o = 0
      n.push(0)
      for (let a = 1; a <= t; a++)
        (r = this.getPoint(a / t)), (o += r.distanceTo(i)), n.push(o), (i = r)
      return (this.cacheArcLengths = n), n
    }
    updateArcLengths() {
      ;(this.needsUpdate = !0), this.getLengths()
    }
    getUtoTmapping(t, n) {
      const r = this.getLengths()
      let i = 0
      const o = r.length
      let a
      n ? (a = n) : (a = t * r[o - 1])
      let s = 0,
        l = o - 1,
        c
      for (; s <= l; )
        if (((i = Math.floor(s + (l - s) / 2)), (c = r[i] - a), c < 0))
          s = i + 1
        else if (c > 0) l = i - 1
        else {
          l = i
          break
        }
      if (((i = l), r[i] === a)) return i / (o - 1)
      const d = r[i],
        p = r[i + 1] - d,
        v = (a - d) / p
      return (i + v) / (o - 1)
    }
    getTangent(t, n) {
      let i = t - 1e-4,
        o = t + 1e-4
      i < 0 && (i = 0), o > 1 && (o = 1)
      const a = this.getPoint(i),
        s = this.getPoint(o),
        l = n || (a.isVector2 ? new Ct() : new Pe())
      return l.copy(s).sub(a).normalize(), l
    }
    getTangentAt(t, n) {
      const r = this.getUtoTmapping(t)
      return this.getTangent(r, n)
    }
    computeFrenetFrames(t, n) {
      const r = new Pe(),
        i = [],
        o = [],
        a = [],
        s = new Pe(),
        l = new qn()
      for (let v = 0; v <= t; v++) {
        const g = v / t
        i[v] = this.getTangentAt(g, new Pe())
      }
      ;(o[0] = new Pe()), (a[0] = new Pe())
      let c = Number.MAX_VALUE
      const d = Math.abs(i[0].x),
        h = Math.abs(i[0].y),
        p = Math.abs(i[0].z)
      d <= c && ((c = d), r.set(1, 0, 0)),
        h <= c && ((c = h), r.set(0, 1, 0)),
        p <= c && r.set(0, 0, 1),
        s.crossVectors(i[0], r).normalize(),
        o[0].crossVectors(i[0], s),
        a[0].crossVectors(i[0], o[0])
      for (let v = 1; v <= t; v++) {
        if (
          ((o[v] = o[v - 1].clone()),
          (a[v] = a[v - 1].clone()),
          s.crossVectors(i[v - 1], i[v]),
          s.length() > Number.EPSILON)
        ) {
          s.normalize()
          const g = Math.acos(hr(i[v - 1].dot(i[v]), -1, 1))
          o[v].applyMatrix4(l.makeRotationAxis(s, g))
        }
        a[v].crossVectors(i[v], o[v])
      }
      if (n === !0) {
        let v = Math.acos(hr(o[0].dot(o[t]), -1, 1))
        ;(v /= t), i[0].dot(s.crossVectors(o[0], o[t])) > 0 && (v = -v)
        for (let g = 1; g <= t; g++)
          o[g].applyMatrix4(l.makeRotationAxis(i[g], v * g)),
            a[g].crossVectors(i[g], o[g])
      }
      return { tangents: i, normals: o, binormals: a }
    }
    clone() {
      return new this.constructor().copy(this)
    }
    copy(t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this
    }
    toJSON() {
      const t = {
        metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' },
      }
      return (
        (t.arcLengthDivisions = this.arcLengthDivisions),
        (t.type = this.type),
        t
      )
    }
    fromJSON(t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this
    }
  }
  class RS extends ua {
    constructor(
      t = 0,
      n = 0,
      r = 1,
      i = 1,
      o = 0,
      a = Math.PI * 2,
      s = !1,
      l = 0
    ) {
      super(),
        (this.isEllipseCurve = !0),
        (this.type = 'EllipseCurve'),
        (this.aX = t),
        (this.aY = n),
        (this.xRadius = r),
        (this.yRadius = i),
        (this.aStartAngle = o),
        (this.aEndAngle = a),
        (this.aClockwise = s),
        (this.aRotation = l)
    }
    getPoint(t, n) {
      const r = n || new Ct(),
        i = Math.PI * 2
      let o = this.aEndAngle - this.aStartAngle
      const a = Math.abs(o) < Number.EPSILON
      for (; o < 0; ) o += i
      for (; o > i; ) o -= i
      o < Number.EPSILON && (a ? (o = 0) : (o = i)),
        this.aClockwise === !0 && !a && (o === i ? (o = -i) : (o = o - i))
      const s = this.aStartAngle + t * o
      let l = this.aX + this.xRadius * Math.cos(s),
        c = this.aY + this.yRadius * Math.sin(s)
      if (this.aRotation !== 0) {
        const d = Math.cos(this.aRotation),
          h = Math.sin(this.aRotation),
          p = l - this.aX,
          v = c - this.aY
        ;(l = p * d - v * h + this.aX), (c = p * h + v * d + this.aY)
      }
      return r.set(l, c)
    }
    copy(t) {
      return (
        super.copy(t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.aX = this.aX),
        (t.aY = this.aY),
        (t.xRadius = this.xRadius),
        (t.yRadius = this.yRadius),
        (t.aStartAngle = this.aStartAngle),
        (t.aEndAngle = this.aEndAngle),
        (t.aClockwise = this.aClockwise),
        (t.aRotation = this.aRotation),
        t
      )
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      )
    }
  }
  class Zfe extends RS {
    constructor(t, n, r, i, o, a) {
      super(t, n, r, r, i, o, a),
        (this.isArcCurve = !0),
        (this.type = 'ArcCurve')
    }
  }
  function DS() {
    let e = 0,
      t = 0,
      n = 0,
      r = 0
    function i(o, a, s, l) {
      ;(e = o),
        (t = s),
        (n = -3 * o + 3 * a - 2 * s - l),
        (r = 2 * o - 2 * a + s + l)
    }
    return {
      initCatmullRom: function (o, a, s, l, c) {
        i(a, s, c * (s - o), c * (l - a))
      },
      initNonuniformCatmullRom: function (o, a, s, l, c, d, h) {
        let p = (a - o) / c - (s - o) / (c + d) + (s - a) / d,
          v = (s - a) / d - (l - a) / (d + h) + (l - s) / h
        ;(p *= d), (v *= d), i(a, s, p, v)
      },
      calc: function (o) {
        const a = o * o,
          s = a * o
        return e + t * o + n * a + r * s
      },
    }
  }
  const Nh = new Pe(),
    G1 = new DS(),
    K1 = new DS(),
    q1 = new DS()
  class Jfe extends ua {
    constructor(t = [], n = !1, r = 'centripetal', i = 0.5) {
      super(),
        (this.isCatmullRomCurve3 = !0),
        (this.type = 'CatmullRomCurve3'),
        (this.points = t),
        (this.closed = n),
        (this.curveType = r),
        (this.tension = i)
    }
    getPoint(t, n = new Pe()) {
      const r = n,
        i = this.points,
        o = i.length,
        a = (o - (this.closed ? 0 : 1)) * t
      let s = Math.floor(a),
        l = a - s
      this.closed
        ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / o) + 1) * o)
        : l === 0 && s === o - 1 && ((s = o - 2), (l = 1))
      let c, d
      this.closed || s > 0
        ? (c = i[(s - 1) % o])
        : (Nh.subVectors(i[0], i[1]).add(i[0]), (c = Nh))
      const h = i[s % o],
        p = i[(s + 1) % o]
      if (
        (this.closed || s + 2 < o
          ? (d = i[(s + 2) % o])
          : (Nh.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (d = Nh)),
        this.curveType === 'centripetal' || this.curveType === 'chordal')
      ) {
        const v = this.curveType === 'chordal' ? 0.5 : 0.25
        let g = Math.pow(c.distanceToSquared(h), v),
          _ = Math.pow(h.distanceToSquared(p), v),
          b = Math.pow(p.distanceToSquared(d), v)
        _ < 1e-4 && (_ = 1),
          g < 1e-4 && (g = _),
          b < 1e-4 && (b = _),
          G1.initNonuniformCatmullRom(c.x, h.x, p.x, d.x, g, _, b),
          K1.initNonuniformCatmullRom(c.y, h.y, p.y, d.y, g, _, b),
          q1.initNonuniformCatmullRom(c.z, h.z, p.z, d.z, g, _, b)
      } else
        this.curveType === 'catmullrom' &&
          (G1.initCatmullRom(c.x, h.x, p.x, d.x, this.tension),
          K1.initCatmullRom(c.y, h.y, p.y, d.y, this.tension),
          q1.initCatmullRom(c.z, h.z, p.z, d.z, this.tension))
      return r.set(G1.calc(l), K1.calc(l), q1.calc(l)), r
    }
    copy(t) {
      super.copy(t), (this.points = [])
      for (let n = 0, r = t.points.length; n < r; n++) {
        const i = t.points[n]
        this.points.push(i.clone())
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      t.points = []
      for (let n = 0, r = this.points.length; n < r; n++) {
        const i = this.points[n]
        t.points.push(i.toArray())
      }
      return (
        (t.closed = this.closed),
        (t.curveType = this.curveType),
        (t.tension = this.tension),
        t
      )
    }
    fromJSON(t) {
      super.fromJSON(t), (this.points = [])
      for (let n = 0, r = t.points.length; n < r; n++) {
        const i = t.points[n]
        this.points.push(new Pe().fromArray(i))
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      )
    }
  }
  function DP(e, t, n, r, i) {
    const o = (r - t) * 0.5,
      a = (i - n) * 0.5,
      s = e * e,
      l = e * s
    return (
      (2 * n - 2 * r + o + a) * l + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
    )
  }
  function Qfe(e, t) {
    const n = 1 - e
    return n * n * t
  }
  function ehe(e, t) {
    return 2 * (1 - e) * e * t
  }
  function the(e, t) {
    return e * e * t
  }
  function Cd(e, t, n, r) {
    return Qfe(e, t) + ehe(e, n) + the(e, r)
  }
  function nhe(e, t) {
    const n = 1 - e
    return n * n * n * t
  }
  function rhe(e, t) {
    const n = 1 - e
    return 3 * n * n * e * t
  }
  function ihe(e, t) {
    return 3 * (1 - e) * e * e * t
  }
  function ohe(e, t) {
    return e * e * e * t
  }
  function wd(e, t, n, r, i) {
    return nhe(e, t) + rhe(e, n) + ihe(e, r) + ohe(e, i)
  }
  class M$ extends ua {
    constructor(t = new Ct(), n = new Ct(), r = new Ct(), i = new Ct()) {
      super(),
        (this.isCubicBezierCurve = !0),
        (this.type = 'CubicBezierCurve'),
        (this.v0 = t),
        (this.v1 = n),
        (this.v2 = r),
        (this.v3 = i)
    }
    getPoint(t, n = new Ct()) {
      const r = n,
        i = this.v0,
        o = this.v1,
        a = this.v2,
        s = this.v3
      return r.set(wd(t, i.x, o.x, a.x, s.x), wd(t, i.y, o.y, a.y, s.y)), r
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      )
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      )
    }
  }
  class ahe extends ua {
    constructor(t = new Pe(), n = new Pe(), r = new Pe(), i = new Pe()) {
      super(),
        (this.isCubicBezierCurve3 = !0),
        (this.type = 'CubicBezierCurve3'),
        (this.v0 = t),
        (this.v1 = n),
        (this.v2 = r),
        (this.v3 = i)
    }
    getPoint(t, n = new Pe()) {
      const r = n,
        i = this.v0,
        o = this.v1,
        a = this.v2,
        s = this.v3
      return (
        r.set(
          wd(t, i.x, o.x, a.x, s.x),
          wd(t, i.y, o.y, a.y, s.y),
          wd(t, i.z, o.z, a.z, s.z)
        ),
        r
      )
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      )
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      )
    }
  }
  class NS extends ua {
    constructor(t = new Ct(), n = new Ct()) {
      super(),
        (this.isLineCurve = !0),
        (this.type = 'LineCurve'),
        (this.v1 = t),
        (this.v2 = n)
    }
    getPoint(t, n = new Ct()) {
      const r = n
      return (
        t === 1
          ? r.copy(this.v2)
          : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)),
        r
      )
    }
    getPointAt(t, n) {
      return this.getPoint(t, n)
    }
    getTangent(t, n = new Ct()) {
      return n.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(t, n) {
      return this.getTangent(t, n)
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
      const t = super.toJSON()
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      )
    }
  }
  class she extends ua {
    constructor(t = new Pe(), n = new Pe()) {
      super(),
        (this.isLineCurve3 = !0),
        (this.type = 'LineCurve3'),
        (this.v1 = t),
        (this.v2 = n)
    }
    getPoint(t, n = new Pe()) {
      const r = n
      return (
        t === 1
          ? r.copy(this.v2)
          : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)),
        r
      )
    }
    getPointAt(t, n) {
      return this.getPoint(t, n)
    }
    getTangent(t, n = new Pe()) {
      return n.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(t, n) {
      return this.getTangent(t, n)
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
      const t = super.toJSON()
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      )
    }
  }
  class E$ extends ua {
    constructor(t = new Ct(), n = new Ct(), r = new Ct()) {
      super(),
        (this.isQuadraticBezierCurve = !0),
        (this.type = 'QuadraticBezierCurve'),
        (this.v0 = t),
        (this.v1 = n),
        (this.v2 = r)
    }
    getPoint(t, n = new Ct()) {
      const r = n,
        i = this.v0,
        o = this.v1,
        a = this.v2
      return r.set(Cd(t, i.x, o.x, a.x), Cd(t, i.y, o.y, a.y)), r
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      )
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      )
    }
  }
  class lhe extends ua {
    constructor(t = new Pe(), n = new Pe(), r = new Pe()) {
      super(),
        (this.isQuadraticBezierCurve3 = !0),
        (this.type = 'QuadraticBezierCurve3'),
        (this.v0 = t),
        (this.v1 = n),
        (this.v2 = r)
    }
    getPoint(t, n = new Pe()) {
      const r = n,
        i = this.v0,
        o = this.v1,
        a = this.v2
      return (
        r.set(Cd(t, i.x, o.x, a.x), Cd(t, i.y, o.y, a.y), Cd(t, i.z, o.z, a.z)),
        r
      )
    }
    copy(t) {
      return (
        super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      )
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      )
    }
    fromJSON(t) {
      return (
        super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      )
    }
  }
  class P$ extends ua {
    constructor(t = []) {
      super(),
        (this.isSplineCurve = !0),
        (this.type = 'SplineCurve'),
        (this.points = t)
    }
    getPoint(t, n = new Ct()) {
      const r = n,
        i = this.points,
        o = (i.length - 1) * t,
        a = Math.floor(o),
        s = o - a,
        l = i[a === 0 ? a : a - 1],
        c = i[a],
        d = i[a > i.length - 2 ? i.length - 1 : a + 1],
        h = i[a > i.length - 3 ? i.length - 1 : a + 2]
      return r.set(DP(s, l.x, c.x, d.x, h.x), DP(s, l.y, c.y, d.y, h.y)), r
    }
    copy(t) {
      super.copy(t), (this.points = [])
      for (let n = 0, r = t.points.length; n < r; n++) {
        const i = t.points[n]
        this.points.push(i.clone())
      }
      return this
    }
    toJSON() {
      const t = super.toJSON()
      t.points = []
      for (let n = 0, r = this.points.length; n < r; n++) {
        const i = this.points[n]
        t.points.push(i.toArray())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t), (this.points = [])
      for (let n = 0, r = t.points.length; n < r; n++) {
        const i = t.points[n]
        this.points.push(new Ct().fromArray(i))
      }
      return this
    }
  }
  var T$ = Object.freeze({
    __proto__: null,
    ArcCurve: Zfe,
    CatmullRomCurve3: Jfe,
    CubicBezierCurve: M$,
    CubicBezierCurve3: ahe,
    EllipseCurve: RS,
    LineCurve: NS,
    LineCurve3: she,
    QuadraticBezierCurve: E$,
    QuadraticBezierCurve3: lhe,
    SplineCurve: P$,
  })
  class uhe extends ua {
    constructor() {
      super(),
        (this.type = 'CurvePath'),
        (this.curves = []),
        (this.autoClose = !1)
    }
    add(t) {
      this.curves.push(t)
    }
    closePath() {
      const t = this.curves[0].getPoint(0),
        n = this.curves[this.curves.length - 1].getPoint(1)
      t.equals(n) || this.curves.push(new NS(n, t))
    }
    getPoint(t, n) {
      const r = t * this.getLength(),
        i = this.getCurveLengths()
      let o = 0
      for (; o < i.length; ) {
        if (i[o] >= r) {
          const a = i[o] - r,
            s = this.curves[o],
            l = s.getLength(),
            c = l === 0 ? 0 : 1 - a / l
          return s.getPointAt(c, n)
        }
        o++
      }
      return null
    }
    getLength() {
      const t = this.getCurveLengths()
      return t[t.length - 1]
    }
    updateArcLengths() {
      ;(this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths()
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths
      const t = []
      let n = 0
      for (let r = 0, i = this.curves.length; r < i; r++)
        (n += this.curves[r].getLength()), t.push(n)
      return (this.cacheLengths = t), t
    }
    getSpacedPoints(t = 40) {
      const n = []
      for (let r = 0; r <= t; r++) n.push(this.getPoint(r / t))
      return this.autoClose && n.push(n[0]), n
    }
    getPoints(t = 12) {
      const n = []
      let r
      for (let i = 0, o = this.curves; i < o.length; i++) {
        const a = o[i],
          s = a.isEllipseCurve
            ? t * 2
            : a.isLineCurve || a.isLineCurve3
            ? 1
            : a.isSplineCurve
            ? t * a.points.length
            : t,
          l = a.getPoints(s)
        for (let c = 0; c < l.length; c++) {
          const d = l[c]
          ;(r && r.equals(d)) || (n.push(d), (r = d))
        }
      }
      return (
        this.autoClose &&
          n.length > 1 &&
          !n[n.length - 1].equals(n[0]) &&
          n.push(n[0]),
        n
      )
    }
    copy(t) {
      super.copy(t), (this.curves = [])
      for (let n = 0, r = t.curves.length; n < r; n++) {
        const i = t.curves[n]
        this.curves.push(i.clone())
      }
      return (this.autoClose = t.autoClose), this
    }
    toJSON() {
      const t = super.toJSON()
      ;(t.autoClose = this.autoClose), (t.curves = [])
      for (let n = 0, r = this.curves.length; n < r; n++) {
        const i = this.curves[n]
        t.curves.push(i.toJSON())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
      for (let n = 0, r = t.curves.length; n < r; n++) {
        const i = t.curves[n]
        this.curves.push(new T$[i.type]().fromJSON(i))
      }
      return this
    }
  }
  class NP extends uhe {
    constructor(t) {
      super(),
        (this.type = 'Path'),
        (this.currentPoint = new Ct()),
        t && this.setFromPoints(t)
    }
    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y)
      for (let n = 1, r = t.length; n < r; n++) this.lineTo(t[n].x, t[n].y)
      return this
    }
    moveTo(t, n) {
      return this.currentPoint.set(t, n), this
    }
    lineTo(t, n) {
      const r = new NS(this.currentPoint.clone(), new Ct(t, n))
      return this.curves.push(r), this.currentPoint.set(t, n), this
    }
    quadraticCurveTo(t, n, r, i) {
      const o = new E$(this.currentPoint.clone(), new Ct(t, n), new Ct(r, i))
      return this.curves.push(o), this.currentPoint.set(r, i), this
    }
    bezierCurveTo(t, n, r, i, o, a) {
      const s = new M$(
        this.currentPoint.clone(),
        new Ct(t, n),
        new Ct(r, i),
        new Ct(o, a)
      )
      return this.curves.push(s), this.currentPoint.set(o, a), this
    }
    splineThru(t) {
      const n = [this.currentPoint.clone()].concat(t),
        r = new P$(n)
      return this.curves.push(r), this.currentPoint.copy(t[t.length - 1]), this
    }
    arc(t, n, r, i, o, a) {
      const s = this.currentPoint.x,
        l = this.currentPoint.y
      return this.absarc(t + s, n + l, r, i, o, a), this
    }
    absarc(t, n, r, i, o, a) {
      return this.absellipse(t, n, r, r, i, o, a), this
    }
    ellipse(t, n, r, i, o, a, s, l) {
      const c = this.currentPoint.x,
        d = this.currentPoint.y
      return this.absellipse(t + c, n + d, r, i, o, a, s, l), this
    }
    absellipse(t, n, r, i, o, a, s, l) {
      const c = new RS(t, n, r, i, o, a, s, l)
      if (this.curves.length > 0) {
        const h = c.getPoint(0)
        h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
      }
      this.curves.push(c)
      const d = c.getPoint(1)
      return this.currentPoint.copy(d), this
    }
    copy(t) {
      return super.copy(t), this.currentPoint.copy(t.currentPoint), this
    }
    toJSON() {
      const t = super.toJSON()
      return (t.currentPoint = this.currentPoint.toArray()), t
    }
    fromJSON(t) {
      return (
        super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
      )
    }
  }
  class k$ extends NP {
    constructor(t) {
      super(t), (this.uuid = ta()), (this.type = 'Shape'), (this.holes = [])
    }
    getPointsHoles(t) {
      const n = []
      for (let r = 0, i = this.holes.length; r < i; r++)
        n[r] = this.holes[r].getPoints(t)
      return n
    }
    extractPoints(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
    }
    copy(t) {
      super.copy(t), (this.holes = [])
      for (let n = 0, r = t.holes.length; n < r; n++) {
        const i = t.holes[n]
        this.holes.push(i.clone())
      }
      return this
    }
    toJSON() {
      const t = super.toJSON()
      ;(t.uuid = this.uuid), (t.holes = [])
      for (let n = 0, r = this.holes.length; n < r; n++) {
        const i = this.holes[n]
        t.holes.push(i.toJSON())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
      for (let n = 0, r = t.holes.length; n < r; n++) {
        const i = t.holes[n]
        this.holes.push(new NP().fromJSON(i))
      }
      return this
    }
  }
  const che = {
    triangulate: function (e, t, n = 2) {
      const r = t && t.length,
        i = r ? t[0] * n : e.length
      let o = A$(e, 0, i, n, !0)
      const a = []
      if (!o || o.next === o.prev) return a
      let s, l, c, d, h, p, v
      if ((r && (o = vhe(e, t, o, n)), e.length > 80 * n)) {
        ;(s = c = e[0]), (l = d = e[1])
        for (let g = n; g < i; g += n)
          (h = e[g]),
            (p = e[g + 1]),
            h < s && (s = h),
            p < l && (l = p),
            h > c && (c = h),
            p > d && (d = p)
        ;(v = Math.max(c - s, d - l)), (v = v !== 0 ? 32767 / v : 0)
      }
      return zd(o, a, n, s, l, v, 0), a
    },
  }
  function A$(e, t, n, r, i) {
    let o, a
    if (i === Ehe(e, t, n, r) > 0)
      for (o = t; o < n; o += r) a = BP(o, e[o], e[o + 1], a)
    else for (o = n - r; o >= t; o -= r) a = BP(o, e[o], e[o + 1], a)
    return a && pm(a, a.next) && (Ud(a), (a = a.next)), a
  }
  function Tl(e, t) {
    if (!e) return e
    t || (t = e)
    let n = e,
      r
    do
      if (
        ((r = !1), !n.steiner && (pm(n, n.next) || Kn(n.prev, n, n.next) === 0))
      ) {
        if ((Ud(n), (n = t = n.prev), n === n.next)) break
        r = !0
      } else n = n.next
    while (r || n !== t)
    return t
  }
  function zd(e, t, n, r, i, o, a) {
    if (!e) return
    !a && o && _he(e, r, i, o)
    let s = e,
      l,
      c
    for (; e.prev !== e.next; ) {
      if (((l = e.prev), (c = e.next), o ? fhe(e, r, i, o) : dhe(e))) {
        t.push((l.i / n) | 0),
          t.push((e.i / n) | 0),
          t.push((c.i / n) | 0),
          Ud(e),
          (e = c.next),
          (s = c.next)
        continue
      }
      if (((e = c), e === s)) {
        a
          ? a === 1
            ? ((e = hhe(Tl(e), t, n)), zd(e, t, n, r, i, o, 2))
            : a === 2 && phe(e, t, n, r, i, o)
          : zd(Tl(e), t, n, r, i, o, 1)
        break
      }
    }
  }
  function dhe(e) {
    const t = e.prev,
      n = e,
      r = e.next
    if (Kn(t, n, r) >= 0) return !1
    const i = t.x,
      o = n.x,
      a = r.x,
      s = t.y,
      l = n.y,
      c = r.y,
      d = i < o ? (i < a ? i : a) : o < a ? o : a,
      h = s < l ? (s < c ? s : c) : l < c ? l : c,
      p = i > o ? (i > a ? i : a) : o > a ? o : a,
      v = s > l ? (s > c ? s : c) : l > c ? l : c
    let g = r.next
    for (; g !== t; ) {
      if (
        g.x >= d &&
        g.x <= p &&
        g.y >= h &&
        g.y <= v &&
        Tu(i, s, o, l, a, c, g.x, g.y) &&
        Kn(g.prev, g, g.next) >= 0
      )
        return !1
      g = g.next
    }
    return !0
  }
  function fhe(e, t, n, r) {
    const i = e.prev,
      o = e,
      a = e.next
    if (Kn(i, o, a) >= 0) return !1
    const s = i.x,
      l = o.x,
      c = a.x,
      d = i.y,
      h = o.y,
      p = a.y,
      v = s < l ? (s < c ? s : c) : l < c ? l : c,
      g = d < h ? (d < p ? d : p) : h < p ? h : p,
      _ = s > l ? (s > c ? s : c) : l > c ? l : c,
      b = d > h ? (d > p ? d : p) : h > p ? h : p,
      y = Jb(v, g, t, n, r),
      M = Jb(_, b, t, n, r)
    let x = e.prevZ,
      w = e.nextZ
    for (; x && x.z >= y && w && w.z <= M; ) {
      if (
        (x.x >= v &&
          x.x <= _ &&
          x.y >= g &&
          x.y <= b &&
          x !== i &&
          x !== a &&
          Tu(s, d, l, h, c, p, x.x, x.y) &&
          Kn(x.prev, x, x.next) >= 0) ||
        ((x = x.prevZ),
        w.x >= v &&
          w.x <= _ &&
          w.y >= g &&
          w.y <= b &&
          w !== i &&
          w !== a &&
          Tu(s, d, l, h, c, p, w.x, w.y) &&
          Kn(w.prev, w, w.next) >= 0)
      )
        return !1
      w = w.nextZ
    }
    for (; x && x.z >= y; ) {
      if (
        x.x >= v &&
        x.x <= _ &&
        x.y >= g &&
        x.y <= b &&
        x !== i &&
        x !== a &&
        Tu(s, d, l, h, c, p, x.x, x.y) &&
        Kn(x.prev, x, x.next) >= 0
      )
        return !1
      x = x.prevZ
    }
    for (; w && w.z <= M; ) {
      if (
        w.x >= v &&
        w.x <= _ &&
        w.y >= g &&
        w.y <= b &&
        w !== i &&
        w !== a &&
        Tu(s, d, l, h, c, p, w.x, w.y) &&
        Kn(w.prev, w, w.next) >= 0
      )
        return !1
      w = w.nextZ
    }
    return !0
  }
  function hhe(e, t, n) {
    let r = e
    do {
      const i = r.prev,
        o = r.next.next
      !pm(i, o) &&
        $$(i, r, r.next, o) &&
        Vd(i, o) &&
        Vd(o, i) &&
        (t.push((i.i / n) | 0),
        t.push((r.i / n) | 0),
        t.push((o.i / n) | 0),
        Ud(r),
        Ud(r.next),
        (r = e = o)),
        (r = r.next)
    } while (r !== e)
    return Tl(r)
  }
  function phe(e, t, n, r, i, o) {
    let a = e
    do {
      let s = a.next.next
      for (; s !== a.prev; ) {
        if (a.i !== s.i && whe(a, s)) {
          let l = O$(a, s)
          ;(a = Tl(a, a.next)),
            (l = Tl(l, l.next)),
            zd(a, t, n, r, i, o, 0),
            zd(l, t, n, r, i, o, 0)
          return
        }
        s = s.next
      }
      a = a.next
    } while (a !== e)
  }
  function vhe(e, t, n, r) {
    const i = []
    let o, a, s, l, c
    for (o = 0, a = t.length; o < a; o++)
      (s = t[o] * r),
        (l = o < a - 1 ? t[o + 1] * r : e.length),
        (c = A$(e, s, l, r, !1)),
        c === c.next && (c.steiner = !0),
        i.push(Che(c))
    for (i.sort(mhe), o = 0; o < i.length; o++) n = ghe(i[o], n)
    return n
  }
  function mhe(e, t) {
    return e.x - t.x
  }
  function ghe(e, t) {
    const n = yhe(e, t)
    if (!n) return t
    const r = O$(n, e)
    return Tl(r, r.next), Tl(n, n.next)
  }
  function yhe(e, t) {
    let n = t,
      r = -1 / 0,
      i
    const o = e.x,
      a = e.y
    do {
      if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
        const p = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y)
        if (
          p <= o &&
          p > r &&
          ((r = p), (i = n.x < n.next.x ? n : n.next), p === o)
        )
          return i
      }
      n = n.next
    } while (n !== t)
    if (!i) return null
    const s = i,
      l = i.x,
      c = i.y
    let d = 1 / 0,
      h
    n = i
    do
      o >= n.x &&
        n.x >= l &&
        o !== n.x &&
        Tu(a < c ? o : r, a, l, c, a < c ? r : o, a, n.x, n.y) &&
        ((h = Math.abs(a - n.y) / (o - n.x)),
        Vd(n, e) &&
          (h < d || (h === d && (n.x > i.x || (n.x === i.x && bhe(i, n))))) &&
          ((i = n), (d = h))),
        (n = n.next)
    while (n !== s)
    return i
  }
  function bhe(e, t) {
    return Kn(e.prev, e, t.prev) < 0 && Kn(t.next, e, e.next) < 0
  }
  function _he(e, t, n, r) {
    let i = e
    do
      i.z === 0 && (i.z = Jb(i.x, i.y, t, n, r)),
        (i.prevZ = i.prev),
        (i.nextZ = i.next),
        (i = i.next)
    while (i !== e)
    ;(i.prevZ.nextZ = null), (i.prevZ = null), She(i)
  }
  function She(e) {
    let t,
      n,
      r,
      i,
      o,
      a,
      s,
      l,
      c = 1
    do {
      for (n = e, e = null, o = null, a = 0; n; ) {
        for (a++, r = n, s = 0, t = 0; t < c && (s++, (r = r.nextZ), !!r); t++);
        for (l = c; s > 0 || (l > 0 && r); )
          s !== 0 && (l === 0 || !r || n.z <= r.z)
            ? ((i = n), (n = n.nextZ), s--)
            : ((i = r), (r = r.nextZ), l--),
            o ? (o.nextZ = i) : (e = i),
            (i.prevZ = o),
            (o = i)
        n = r
      }
      ;(o.nextZ = null), (c *= 2)
    } while (a > 1)
    return e
  }
  function Jb(e, t, n, r, i) {
    return (
      (e = ((e - n) * i) | 0),
      (t = ((t - r) * i) | 0),
      (e = (e | (e << 8)) & 16711935),
      (e = (e | (e << 4)) & 252645135),
      (e = (e | (e << 2)) & 858993459),
      (e = (e | (e << 1)) & 1431655765),
      (t = (t | (t << 8)) & 16711935),
      (t = (t | (t << 4)) & 252645135),
      (t = (t | (t << 2)) & 858993459),
      (t = (t | (t << 1)) & 1431655765),
      e | (t << 1)
    )
  }
  function Che(e) {
    let t = e,
      n = e
    do (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next)
    while (t !== e)
    return n
  }
  function Tu(e, t, n, r, i, o, a, s) {
    return (
      (i - a) * (t - s) >= (e - a) * (o - s) &&
      (e - a) * (r - s) >= (n - a) * (t - s) &&
      (n - a) * (o - s) >= (i - a) * (r - s)
    )
  }
  function whe(e, t) {
    return (
      e.next.i !== t.i &&
      e.prev.i !== t.i &&
      !xhe(e, t) &&
      ((Vd(e, t) &&
        Vd(t, e) &&
        Mhe(e, t) &&
        (Kn(e.prev, e, t.prev) || Kn(e, t.prev, t))) ||
        (pm(e, t) && Kn(e.prev, e, e.next) > 0 && Kn(t.prev, t, t.next) > 0))
    )
  }
  function Kn(e, t, n) {
    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
  }
  function pm(e, t) {
    return e.x === t.x && e.y === t.y
  }
  function $$(e, t, n, r) {
    const i = Fh(Kn(e, t, n)),
      o = Fh(Kn(e, t, r)),
      a = Fh(Kn(n, r, e)),
      s = Fh(Kn(n, r, t))
    return !!(
      (i !== o && a !== s) ||
      (i === 0 && Bh(e, n, t)) ||
      (o === 0 && Bh(e, r, t)) ||
      (a === 0 && Bh(n, e, r)) ||
      (s === 0 && Bh(n, t, r))
    )
  }
  function Bh(e, t, n) {
    return (
      t.x <= Math.max(e.x, n.x) &&
      t.x >= Math.min(e.x, n.x) &&
      t.y <= Math.max(e.y, n.y) &&
      t.y >= Math.min(e.y, n.y)
    )
  }
  function Fh(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
  }
  function xhe(e, t) {
    let n = e
    do {
      if (
        n.i !== e.i &&
        n.next.i !== e.i &&
        n.i !== t.i &&
        n.next.i !== t.i &&
        $$(n, n.next, e, t)
      )
        return !0
      n = n.next
    } while (n !== e)
    return !1
  }
  function Vd(e, t) {
    return Kn(e.prev, e, e.next) < 0
      ? Kn(e, t, e.next) >= 0 && Kn(e, e.prev, t) >= 0
      : Kn(e, t, e.prev) < 0 || Kn(e, e.next, t) < 0
  }
  function Mhe(e, t) {
    let n = e,
      r = !1
    const i = (e.x + t.x) / 2,
      o = (e.y + t.y) / 2
    do
      n.y > o != n.next.y > o &&
        n.next.y !== n.y &&
        i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
        (r = !r),
        (n = n.next)
    while (n !== e)
    return r
  }
  function O$(e, t) {
    const n = new Qb(e.i, e.x, e.y),
      r = new Qb(t.i, t.x, t.y),
      i = e.next,
      o = t.prev
    return (
      (e.next = t),
      (t.prev = e),
      (n.next = i),
      (i.prev = n),
      (r.next = n),
      (n.prev = r),
      (o.next = r),
      (r.prev = o),
      r
    )
  }
  function BP(e, t, n, r) {
    const i = new Qb(e, t, n)
    return (
      r
        ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
        : ((i.prev = i), (i.next = i)),
      i
    )
  }
  function Ud(e) {
    ;(e.next.prev = e.prev),
      (e.prev.next = e.next),
      e.prevZ && (e.prevZ.nextZ = e.nextZ),
      e.nextZ && (e.nextZ.prevZ = e.prevZ)
  }
  function Qb(e, t, n) {
    ;(this.i = e),
      (this.x = t),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1)
  }
  function Ehe(e, t, n, r) {
    let i = 0
    for (let o = t, a = n - r; o < n; o += r)
      (i += (e[a] - e[o]) * (e[o + 1] + e[a + 1])), (a = o)
    return i
  }
  class xd {
    static area(t) {
      const n = t.length
      let r = 0
      for (let i = n - 1, o = 0; o < n; i = o++)
        r += t[i].x * t[o].y - t[o].x * t[i].y
      return r * 0.5
    }
    static isClockWise(t) {
      return xd.area(t) < 0
    }
    static triangulateShape(t, n) {
      const r = [],
        i = [],
        o = []
      FP(t), zP(r, t)
      let a = t.length
      n.forEach(FP)
      for (let l = 0; l < n.length; l++)
        i.push(a), (a += n[l].length), zP(r, n[l])
      const s = che.triangulate(r, i)
      for (let l = 0; l < s.length; l += 3) o.push(s.slice(l, l + 3))
      return o
    }
  }
  function FP(e) {
    const t = e.length
    t > 2 && e[t - 1].equals(e[0]) && e.pop()
  }
  function zP(e, t) {
    for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
  }
  class BS extends la {
    constructor(
      t = new k$([
        new Ct(0.5, 0.5),
        new Ct(-0.5, 0.5),
        new Ct(-0.5, -0.5),
        new Ct(0.5, -0.5),
      ]),
      n = {}
    ) {
      super(),
        (this.type = 'ExtrudeGeometry'),
        (this.parameters = { shapes: t, options: n }),
        (t = Array.isArray(t) ? t : [t])
      const r = this,
        i = [],
        o = []
      for (let s = 0, l = t.length; s < l; s++) {
        const c = t[s]
        a(c)
      }
      this.setAttribute('position', new so(i, 3)),
        this.setAttribute('uv', new so(o, 2)),
        this.computeVertexNormals()
      function a(s) {
        const l = [],
          c = n.curveSegments !== void 0 ? n.curveSegments : 12,
          d = n.steps !== void 0 ? n.steps : 1,
          h = n.depth !== void 0 ? n.depth : 1
        let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
          v = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2,
          g = n.bevelSize !== void 0 ? n.bevelSize : v - 0.1,
          _ = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
          b = n.bevelSegments !== void 0 ? n.bevelSegments : 3
        const y = n.extrudePath,
          M = n.UVGenerator !== void 0 ? n.UVGenerator : Phe
        let x,
          w = !1,
          E,
          P,
          A,
          F
        y &&
          ((x = y.getSpacedPoints(d)),
          (w = !0),
          (p = !1),
          (E = y.computeFrenetFrames(d, !1)),
          (P = new Pe()),
          (A = new Pe()),
          (F = new Pe())),
          p || ((b = 0), (v = 0), (g = 0), (_ = 0))
        const T = s.extractPoints(c)
        let k = T.shape
        const R = T.holes
        if (!xd.isClockWise(k)) {
          k = k.reverse()
          for (let D = 0, G = R.length; D < G; D++) {
            const z = R[D]
            xd.isClockWise(z) && (R[D] = z.reverse())
          }
        }
        const N = xd.triangulateShape(k, R),
          I = k
        for (let D = 0, G = R.length; D < G; D++) {
          const z = R[D]
          k = k.concat(z)
        }
        function B(D, G, z) {
          return (
            G || console.error('THREE.ExtrudeGeometry: vec does not exist'),
            D.clone().addScaledVector(G, z)
          )
        }
        const V = k.length,
          L = N.length
        function W(D, G, z) {
          let ie, ae, re
          const pe = D.x - G.x,
            we = D.y - G.y,
            $e = z.x - D.x,
            Ae = z.y - D.y,
            ft = pe * pe + we * we,
            Q = pe * Ae - we * $e
          if (Math.abs(Q) > Number.EPSILON) {
            const X = Math.sqrt(ft),
              he = Math.sqrt($e * $e + Ae * Ae),
              de = G.x - we / X,
              xe = G.y + pe / X,
              ne = z.x - Ae / he,
              Le = z.y + $e / he,
              et = ((ne - de) * Ae - (Le - xe) * $e) / (pe * Ae - we * $e)
            ;(ie = de + pe * et - D.x), (ae = xe + we * et - D.y)
            const Ne = ie * ie + ae * ae
            if (Ne <= 2) return new Ct(ie, ae)
            re = Math.sqrt(Ne / 2)
          } else {
            let X = !1
            pe > Number.EPSILON
              ? $e > Number.EPSILON && (X = !0)
              : pe < -Number.EPSILON
              ? $e < -Number.EPSILON && (X = !0)
              : Math.sign(we) === Math.sign(Ae) && (X = !0),
              X
                ? ((ie = -we), (ae = pe), (re = Math.sqrt(ft)))
                : ((ie = pe), (ae = we), (re = Math.sqrt(ft / 2)))
          }
          return new Ct(ie / re, ae / re)
        }
        const Y = []
        for (
          let D = 0, G = I.length, z = G - 1, ie = D + 1;
          D < G;
          D++, z++, ie++
        )
          z === G && (z = 0),
            ie === G && (ie = 0),
            (Y[D] = W(I[D], I[z], I[ie]))
        const U = []
        let le,
          q = Y.concat()
        for (let D = 0, G = R.length; D < G; D++) {
          const z = R[D]
          le = []
          for (
            let ie = 0, ae = z.length, re = ae - 1, pe = ie + 1;
            ie < ae;
            ie++, re++, pe++
          )
            re === ae && (re = 0),
              pe === ae && (pe = 0),
              (le[ie] = W(z[ie], z[re], z[pe]))
          U.push(le), (q = q.concat(le))
        }
        for (let D = 0; D < b; D++) {
          const G = D / b,
            z = v * Math.cos((G * Math.PI) / 2),
            ie = g * Math.sin((G * Math.PI) / 2) + _
          for (let ae = 0, re = I.length; ae < re; ae++) {
            const pe = B(I[ae], Y[ae], ie)
            Re(pe.x, pe.y, -z)
          }
          for (let ae = 0, re = R.length; ae < re; ae++) {
            const pe = R[ae]
            le = U[ae]
            for (let we = 0, $e = pe.length; we < $e; we++) {
              const Ae = B(pe[we], le[we], ie)
              Re(Ae.x, Ae.y, -z)
            }
          }
        }
        const oe = g + _
        for (let D = 0; D < V; D++) {
          const G = p ? B(k[D], q[D], oe) : k[D]
          w
            ? (A.copy(E.normals[0]).multiplyScalar(G.x),
              P.copy(E.binormals[0]).multiplyScalar(G.y),
              F.copy(x[0]).add(A).add(P),
              Re(F.x, F.y, F.z))
            : Re(G.x, G.y, 0)
        }
        for (let D = 1; D <= d; D++)
          for (let G = 0; G < V; G++) {
            const z = p ? B(k[G], q[G], oe) : k[G]
            w
              ? (A.copy(E.normals[D]).multiplyScalar(z.x),
                P.copy(E.binormals[D]).multiplyScalar(z.y),
                F.copy(x[D]).add(A).add(P),
                Re(F.x, F.y, F.z))
              : Re(z.x, z.y, (h / d) * D)
          }
        for (let D = b - 1; D >= 0; D--) {
          const G = D / b,
            z = v * Math.cos((G * Math.PI) / 2),
            ie = g * Math.sin((G * Math.PI) / 2) + _
          for (let ae = 0, re = I.length; ae < re; ae++) {
            const pe = B(I[ae], Y[ae], ie)
            Re(pe.x, pe.y, h + z)
          }
          for (let ae = 0, re = R.length; ae < re; ae++) {
            const pe = R[ae]
            le = U[ae]
            for (let we = 0, $e = pe.length; we < $e; we++) {
              const Ae = B(pe[we], le[we], ie)
              w
                ? Re(Ae.x, Ae.y + x[d - 1].y, x[d - 1].x + z)
                : Re(Ae.x, Ae.y, h + z)
            }
          }
        }
        te(), ue()
        function te() {
          const D = i.length / 3
          if (p) {
            let G = 0,
              z = V * G
            for (let ie = 0; ie < L; ie++) {
              const ae = N[ie]
              qe(ae[2] + z, ae[1] + z, ae[0] + z)
            }
            ;(G = d + b * 2), (z = V * G)
            for (let ie = 0; ie < L; ie++) {
              const ae = N[ie]
              qe(ae[0] + z, ae[1] + z, ae[2] + z)
            }
          } else {
            for (let G = 0; G < L; G++) {
              const z = N[G]
              qe(z[2], z[1], z[0])
            }
            for (let G = 0; G < L; G++) {
              const z = N[G]
              qe(z[0] + V * d, z[1] + V * d, z[2] + V * d)
            }
          }
          r.addGroup(D, i.length / 3 - D, 0)
        }
        function ue() {
          const D = i.length / 3
          let G = 0
          me(I, G), (G += I.length)
          for (let z = 0, ie = R.length; z < ie; z++) {
            const ae = R[z]
            me(ae, G), (G += ae.length)
          }
          r.addGroup(D, i.length / 3 - D, 1)
        }
        function me(D, G) {
          let z = D.length
          for (; --z >= 0; ) {
            const ie = z
            let ae = z - 1
            ae < 0 && (ae = D.length - 1)
            for (let re = 0, pe = d + b * 2; re < pe; re++) {
              const we = V * re,
                $e = V * (re + 1),
                Ae = G + ie + we,
                ft = G + ae + we,
                Q = G + ae + $e,
                X = G + ie + $e
              Ve(Ae, ft, Q, X)
            }
          }
        }
        function Re(D, G, z) {
          l.push(D), l.push(G), l.push(z)
        }
        function qe(D, G, z) {
          nt(D), nt(G), nt(z)
          const ie = i.length / 3,
            ae = M.generateTopUV(r, i, ie - 3, ie - 2, ie - 1)
          We(ae[0]), We(ae[1]), We(ae[2])
        }
        function Ve(D, G, z, ie) {
          nt(D), nt(G), nt(ie), nt(G), nt(z), nt(ie)
          const ae = i.length / 3,
            re = M.generateSideWallUV(r, i, ae - 6, ae - 3, ae - 2, ae - 1)
          We(re[0]), We(re[1]), We(re[3]), We(re[1]), We(re[2]), We(re[3])
        }
        function nt(D) {
          i.push(l[D * 3 + 0]), i.push(l[D * 3 + 1]), i.push(l[D * 3 + 2])
        }
        function We(D) {
          o.push(D.x), o.push(D.y)
        }
      }
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      )
    }
    toJSON() {
      const t = super.toJSON(),
        n = this.parameters.shapes,
        r = this.parameters.options
      return The(n, r, t)
    }
    static fromJSON(t, n) {
      const r = []
      for (let o = 0, a = t.shapes.length; o < a; o++) {
        const s = n[t.shapes[o]]
        r.push(s)
      }
      const i = t.options.extrudePath
      return (
        i !== void 0 && (t.options.extrudePath = new T$[i.type]().fromJSON(i)),
        new BS(r, t.options)
      )
    }
  }
  const Phe = {
    generateTopUV: function (e, t, n, r, i) {
      const o = t[n * 3],
        a = t[n * 3 + 1],
        s = t[r * 3],
        l = t[r * 3 + 1],
        c = t[i * 3],
        d = t[i * 3 + 1]
      return [new Ct(o, a), new Ct(s, l), new Ct(c, d)]
    },
    generateSideWallUV: function (e, t, n, r, i, o) {
      const a = t[n * 3],
        s = t[n * 3 + 1],
        l = t[n * 3 + 2],
        c = t[r * 3],
        d = t[r * 3 + 1],
        h = t[r * 3 + 2],
        p = t[i * 3],
        v = t[i * 3 + 1],
        g = t[i * 3 + 2],
        _ = t[o * 3],
        b = t[o * 3 + 1],
        y = t[o * 3 + 2]
      return Math.abs(s - d) < Math.abs(a - c)
        ? [
            new Ct(a, 1 - l),
            new Ct(c, 1 - h),
            new Ct(p, 1 - g),
            new Ct(_, 1 - y),
          ]
        : [
            new Ct(s, 1 - l),
            new Ct(d, 1 - h),
            new Ct(v, 1 - g),
            new Ct(b, 1 - y),
          ]
    },
  }
  function The(e, t, n) {
    if (((n.shapes = []), Array.isArray(e)))
      for (let r = 0, i = e.length; r < i; r++) {
        const o = e[r]
        n.shapes.push(o.uuid)
      }
    else n.shapes.push(e.uuid)
    return (
      (n.options = Object.assign({}, t)),
      t.extrudePath !== void 0 &&
        (n.options.extrudePath = t.extrudePath.toJSON()),
      n
    )
  }
  class khe extends la {
    constructor(t = null) {
      if (
        (super(),
        (this.type = 'WireframeGeometry'),
        (this.parameters = { geometry: t }),
        t !== null)
      ) {
        const n = [],
          r = new Set(),
          i = new Pe(),
          o = new Pe()
        if (t.index !== null) {
          const a = t.attributes.position,
            s = t.index
          let l = t.groups
          l.length === 0 &&
            (l = [{ start: 0, count: s.count, materialIndex: 0 }])
          for (let c = 0, d = l.length; c < d; ++c) {
            const h = l[c],
              p = h.start,
              v = h.count
            for (let g = p, _ = p + v; g < _; g += 3)
              for (let b = 0; b < 3; b++) {
                const y = s.getX(g + b),
                  M = s.getX(g + ((b + 1) % 3))
                i.fromBufferAttribute(a, y),
                  o.fromBufferAttribute(a, M),
                  VP(i, o, r) === !0 &&
                    (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z))
              }
          }
        } else {
          const a = t.attributes.position
          for (let s = 0, l = a.count / 3; s < l; s++)
            for (let c = 0; c < 3; c++) {
              const d = 3 * s + c,
                h = 3 * s + ((c + 1) % 3)
              i.fromBufferAttribute(a, d),
                o.fromBufferAttribute(a, h),
                VP(i, o, r) === !0 &&
                  (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z))
            }
        }
        this.setAttribute('position', new so(n, 3))
      }
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      )
    }
  }
  function VP(e, t, n) {
    const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
      i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`
    return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0)
  }
  class Ahe extends cc {
    constructor(t) {
      super(),
        (this.isMeshPhongMaterial = !0),
        (this.type = 'MeshPhongMaterial'),
        (this.color = new xn(16777215)),
        (this.specular = new xn(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new xn(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = kS),
        (this.normalScale = new Ct(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = nf),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = 'round'),
        (this.wireframeLinejoin = 'round'),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      )
    }
  }
  class $he extends cc {
    constructor(t) {
      super(),
        (this.isMeshLambertMaterial = !0),
        (this.type = 'MeshLambertMaterial'),
        (this.color = new xn(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new xn(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = kS),
        (this.normalScale = new Ct(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = nf),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = 'round'),
        (this.wireframeLinejoin = 'round'),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t)
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      )
    }
  }
  const UP = {
    enabled: !1,
    files: {},
    add: function (e, t) {
      this.enabled !== !1 && (this.files[e] = t)
    },
    get: function (e) {
      if (this.enabled !== !1) return this.files[e]
    },
    remove: function (e) {
      delete this.files[e]
    },
    clear: function () {
      this.files = {}
    },
  }
  class Ohe {
    constructor(t, n, r) {
      const i = this
      let o = !1,
        a = 0,
        s = 0,
        l
      const c = []
      ;(this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = n),
        (this.onError = r),
        (this.itemStart = function (d) {
          s++, o === !1 && i.onStart !== void 0 && i.onStart(d, a, s), (o = !0)
        }),
        (this.itemEnd = function (d) {
          a++,
            i.onProgress !== void 0 && i.onProgress(d, a, s),
            a === s && ((o = !1), i.onLoad !== void 0 && i.onLoad())
        }),
        (this.itemError = function (d) {
          i.onError !== void 0 && i.onError(d)
        }),
        (this.resolveURL = function (d) {
          return l ? l(d) : d
        }),
        (this.setURLModifier = function (d) {
          return (l = d), this
        }),
        (this.addHandler = function (d, h) {
          return c.push(d, h), this
        }),
        (this.removeHandler = function (d) {
          const h = c.indexOf(d)
          return h !== -1 && c.splice(h, 2), this
        }),
        (this.getHandler = function (d) {
          for (let h = 0, p = c.length; h < p; h += 2) {
            const v = c[h],
              g = c[h + 1]
            if ((v.global && (v.lastIndex = 0), v.test(d))) return g
          }
          return null
        })
    }
  }
  const Lhe = new Ohe()
  class L$ {
    constructor(t) {
      ;(this.manager = t !== void 0 ? t : Lhe),
        (this.crossOrigin = 'anonymous'),
        (this.withCredentials = !1),
        (this.path = ''),
        (this.resourcePath = ''),
        (this.requestHeader = {})
    }
    load() {}
    loadAsync(t, n) {
      const r = this
      return new Promise(function (i, o) {
        r.load(t, i, n, o)
      })
    }
    parse() {}
    setCrossOrigin(t) {
      return (this.crossOrigin = t), this
    }
    setWithCredentials(t) {
      return (this.withCredentials = t), this
    }
    setPath(t) {
      return (this.path = t), this
    }
    setResourcePath(t) {
      return (this.resourcePath = t), this
    }
    setRequestHeader(t) {
      return (this.requestHeader = t), this
    }
  }
  class Ihe extends L$ {
    constructor(t) {
      super(t)
    }
    load(t, n, r, i) {
      this.path !== void 0 && (t = this.path + t),
        (t = this.manager.resolveURL(t))
      const o = this,
        a = UP.get(t)
      if (a !== void 0)
        return (
          o.manager.itemStart(t),
          setTimeout(function () {
            n && n(a), o.manager.itemEnd(t)
          }, 0),
          a
        )
      const s = Fd('img')
      function l() {
        d(), UP.add(t, this), n && n(this), o.manager.itemEnd(t)
      }
      function c(h) {
        d(), i && i(h), o.manager.itemError(t), o.manager.itemEnd(t)
      }
      function d() {
        s.removeEventListener('load', l, !1),
          s.removeEventListener('error', c, !1)
      }
      return (
        s.addEventListener('load', l, !1),
        s.addEventListener('error', c, !1),
        t.slice(0, 5) !== 'data:' &&
          this.crossOrigin !== void 0 &&
          (s.crossOrigin = this.crossOrigin),
        o.manager.itemStart(t),
        (s.src = t),
        s
      )
    }
  }
  class HP extends L$ {
    constructor(t) {
      super(t)
    }
    load(t, n, r, i) {
      const o = new Ei(),
        a = new Ihe(this.manager)
      return (
        a.setCrossOrigin(this.crossOrigin),
        a.setPath(this.path),
        a.load(
          t,
          function (s) {
            ;(o.image = s), (o.needsUpdate = !0), n !== void 0 && n(o)
          },
          r,
          i
        ),
        o
      )
    }
  }
  class I$ extends Br {
    constructor(t, n = 1) {
      super(),
        (this.isLight = !0),
        (this.type = 'Light'),
        (this.color = new xn(t)),
        (this.intensity = n)
    }
    dispose() {}
    copy(t, n) {
      return (
        super.copy(t, n),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      )
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        (n.object.color = this.color.getHex()),
        (n.object.intensity = this.intensity),
        this.groundColor !== void 0 &&
          (n.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (n.object.distance = this.distance),
        this.angle !== void 0 && (n.object.angle = this.angle),
        this.decay !== void 0 && (n.object.decay = this.decay),
        this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
        n
      )
    }
  }
  const X1 = new qn(),
    WP = new Pe(),
    jP = new Pe()
  class Rhe {
    constructor(t) {
      ;(this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new Ct(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new qn()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new LS()),
        (this._frameExtents = new Ct(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new Jn(0, 0, 1, 1)])
    }
    getViewportCount() {
      return this._viewportCount
    }
    getFrustum() {
      return this._frustum
    }
    updateMatrices(t) {
      const n = this.camera,
        r = this.matrix
      WP.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(WP),
        jP.setFromMatrixPosition(t.target.matrixWorld),
        n.lookAt(jP),
        n.updateMatrixWorld(),
        X1.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(X1),
        r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        r.multiply(X1)
    }
    getViewport(t) {
      return this._viewports[t]
    }
    getFrameExtents() {
      return this._frameExtents
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      )
    }
    clone() {
      return new this.constructor().copy(this)
    }
    toJSON() {
      const t = {}
      return (
        this.bias !== 0 && (t.bias = this.bias),
        this.normalBias !== 0 && (t.normalBias = this.normalBias),
        this.radius !== 1 && (t.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      )
    }
  }
  class Dhe extends Rhe {
    constructor() {
      super(new b$(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0)
    }
  }
  class GP extends I$ {
    constructor(t, n) {
      super(t, n),
        (this.isDirectionalLight = !0),
        (this.type = 'DirectionalLight'),
        this.position.copy(Br.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new Br()),
        (this.shadow = new Dhe())
    }
    dispose() {
      this.shadow.dispose()
    }
    copy(t) {
      return (
        super.copy(t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      )
    }
  }
  class Nhe extends I$ {
    constructor(t, n) {
      super(t, n), (this.isAmbientLight = !0), (this.type = 'AmbientLight')
    }
  }
  class Bhe extends la {
    constructor() {
      super(),
        (this.isInstancedBufferGeometry = !0),
        (this.type = 'InstancedBufferGeometry'),
        (this.instanceCount = 1 / 0)
    }
    copy(t) {
      return super.copy(t), (this.instanceCount = t.instanceCount), this
    }
    toJSON() {
      const t = super.toJSON()
      return (
        (t.instanceCount = this.instanceCount),
        (t.isInstancedBufferGeometry = !0),
        t
      )
    }
  }
  class e_ extends Yfe {
    constructor(t, n, r = 1) {
      super(t, n),
        (this.isInstancedInterleavedBuffer = !0),
        (this.meshPerAttribute = r)
    }
    copy(t) {
      return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
    }
    clone(t) {
      const n = super.clone(t)
      return (n.meshPerAttribute = this.meshPerAttribute), n
    }
    toJSON(t) {
      const n = super.toJSON(t)
      return (
        (n.isInstancedInterleavedBuffer = !0),
        (n.meshPerAttribute = this.meshPerAttribute),
        n
      )
    }
  }
  class Fhe {
    constructor(t, n, r = 0, i = 1 / 0) {
      ;(this.ray = new d$(t, n)),
        (this.near = r),
        (this.far = i),
        (this.camera = null),
        (this.layers = new $S()),
        (this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        })
    }
    set(t, n) {
      this.ray.set(t, n)
    }
    setFromCamera(t, n) {
      n.isPerspectiveCamera
        ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld),
          this.ray.direction
            .set(t.x, t.y, 0.5)
            .unproject(n)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = n))
        : n.isOrthographicCamera
        ? (this.ray.origin
            .set(t.x, t.y, (n.near + n.far) / (n.near - n.far))
            .unproject(n),
          this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld),
          (this.camera = n))
        : console.error('THREE.Raycaster: Unsupported camera type: ' + n.type)
    }
    intersectObject(t, n = !0, r = []) {
      return t_(t, this, r, n), r.sort(KP), r
    }
    intersectObjects(t, n = !0, r = []) {
      for (let i = 0, o = t.length; i < o; i++) t_(t[i], this, r, n)
      return r.sort(KP), r
    }
  }
  function KP(e, t) {
    return e.distance - t.distance
  }
  function t_(e, t, n, r) {
    if ((e.layers.test(t.layers) && e.raycast(t, n), r === !0)) {
      const i = e.children
      for (let o = 0, a = i.length; o < a; o++) t_(i[o], t, n, !0)
    }
  }
  class qP {
    constructor(t = 1, n = 0, r = 0) {
      return (this.radius = t), (this.phi = n), (this.theta = r), this
    }
    set(t, n, r) {
      return (this.radius = t), (this.phi = n), (this.theta = r), this
    }
    copy(t) {
      return (
        (this.radius = t.radius),
        (this.phi = t.phi),
        (this.theta = t.theta),
        this
      )
    }
    makeSafe() {
      return (
        (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
      )
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z)
    }
    setFromCartesianCoords(t, n, r) {
      return (
        (this.radius = Math.sqrt(t * t + n * n + r * r)),
        this.radius === 0
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(t, r)),
            (this.phi = Math.acos(hr(n / this.radius, -1, 1)))),
        this
      )
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  const XP = new Pe(),
    zh = new Pe()
  class zhe {
    constructor(t = new Pe(), n = new Pe()) {
      ;(this.start = t), (this.end = n)
    }
    set(t, n) {
      return this.start.copy(t), this.end.copy(n), this
    }
    copy(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this
    }
    getCenter(t) {
      return t.addVectors(this.start, this.end).multiplyScalar(0.5)
    }
    delta(t) {
      return t.subVectors(this.end, this.start)
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end)
    }
    distance() {
      return this.start.distanceTo(this.end)
    }
    at(t, n) {
      return this.delta(n).multiplyScalar(t).add(this.start)
    }
    closestPointToPointParameter(t, n) {
      XP.subVectors(t, this.start), zh.subVectors(this.end, this.start)
      const r = zh.dot(zh)
      let o = zh.dot(XP) / r
      return n && (o = hr(o, 0, 1)), o
    }
    closestPointToPoint(t, n, r) {
      const i = this.closestPointToPointParameter(t, n)
      return this.delta(r).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
    }
    equals(t) {
      return t.start.equals(this.start) && t.end.equals(this.end)
    }
    clone() {
      return new this.constructor().copy(this)
    }
  }
  typeof __THREE_DEVTOOLS__ < 'u' &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent('register', { detail: { revision: PS } })
    )
  typeof window < 'u' &&
    (window.__THREE__
      ? console.warn('WARNING: Multiple instances of Three.js being imported.')
      : (window.__THREE__ = PS))
  var wv = { exports: {} }
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */ wv.exports
  ;(function (e, t) {
    ;(function () {
      var n,
        r = '4.17.21',
        i = 200,
        o = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
        a = 'Expected a function',
        s = 'Invalid `variable` option passed into `_.template`',
        l = '__lodash_hash_undefined__',
        c = 500,
        d = '__lodash_placeholder__',
        h = 1,
        p = 2,
        v = 4,
        g = 1,
        _ = 2,
        b = 1,
        y = 2,
        M = 4,
        x = 8,
        w = 16,
        E = 32,
        P = 64,
        A = 128,
        F = 256,
        T = 512,
        k = 30,
        R = '...',
        j = 800,
        N = 16,
        I = 1,
        B = 2,
        V = 3,
        L = 1 / 0,
        W = 9007199254740991,
        Y = 17976931348623157e292,
        U = 0 / 0,
        le = 4294967295,
        q = le - 1,
        oe = le >>> 1,
        te = [
          ['ary', A],
          ['bind', b],
          ['bindKey', y],
          ['curry', x],
          ['curryRight', w],
          ['flip', T],
          ['partial', E],
          ['partialRight', P],
          ['rearg', F],
        ],
        ue = '[object Arguments]',
        me = '[object Array]',
        Re = '[object AsyncFunction]',
        qe = '[object Boolean]',
        Ve = '[object Date]',
        nt = '[object DOMException]',
        We = '[object Error]',
        D = '[object Function]',
        G = '[object GeneratorFunction]',
        z = '[object Map]',
        ie = '[object Number]',
        ae = '[object Null]',
        re = '[object Object]',
        pe = '[object Promise]',
        we = '[object Proxy]',
        $e = '[object RegExp]',
        Ae = '[object Set]',
        ft = '[object String]',
        Q = '[object Symbol]',
        X = '[object Undefined]',
        he = '[object WeakMap]',
        de = '[object WeakSet]',
        xe = '[object ArrayBuffer]',
        ne = '[object DataView]',
        Le = '[object Float32Array]',
        et = '[object Float64Array]',
        Ne = '[object Int8Array]',
        Et = '[object Int16Array]',
        kt = '[object Int32Array]',
        je = '[object Uint8Array]',
        Ge = '[object Uint8ClampedArray]',
        Ye = '[object Uint16Array]',
        lt = '[object Uint32Array]',
        gt = /\b__p \+= '';/g,
        _e = /\b(__p \+=) '' \+/g,
        bt = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
        He = /&(?:amp|lt|gt|quot|#39);/g,
        _t = /[&<>"']/g,
        wt = RegExp(He.source),
        Zt = RegExp(_t.source),
        ln = /<%-([\s\S]+?)%>/g,
        Pn = /<%([\s\S]+?)%>/g,
        Tr = /<%=([\s\S]+?)%>/g,
        vt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        Gt = /^\w*$/,
        pn =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        yr = /[\\^$.*+?()[\]{}|]/g,
        hi = RegExp(yr.source),
        Qr = /^\s+/,
        Ur = /\s/,
        da = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        co = /\{\n\/\* \[wrapped with (.+)\] \*/,
        ki = /,? & /,
        fo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
        ho = /[()=,{}\[\]\/\s]/,
        Rs = /\\(\\)?/g,
        fe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
        Ue = /\w*$/,
        Xe = /^[-+]0x[0-9a-f]+$/i,
        De = /^0b[01]+$/i,
        rt = /^\[object .+?Constructor\]$/,
        Ot = /^0o[0-7]+$/i,
        Ke = /^(?:0|[1-9]\d*)$/,
        ct = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
        Tt = /($^)/,
        Bt = /['\n\r\u2028\u2029\\]/g,
        Dt = '\\ud800-\\udfff',
        jt = '\\u0300-\\u036f',
        _n = '\\ufe20-\\ufe2f',
        Dn = '\\u20d0-\\u20ff',
        kr = jt + _n + Dn,
        ei = '\\u2700-\\u27bf',
        Fn = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        un = '\\xac\\xb1\\xd7\\xf7',
        Ka = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        Wn = '\\u2000-\\u206f',
        Wi =
          ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        Ds = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        $n = '\\ufe0e\\ufe0f',
        qa = un + Ka + Wn + Wi,
        Un = "[']",
        Fo = '[' + Dt + ']',
        Ns = '[' + qa + ']',
        Qn = '[' + kr + ']',
        Xa = '\\d+',
        hc = '[' + ei + ']',
        zo = '[' + Fn + ']',
        Dl = '[^' + Dt + qa + Xa + ei + Fn + Ds + ']',
        Nl = '\\ud83c[\\udffb-\\udfff]',
        Bs = '(?:' + Qn + '|' + Nl + ')',
        pc = '[^' + Dt + ']',
        vc = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        mc = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        Ya = '[' + Ds + ']',
        lf = '\\u200d',
        gc = '(?:' + zo + '|' + Dl + ')',
        Cm = '(?:' + Ya + '|' + Dl + ')',
        yc = '(?:' + Un + '(?:d|ll|m|re|s|t|ve))?',
        bc = '(?:' + Un + '(?:D|LL|M|RE|S|T|VE))?',
        _c = Bs + '?',
        Sc = '[' + $n + ']?',
        Bl = '(?:' + lf + '(?:' + [pc, vc, mc].join('|') + ')' + Sc + _c + ')*',
        wm = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        uf = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        Cc = Sc + _c + Bl,
        xm = '(?:' + [hc, vc, mc].join('|') + ')' + Cc,
        wc = '(?:' + [pc + Qn + '?', Qn, vc, mc, Fo].join('|') + ')',
        cf = RegExp(Un, 'g'),
        df = RegExp(Qn, 'g'),
        xc = RegExp(Nl + '(?=' + Nl + ')|' + wc + Cc, 'g'),
        ff = RegExp(
          [
            Ya + '?' + zo + '+' + yc + '(?=' + [Ns, Ya, '$'].join('|') + ')',
            Cm + '+' + bc + '(?=' + [Ns, Ya + gc, '$'].join('|') + ')',
            Ya + '?' + gc + '+' + yc,
            Ya + '+' + bc,
            uf,
            wm,
            Xa,
            xm,
          ].join('|'),
          'g'
        ),
        hf = RegExp('[' + lf + Dt + kr + $n + ']'),
        Mm =
          /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
        GS = [
          'Array',
          'Buffer',
          'DataView',
          'Date',
          'Error',
          'Float32Array',
          'Float64Array',
          'Function',
          'Int8Array',
          'Int16Array',
          'Int32Array',
          'Map',
          'Math',
          'Object',
          'Promise',
          'RegExp',
          'Set',
          'String',
          'Symbol',
          'TypeError',
          'Uint8Array',
          'Uint8ClampedArray',
          'Uint16Array',
          'Uint32Array',
          'WeakMap',
          '_',
          'clearTimeout',
          'isFinite',
          'parseInt',
          'setTimeout',
        ],
        ke = -1,
        Be = {}
      ;(Be[Le] =
        Be[et] =
        Be[Ne] =
        Be[Et] =
        Be[kt] =
        Be[je] =
        Be[Ge] =
        Be[Ye] =
        Be[lt] =
          !0),
        (Be[ue] =
          Be[me] =
          Be[xe] =
          Be[qe] =
          Be[ne] =
          Be[Ve] =
          Be[We] =
          Be[D] =
          Be[z] =
          Be[ie] =
          Be[re] =
          Be[$e] =
          Be[Ae] =
          Be[ft] =
          Be[he] =
            !1)
      var Qe = {}
      ;(Qe[ue] =
        Qe[me] =
        Qe[xe] =
        Qe[ne] =
        Qe[qe] =
        Qe[Ve] =
        Qe[Le] =
        Qe[et] =
        Qe[Ne] =
        Qe[Et] =
        Qe[kt] =
        Qe[z] =
        Qe[ie] =
        Qe[re] =
        Qe[$e] =
        Qe[Ae] =
        Qe[ft] =
        Qe[Q] =
        Qe[je] =
        Qe[Ge] =
        Qe[Ye] =
        Qe[lt] =
          !0),
        (Qe[We] = Qe[D] = Qe[he] = !1)
      var St = {
          : 'A',
          : 'A',
          : 'A',
          : 'A',
          : 'A',
          : 'A',
          : 'a',
          : 'a',
          : 'a',
          : 'a',
          : 'a',
          : 'a',
          : 'C',
          : 'c',
          : 'D',
          : 'd',
          : 'E',
          : 'E',
          : 'E',
          : 'E',
          : 'e',
          : 'e',
          : 'e',
          : 'e',
          : 'I',
          : 'I',
          : 'I',
          : 'I',
          : 'i',
          : 'i',
          : 'i',
          : 'i',
          : 'N',
          : 'n',
          : 'O',
          : 'O',
          : 'O',
          : 'O',
          : 'O',
          : 'O',
          : 'o',
          : 'o',
          : 'o',
          : 'o',
          : 'o',
          : 'o',
          : 'U',
          : 'U',
          : 'U',
          : 'U',
          : 'u',
          : 'u',
          : 'u',
          : 'u',
          : 'Y',
          : 'y',
          : 'y',
          : 'Ae',
          : 'ae',
          : 'Th',
          : 'th',
          : 'ss',
          : 'A',
          : 'A',
          : 'A',
          : 'a',
          : 'a',
          : 'a',
          : 'C',
          : 'C',
          : 'C',
          : 'C',
          : 'c',
          : 'c',
          : 'c',
          : 'c',
          : 'D',
          : 'D',
          : 'd',
          : 'd',
          : 'E',
          : 'E',
          : 'E',
          : 'E',
          : 'E',
          : 'e',
          : 'e',
          : 'e',
          : 'e',
          : 'e',
          : 'G',
          : 'G',
          : 'G',
          : 'G',
          : 'g',
          : 'g',
          : 'g',
          : 'g',
          : 'H',
          : 'H',
          : 'h',
          : 'h',
          : 'I',
          : 'I',
          : 'I',
          : 'I',
          : 'I',
          : 'i',
          : 'i',
          : 'i',
          : 'i',
          : 'i',
          : 'J',
          : 'j',
          : 'K',
          : 'k',
          : 'k',
          : 'L',
          : 'L',
          : 'L',
          : 'L',
          : 'L',
          : 'l',
          : 'l',
          : 'l',
          : 'l',
          : 'l',
          : 'N',
          : 'N',
          : 'N',
          : 'N',
          : 'n',
          : 'n',
          : 'n',
          : 'n',
          : 'O',
          : 'O',
          : 'O',
          : 'o',
          : 'o',
          : 'o',
          : 'R',
          : 'R',
          : 'R',
          : 'r',
          : 'r',
          : 'r',
          : 'S',
          : 'S',
          : 'S',
          : 'S',
          : 's',
          : 's',
          : 's',
          : 's',
          : 'T',
          : 'T',
          : 'T',
          : 't',
          : 't',
          : 't',
          : 'U',
          : 'U',
          : 'U',
          : 'U',
          : 'U',
          : 'U',
          : 'u',
          : 'u',
          : 'u',
          : 'u',
          : 'u',
          : 'u',
          : 'W',
          : 'w',
          : 'Y',
          : 'y',
          : 'Y',
          : 'Z',
          : 'Z',
          : 'Z',
          : 'z',
          : 'z',
          : 'z',
          : 'IJ',
          : 'ij',
          : 'Oe',
          : 'oe',
          : "'n",
          : 's',
        },
        At = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
        },
        Vt = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'",
        },
        vn = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029',
        },
        or = parseFloat,
        ti = parseInt,
        pi = typeof Bi == 'object' && Bi && Bi.Object === Object && Bi,
        Fl = typeof self == 'object' && self && self.Object === Object && self,
        jn = pi || Fl || Function('return this')(),
        Mc = t && !t.nodeType && t,
        Sn = Mc && !0 && e && !e.nodeType && e,
        Vo = Sn && Sn.exports === Mc,
        fa = Vo && pi.process,
        br = (function () {
          try {
            var Oe = Sn && Sn.require && Sn.require('util').types
            return Oe || (fa && fa.binding && fa.binding('util'))
          } catch {}
        })(),
        zl = br && br.isArrayBuffer,
        Vl = br && br.isDate,
        Ul = br && br.isMap,
        pf = br && br.isRegExp,
        Za = br && br.isSet,
        KS = br && br.isTypedArray
      function Ai(Oe, ot, Ze) {
        switch (Ze.length) {
          case 0:
            return Oe.call(ot)
          case 1:
            return Oe.call(ot, Ze[0])
          case 2:
            return Oe.call(ot, Ze[0], Ze[1])
          case 3:
            return Oe.call(ot, Ze[0], Ze[1], Ze[2])
        }
        return Oe.apply(ot, Ze)
      }
      function nO(Oe, ot, Ze, Nt) {
        for (var Jt = -1, wn = Oe == null ? 0 : Oe.length; ++Jt < wn; ) {
          var cr = Oe[Jt]
          ot(Nt, cr, Ze(cr), Oe)
        }
        return Nt
      }
      function ji(Oe, ot) {
        for (
          var Ze = -1, Nt = Oe == null ? 0 : Oe.length;
          ++Ze < Nt && ot(Oe[Ze], Ze, Oe) !== !1;

        );
        return Oe
      }
      function rO(Oe, ot) {
        for (
          var Ze = Oe == null ? 0 : Oe.length;
          Ze-- && ot(Oe[Ze], Ze, Oe) !== !1;

        );
        return Oe
      }
      function qS(Oe, ot) {
        for (var Ze = -1, Nt = Oe == null ? 0 : Oe.length; ++Ze < Nt; )
          if (!ot(Oe[Ze], Ze, Oe)) return !1
        return !0
      }
      function Ja(Oe, ot) {
        for (
          var Ze = -1, Nt = Oe == null ? 0 : Oe.length, Jt = 0, wn = [];
          ++Ze < Nt;

        ) {
          var cr = Oe[Ze]
          ot(cr, Ze, Oe) && (wn[Jt++] = cr)
        }
        return wn
      }
      function vf(Oe, ot) {
        var Ze = Oe == null ? 0 : Oe.length
        return !!Ze && Hl(Oe, ot, 0) > -1
      }
      function Em(Oe, ot, Ze) {
        for (var Nt = -1, Jt = Oe == null ? 0 : Oe.length; ++Nt < Jt; )
          if (Ze(ot, Oe[Nt])) return !0
        return !1
      }
      function Hn(Oe, ot) {
        for (
          var Ze = -1, Nt = Oe == null ? 0 : Oe.length, Jt = Array(Nt);
          ++Ze < Nt;

        )
          Jt[Ze] = ot(Oe[Ze], Ze, Oe)
        return Jt
      }
      function Qa(Oe, ot) {
        for (var Ze = -1, Nt = ot.length, Jt = Oe.length; ++Ze < Nt; )
          Oe[Jt + Ze] = ot[Ze]
        return Oe
      }
      function Pm(Oe, ot, Ze, Nt) {
        var Jt = -1,
          wn = Oe == null ? 0 : Oe.length
        for (Nt && wn && (Ze = Oe[++Jt]); ++Jt < wn; )
          Ze = ot(Ze, Oe[Jt], Jt, Oe)
        return Ze
      }
      function iO(Oe, ot, Ze, Nt) {
        var Jt = Oe == null ? 0 : Oe.length
        for (Nt && Jt && (Ze = Oe[--Jt]); Jt--; ) Ze = ot(Ze, Oe[Jt], Jt, Oe)
        return Ze
      }
      function Tm(Oe, ot) {
        for (var Ze = -1, Nt = Oe == null ? 0 : Oe.length; ++Ze < Nt; )
          if (ot(Oe[Ze], Ze, Oe)) return !0
        return !1
      }
      var oO = km('length')
      function aO(Oe) {
        return Oe.split('')
      }
      function sO(Oe) {
        return Oe.match(fo) || []
      }
      function XS(Oe, ot, Ze) {
        var Nt
        return (
          Ze(Oe, function (Jt, wn, cr) {
            if (ot(Jt, wn, cr)) return (Nt = wn), !1
          }),
          Nt
        )
      }
      function mf(Oe, ot, Ze, Nt) {
        for (
          var Jt = Oe.length, wn = Ze + (Nt ? 1 : -1);
          Nt ? wn-- : ++wn < Jt;

        )
          if (ot(Oe[wn], wn, Oe)) return wn
        return -1
      }
      function Hl(Oe, ot, Ze) {
        return ot === ot ? bO(Oe, ot, Ze) : mf(Oe, YS, Ze)
      }
      function lO(Oe, ot, Ze, Nt) {
        for (var Jt = Ze - 1, wn = Oe.length; ++Jt < wn; )
          if (Nt(Oe[Jt], ot)) return Jt
        return -1
      }
      function YS(Oe) {
        return Oe !== Oe
      }
      function ZS(Oe, ot) {
        var Ze = Oe == null ? 0 : Oe.length
        return Ze ? $m(Oe, ot) / Ze : U
      }
      function km(Oe) {
        return function (ot) {
          return ot == null ? n : ot[Oe]
        }
      }
      function Am(Oe) {
        return function (ot) {
          return Oe == null ? n : Oe[ot]
        }
      }
      function JS(Oe, ot, Ze, Nt, Jt) {
        return (
          Jt(Oe, function (wn, cr, On) {
            Ze = Nt ? ((Nt = !1), wn) : ot(Ze, wn, cr, On)
          }),
          Ze
        )
      }
      function uO(Oe, ot) {
        var Ze = Oe.length
        for (Oe.sort(ot); Ze--; ) Oe[Ze] = Oe[Ze].value
        return Oe
      }
      function $m(Oe, ot) {
        for (var Ze, Nt = -1, Jt = Oe.length; ++Nt < Jt; ) {
          var wn = ot(Oe[Nt])
          wn !== n && (Ze = Ze === n ? wn : Ze + wn)
        }
        return Ze
      }
      function Om(Oe, ot) {
        for (var Ze = -1, Nt = Array(Oe); ++Ze < Oe; ) Nt[Ze] = ot(Ze)
        return Nt
      }
      function cO(Oe, ot) {
        return Hn(ot, function (Ze) {
          return [Ze, Oe[Ze]]
        })
      }
      function QS(Oe) {
        return Oe && Oe.slice(0, rC(Oe) + 1).replace(Qr, '')
      }
      function $i(Oe) {
        return function (ot) {
          return Oe(ot)
        }
      }
      function Lm(Oe, ot) {
        return Hn(ot, function (Ze) {
          return Oe[Ze]
        })
      }
      function Ec(Oe, ot) {
        return Oe.has(ot)
      }
      function eC(Oe, ot) {
        for (
          var Ze = -1, Nt = Oe.length;
          ++Ze < Nt && Hl(ot, Oe[Ze], 0) > -1;

        );
        return Ze
      }
      function tC(Oe, ot) {
        for (var Ze = Oe.length; Ze-- && Hl(ot, Oe[Ze], 0) > -1; );
        return Ze
      }
      function dO(Oe, ot) {
        for (var Ze = Oe.length, Nt = 0; Ze--; ) Oe[Ze] === ot && ++Nt
        return Nt
      }
      var fO = Am(St),
        hO = Am(At)
      function pO(Oe) {
        return '\\' + vn[Oe]
      }
      function vO(Oe, ot) {
        return Oe == null ? n : Oe[ot]
      }
      function Wl(Oe) {
        return hf.test(Oe)
      }
      function mO(Oe) {
        return Mm.test(Oe)
      }
      function gO(Oe) {
        for (var ot, Ze = []; !(ot = Oe.next()).done; ) Ze.push(ot.value)
        return Ze
      }
      function Im(Oe) {
        var ot = -1,
          Ze = Array(Oe.size)
        return (
          Oe.forEach(function (Nt, Jt) {
            Ze[++ot] = [Jt, Nt]
          }),
          Ze
        )
      }
      function nC(Oe, ot) {
        return function (Ze) {
          return Oe(ot(Ze))
        }
      }
      function es(Oe, ot) {
        for (var Ze = -1, Nt = Oe.length, Jt = 0, wn = []; ++Ze < Nt; ) {
          var cr = Oe[Ze]
          ;(cr === ot || cr === d) && ((Oe[Ze] = d), (wn[Jt++] = Ze))
        }
        return wn
      }
      function gf(Oe) {
        var ot = -1,
          Ze = Array(Oe.size)
        return (
          Oe.forEach(function (Nt) {
            Ze[++ot] = Nt
          }),
          Ze
        )
      }
      function yO(Oe) {
        var ot = -1,
          Ze = Array(Oe.size)
        return (
          Oe.forEach(function (Nt) {
            Ze[++ot] = [Nt, Nt]
          }),
          Ze
        )
      }
      function bO(Oe, ot, Ze) {
        for (var Nt = Ze - 1, Jt = Oe.length; ++Nt < Jt; )
          if (Oe[Nt] === ot) return Nt
        return -1
      }
      function _O(Oe, ot, Ze) {
        for (var Nt = Ze + 1; Nt--; ) if (Oe[Nt] === ot) return Nt
        return Nt
      }
      function jl(Oe) {
        return Wl(Oe) ? CO(Oe) : oO(Oe)
      }
      function po(Oe) {
        return Wl(Oe) ? wO(Oe) : aO(Oe)
      }
      function rC(Oe) {
        for (var ot = Oe.length; ot-- && Ur.test(Oe.charAt(ot)); );
        return ot
      }
      var SO = Am(Vt)
      function CO(Oe) {
        for (var ot = (xc.lastIndex = 0); xc.test(Oe); ) ++ot
        return ot
      }
      function wO(Oe) {
        return Oe.match(xc) || []
      }
      function xO(Oe) {
        return Oe.match(ff) || []
      }
      var MO = function Oe(ot) {
          ot = ot == null ? jn : Gl.defaults(jn.Object(), ot, Gl.pick(jn, GS))
          var Ze = ot.Array,
            Nt = ot.Date,
            Jt = ot.Error,
            wn = ot.Function,
            cr = ot.Math,
            On = ot.Object,
            Rm = ot.RegExp,
            EO = ot.String,
            Gi = ot.TypeError,
            yf = Ze.prototype,
            PO = wn.prototype,
            Kl = On.prototype,
            bf = ot['__core-js_shared__'],
            _f = PO.toString,
            Tn = Kl.hasOwnProperty,
            TO = 0,
            iC = (function () {
              var u = /[^.]+$/.exec((bf && bf.keys && bf.keys.IE_PROTO) || '')
              return u ? 'Symbol(src)_1.' + u : ''
            })(),
            Sf = Kl.toString,
            kO = _f.call(On),
            AO = jn._,
            $O = Rm(
              '^' +
                _f
                  .call(Tn)
                  .replace(yr, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            ),
            Cf = Vo ? ot.Buffer : n,
            ts = ot.Symbol,
            wf = ot.Uint8Array,
            oC = Cf ? Cf.allocUnsafe : n,
            xf = nC(On.getPrototypeOf, On),
            aC = On.create,
            sC = Kl.propertyIsEnumerable,
            Mf = yf.splice,
            lC = ts ? ts.isConcatSpreadable : n,
            Pc = ts ? ts.iterator : n,
            Fs = ts ? ts.toStringTag : n,
            Ef = (function () {
              try {
                var u = Ws(On, 'defineProperty')
                return u({}, '', {}), u
              } catch {}
            })(),
            OO = ot.clearTimeout !== jn.clearTimeout && ot.clearTimeout,
            LO = Nt && Nt.now !== jn.Date.now && Nt.now,
            IO = ot.setTimeout !== jn.setTimeout && ot.setTimeout,
            Pf = cr.ceil,
            Tf = cr.floor,
            Dm = On.getOwnPropertySymbols,
            RO = Cf ? Cf.isBuffer : n,
            uC = ot.isFinite,
            DO = yf.join,
            NO = nC(On.keys, On),
            dr = cr.max,
            Hr = cr.min,
            BO = Nt.now,
            FO = ot.parseInt,
            cC = cr.random,
            zO = yf.reverse,
            Nm = Ws(ot, 'DataView'),
            Tc = Ws(ot, 'Map'),
            Bm = Ws(ot, 'Promise'),
            ql = Ws(ot, 'Set'),
            kc = Ws(ot, 'WeakMap'),
            Ac = Ws(On, 'create'),
            kf = kc && new kc(),
            Xl = {},
            VO = js(Nm),
            UO = js(Tc),
            HO = js(Bm),
            WO = js(ql),
            jO = js(kc),
            Af = ts ? ts.prototype : n,
            $c = Af ? Af.valueOf : n,
            dC = Af ? Af.toString : n
          function ee(u) {
            if (Zn(u) && !Qt(u) && !(u instanceof fn)) {
              if (u instanceof Ki) return u
              if (Tn.call(u, '__wrapped__')) return fw(u)
            }
            return new Ki(u)
          }
          var Yl = (function () {
            function u() {}
            return function (f) {
              if (!Gn(f)) return {}
              if (aC) return aC(f)
              u.prototype = f
              var S = new u()
              return (u.prototype = n), S
            }
          })()
          function $f() {}
          function Ki(u, f) {
            ;(this.__wrapped__ = u),
              (this.__actions__ = []),
              (this.__chain__ = !!f),
              (this.__index__ = 0),
              (this.__values__ = n)
          }
          ;(ee.templateSettings = {
            escape: ln,
            evaluate: Pn,
            interpolate: Tr,
            variable: '',
            imports: { _: ee },
          }),
            (ee.prototype = $f.prototype),
            (ee.prototype.constructor = ee),
            (Ki.prototype = Yl($f.prototype)),
            (Ki.prototype.constructor = Ki)
          function fn(u) {
            ;(this.__wrapped__ = u),
              (this.__actions__ = []),
              (this.__dir__ = 1),
              (this.__filtered__ = !1),
              (this.__iteratees__ = []),
              (this.__takeCount__ = le),
              (this.__views__ = [])
          }
          function GO() {
            var u = new fn(this.__wrapped__)
            return (
              (u.__actions__ = vi(this.__actions__)),
              (u.__dir__ = this.__dir__),
              (u.__filtered__ = this.__filtered__),
              (u.__iteratees__ = vi(this.__iteratees__)),
              (u.__takeCount__ = this.__takeCount__),
              (u.__views__ = vi(this.__views__)),
              u
            )
          }
          function KO() {
            if (this.__filtered__) {
              var u = new fn(this)
              ;(u.__dir__ = -1), (u.__filtered__ = !0)
            } else (u = this.clone()), (u.__dir__ *= -1)
            return u
          }
          function qO() {
            var u = this.__wrapped__.value(),
              f = this.__dir__,
              S = Qt(u),
              $ = f < 0,
              K = S ? u.length : 0,
              se = a5(0, K, this.__views__),
              be = se.start,
              Me = se.end,
              Ie = Me - be,
              ut = $ ? Me : be - 1,
              dt = this.__iteratees__,
              ht = dt.length,
              $t = 0,
              Ut = Hr(Ie, this.__takeCount__)
            if (!S || (!$ && K == Ie && Ut == Ie))
              return RC(u, this.__actions__)
            var qt = []
            e: for (; Ie-- && $t < Ut; ) {
              ut += f
              for (var nn = -1, Xt = u[ut]; ++nn < ht; ) {
                var dn = dt[nn],
                  mn = dn.iteratee,
                  Ii = dn.type,
                  ii = mn(Xt)
                if (Ii == B) Xt = ii
                else if (!ii) {
                  if (Ii == I) continue e
                  break e
                }
              }
              qt[$t++] = Xt
            }
            return qt
          }
          ;(fn.prototype = Yl($f.prototype)), (fn.prototype.constructor = fn)
          function zs(u) {
            var f = -1,
              S = u == null ? 0 : u.length
            for (this.clear(); ++f < S; ) {
              var $ = u[f]
              this.set($[0], $[1])
            }
          }
          function XO() {
            ;(this.__data__ = Ac ? Ac(null) : {}), (this.size = 0)
          }
          function YO(u) {
            var f = this.has(u) && delete this.__data__[u]
            return (this.size -= f ? 1 : 0), f
          }
          function ZO(u) {
            var f = this.__data__
            if (Ac) {
              var S = f[u]
              return S === l ? n : S
            }
            return Tn.call(f, u) ? f[u] : n
          }
          function JO(u) {
            var f = this.__data__
            return Ac ? f[u] !== n : Tn.call(f, u)
          }
          function QO(u, f) {
            var S = this.__data__
            return (
              (this.size += this.has(u) ? 0 : 1),
              (S[u] = Ac && f === n ? l : f),
              this
            )
          }
          ;(zs.prototype.clear = XO),
            (zs.prototype.delete = YO),
            (zs.prototype.get = ZO),
            (zs.prototype.has = JO),
            (zs.prototype.set = QO)
          function ha(u) {
            var f = -1,
              S = u == null ? 0 : u.length
            for (this.clear(); ++f < S; ) {
              var $ = u[f]
              this.set($[0], $[1])
            }
          }
          function eL() {
            ;(this.__data__ = []), (this.size = 0)
          }
          function tL(u) {
            var f = this.__data__,
              S = Of(f, u)
            if (S < 0) return !1
            var $ = f.length - 1
            return S == $ ? f.pop() : Mf.call(f, S, 1), --this.size, !0
          }
          function nL(u) {
            var f = this.__data__,
              S = Of(f, u)
            return S < 0 ? n : f[S][1]
          }
          function rL(u) {
            return Of(this.__data__, u) > -1
          }
          function iL(u, f) {
            var S = this.__data__,
              $ = Of(S, u)
            return $ < 0 ? (++this.size, S.push([u, f])) : (S[$][1] = f), this
          }
          ;(ha.prototype.clear = eL),
            (ha.prototype.delete = tL),
            (ha.prototype.get = nL),
            (ha.prototype.has = rL),
            (ha.prototype.set = iL)
          function pa(u) {
            var f = -1,
              S = u == null ? 0 : u.length
            for (this.clear(); ++f < S; ) {
              var $ = u[f]
              this.set($[0], $[1])
            }
          }
          function oL() {
            ;(this.size = 0),
              (this.__data__ = {
                hash: new zs(),
                map: new (Tc || ha)(),
                string: new zs(),
              })
          }
          function aL(u) {
            var f = Wf(this, u).delete(u)
            return (this.size -= f ? 1 : 0), f
          }
          function sL(u) {
            return Wf(this, u).get(u)
          }
          function lL(u) {
            return Wf(this, u).has(u)
          }
          function uL(u, f) {
            var S = Wf(this, u),
              $ = S.size
            return S.set(u, f), (this.size += S.size == $ ? 0 : 1), this
          }
          ;(pa.prototype.clear = oL),
            (pa.prototype.delete = aL),
            (pa.prototype.get = sL),
            (pa.prototype.has = lL),
            (pa.prototype.set = uL)
          function Vs(u) {
            var f = -1,
              S = u == null ? 0 : u.length
            for (this.__data__ = new pa(); ++f < S; ) this.add(u[f])
          }
          function cL(u) {
            return this.__data__.set(u, l), this
          }
          function dL(u) {
            return this.__data__.has(u)
          }
          ;(Vs.prototype.add = Vs.prototype.push = cL), (Vs.prototype.has = dL)
          function vo(u) {
            var f = (this.__data__ = new ha(u))
            this.size = f.size
          }
          function fL() {
            ;(this.__data__ = new ha()), (this.size = 0)
          }
          function hL(u) {
            var f = this.__data__,
              S = f.delete(u)
            return (this.size = f.size), S
          }
          function pL(u) {
            return this.__data__.get(u)
          }
          function vL(u) {
            return this.__data__.has(u)
          }
          function mL(u, f) {
            var S = this.__data__
            if (S instanceof ha) {
              var $ = S.__data__
              if (!Tc || $.length < i - 1)
                return $.push([u, f]), (this.size = ++S.size), this
              S = this.__data__ = new pa($)
            }
            return S.set(u, f), (this.size = S.size), this
          }
          ;(vo.prototype.clear = fL),
            (vo.prototype.delete = hL),
            (vo.prototype.get = pL),
            (vo.prototype.has = vL),
            (vo.prototype.set = mL)
          function fC(u, f) {
            var S = Qt(u),
              $ = !S && Gs(u),
              K = !S && !$ && as(u),
              se = !S && !$ && !K && eu(u),
              be = S || $ || K || se,
              Me = be ? Om(u.length, EO) : [],
              Ie = Me.length
            for (var ut in u)
              (f || Tn.call(u, ut)) &&
                !(
                  be &&
                  (ut == 'length' ||
                    (K && (ut == 'offset' || ut == 'parent')) ||
                    (se &&
                      (ut == 'buffer' ||
                        ut == 'byteLength' ||
                        ut == 'byteOffset')) ||
                    ya(ut, Ie))
                ) &&
                Me.push(ut)
            return Me
          }
          function hC(u) {
            var f = u.length
            return f ? u[Xm(0, f - 1)] : n
          }
          function gL(u, f) {
            return jf(vi(u), Us(f, 0, u.length))
          }
          function yL(u) {
            return jf(vi(u))
          }
          function Fm(u, f, S) {
            ;((S !== n && !mo(u[f], S)) || (S === n && !(f in u))) &&
              va(u, f, S)
          }
          function Oc(u, f, S) {
            var $ = u[f]
            ;(!(Tn.call(u, f) && mo($, S)) || (S === n && !(f in u))) &&
              va(u, f, S)
          }
          function Of(u, f) {
            for (var S = u.length; S--; ) if (mo(u[S][0], f)) return S
            return -1
          }
          function bL(u, f, S, $) {
            return (
              ns(u, function (K, se, be) {
                f($, K, S(K), be)
              }),
              $
            )
          }
          function pC(u, f) {
            return u && Ho(f, _r(f), u)
          }
          function _L(u, f) {
            return u && Ho(f, gi(f), u)
          }
          function va(u, f, S) {
            f == '__proto__' && Ef
              ? Ef(u, f, {
                  configurable: !0,
                  enumerable: !0,
                  value: S,
                  writable: !0,
                })
              : (u[f] = S)
          }
          function zm(u, f) {
            for (var S = -1, $ = f.length, K = Ze($), se = u == null; ++S < $; )
              K[S] = se ? n : _g(u, f[S])
            return K
          }
          function Us(u, f, S) {
            return (
              u === u &&
                (S !== n && (u = u <= S ? u : S),
                f !== n && (u = u >= f ? u : f)),
              u
            )
          }
          function qi(u, f, S, $, K, se) {
            var be,
              Me = f & h,
              Ie = f & p,
              ut = f & v
            if ((S && (be = K ? S(u, $, K, se) : S(u)), be !== n)) return be
            if (!Gn(u)) return u
            var dt = Qt(u)
            if (dt) {
              if (((be = l5(u)), !Me)) return vi(u, be)
            } else {
              var ht = Wr(u),
                $t = ht == D || ht == G
              if (as(u)) return BC(u, Me)
              if (ht == re || ht == ue || ($t && !K)) {
                if (((be = Ie || $t ? {} : rw(u)), !Me))
                  return Ie ? ZL(u, _L(be, u)) : YL(u, pC(be, u))
              } else {
                if (!Qe[ht]) return K ? u : {}
                be = u5(u, ht, Me)
              }
            }
            se || (se = new vo())
            var Ut = se.get(u)
            if (Ut) return Ut
            se.set(u, be),
              Ow(u)
                ? u.forEach(function (Xt) {
                    be.add(qi(Xt, f, S, Xt, u, se))
                  })
                : Aw(u) &&
                  u.forEach(function (Xt, dn) {
                    be.set(dn, qi(Xt, f, S, dn, u, se))
                  })
            var qt = ut ? (Ie ? ag : og) : Ie ? gi : _r,
              nn = dt ? n : qt(u)
            return (
              ji(nn || u, function (Xt, dn) {
                nn && ((dn = Xt), (Xt = u[dn])),
                  Oc(be, dn, qi(Xt, f, S, dn, u, se))
              }),
              be
            )
          }
          function SL(u) {
            var f = _r(u)
            return function (S) {
              return vC(S, u, f)
            }
          }
          function vC(u, f, S) {
            var $ = S.length
            if (u == null) return !$
            for (u = On(u); $--; ) {
              var K = S[$],
                se = f[K],
                be = u[K]
              if ((be === n && !(K in u)) || !se(be)) return !1
            }
            return !0
          }
          function mC(u, f, S) {
            if (typeof u != 'function') throw new Gi(a)
            return Fc(function () {
              u.apply(n, S)
            }, f)
          }
          function Lc(u, f, S, $) {
            var K = -1,
              se = vf,
              be = !0,
              Me = u.length,
              Ie = [],
              ut = f.length
            if (!Me) return Ie
            S && (f = Hn(f, $i(S))),
              $
                ? ((se = Em), (be = !1))
                : f.length >= i && ((se = Ec), (be = !1), (f = new Vs(f)))
            e: for (; ++K < Me; ) {
              var dt = u[K],
                ht = S == null ? dt : S(dt)
              if (((dt = $ || dt !== 0 ? dt : 0), be && ht === ht)) {
                for (var $t = ut; $t--; ) if (f[$t] === ht) continue e
                Ie.push(dt)
              } else se(f, ht, $) || Ie.push(dt)
            }
            return Ie
          }
          var ns = HC(Uo),
            gC = HC(Um, !0)
          function CL(u, f) {
            var S = !0
            return (
              ns(u, function ($, K, se) {
                return (S = !!f($, K, se)), S
              }),
              S
            )
          }
          function Lf(u, f, S) {
            for (var $ = -1, K = u.length; ++$ < K; ) {
              var se = u[$],
                be = f(se)
              if (be != null && (Me === n ? be === be && !Li(be) : S(be, Me)))
                var Me = be,
                  Ie = se
            }
            return Ie
          }
          function wL(u, f, S, $) {
            var K = u.length
            for (
              S = tn(S),
                S < 0 && (S = -S > K ? 0 : K + S),
                $ = $ === n || $ > K ? K : tn($),
                $ < 0 && ($ += K),
                $ = S > $ ? 0 : Iw($);
              S < $;

            )
              u[S++] = f
            return u
          }
          function yC(u, f) {
            var S = []
            return (
              ns(u, function ($, K, se) {
                f($, K, se) && S.push($)
              }),
              S
            )
          }
          function Ar(u, f, S, $, K) {
            var se = -1,
              be = u.length
            for (S || (S = d5), K || (K = []); ++se < be; ) {
              var Me = u[se]
              f > 0 && S(Me)
                ? f > 1
                  ? Ar(Me, f - 1, S, $, K)
                  : Qa(K, Me)
                : $ || (K[K.length] = Me)
            }
            return K
          }
          var Vm = WC(),
            bC = WC(!0)
          function Uo(u, f) {
            return u && Vm(u, f, _r)
          }
          function Um(u, f) {
            return u && bC(u, f, _r)
          }
          function If(u, f) {
            return Ja(f, function (S) {
              return ba(u[S])
            })
          }
          function Hs(u, f) {
            f = is(f, u)
            for (var S = 0, $ = f.length; u != null && S < $; )
              u = u[Wo(f[S++])]
            return S && S == $ ? u : n
          }
          function _C(u, f, S) {
            var $ = f(u)
            return Qt(u) ? $ : Qa($, S(u))
          }
          function ni(u) {
            return u == null
              ? u === n
                ? X
                : ae
              : Fs && Fs in On(u)
              ? o5(u)
              : y5(u)
          }
          function Hm(u, f) {
            return u > f
          }
          function xL(u, f) {
            return u != null && Tn.call(u, f)
          }
          function ML(u, f) {
            return u != null && f in On(u)
          }
          function EL(u, f, S) {
            return u >= Hr(f, S) && u < dr(f, S)
          }
          function Wm(u, f, S) {
            for (
              var $ = S ? Em : vf,
                K = u[0].length,
                se = u.length,
                be = se,
                Me = Ze(se),
                Ie = 1 / 0,
                ut = [];
              be--;

            ) {
              var dt = u[be]
              be && f && (dt = Hn(dt, $i(f))),
                (Ie = Hr(dt.length, Ie)),
                (Me[be] =
                  !S && (f || (K >= 120 && dt.length >= 120))
                    ? new Vs(be && dt)
                    : n)
            }
            dt = u[0]
            var ht = -1,
              $t = Me[0]
            e: for (; ++ht < K && ut.length < Ie; ) {
              var Ut = dt[ht],
                qt = f ? f(Ut) : Ut
              if (
                ((Ut = S || Ut !== 0 ? Ut : 0),
                !($t ? Ec($t, qt) : $(ut, qt, S)))
              ) {
                for (be = se; --be; ) {
                  var nn = Me[be]
                  if (!(nn ? Ec(nn, qt) : $(u[be], qt, S))) continue e
                }
                $t && $t.push(qt), ut.push(Ut)
              }
            }
            return ut
          }
          function PL(u, f, S, $) {
            return (
              Uo(u, function (K, se, be) {
                f($, S(K), se, be)
              }),
              $
            )
          }
          function Ic(u, f, S) {
            ;(f = is(f, u)), (u = sw(u, f))
            var $ = u == null ? u : u[Wo(Yi(f))]
            return $ == null ? n : Ai($, u, S)
          }
          function SC(u) {
            return Zn(u) && ni(u) == ue
          }
          function TL(u) {
            return Zn(u) && ni(u) == xe
          }
          function kL(u) {
            return Zn(u) && ni(u) == Ve
          }
          function Rc(u, f, S, $, K) {
            return u === f
              ? !0
              : u == null || f == null || (!Zn(u) && !Zn(f))
              ? u !== u && f !== f
              : AL(u, f, S, $, Rc, K)
          }
          function AL(u, f, S, $, K, se) {
            var be = Qt(u),
              Me = Qt(f),
              Ie = be ? me : Wr(u),
              ut = Me ? me : Wr(f)
            ;(Ie = Ie == ue ? re : Ie), (ut = ut == ue ? re : ut)
            var dt = Ie == re,
              ht = ut == re,
              $t = Ie == ut
            if ($t && as(u)) {
              if (!as(f)) return !1
              ;(be = !0), (dt = !1)
            }
            if ($t && !dt)
              return (
                se || (se = new vo()),
                be || eu(u) ? ew(u, f, S, $, K, se) : r5(u, f, Ie, S, $, K, se)
              )
            if (!(S & g)) {
              var Ut = dt && Tn.call(u, '__wrapped__'),
                qt = ht && Tn.call(f, '__wrapped__')
              if (Ut || qt) {
                var nn = Ut ? u.value() : u,
                  Xt = qt ? f.value() : f
                return se || (se = new vo()), K(nn, Xt, S, $, se)
              }
            }
            return $t ? (se || (se = new vo()), i5(u, f, S, $, K, se)) : !1
          }
          function $L(u) {
            return Zn(u) && Wr(u) == z
          }
          function jm(u, f, S, $) {
            var K = S.length,
              se = K,
              be = !$
            if (u == null) return !se
            for (u = On(u); K--; ) {
              var Me = S[K]
              if (be && Me[2] ? Me[1] !== u[Me[0]] : !(Me[0] in u)) return !1
            }
            for (; ++K < se; ) {
              Me = S[K]
              var Ie = Me[0],
                ut = u[Ie],
                dt = Me[1]
              if (be && Me[2]) {
                if (ut === n && !(Ie in u)) return !1
              } else {
                var ht = new vo()
                if ($) var $t = $(ut, dt, Ie, u, f, ht)
                if (!($t === n ? Rc(dt, ut, g | _, $, ht) : $t)) return !1
              }
            }
            return !0
          }
          function CC(u) {
            if (!Gn(u) || h5(u)) return !1
            var f = ba(u) ? $O : rt
            return f.test(js(u))
          }
          function OL(u) {
            return Zn(u) && ni(u) == $e
          }
          function LL(u) {
            return Zn(u) && Wr(u) == Ae
          }
          function IL(u) {
            return Zn(u) && Zf(u.length) && !!Be[ni(u)]
          }
          function wC(u) {
            return typeof u == 'function'
              ? u
              : u == null
              ? yi
              : typeof u == 'object'
              ? Qt(u)
                ? EC(u[0], u[1])
                : MC(u)
              : jw(u)
          }
          function Gm(u) {
            if (!Bc(u)) return NO(u)
            var f = []
            for (var S in On(u))
              Tn.call(u, S) && S != 'constructor' && f.push(S)
            return f
          }
          function RL(u) {
            if (!Gn(u)) return g5(u)
            var f = Bc(u),
              S = []
            for (var $ in u)
              ($ == 'constructor' && (f || !Tn.call(u, $))) || S.push($)
            return S
          }
          function Km(u, f) {
            return u < f
          }
          function xC(u, f) {
            var S = -1,
              $ = mi(u) ? Ze(u.length) : []
            return (
              ns(u, function (K, se, be) {
                $[++S] = f(K, se, be)
              }),
              $
            )
          }
          function MC(u) {
            var f = lg(u)
            return f.length == 1 && f[0][2]
              ? ow(f[0][0], f[0][1])
              : function (S) {
                  return S === u || jm(S, u, f)
                }
          }
          function EC(u, f) {
            return cg(u) && iw(f)
              ? ow(Wo(u), f)
              : function (S) {
                  var $ = _g(S, u)
                  return $ === n && $ === f ? Sg(S, u) : Rc(f, $, g | _)
                }
          }
          function Rf(u, f, S, $, K) {
            u !== f &&
              Vm(
                f,
                function (se, be) {
                  if ((K || (K = new vo()), Gn(se))) DL(u, f, be, S, Rf, $, K)
                  else {
                    var Me = $ ? $(fg(u, be), se, be + '', u, f, K) : n
                    Me === n && (Me = se), Fm(u, be, Me)
                  }
                },
                gi
              )
          }
          function DL(u, f, S, $, K, se, be) {
            var Me = fg(u, S),
              Ie = fg(f, S),
              ut = be.get(Ie)
            if (ut) {
              Fm(u, S, ut)
              return
            }
            var dt = se ? se(Me, Ie, S + '', u, f, be) : n,
              ht = dt === n
            if (ht) {
              var $t = Qt(Ie),
                Ut = !$t && as(Ie),
                qt = !$t && !Ut && eu(Ie)
              ;(dt = Ie),
                $t || Ut || qt
                  ? Qt(Me)
                    ? (dt = Me)
                    : er(Me)
                    ? (dt = vi(Me))
                    : Ut
                    ? ((ht = !1), (dt = BC(Ie, !0)))
                    : qt
                    ? ((ht = !1), (dt = FC(Ie, !0)))
                    : (dt = [])
                  : zc(Ie) || Gs(Ie)
                  ? ((dt = Me),
                    Gs(Me)
                      ? (dt = Rw(Me))
                      : (!Gn(Me) || ba(Me)) && (dt = rw(Ie)))
                  : (ht = !1)
            }
            ht && (be.set(Ie, dt), K(dt, Ie, $, se, be), be.delete(Ie)),
              Fm(u, S, dt)
          }
          function PC(u, f) {
            var S = u.length
            if (S) return (f += f < 0 ? S : 0), ya(f, S) ? u[f] : n
          }
          function TC(u, f, S) {
            f.length
              ? (f = Hn(f, function (se) {
                  return Qt(se)
                    ? function (be) {
                        return Hs(be, se.length === 1 ? se[0] : se)
                      }
                    : se
                }))
              : (f = [yi])
            var $ = -1
            f = Hn(f, $i(Kt()))
            var K = xC(u, function (se, be, Me) {
              var Ie = Hn(f, function (ut) {
                return ut(se)
              })
              return { criteria: Ie, index: ++$, value: se }
            })
            return uO(K, function (se, be) {
              return XL(se, be, S)
            })
          }
          function NL(u, f) {
            return kC(u, f, function (S, $) {
              return Sg(u, $)
            })
          }
          function kC(u, f, S) {
            for (var $ = -1, K = f.length, se = {}; ++$ < K; ) {
              var be = f[$],
                Me = Hs(u, be)
              S(Me, be) && Dc(se, is(be, u), Me)
            }
            return se
          }
          function BL(u) {
            return function (f) {
              return Hs(f, u)
            }
          }
          function qm(u, f, S, $) {
            var K = $ ? lO : Hl,
              se = -1,
              be = f.length,
              Me = u
            for (u === f && (f = vi(f)), S && (Me = Hn(u, $i(S))); ++se < be; )
              for (
                var Ie = 0, ut = f[se], dt = S ? S(ut) : ut;
                (Ie = K(Me, dt, Ie, $)) > -1;

              )
                Me !== u && Mf.call(Me, Ie, 1), Mf.call(u, Ie, 1)
            return u
          }
          function AC(u, f) {
            for (var S = u ? f.length : 0, $ = S - 1; S--; ) {
              var K = f[S]
              if (S == $ || K !== se) {
                var se = K
                ya(K) ? Mf.call(u, K, 1) : Jm(u, K)
              }
            }
            return u
          }
          function Xm(u, f) {
            return u + Tf(cC() * (f - u + 1))
          }
          function FL(u, f, S, $) {
            for (
              var K = -1, se = dr(Pf((f - u) / (S || 1)), 0), be = Ze(se);
              se--;

            )
              (be[$ ? se : ++K] = u), (u += S)
            return be
          }
          function Ym(u, f) {
            var S = ''
            if (!u || f < 1 || f > W) return S
            do f % 2 && (S += u), (f = Tf(f / 2)), f && (u += u)
            while (f)
            return S
          }
          function on(u, f) {
            return hg(aw(u, f, yi), u + '')
          }
          function zL(u) {
            return hC(tu(u))
          }
          function VL(u, f) {
            var S = tu(u)
            return jf(S, Us(f, 0, S.length))
          }
          function Dc(u, f, S, $) {
            if (!Gn(u)) return u
            f = is(f, u)
            for (
              var K = -1, se = f.length, be = se - 1, Me = u;
              Me != null && ++K < se;

            ) {
              var Ie = Wo(f[K]),
                ut = S
              if (
                Ie === '__proto__' ||
                Ie === 'constructor' ||
                Ie === 'prototype'
              )
                return u
              if (K != be) {
                var dt = Me[Ie]
                ;(ut = $ ? $(dt, Ie, Me) : n),
                  ut === n && (ut = Gn(dt) ? dt : ya(f[K + 1]) ? [] : {})
              }
              Oc(Me, Ie, ut), (Me = Me[Ie])
            }
            return u
          }
          var $C = kf
              ? function (u, f) {
                  return kf.set(u, f), u
                }
              : yi,
            UL = Ef
              ? function (u, f) {
                  return Ef(u, 'toString', {
                    configurable: !0,
                    enumerable: !1,
                    value: wg(f),
                    writable: !0,
                  })
                }
              : yi
          function HL(u) {
            return jf(tu(u))
          }
          function Xi(u, f, S) {
            var $ = -1,
              K = u.length
            f < 0 && (f = -f > K ? 0 : K + f),
              (S = S > K ? K : S),
              S < 0 && (S += K),
              (K = f > S ? 0 : (S - f) >>> 0),
              (f >>>= 0)
            for (var se = Ze(K); ++$ < K; ) se[$] = u[$ + f]
            return se
          }
          function WL(u, f) {
            var S
            return (
              ns(u, function ($, K, se) {
                return (S = f($, K, se)), !S
              }),
              !!S
            )
          }
          function Df(u, f, S) {
            var $ = 0,
              K = u == null ? $ : u.length
            if (typeof f == 'number' && f === f && K <= oe) {
              for (; $ < K; ) {
                var se = ($ + K) >>> 1,
                  be = u[se]
                be !== null && !Li(be) && (S ? be <= f : be < f)
                  ? ($ = se + 1)
                  : (K = se)
              }
              return K
            }
            return Zm(u, f, yi, S)
          }
          function Zm(u, f, S, $) {
            var K = 0,
              se = u == null ? 0 : u.length
            if (se === 0) return 0
            f = S(f)
            for (
              var be = f !== f, Me = f === null, Ie = Li(f), ut = f === n;
              K < se;

            ) {
              var dt = Tf((K + se) / 2),
                ht = S(u[dt]),
                $t = ht !== n,
                Ut = ht === null,
                qt = ht === ht,
                nn = Li(ht)
              if (be) var Xt = $ || qt
              else
                ut
                  ? (Xt = qt && ($ || $t))
                  : Me
                  ? (Xt = qt && $t && ($ || !Ut))
                  : Ie
                  ? (Xt = qt && $t && !Ut && ($ || !nn))
                  : Ut || nn
                  ? (Xt = !1)
                  : (Xt = $ ? ht <= f : ht < f)
              Xt ? (K = dt + 1) : (se = dt)
            }
            return Hr(se, q)
          }
          function OC(u, f) {
            for (var S = -1, $ = u.length, K = 0, se = []; ++S < $; ) {
              var be = u[S],
                Me = f ? f(be) : be
              if (!S || !mo(Me, Ie)) {
                var Ie = Me
                se[K++] = be === 0 ? 0 : be
              }
            }
            return se
          }
          function LC(u) {
            return typeof u == 'number' ? u : Li(u) ? U : +u
          }
          function Oi(u) {
            if (typeof u == 'string') return u
            if (Qt(u)) return Hn(u, Oi) + ''
            if (Li(u)) return dC ? dC.call(u) : ''
            var f = u + ''
            return f == '0' && 1 / u == -L ? '-0' : f
          }
          function rs(u, f, S) {
            var $ = -1,
              K = vf,
              se = u.length,
              be = !0,
              Me = [],
              Ie = Me
            if (S) (be = !1), (K = Em)
            else if (se >= i) {
              var ut = f ? null : t5(u)
              if (ut) return gf(ut)
              ;(be = !1), (K = Ec), (Ie = new Vs())
            } else Ie = f ? [] : Me
            e: for (; ++$ < se; ) {
              var dt = u[$],
                ht = f ? f(dt) : dt
              if (((dt = S || dt !== 0 ? dt : 0), be && ht === ht)) {
                for (var $t = Ie.length; $t--; ) if (Ie[$t] === ht) continue e
                f && Ie.push(ht), Me.push(dt)
              } else K(Ie, ht, S) || (Ie !== Me && Ie.push(ht), Me.push(dt))
            }
            return Me
          }
          function Jm(u, f) {
            return (
              (f = is(f, u)), (u = sw(u, f)), u == null || delete u[Wo(Yi(f))]
            )
          }
          function IC(u, f, S, $) {
            return Dc(u, f, S(Hs(u, f)), $)
          }
          function Nf(u, f, S, $) {
            for (
              var K = u.length, se = $ ? K : -1;
              ($ ? se-- : ++se < K) && f(u[se], se, u);

            );
            return S
              ? Xi(u, $ ? 0 : se, $ ? se + 1 : K)
              : Xi(u, $ ? se + 1 : 0, $ ? K : se)
          }
          function RC(u, f) {
            var S = u
            return (
              S instanceof fn && (S = S.value()),
              Pm(
                f,
                function ($, K) {
                  return K.func.apply(K.thisArg, Qa([$], K.args))
                },
                S
              )
            )
          }
          function Qm(u, f, S) {
            var $ = u.length
            if ($ < 2) return $ ? rs(u[0]) : []
            for (var K = -1, se = Ze($); ++K < $; )
              for (var be = u[K], Me = -1; ++Me < $; )
                Me != K && (se[K] = Lc(se[K] || be, u[Me], f, S))
            return rs(Ar(se, 1), f, S)
          }
          function DC(u, f, S) {
            for (var $ = -1, K = u.length, se = f.length, be = {}; ++$ < K; ) {
              var Me = $ < se ? f[$] : n
              S(be, u[$], Me)
            }
            return be
          }
          function eg(u) {
            return er(u) ? u : []
          }
          function tg(u) {
            return typeof u == 'function' ? u : yi
          }
          function is(u, f) {
            return Qt(u) ? u : cg(u, f) ? [u] : dw(Mn(u))
          }
          var jL = on
          function os(u, f, S) {
            var $ = u.length
            return (S = S === n ? $ : S), !f && S >= $ ? u : Xi(u, f, S)
          }
          var NC =
            OO ||
            function (u) {
              return jn.clearTimeout(u)
            }
          function BC(u, f) {
            if (f) return u.slice()
            var S = u.length,
              $ = oC ? oC(S) : new u.constructor(S)
            return u.copy($), $
          }
          function ng(u) {
            var f = new u.constructor(u.byteLength)
            return new wf(f).set(new wf(u)), f
          }
          function GL(u, f) {
            var S = f ? ng(u.buffer) : u.buffer
            return new u.constructor(S, u.byteOffset, u.byteLength)
          }
          function KL(u) {
            var f = new u.constructor(u.source, Ue.exec(u))
            return (f.lastIndex = u.lastIndex), f
          }
          function qL(u) {
            return $c ? On($c.call(u)) : {}
          }
          function FC(u, f) {
            var S = f ? ng(u.buffer) : u.buffer
            return new u.constructor(S, u.byteOffset, u.length)
          }
          function zC(u, f) {
            if (u !== f) {
              var S = u !== n,
                $ = u === null,
                K = u === u,
                se = Li(u),
                be = f !== n,
                Me = f === null,
                Ie = f === f,
                ut = Li(f)
              if (
                (!Me && !ut && !se && u > f) ||
                (se && be && Ie && !Me && !ut) ||
                ($ && be && Ie) ||
                (!S && Ie) ||
                !K
              )
                return 1
              if (
                (!$ && !se && !ut && u < f) ||
                (ut && S && K && !$ && !se) ||
                (Me && S && K) ||
                (!be && K) ||
                !Ie
              )
                return -1
            }
            return 0
          }
          function XL(u, f, S) {
            for (
              var $ = -1,
                K = u.criteria,
                se = f.criteria,
                be = K.length,
                Me = S.length;
              ++$ < be;

            ) {
              var Ie = zC(K[$], se[$])
              if (Ie) {
                if ($ >= Me) return Ie
                var ut = S[$]
                return Ie * (ut == 'desc' ? -1 : 1)
              }
            }
            return u.index - f.index
          }
          function VC(u, f, S, $) {
            for (
              var K = -1,
                se = u.length,
                be = S.length,
                Me = -1,
                Ie = f.length,
                ut = dr(se - be, 0),
                dt = Ze(Ie + ut),
                ht = !$;
              ++Me < Ie;

            )
              dt[Me] = f[Me]
            for (; ++K < be; ) (ht || K < se) && (dt[S[K]] = u[K])
            for (; ut--; ) dt[Me++] = u[K++]
            return dt
          }
          function UC(u, f, S, $) {
            for (
              var K = -1,
                se = u.length,
                be = -1,
                Me = S.length,
                Ie = -1,
                ut = f.length,
                dt = dr(se - Me, 0),
                ht = Ze(dt + ut),
                $t = !$;
              ++K < dt;

            )
              ht[K] = u[K]
            for (var Ut = K; ++Ie < ut; ) ht[Ut + Ie] = f[Ie]
            for (; ++be < Me; ) ($t || K < se) && (ht[Ut + S[be]] = u[K++])
            return ht
          }
          function vi(u, f) {
            var S = -1,
              $ = u.length
            for (f || (f = Ze($)); ++S < $; ) f[S] = u[S]
            return f
          }
          function Ho(u, f, S, $) {
            var K = !S
            S || (S = {})
            for (var se = -1, be = f.length; ++se < be; ) {
              var Me = f[se],
                Ie = $ ? $(S[Me], u[Me], Me, S, u) : n
              Ie === n && (Ie = u[Me]), K ? va(S, Me, Ie) : Oc(S, Me, Ie)
            }
            return S
          }
          function YL(u, f) {
            return Ho(u, ug(u), f)
          }
          function ZL(u, f) {
            return Ho(u, tw(u), f)
          }
          function Bf(u, f) {
            return function (S, $) {
              var K = Qt(S) ? nO : bL,
                se = f ? f() : {}
              return K(S, u, Kt($, 2), se)
            }
          }
          function Zl(u) {
            return on(function (f, S) {
              var $ = -1,
                K = S.length,
                se = K > 1 ? S[K - 1] : n,
                be = K > 2 ? S[2] : n
              for (
                se = u.length > 3 && typeof se == 'function' ? (K--, se) : n,
                  be && ri(S[0], S[1], be) && ((se = K < 3 ? n : se), (K = 1)),
                  f = On(f);
                ++$ < K;

              ) {
                var Me = S[$]
                Me && u(f, Me, $, se)
              }
              return f
            })
          }
          function HC(u, f) {
            return function (S, $) {
              if (S == null) return S
              if (!mi(S)) return u(S, $)
              for (
                var K = S.length, se = f ? K : -1, be = On(S);
                (f ? se-- : ++se < K) && $(be[se], se, be) !== !1;

              );
              return S
            }
          }
          function WC(u) {
            return function (f, S, $) {
              for (var K = -1, se = On(f), be = $(f), Me = be.length; Me--; ) {
                var Ie = be[u ? Me : ++K]
                if (S(se[Ie], Ie, se) === !1) break
              }
              return f
            }
          }
          function JL(u, f, S) {
            var $ = f & b,
              K = Nc(u)
            function se() {
              var be = this && this !== jn && this instanceof se ? K : u
              return be.apply($ ? S : this, arguments)
            }
            return se
          }
          function jC(u) {
            return function (f) {
              f = Mn(f)
              var S = Wl(f) ? po(f) : n,
                $ = S ? S[0] : f.charAt(0),
                K = S ? os(S, 1).join('') : f.slice(1)
              return $[u]() + K
            }
          }
          function Jl(u) {
            return function (f) {
              return Pm(Hw(Uw(f).replace(cf, '')), u, '')
            }
          }
          function Nc(u) {
            return function () {
              var f = arguments
              switch (f.length) {
                case 0:
                  return new u()
                case 1:
                  return new u(f[0])
                case 2:
                  return new u(f[0], f[1])
                case 3:
                  return new u(f[0], f[1], f[2])
                case 4:
                  return new u(f[0], f[1], f[2], f[3])
                case 5:
                  return new u(f[0], f[1], f[2], f[3], f[4])
                case 6:
                  return new u(f[0], f[1], f[2], f[3], f[4], f[5])
                case 7:
                  return new u(f[0], f[1], f[2], f[3], f[4], f[5], f[6])
              }
              var S = Yl(u.prototype),
                $ = u.apply(S, f)
              return Gn($) ? $ : S
            }
          }
          function QL(u, f, S) {
            var $ = Nc(u)
            function K() {
              for (
                var se = arguments.length, be = Ze(se), Me = se, Ie = Ql(K);
                Me--;

              )
                be[Me] = arguments[Me]
              var ut =
                se < 3 && be[0] !== Ie && be[se - 1] !== Ie ? [] : es(be, Ie)
              if (((se -= ut.length), se < S))
                return YC(u, f, Ff, K.placeholder, n, be, ut, n, n, S - se)
              var dt = this && this !== jn && this instanceof K ? $ : u
              return Ai(dt, this, be)
            }
            return K
          }
          function GC(u) {
            return function (f, S, $) {
              var K = On(f)
              if (!mi(f)) {
                var se = Kt(S, 3)
                ;(f = _r(f)),
                  (S = function (Me) {
                    return se(K[Me], Me, K)
                  })
              }
              var be = u(f, S, $)
              return be > -1 ? K[se ? f[be] : be] : n
            }
          }
          function KC(u) {
            return ga(function (f) {
              var S = f.length,
                $ = S,
                K = Ki.prototype.thru
              for (u && f.reverse(); $--; ) {
                var se = f[$]
                if (typeof se != 'function') throw new Gi(a)
                if (K && !be && Hf(se) == 'wrapper') var be = new Ki([], !0)
              }
              for ($ = be ? $ : S; ++$ < S; ) {
                se = f[$]
                var Me = Hf(se),
                  Ie = Me == 'wrapper' ? sg(se) : n
                Ie &&
                dg(Ie[0]) &&
                Ie[1] == (A | x | E | F) &&
                !Ie[4].length &&
                Ie[9] == 1
                  ? (be = be[Hf(Ie[0])].apply(be, Ie[3]))
                  : (be = se.length == 1 && dg(se) ? be[Me]() : be.thru(se))
              }
              return function () {
                var ut = arguments,
                  dt = ut[0]
                if (be && ut.length == 1 && Qt(dt)) return be.plant(dt).value()
                for (
                  var ht = 0, $t = S ? f[ht].apply(this, ut) : dt;
                  ++ht < S;

                )
                  $t = f[ht].call(this, $t)
                return $t
              }
            })
          }
          function Ff(u, f, S, $, K, se, be, Me, Ie, ut) {
            var dt = f & A,
              ht = f & b,
              $t = f & y,
              Ut = f & (x | w),
              qt = f & T,
              nn = $t ? n : Nc(u)
            function Xt() {
              for (var dn = arguments.length, mn = Ze(dn), Ii = dn; Ii--; )
                mn[Ii] = arguments[Ii]
              if (Ut)
                var ii = Ql(Xt),
                  Ri = dO(mn, ii)
              if (
                ($ && (mn = VC(mn, $, K, Ut)),
                se && (mn = UC(mn, se, be, Ut)),
                (dn -= Ri),
                Ut && dn < ut)
              ) {
                var tr = es(mn, ii)
                return YC(u, f, Ff, Xt.placeholder, S, mn, tr, Me, Ie, ut - dn)
              }
              var go = ht ? S : this,
                Sa = $t ? go[u] : u
              return (
                (dn = mn.length),
                Me ? (mn = b5(mn, Me)) : qt && dn > 1 && mn.reverse(),
                dt && Ie < dn && (mn.length = Ie),
                this &&
                  this !== jn &&
                  this instanceof Xt &&
                  (Sa = nn || Nc(Sa)),
                Sa.apply(go, mn)
              )
            }
            return Xt
          }
          function qC(u, f) {
            return function (S, $) {
              return PL(S, u, f($), {})
            }
          }
          function zf(u, f) {
            return function (S, $) {
              var K
              if (S === n && $ === n) return f
              if ((S !== n && (K = S), $ !== n)) {
                if (K === n) return $
                typeof S == 'string' || typeof $ == 'string'
                  ? ((S = Oi(S)), ($ = Oi($)))
                  : ((S = LC(S)), ($ = LC($))),
                  (K = u(S, $))
              }
              return K
            }
          }
          function rg(u) {
            return ga(function (f) {
              return (
                (f = Hn(f, $i(Kt()))),
                on(function (S) {
                  var $ = this
                  return u(f, function (K) {
                    return Ai(K, $, S)
                  })
                })
              )
            })
          }
          function Vf(u, f) {
            f = f === n ? ' ' : Oi(f)
            var S = f.length
            if (S < 2) return S ? Ym(f, u) : f
            var $ = Ym(f, Pf(u / jl(f)))
            return Wl(f) ? os(po($), 0, u).join('') : $.slice(0, u)
          }
          function e5(u, f, S, $) {
            var K = f & b,
              se = Nc(u)
            function be() {
              for (
                var Me = -1,
                  Ie = arguments.length,
                  ut = -1,
                  dt = $.length,
                  ht = Ze(dt + Ie),
                  $t = this && this !== jn && this instanceof be ? se : u;
                ++ut < dt;

              )
                ht[ut] = $[ut]
              for (; Ie--; ) ht[ut++] = arguments[++Me]
              return Ai($t, K ? S : this, ht)
            }
            return be
          }
          function XC(u) {
            return function (f, S, $) {
              return (
                $ && typeof $ != 'number' && ri(f, S, $) && (S = $ = n),
                (f = _a(f)),
                S === n ? ((S = f), (f = 0)) : (S = _a(S)),
                ($ = $ === n ? (f < S ? 1 : -1) : _a($)),
                FL(f, S, $, u)
              )
            }
          }
          function Uf(u) {
            return function (f, S) {
              return (
                (typeof f == 'string' && typeof S == 'string') ||
                  ((f = Zi(f)), (S = Zi(S))),
                u(f, S)
              )
            }
          }
          function YC(u, f, S, $, K, se, be, Me, Ie, ut) {
            var dt = f & x,
              ht = dt ? be : n,
              $t = dt ? n : be,
              Ut = dt ? se : n,
              qt = dt ? n : se
            ;(f |= dt ? E : P), (f &= ~(dt ? P : E)), f & M || (f &= ~(b | y))
            var nn = [u, f, K, Ut, ht, qt, $t, Me, Ie, ut],
              Xt = S.apply(n, nn)
            return dg(u) && lw(Xt, nn), (Xt.placeholder = $), uw(Xt, u, f)
          }
          function ig(u) {
            var f = cr[u]
            return function (S, $) {
              if (
                ((S = Zi(S)), ($ = $ == null ? 0 : Hr(tn($), 292)), $ && uC(S))
              ) {
                var K = (Mn(S) + 'e').split('e'),
                  se = f(K[0] + 'e' + (+K[1] + $))
                return (
                  (K = (Mn(se) + 'e').split('e')), +(K[0] + 'e' + (+K[1] - $))
                )
              }
              return f(S)
            }
          }
          var t5 =
            ql && 1 / gf(new ql([, -0]))[1] == L
              ? function (u) {
                  return new ql(u)
                }
              : Eg
          function ZC(u) {
            return function (f) {
              var S = Wr(f)
              return S == z ? Im(f) : S == Ae ? yO(f) : cO(f, u(f))
            }
          }
          function ma(u, f, S, $, K, se, be, Me) {
            var Ie = f & y
            if (!Ie && typeof u != 'function') throw new Gi(a)
            var ut = $ ? $.length : 0
            if (
              (ut || ((f &= ~(E | P)), ($ = K = n)),
              (be = be === n ? be : dr(tn(be), 0)),
              (Me = Me === n ? Me : tn(Me)),
              (ut -= K ? K.length : 0),
              f & P)
            ) {
              var dt = $,
                ht = K
              $ = K = n
            }
            var $t = Ie ? n : sg(u),
              Ut = [u, f, S, $, K, dt, ht, se, be, Me]
            if (
              ($t && m5(Ut, $t),
              (u = Ut[0]),
              (f = Ut[1]),
              (S = Ut[2]),
              ($ = Ut[3]),
              (K = Ut[4]),
              (Me = Ut[9] =
                Ut[9] === n ? (Ie ? 0 : u.length) : dr(Ut[9] - ut, 0)),
              !Me && f & (x | w) && (f &= ~(x | w)),
              !f || f == b)
            )
              var qt = JL(u, f, S)
            else
              f == x || f == w
                ? (qt = QL(u, f, Me))
                : (f == E || f == (b | E)) && !K.length
                ? (qt = e5(u, f, S, $))
                : (qt = Ff.apply(n, Ut))
            var nn = $t ? $C : lw
            return uw(nn(qt, Ut), u, f)
          }
          function JC(u, f, S, $) {
            return u === n || (mo(u, Kl[S]) && !Tn.call($, S)) ? f : u
          }
          function QC(u, f, S, $, K, se) {
            return (
              Gn(u) &&
                Gn(f) &&
                (se.set(f, u), Rf(u, f, n, QC, se), se.delete(f)),
              u
            )
          }
          function n5(u) {
            return zc(u) ? n : u
          }
          function ew(u, f, S, $, K, se) {
            var be = S & g,
              Me = u.length,
              Ie = f.length
            if (Me != Ie && !(be && Ie > Me)) return !1
            var ut = se.get(u),
              dt = se.get(f)
            if (ut && dt) return ut == f && dt == u
            var ht = -1,
              $t = !0,
              Ut = S & _ ? new Vs() : n
            for (se.set(u, f), se.set(f, u); ++ht < Me; ) {
              var qt = u[ht],
                nn = f[ht]
              if ($)
                var Xt = be ? $(nn, qt, ht, f, u, se) : $(qt, nn, ht, u, f, se)
              if (Xt !== n) {
                if (Xt) continue
                $t = !1
                break
              }
              if (Ut) {
                if (
                  !Tm(f, function (dn, mn) {
                    if (!Ec(Ut, mn) && (qt === dn || K(qt, dn, S, $, se)))
                      return Ut.push(mn)
                  })
                ) {
                  $t = !1
                  break
                }
              } else if (!(qt === nn || K(qt, nn, S, $, se))) {
                $t = !1
                break
              }
            }
            return se.delete(u), se.delete(f), $t
          }
          function r5(u, f, S, $, K, se, be) {
            switch (S) {
              case ne:
                if (
                  u.byteLength != f.byteLength ||
                  u.byteOffset != f.byteOffset
                )
                  return !1
                ;(u = u.buffer), (f = f.buffer)
              case xe:
                return !(
                  u.byteLength != f.byteLength || !se(new wf(u), new wf(f))
                )
              case qe:
              case Ve:
              case ie:
                return mo(+u, +f)
              case We:
                return u.name == f.name && u.message == f.message
              case $e:
              case ft:
                return u == f + ''
              case z:
                var Me = Im
              case Ae:
                var Ie = $ & g
                if ((Me || (Me = gf), u.size != f.size && !Ie)) return !1
                var ut = be.get(u)
                if (ut) return ut == f
                ;($ |= _), be.set(u, f)
                var dt = ew(Me(u), Me(f), $, K, se, be)
                return be.delete(u), dt
              case Q:
                if ($c) return $c.call(u) == $c.call(f)
            }
            return !1
          }
          function i5(u, f, S, $, K, se) {
            var be = S & g,
              Me = og(u),
              Ie = Me.length,
              ut = og(f),
              dt = ut.length
            if (Ie != dt && !be) return !1
            for (var ht = Ie; ht--; ) {
              var $t = Me[ht]
              if (!(be ? $t in f : Tn.call(f, $t))) return !1
            }
            var Ut = se.get(u),
              qt = se.get(f)
            if (Ut && qt) return Ut == f && qt == u
            var nn = !0
            se.set(u, f), se.set(f, u)
            for (var Xt = be; ++ht < Ie; ) {
              $t = Me[ht]
              var dn = u[$t],
                mn = f[$t]
              if ($)
                var Ii = be ? $(mn, dn, $t, f, u, se) : $(dn, mn, $t, u, f, se)
              if (!(Ii === n ? dn === mn || K(dn, mn, S, $, se) : Ii)) {
                nn = !1
                break
              }
              Xt || (Xt = $t == 'constructor')
            }
            if (nn && !Xt) {
              var ii = u.constructor,
                Ri = f.constructor
              ii != Ri &&
                'constructor' in u &&
                'constructor' in f &&
                !(
                  typeof ii == 'function' &&
                  ii instanceof ii &&
                  typeof Ri == 'function' &&
                  Ri instanceof Ri
                ) &&
                (nn = !1)
            }
            return se.delete(u), se.delete(f), nn
          }
          function ga(u) {
            return hg(aw(u, n, vw), u + '')
          }
          function og(u) {
            return _C(u, _r, ug)
          }
          function ag(u) {
            return _C(u, gi, tw)
          }
          var sg = kf
            ? function (u) {
                return kf.get(u)
              }
            : Eg
          function Hf(u) {
            for (
              var f = u.name + '', S = Xl[f], $ = Tn.call(Xl, f) ? S.length : 0;
              $--;

            ) {
              var K = S[$],
                se = K.func
              if (se == null || se == u) return K.name
            }
            return f
          }
          function Ql(u) {
            var f = Tn.call(ee, 'placeholder') ? ee : u
            return f.placeholder
          }
          function Kt() {
            var u = ee.iteratee || xg
            return (
              (u = u === xg ? wC : u),
              arguments.length ? u(arguments[0], arguments[1]) : u
            )
          }
          function Wf(u, f) {
            var S = u.__data__
            return f5(f) ? S[typeof f == 'string' ? 'string' : 'hash'] : S.map
          }
          function lg(u) {
            for (var f = _r(u), S = f.length; S--; ) {
              var $ = f[S],
                K = u[$]
              f[S] = [$, K, iw(K)]
            }
            return f
          }
          function Ws(u, f) {
            var S = vO(u, f)
            return CC(S) ? S : n
          }
          function o5(u) {
            var f = Tn.call(u, Fs),
              S = u[Fs]
            try {
              u[Fs] = n
              var $ = !0
            } catch {}
            var K = Sf.call(u)
            return $ && (f ? (u[Fs] = S) : delete u[Fs]), K
          }
          var ug = Dm
              ? function (u) {
                  return u == null
                    ? []
                    : ((u = On(u)),
                      Ja(Dm(u), function (f) {
                        return sC.call(u, f)
                      }))
                }
              : Pg,
            tw = Dm
              ? function (u) {
                  for (var f = []; u; ) Qa(f, ug(u)), (u = xf(u))
                  return f
                }
              : Pg,
            Wr = ni
          ;((Nm && Wr(new Nm(new ArrayBuffer(1))) != ne) ||
            (Tc && Wr(new Tc()) != z) ||
            (Bm && Wr(Bm.resolve()) != pe) ||
            (ql && Wr(new ql()) != Ae) ||
            (kc && Wr(new kc()) != he)) &&
            (Wr = function (u) {
              var f = ni(u),
                S = f == re ? u.constructor : n,
                $ = S ? js(S) : ''
              if ($)
                switch ($) {
                  case VO:
                    return ne
                  case UO:
                    return z
                  case HO:
                    return pe
                  case WO:
                    return Ae
                  case jO:
                    return he
                }
              return f
            })
          function a5(u, f, S) {
            for (var $ = -1, K = S.length; ++$ < K; ) {
              var se = S[$],
                be = se.size
              switch (se.type) {
                case 'drop':
                  u += be
                  break
                case 'dropRight':
                  f -= be
                  break
                case 'take':
                  f = Hr(f, u + be)
                  break
                case 'takeRight':
                  u = dr(u, f - be)
                  break
              }
            }
            return { start: u, end: f }
          }
          function s5(u) {
            var f = u.match(co)
            return f ? f[1].split(ki) : []
          }
          function nw(u, f, S) {
            f = is(f, u)
            for (var $ = -1, K = f.length, se = !1; ++$ < K; ) {
              var be = Wo(f[$])
              if (!(se = u != null && S(u, be))) break
              u = u[be]
            }
            return se || ++$ != K
              ? se
              : ((K = u == null ? 0 : u.length),
                !!K && Zf(K) && ya(be, K) && (Qt(u) || Gs(u)))
          }
          function l5(u) {
            var f = u.length,
              S = new u.constructor(f)
            return (
              f &&
                typeof u[0] == 'string' &&
                Tn.call(u, 'index') &&
                ((S.index = u.index), (S.input = u.input)),
              S
            )
          }
          function rw(u) {
            return typeof u.constructor == 'function' && !Bc(u) ? Yl(xf(u)) : {}
          }
          function u5(u, f, S) {
            var $ = u.constructor
            switch (f) {
              case xe:
                return ng(u)
              case qe:
              case Ve:
                return new $(+u)
              case ne:
                return GL(u, S)
              case Le:
              case et:
              case Ne:
              case Et:
              case kt:
              case je:
              case Ge:
              case Ye:
              case lt:
                return FC(u, S)
              case z:
                return new $()
              case ie:
              case ft:
                return new $(u)
              case $e:
                return KL(u)
              case Ae:
                return new $()
              case Q:
                return qL(u)
            }
          }
          function c5(u, f) {
            var S = f.length
            if (!S) return u
            var $ = S - 1
            return (
              (f[$] = (S > 1 ? '& ' : '') + f[$]),
              (f = f.join(S > 2 ? ', ' : ' ')),
              u.replace(
                da,
                `{
/* [wrapped with ` +
                  f +
                  `] */
`
              )
            )
          }
          function d5(u) {
            return Qt(u) || Gs(u) || !!(lC && u && u[lC])
          }
          function ya(u, f) {
            var S = typeof u
            return (
              (f = f ?? W),
              !!f &&
                (S == 'number' || (S != 'symbol' && Ke.test(u))) &&
                u > -1 &&
                u % 1 == 0 &&
                u < f
            )
          }
          function ri(u, f, S) {
            if (!Gn(S)) return !1
            var $ = typeof f
            return (
              $ == 'number' ? mi(S) && ya(f, S.length) : $ == 'string' && f in S
            )
              ? mo(S[f], u)
              : !1
          }
          function cg(u, f) {
            if (Qt(u)) return !1
            var S = typeof u
            return S == 'number' ||
              S == 'symbol' ||
              S == 'boolean' ||
              u == null ||
              Li(u)
              ? !0
              : Gt.test(u) || !vt.test(u) || (f != null && u in On(f))
          }
          function f5(u) {
            var f = typeof u
            return f == 'string' ||
              f == 'number' ||
              f == 'symbol' ||
              f == 'boolean'
              ? u !== '__proto__'
              : u === null
          }
          function dg(u) {
            var f = Hf(u),
              S = ee[f]
            if (typeof S != 'function' || !(f in fn.prototype)) return !1
            if (u === S) return !0
            var $ = sg(S)
            return !!$ && u === $[0]
          }
          function h5(u) {
            return !!iC && iC in u
          }
          var p5 = bf ? ba : Tg
          function Bc(u) {
            var f = u && u.constructor,
              S = (typeof f == 'function' && f.prototype) || Kl
            return u === S
          }
          function iw(u) {
            return u === u && !Gn(u)
          }
          function ow(u, f) {
            return function (S) {
              return S == null ? !1 : S[u] === f && (f !== n || u in On(S))
            }
          }
          function v5(u) {
            var f = Xf(u, function ($) {
                return S.size === c && S.clear(), $
              }),
              S = f.cache
            return f
          }
          function m5(u, f) {
            var S = u[1],
              $ = f[1],
              K = S | $,
              se = K < (b | y | A),
              be =
                ($ == A && S == x) ||
                ($ == A && S == F && u[7].length <= f[8]) ||
                ($ == (A | F) && f[7].length <= f[8] && S == x)
            if (!(se || be)) return u
            $ & b && ((u[2] = f[2]), (K |= S & b ? 0 : M))
            var Me = f[3]
            if (Me) {
              var Ie = u[3]
              ;(u[3] = Ie ? VC(Ie, Me, f[4]) : Me),
                (u[4] = Ie ? es(u[3], d) : f[4])
            }
            return (
              (Me = f[5]),
              Me &&
                ((Ie = u[5]),
                (u[5] = Ie ? UC(Ie, Me, f[6]) : Me),
                (u[6] = Ie ? es(u[5], d) : f[6])),
              (Me = f[7]),
              Me && (u[7] = Me),
              $ & A && (u[8] = u[8] == null ? f[8] : Hr(u[8], f[8])),
              u[9] == null && (u[9] = f[9]),
              (u[0] = f[0]),
              (u[1] = K),
              u
            )
          }
          function g5(u) {
            var f = []
            if (u != null) for (var S in On(u)) f.push(S)
            return f
          }
          function y5(u) {
            return Sf.call(u)
          }
          function aw(u, f, S) {
            return (
              (f = dr(f === n ? u.length - 1 : f, 0)),
              function () {
                for (
                  var $ = arguments,
                    K = -1,
                    se = dr($.length - f, 0),
                    be = Ze(se);
                  ++K < se;

                )
                  be[K] = $[f + K]
                K = -1
                for (var Me = Ze(f + 1); ++K < f; ) Me[K] = $[K]
                return (Me[f] = S(be)), Ai(u, this, Me)
              }
            )
          }
          function sw(u, f) {
            return f.length < 2 ? u : Hs(u, Xi(f, 0, -1))
          }
          function b5(u, f) {
            for (var S = u.length, $ = Hr(f.length, S), K = vi(u); $--; ) {
              var se = f[$]
              u[$] = ya(se, S) ? K[se] : n
            }
            return u
          }
          function fg(u, f) {
            if (
              !(f === 'constructor' && typeof u[f] == 'function') &&
              f != '__proto__'
            )
              return u[f]
          }
          var lw = cw($C),
            Fc =
              IO ||
              function (u, f) {
                return jn.setTimeout(u, f)
              },
            hg = cw(UL)
          function uw(u, f, S) {
            var $ = f + ''
            return hg(u, c5($, _5(s5($), S)))
          }
          function cw(u) {
            var f = 0,
              S = 0
            return function () {
              var $ = BO(),
                K = N - ($ - S)
              if (((S = $), K > 0)) {
                if (++f >= j) return arguments[0]
              } else f = 0
              return u.apply(n, arguments)
            }
          }
          function jf(u, f) {
            var S = -1,
              $ = u.length,
              K = $ - 1
            for (f = f === n ? $ : f; ++S < f; ) {
              var se = Xm(S, K),
                be = u[se]
              ;(u[se] = u[S]), (u[S] = be)
            }
            return (u.length = f), u
          }
          var dw = v5(function (u) {
            var f = []
            return (
              u.charCodeAt(0) === 46 && f.push(''),
              u.replace(pn, function (S, $, K, se) {
                f.push(K ? se.replace(Rs, '$1') : $ || S)
              }),
              f
            )
          })
          function Wo(u) {
            if (typeof u == 'string' || Li(u)) return u
            var f = u + ''
            return f == '0' && 1 / u == -L ? '-0' : f
          }
          function js(u) {
            if (u != null) {
              try {
                return _f.call(u)
              } catch {}
              try {
                return u + ''
              } catch {}
            }
            return ''
          }
          function _5(u, f) {
            return (
              ji(te, function (S) {
                var $ = '_.' + S[0]
                f & S[1] && !vf(u, $) && u.push($)
              }),
              u.sort()
            )
          }
          function fw(u) {
            if (u instanceof fn) return u.clone()
            var f = new Ki(u.__wrapped__, u.__chain__)
            return (
              (f.__actions__ = vi(u.__actions__)),
              (f.__index__ = u.__index__),
              (f.__values__ = u.__values__),
              f
            )
          }
          function S5(u, f, S) {
            ;(S ? ri(u, f, S) : f === n) ? (f = 1) : (f = dr(tn(f), 0))
            var $ = u == null ? 0 : u.length
            if (!$ || f < 1) return []
            for (var K = 0, se = 0, be = Ze(Pf($ / f)); K < $; )
              be[se++] = Xi(u, K, (K += f))
            return be
          }
          function C5(u) {
            for (
              var f = -1, S = u == null ? 0 : u.length, $ = 0, K = [];
              ++f < S;

            ) {
              var se = u[f]
              se && (K[$++] = se)
            }
            return K
          }
          function w5() {
            var u = arguments.length
            if (!u) return []
            for (var f = Ze(u - 1), S = arguments[0], $ = u; $--; )
              f[$ - 1] = arguments[$]
            return Qa(Qt(S) ? vi(S) : [S], Ar(f, 1))
          }
          var x5 = on(function (u, f) {
              return er(u) ? Lc(u, Ar(f, 1, er, !0)) : []
            }),
            M5 = on(function (u, f) {
              var S = Yi(f)
              return (
                er(S) && (S = n), er(u) ? Lc(u, Ar(f, 1, er, !0), Kt(S, 2)) : []
              )
            }),
            E5 = on(function (u, f) {
              var S = Yi(f)
              return (
                er(S) && (S = n), er(u) ? Lc(u, Ar(f, 1, er, !0), n, S) : []
              )
            })
          function P5(u, f, S) {
            var $ = u == null ? 0 : u.length
            return $
              ? ((f = S || f === n ? 1 : tn(f)), Xi(u, f < 0 ? 0 : f, $))
              : []
          }
          function T5(u, f, S) {
            var $ = u == null ? 0 : u.length
            return $
              ? ((f = S || f === n ? 1 : tn(f)),
                (f = $ - f),
                Xi(u, 0, f < 0 ? 0 : f))
              : []
          }
          function k5(u, f) {
            return u && u.length ? Nf(u, Kt(f, 3), !0, !0) : []
          }
          function A5(u, f) {
            return u && u.length ? Nf(u, Kt(f, 3), !0) : []
          }
          function $5(u, f, S, $) {
            var K = u == null ? 0 : u.length
            return K
              ? (S && typeof S != 'number' && ri(u, f, S) && ((S = 0), ($ = K)),
                wL(u, f, S, $))
              : []
          }
          function hw(u, f, S) {
            var $ = u == null ? 0 : u.length
            if (!$) return -1
            var K = S == null ? 0 : tn(S)
            return K < 0 && (K = dr($ + K, 0)), mf(u, Kt(f, 3), K)
          }
          function pw(u, f, S) {
            var $ = u == null ? 0 : u.length
            if (!$) return -1
            var K = $ - 1
            return (
              S !== n &&
                ((K = tn(S)), (K = S < 0 ? dr($ + K, 0) : Hr(K, $ - 1))),
              mf(u, Kt(f, 3), K, !0)
            )
          }
          function vw(u) {
            var f = u == null ? 0 : u.length
            return f ? Ar(u, 1) : []
          }
          function O5(u) {
            var f = u == null ? 0 : u.length
            return f ? Ar(u, L) : []
          }
          function L5(u, f) {
            var S = u == null ? 0 : u.length
            return S ? ((f = f === n ? 1 : tn(f)), Ar(u, f)) : []
          }
          function I5(u) {
            for (var f = -1, S = u == null ? 0 : u.length, $ = {}; ++f < S; ) {
              var K = u[f]
              $[K[0]] = K[1]
            }
            return $
          }
          function mw(u) {
            return u && u.length ? u[0] : n
          }
          function R5(u, f, S) {
            var $ = u == null ? 0 : u.length
            if (!$) return -1
            var K = S == null ? 0 : tn(S)
            return K < 0 && (K = dr($ + K, 0)), Hl(u, f, K)
          }
          function D5(u) {
            var f = u == null ? 0 : u.length
            return f ? Xi(u, 0, -1) : []
          }
          var N5 = on(function (u) {
              var f = Hn(u, eg)
              return f.length && f[0] === u[0] ? Wm(f) : []
            }),
            B5 = on(function (u) {
              var f = Yi(u),
                S = Hn(u, eg)
              return (
                f === Yi(S) ? (f = n) : S.pop(),
                S.length && S[0] === u[0] ? Wm(S, Kt(f, 2)) : []
              )
            }),
            F5 = on(function (u) {
              var f = Yi(u),
                S = Hn(u, eg)
              return (
                (f = typeof f == 'function' ? f : n),
                f && S.pop(),
                S.length && S[0] === u[0] ? Wm(S, n, f) : []
              )
            })
          function z5(u, f) {
            return u == null ? '' : DO.call(u, f)
          }
          function Yi(u) {
            var f = u == null ? 0 : u.length
            return f ? u[f - 1] : n
          }
          function V5(u, f, S) {
            var $ = u == null ? 0 : u.length
            if (!$) return -1
            var K = $
            return (
              S !== n &&
                ((K = tn(S)), (K = K < 0 ? dr($ + K, 0) : Hr(K, $ - 1))),
              f === f ? _O(u, f, K) : mf(u, YS, K, !0)
            )
          }
          function U5(u, f) {
            return u && u.length ? PC(u, tn(f)) : n
          }
          var H5 = on(gw)
          function gw(u, f) {
            return u && u.length && f && f.length ? qm(u, f) : u
          }
          function W5(u, f, S) {
            return u && u.length && f && f.length ? qm(u, f, Kt(S, 2)) : u
          }
          function j5(u, f, S) {
            return u && u.length && f && f.length ? qm(u, f, n, S) : u
          }
          var G5 = ga(function (u, f) {
            var S = u == null ? 0 : u.length,
              $ = zm(u, f)
            return (
              AC(
                u,
                Hn(f, function (K) {
                  return ya(K, S) ? +K : K
                }).sort(zC)
              ),
              $
            )
          })
          function K5(u, f) {
            var S = []
            if (!(u && u.length)) return S
            var $ = -1,
              K = [],
              se = u.length
            for (f = Kt(f, 3); ++$ < se; ) {
              var be = u[$]
              f(be, $, u) && (S.push(be), K.push($))
            }
            return AC(u, K), S
          }
          function pg(u) {
            return u == null ? u : zO.call(u)
          }
          function q5(u, f, S) {
            var $ = u == null ? 0 : u.length
            return $
              ? (S && typeof S != 'number' && ri(u, f, S)
                  ? ((f = 0), (S = $))
                  : ((f = f == null ? 0 : tn(f)), (S = S === n ? $ : tn(S))),
                Xi(u, f, S))
              : []
          }
          function X5(u, f) {
            return Df(u, f)
          }
          function Y5(u, f, S) {
            return Zm(u, f, Kt(S, 2))
          }
          function Z5(u, f) {
            var S = u == null ? 0 : u.length
            if (S) {
              var $ = Df(u, f)
              if ($ < S && mo(u[$], f)) return $
            }
            return -1
          }
          function J5(u, f) {
            return Df(u, f, !0)
          }
          function Q5(u, f, S) {
            return Zm(u, f, Kt(S, 2), !0)
          }
          function eI(u, f) {
            var S = u == null ? 0 : u.length
            if (S) {
              var $ = Df(u, f, !0) - 1
              if (mo(u[$], f)) return $
            }
            return -1
          }
          function tI(u) {
            return u && u.length ? OC(u) : []
          }
          function nI(u, f) {
            return u && u.length ? OC(u, Kt(f, 2)) : []
          }
          function rI(u) {
            var f = u == null ? 0 : u.length
            return f ? Xi(u, 1, f) : []
          }
          function iI(u, f, S) {
            return u && u.length
              ? ((f = S || f === n ? 1 : tn(f)), Xi(u, 0, f < 0 ? 0 : f))
              : []
          }
          function oI(u, f, S) {
            var $ = u == null ? 0 : u.length
            return $
              ? ((f = S || f === n ? 1 : tn(f)),
                (f = $ - f),
                Xi(u, f < 0 ? 0 : f, $))
              : []
          }
          function aI(u, f) {
            return u && u.length ? Nf(u, Kt(f, 3), !1, !0) : []
          }
          function sI(u, f) {
            return u && u.length ? Nf(u, Kt(f, 3)) : []
          }
          var lI = on(function (u) {
              return rs(Ar(u, 1, er, !0))
            }),
            uI = on(function (u) {
              var f = Yi(u)
              return er(f) && (f = n), rs(Ar(u, 1, er, !0), Kt(f, 2))
            }),
            cI = on(function (u) {
              var f = Yi(u)
              return (
                (f = typeof f == 'function' ? f : n), rs(Ar(u, 1, er, !0), n, f)
              )
            })
          function dI(u) {
            return u && u.length ? rs(u) : []
          }
          function fI(u, f) {
            return u && u.length ? rs(u, Kt(f, 2)) : []
          }
          function hI(u, f) {
            return (
              (f = typeof f == 'function' ? f : n),
              u && u.length ? rs(u, n, f) : []
            )
          }
          function vg(u) {
            if (!(u && u.length)) return []
            var f = 0
            return (
              (u = Ja(u, function (S) {
                if (er(S)) return (f = dr(S.length, f)), !0
              })),
              Om(f, function (S) {
                return Hn(u, km(S))
              })
            )
          }
          function yw(u, f) {
            if (!(u && u.length)) return []
            var S = vg(u)
            return f == null
              ? S
              : Hn(S, function ($) {
                  return Ai(f, n, $)
                })
          }
          var pI = on(function (u, f) {
              return er(u) ? Lc(u, f) : []
            }),
            vI = on(function (u) {
              return Qm(Ja(u, er))
            }),
            mI = on(function (u) {
              var f = Yi(u)
              return er(f) && (f = n), Qm(Ja(u, er), Kt(f, 2))
            }),
            gI = on(function (u) {
              var f = Yi(u)
              return (f = typeof f == 'function' ? f : n), Qm(Ja(u, er), n, f)
            }),
            yI = on(vg)
          function bI(u, f) {
            return DC(u || [], f || [], Oc)
          }
          function _I(u, f) {
            return DC(u || [], f || [], Dc)
          }
          var SI = on(function (u) {
            var f = u.length,
              S = f > 1 ? u[f - 1] : n
            return (S = typeof S == 'function' ? (u.pop(), S) : n), yw(u, S)
          })
          function bw(u) {
            var f = ee(u)
            return (f.__chain__ = !0), f
          }
          function CI(u, f) {
            return f(u), u
          }
          function Gf(u, f) {
            return f(u)
          }
          var wI = ga(function (u) {
            var f = u.length,
              S = f ? u[0] : 0,
              $ = this.__wrapped__,
              K = function (se) {
                return zm(se, u)
              }
            return f > 1 ||
              this.__actions__.length ||
              !($ instanceof fn) ||
              !ya(S)
              ? this.thru(K)
              : (($ = $.slice(S, +S + (f ? 1 : 0))),
                $.__actions__.push({ func: Gf, args: [K], thisArg: n }),
                new Ki($, this.__chain__).thru(function (se) {
                  return f && !se.length && se.push(n), se
                }))
          })
          function xI() {
            return bw(this)
          }
          function MI() {
            return new Ki(this.value(), this.__chain__)
          }
          function EI() {
            this.__values__ === n && (this.__values__ = Lw(this.value()))
            var u = this.__index__ >= this.__values__.length,
              f = u ? n : this.__values__[this.__index__++]
            return { done: u, value: f }
          }
          function PI() {
            return this
          }
          function TI(u) {
            for (var f, S = this; S instanceof $f; ) {
              var $ = fw(S)
              ;($.__index__ = 0),
                ($.__values__ = n),
                f ? (K.__wrapped__ = $) : (f = $)
              var K = $
              S = S.__wrapped__
            }
            return (K.__wrapped__ = u), f
          }
          function kI() {
            var u = this.__wrapped__
            if (u instanceof fn) {
              var f = u
              return (
                this.__actions__.length && (f = new fn(this)),
                (f = f.reverse()),
                f.__actions__.push({ func: Gf, args: [pg], thisArg: n }),
                new Ki(f, this.__chain__)
              )
            }
            return this.thru(pg)
          }
          function AI() {
            return RC(this.__wrapped__, this.__actions__)
          }
          var $I = Bf(function (u, f, S) {
            Tn.call(u, S) ? ++u[S] : va(u, S, 1)
          })
          function OI(u, f, S) {
            var $ = Qt(u) ? qS : CL
            return S && ri(u, f, S) && (f = n), $(u, Kt(f, 3))
          }
          function LI(u, f) {
            var S = Qt(u) ? Ja : yC
            return S(u, Kt(f, 3))
          }
          var II = GC(hw),
            RI = GC(pw)
          function DI(u, f) {
            return Ar(Kf(u, f), 1)
          }
          function NI(u, f) {
            return Ar(Kf(u, f), L)
          }
          function BI(u, f, S) {
            return (S = S === n ? 1 : tn(S)), Ar(Kf(u, f), S)
          }
          function _w(u, f) {
            var S = Qt(u) ? ji : ns
            return S(u, Kt(f, 3))
          }
          function Sw(u, f) {
            var S = Qt(u) ? rO : gC
            return S(u, Kt(f, 3))
          }
          var FI = Bf(function (u, f, S) {
            Tn.call(u, S) ? u[S].push(f) : va(u, S, [f])
          })
          function zI(u, f, S, $) {
            ;(u = mi(u) ? u : tu(u)), (S = S && !$ ? tn(S) : 0)
            var K = u.length
            return (
              S < 0 && (S = dr(K + S, 0)),
              Jf(u) ? S <= K && u.indexOf(f, S) > -1 : !!K && Hl(u, f, S) > -1
            )
          }
          var VI = on(function (u, f, S) {
              var $ = -1,
                K = typeof f == 'function',
                se = mi(u) ? Ze(u.length) : []
              return (
                ns(u, function (be) {
                  se[++$] = K ? Ai(f, be, S) : Ic(be, f, S)
                }),
                se
              )
            }),
            UI = Bf(function (u, f, S) {
              va(u, S, f)
            })
          function Kf(u, f) {
            var S = Qt(u) ? Hn : xC
            return S(u, Kt(f, 3))
          }
          function HI(u, f, S, $) {
            return u == null
              ? []
              : (Qt(f) || (f = f == null ? [] : [f]),
                (S = $ ? n : S),
                Qt(S) || (S = S == null ? [] : [S]),
                TC(u, f, S))
          }
          var WI = Bf(
            function (u, f, S) {
              u[S ? 0 : 1].push(f)
            },
            function () {
              return [[], []]
            }
          )
          function jI(u, f, S) {
            var $ = Qt(u) ? Pm : JS,
              K = arguments.length < 3
            return $(u, Kt(f, 4), S, K, ns)
          }
          function GI(u, f, S) {
            var $ = Qt(u) ? iO : JS,
              K = arguments.length < 3
            return $(u, Kt(f, 4), S, K, gC)
          }
          function KI(u, f) {
            var S = Qt(u) ? Ja : yC
            return S(u, Yf(Kt(f, 3)))
          }
          function qI(u) {
            var f = Qt(u) ? hC : zL
            return f(u)
          }
          function XI(u, f, S) {
            ;(S ? ri(u, f, S) : f === n) ? (f = 1) : (f = tn(f))
            var $ = Qt(u) ? gL : VL
            return $(u, f)
          }
          function YI(u) {
            var f = Qt(u) ? yL : HL
            return f(u)
          }
          function ZI(u) {
            if (u == null) return 0
            if (mi(u)) return Jf(u) ? jl(u) : u.length
            var f = Wr(u)
            return f == z || f == Ae ? u.size : Gm(u).length
          }
          function JI(u, f, S) {
            var $ = Qt(u) ? Tm : WL
            return S && ri(u, f, S) && (f = n), $(u, Kt(f, 3))
          }
          var QI = on(function (u, f) {
              if (u == null) return []
              var S = f.length
              return (
                S > 1 && ri(u, f[0], f[1])
                  ? (f = [])
                  : S > 2 && ri(f[0], f[1], f[2]) && (f = [f[0]]),
                TC(u, Ar(f, 1), [])
              )
            }),
            qf =
              LO ||
              function () {
                return jn.Date.now()
              }
          function eR(u, f) {
            if (typeof f != 'function') throw new Gi(a)
            return (
              (u = tn(u)),
              function () {
                if (--u < 1) return f.apply(this, arguments)
              }
            )
          }
          function Cw(u, f, S) {
            return (
              (f = S ? n : f),
              (f = u && f == null ? u.length : f),
              ma(u, A, n, n, n, n, f)
            )
          }
          function ww(u, f) {
            var S
            if (typeof f != 'function') throw new Gi(a)
            return (
              (u = tn(u)),
              function () {
                return (
                  --u > 0 && (S = f.apply(this, arguments)),
                  u <= 1 && (f = n),
                  S
                )
              }
            )
          }
          var mg = on(function (u, f, S) {
              var $ = b
              if (S.length) {
                var K = es(S, Ql(mg))
                $ |= E
              }
              return ma(u, $, f, S, K)
            }),
            xw = on(function (u, f, S) {
              var $ = b | y
              if (S.length) {
                var K = es(S, Ql(xw))
                $ |= E
              }
              return ma(f, $, u, S, K)
            })
          function Mw(u, f, S) {
            f = S ? n : f
            var $ = ma(u, x, n, n, n, n, n, f)
            return ($.placeholder = Mw.placeholder), $
          }
          function Ew(u, f, S) {
            f = S ? n : f
            var $ = ma(u, w, n, n, n, n, n, f)
            return ($.placeholder = Ew.placeholder), $
          }
          function Pw(u, f, S) {
            var $,
              K,
              se,
              be,
              Me,
              Ie,
              ut = 0,
              dt = !1,
              ht = !1,
              $t = !0
            if (typeof u != 'function') throw new Gi(a)
            ;(f = Zi(f) || 0),
              Gn(S) &&
                ((dt = !!S.leading),
                (ht = 'maxWait' in S),
                (se = ht ? dr(Zi(S.maxWait) || 0, f) : se),
                ($t = 'trailing' in S ? !!S.trailing : $t))
            function Ut(tr) {
              var go = $,
                Sa = K
              return ($ = K = n), (ut = tr), (be = u.apply(Sa, go)), be
            }
            function qt(tr) {
              return (ut = tr), (Me = Fc(dn, f)), dt ? Ut(tr) : be
            }
            function nn(tr) {
              var go = tr - Ie,
                Sa = tr - ut,
                Gw = f - go
              return ht ? Hr(Gw, se - Sa) : Gw
            }
            function Xt(tr) {
              var go = tr - Ie,
                Sa = tr - ut
              return Ie === n || go >= f || go < 0 || (ht && Sa >= se)
            }
            function dn() {
              var tr = qf()
              if (Xt(tr)) return mn(tr)
              Me = Fc(dn, nn(tr))
            }
            function mn(tr) {
              return (Me = n), $t && $ ? Ut(tr) : (($ = K = n), be)
            }
            function Ii() {
              Me !== n && NC(Me), (ut = 0), ($ = Ie = K = Me = n)
            }
            function ii() {
              return Me === n ? be : mn(qf())
            }
            function Ri() {
              var tr = qf(),
                go = Xt(tr)
              if ((($ = arguments), (K = this), (Ie = tr), go)) {
                if (Me === n) return qt(Ie)
                if (ht) return NC(Me), (Me = Fc(dn, f)), Ut(Ie)
              }
              return Me === n && (Me = Fc(dn, f)), be
            }
            return (Ri.cancel = Ii), (Ri.flush = ii), Ri
          }
          var tR = on(function (u, f) {
              return mC(u, 1, f)
            }),
            nR = on(function (u, f, S) {
              return mC(u, Zi(f) || 0, S)
            })
          function rR(u) {
            return ma(u, T)
          }
          function Xf(u, f) {
            if (typeof u != 'function' || (f != null && typeof f != 'function'))
              throw new Gi(a)
            var S = function () {
              var $ = arguments,
                K = f ? f.apply(this, $) : $[0],
                se = S.cache
              if (se.has(K)) return se.get(K)
              var be = u.apply(this, $)
              return (S.cache = se.set(K, be) || se), be
            }
            return (S.cache = new (Xf.Cache || pa)()), S
          }
          Xf.Cache = pa
          function Yf(u) {
            if (typeof u != 'function') throw new Gi(a)
            return function () {
              var f = arguments
              switch (f.length) {
                case 0:
                  return !u.call(this)
                case 1:
                  return !u.call(this, f[0])
                case 2:
                  return !u.call(this, f[0], f[1])
                case 3:
                  return !u.call(this, f[0], f[1], f[2])
              }
              return !u.apply(this, f)
            }
          }
          function iR(u) {
            return ww(2, u)
          }
          var oR = jL(function (u, f) {
              f =
                f.length == 1 && Qt(f[0])
                  ? Hn(f[0], $i(Kt()))
                  : Hn(Ar(f, 1), $i(Kt()))
              var S = f.length
              return on(function ($) {
                for (var K = -1, se = Hr($.length, S); ++K < se; )
                  $[K] = f[K].call(this, $[K])
                return Ai(u, this, $)
              })
            }),
            gg = on(function (u, f) {
              var S = es(f, Ql(gg))
              return ma(u, E, n, f, S)
            }),
            Tw = on(function (u, f) {
              var S = es(f, Ql(Tw))
              return ma(u, P, n, f, S)
            }),
            aR = ga(function (u, f) {
              return ma(u, F, n, n, n, f)
            })
          function sR(u, f) {
            if (typeof u != 'function') throw new Gi(a)
            return (f = f === n ? f : tn(f)), on(u, f)
          }
          function lR(u, f) {
            if (typeof u != 'function') throw new Gi(a)
            return (
              (f = f == null ? 0 : dr(tn(f), 0)),
              on(function (S) {
                var $ = S[f],
                  K = os(S, 0, f)
                return $ && Qa(K, $), Ai(u, this, K)
              })
            )
          }
          function uR(u, f, S) {
            var $ = !0,
              K = !0
            if (typeof u != 'function') throw new Gi(a)
            return (
              Gn(S) &&
                (($ = 'leading' in S ? !!S.leading : $),
                (K = 'trailing' in S ? !!S.trailing : K)),
              Pw(u, f, { leading: $, maxWait: f, trailing: K })
            )
          }
          function cR(u) {
            return Cw(u, 1)
          }
          function dR(u, f) {
            return gg(tg(f), u)
          }
          function fR() {
            if (!arguments.length) return []
            var u = arguments[0]
            return Qt(u) ? u : [u]
          }
          function hR(u) {
            return qi(u, v)
          }
          function pR(u, f) {
            return (f = typeof f == 'function' ? f : n), qi(u, v, f)
          }
          function vR(u) {
            return qi(u, h | v)
          }
          function mR(u, f) {
            return (f = typeof f == 'function' ? f : n), qi(u, h | v, f)
          }
          function gR(u, f) {
            return f == null || vC(u, f, _r(f))
          }
          function mo(u, f) {
            return u === f || (u !== u && f !== f)
          }
          var yR = Uf(Hm),
            bR = Uf(function (u, f) {
              return u >= f
            }),
            Gs = SC(
              (function () {
                return arguments
              })()
            )
              ? SC
              : function (u) {
                  return Zn(u) && Tn.call(u, 'callee') && !sC.call(u, 'callee')
                },
            Qt = Ze.isArray,
            _R = zl ? $i(zl) : TL
          function mi(u) {
            return u != null && Zf(u.length) && !ba(u)
          }
          function er(u) {
            return Zn(u) && mi(u)
          }
          function SR(u) {
            return u === !0 || u === !1 || (Zn(u) && ni(u) == qe)
          }
          var as = RO || Tg,
            CR = Vl ? $i(Vl) : kL
          function wR(u) {
            return Zn(u) && u.nodeType === 1 && !zc(u)
          }
          function xR(u) {
            if (u == null) return !0
            if (
              mi(u) &&
              (Qt(u) ||
                typeof u == 'string' ||
                typeof u.splice == 'function' ||
                as(u) ||
                eu(u) ||
                Gs(u))
            )
              return !u.length
            var f = Wr(u)
            if (f == z || f == Ae) return !u.size
            if (Bc(u)) return !Gm(u).length
            for (var S in u) if (Tn.call(u, S)) return !1
            return !0
          }
          function MR(u, f) {
            return Rc(u, f)
          }
          function ER(u, f, S) {
            S = typeof S == 'function' ? S : n
            var $ = S ? S(u, f) : n
            return $ === n ? Rc(u, f, n, S) : !!$
          }
          function yg(u) {
            if (!Zn(u)) return !1
            var f = ni(u)
            return (
              f == We ||
              f == nt ||
              (typeof u.message == 'string' &&
                typeof u.name == 'string' &&
                !zc(u))
            )
          }
          function PR(u) {
            return typeof u == 'number' && uC(u)
          }
          function ba(u) {
            if (!Gn(u)) return !1
            var f = ni(u)
            return f == D || f == G || f == Re || f == we
          }
          function kw(u) {
            return typeof u == 'number' && u == tn(u)
          }
          function Zf(u) {
            return typeof u == 'number' && u > -1 && u % 1 == 0 && u <= W
          }
          function Gn(u) {
            var f = typeof u
            return u != null && (f == 'object' || f == 'function')
          }
          function Zn(u) {
            return u != null && typeof u == 'object'
          }
          var Aw = Ul ? $i(Ul) : $L
          function TR(u, f) {
            return u === f || jm(u, f, lg(f))
          }
          function kR(u, f, S) {
            return (S = typeof S == 'function' ? S : n), jm(u, f, lg(f), S)
          }
          function AR(u) {
            return $w(u) && u != +u
          }
          function $R(u) {
            if (p5(u)) throw new Jt(o)
            return CC(u)
          }
          function OR(u) {
            return u === null
          }
          function LR(u) {
            return u == null
          }
          function $w(u) {
            return typeof u == 'number' || (Zn(u) && ni(u) == ie)
          }
          function zc(u) {
            if (!Zn(u) || ni(u) != re) return !1
            var f = xf(u)
            if (f === null) return !0
            var S = Tn.call(f, 'constructor') && f.constructor
            return typeof S == 'function' && S instanceof S && _f.call(S) == kO
          }
          var bg = pf ? $i(pf) : OL
          function IR(u) {
            return kw(u) && u >= -W && u <= W
          }
          var Ow = Za ? $i(Za) : LL
          function Jf(u) {
            return typeof u == 'string' || (!Qt(u) && Zn(u) && ni(u) == ft)
          }
          function Li(u) {
            return typeof u == 'symbol' || (Zn(u) && ni(u) == Q)
          }
          var eu = KS ? $i(KS) : IL
          function RR(u) {
            return u === n
          }
          function DR(u) {
            return Zn(u) && Wr(u) == he
          }
          function NR(u) {
            return Zn(u) && ni(u) == de
          }
          var BR = Uf(Km),
            FR = Uf(function (u, f) {
              return u <= f
            })
          function Lw(u) {
            if (!u) return []
            if (mi(u)) return Jf(u) ? po(u) : vi(u)
            if (Pc && u[Pc]) return gO(u[Pc]())
            var f = Wr(u),
              S = f == z ? Im : f == Ae ? gf : tu
            return S(u)
          }
          function _a(u) {
            if (!u) return u === 0 ? u : 0
            if (((u = Zi(u)), u === L || u === -L)) {
              var f = u < 0 ? -1 : 1
              return f * Y
            }
            return u === u ? u : 0
          }
          function tn(u) {
            var f = _a(u),
              S = f % 1
            return f === f ? (S ? f - S : f) : 0
          }
          function Iw(u) {
            return u ? Us(tn(u), 0, le) : 0
          }
          function Zi(u) {
            if (typeof u == 'number') return u
            if (Li(u)) return U
            if (Gn(u)) {
              var f = typeof u.valueOf == 'function' ? u.valueOf() : u
              u = Gn(f) ? f + '' : f
            }
            if (typeof u != 'string') return u === 0 ? u : +u
            u = QS(u)
            var S = De.test(u)
            return S || Ot.test(u)
              ? ti(u.slice(2), S ? 2 : 8)
              : Xe.test(u)
              ? U
              : +u
          }
          function Rw(u) {
            return Ho(u, gi(u))
          }
          function zR(u) {
            return u ? Us(tn(u), -W, W) : u === 0 ? u : 0
          }
          function Mn(u) {
            return u == null ? '' : Oi(u)
          }
          var VR = Zl(function (u, f) {
              if (Bc(f) || mi(f)) {
                Ho(f, _r(f), u)
                return
              }
              for (var S in f) Tn.call(f, S) && Oc(u, S, f[S])
            }),
            Dw = Zl(function (u, f) {
              Ho(f, gi(f), u)
            }),
            Qf = Zl(function (u, f, S, $) {
              Ho(f, gi(f), u, $)
            }),
            UR = Zl(function (u, f, S, $) {
              Ho(f, _r(f), u, $)
            }),
            HR = ga(zm)
          function WR(u, f) {
            var S = Yl(u)
            return f == null ? S : pC(S, f)
          }
          var jR = on(function (u, f) {
              u = On(u)
              var S = -1,
                $ = f.length,
                K = $ > 2 ? f[2] : n
              for (K && ri(f[0], f[1], K) && ($ = 1); ++S < $; )
                for (
                  var se = f[S], be = gi(se), Me = -1, Ie = be.length;
                  ++Me < Ie;

                ) {
                  var ut = be[Me],
                    dt = u[ut]
                  ;(dt === n || (mo(dt, Kl[ut]) && !Tn.call(u, ut))) &&
                    (u[ut] = se[ut])
                }
              return u
            }),
            GR = on(function (u) {
              return u.push(n, QC), Ai(Nw, n, u)
            })
          function KR(u, f) {
            return XS(u, Kt(f, 3), Uo)
          }
          function qR(u, f) {
            return XS(u, Kt(f, 3), Um)
          }
          function XR(u, f) {
            return u == null ? u : Vm(u, Kt(f, 3), gi)
          }
          function YR(u, f) {
            return u == null ? u : bC(u, Kt(f, 3), gi)
          }
          function ZR(u, f) {
            return u && Uo(u, Kt(f, 3))
          }
          function JR(u, f) {
            return u && Um(u, Kt(f, 3))
          }
          function QR(u) {
            return u == null ? [] : If(u, _r(u))
          }
          function e6(u) {
            return u == null ? [] : If(u, gi(u))
          }
          function _g(u, f, S) {
            var $ = u == null ? n : Hs(u, f)
            return $ === n ? S : $
          }
          function t6(u, f) {
            return u != null && nw(u, f, xL)
          }
          function Sg(u, f) {
            return u != null && nw(u, f, ML)
          }
          var n6 = qC(function (u, f, S) {
              f != null && typeof f.toString != 'function' && (f = Sf.call(f)),
                (u[f] = S)
            }, wg(yi)),
            r6 = qC(function (u, f, S) {
              f != null && typeof f.toString != 'function' && (f = Sf.call(f)),
                Tn.call(u, f) ? u[f].push(S) : (u[f] = [S])
            }, Kt),
            i6 = on(Ic)
          function _r(u) {
            return mi(u) ? fC(u) : Gm(u)
          }
          function gi(u) {
            return mi(u) ? fC(u, !0) : RL(u)
          }
          function o6(u, f) {
            var S = {}
            return (
              (f = Kt(f, 3)),
              Uo(u, function ($, K, se) {
                va(S, f($, K, se), $)
              }),
              S
            )
          }
          function a6(u, f) {
            var S = {}
            return (
              (f = Kt(f, 3)),
              Uo(u, function ($, K, se) {
                va(S, K, f($, K, se))
              }),
              S
            )
          }
          var s6 = Zl(function (u, f, S) {
              Rf(u, f, S)
            }),
            Nw = Zl(function (u, f, S, $) {
              Rf(u, f, S, $)
            }),
            l6 = ga(function (u, f) {
              var S = {}
              if (u == null) return S
              var $ = !1
              ;(f = Hn(f, function (se) {
                return (se = is(se, u)), $ || ($ = se.length > 1), se
              })),
                Ho(u, ag(u), S),
                $ && (S = qi(S, h | p | v, n5))
              for (var K = f.length; K--; ) Jm(S, f[K])
              return S
            })
          function u6(u, f) {
            return Bw(u, Yf(Kt(f)))
          }
          var c6 = ga(function (u, f) {
            return u == null ? {} : NL(u, f)
          })
          function Bw(u, f) {
            if (u == null) return {}
            var S = Hn(ag(u), function ($) {
              return [$]
            })
            return (
              (f = Kt(f)),
              kC(u, S, function ($, K) {
                return f($, K[0])
              })
            )
          }
          function d6(u, f, S) {
            f = is(f, u)
            var $ = -1,
              K = f.length
            for (K || ((K = 1), (u = n)); ++$ < K; ) {
              var se = u == null ? n : u[Wo(f[$])]
              se === n && (($ = K), (se = S)), (u = ba(se) ? se.call(u) : se)
            }
            return u
          }
          function f6(u, f, S) {
            return u == null ? u : Dc(u, f, S)
          }
          function h6(u, f, S, $) {
            return (
              ($ = typeof $ == 'function' ? $ : n),
              u == null ? u : Dc(u, f, S, $)
            )
          }
          var Fw = ZC(_r),
            zw = ZC(gi)
          function p6(u, f, S) {
            var $ = Qt(u),
              K = $ || as(u) || eu(u)
            if (((f = Kt(f, 4)), S == null)) {
              var se = u && u.constructor
              K
                ? (S = $ ? new se() : [])
                : Gn(u)
                ? (S = ba(se) ? Yl(xf(u)) : {})
                : (S = {})
            }
            return (
              (K ? ji : Uo)(u, function (be, Me, Ie) {
                return f(S, be, Me, Ie)
              }),
              S
            )
          }
          function v6(u, f) {
            return u == null ? !0 : Jm(u, f)
          }
          function m6(u, f, S) {
            return u == null ? u : IC(u, f, tg(S))
          }
          function g6(u, f, S, $) {
            return (
              ($ = typeof $ == 'function' ? $ : n),
              u == null ? u : IC(u, f, tg(S), $)
            )
          }
          function tu(u) {
            return u == null ? [] : Lm(u, _r(u))
          }
          function y6(u) {
            return u == null ? [] : Lm(u, gi(u))
          }
          function b6(u, f, S) {
            return (
              S === n && ((S = f), (f = n)),
              S !== n && ((S = Zi(S)), (S = S === S ? S : 0)),
              f !== n && ((f = Zi(f)), (f = f === f ? f : 0)),
              Us(Zi(u), f, S)
            )
          }
          function _6(u, f, S) {
            return (
              (f = _a(f)),
              S === n ? ((S = f), (f = 0)) : (S = _a(S)),
              (u = Zi(u)),
              EL(u, f, S)
            )
          }
          function S6(u, f, S) {
            if (
              (S && typeof S != 'boolean' && ri(u, f, S) && (f = S = n),
              S === n &&
                (typeof f == 'boolean'
                  ? ((S = f), (f = n))
                  : typeof u == 'boolean' && ((S = u), (u = n))),
              u === n && f === n
                ? ((u = 0), (f = 1))
                : ((u = _a(u)), f === n ? ((f = u), (u = 0)) : (f = _a(f))),
              u > f)
            ) {
              var $ = u
              ;(u = f), (f = $)
            }
            if (S || u % 1 || f % 1) {
              var K = cC()
              return Hr(u + K * (f - u + or('1e-' + ((K + '').length - 1))), f)
            }
            return Xm(u, f)
          }
          var C6 = Jl(function (u, f, S) {
            return (f = f.toLowerCase()), u + (S ? Vw(f) : f)
          })
          function Vw(u) {
            return Cg(Mn(u).toLowerCase())
          }
          function Uw(u) {
            return (u = Mn(u)), u && u.replace(ct, fO).replace(df, '')
          }
          function w6(u, f, S) {
            ;(u = Mn(u)), (f = Oi(f))
            var $ = u.length
            S = S === n ? $ : Us(tn(S), 0, $)
            var K = S
            return (S -= f.length), S >= 0 && u.slice(S, K) == f
          }
          function x6(u) {
            return (u = Mn(u)), u && Zt.test(u) ? u.replace(_t, hO) : u
          }
          function M6(u) {
            return (u = Mn(u)), u && hi.test(u) ? u.replace(yr, '\\$&') : u
          }
          var E6 = Jl(function (u, f, S) {
              return u + (S ? '-' : '') + f.toLowerCase()
            }),
            P6 = Jl(function (u, f, S) {
              return u + (S ? ' ' : '') + f.toLowerCase()
            }),
            T6 = jC('toLowerCase')
          function k6(u, f, S) {
            ;(u = Mn(u)), (f = tn(f))
            var $ = f ? jl(u) : 0
            if (!f || $ >= f) return u
            var K = (f - $) / 2
            return Vf(Tf(K), S) + u + Vf(Pf(K), S)
          }
          function A6(u, f, S) {
            ;(u = Mn(u)), (f = tn(f))
            var $ = f ? jl(u) : 0
            return f && $ < f ? u + Vf(f - $, S) : u
          }
          function $6(u, f, S) {
            ;(u = Mn(u)), (f = tn(f))
            var $ = f ? jl(u) : 0
            return f && $ < f ? Vf(f - $, S) + u : u
          }
          function O6(u, f, S) {
            return (
              S || f == null ? (f = 0) : f && (f = +f),
              FO(Mn(u).replace(Qr, ''), f || 0)
            )
          }
          function L6(u, f, S) {
            return (
              (S ? ri(u, f, S) : f === n) ? (f = 1) : (f = tn(f)), Ym(Mn(u), f)
            )
          }
          function I6() {
            var u = arguments,
              f = Mn(u[0])
            return u.length < 3 ? f : f.replace(u[1], u[2])
          }
          var R6 = Jl(function (u, f, S) {
            return u + (S ? '_' : '') + f.toLowerCase()
          })
          function D6(u, f, S) {
            return (
              S && typeof S != 'number' && ri(u, f, S) && (f = S = n),
              (S = S === n ? le : S >>> 0),
              S
                ? ((u = Mn(u)),
                  u &&
                  (typeof f == 'string' || (f != null && !bg(f))) &&
                  ((f = Oi(f)), !f && Wl(u))
                    ? os(po(u), 0, S)
                    : u.split(f, S))
                : []
            )
          }
          var N6 = Jl(function (u, f, S) {
            return u + (S ? ' ' : '') + Cg(f)
          })
          function B6(u, f, S) {
            return (
              (u = Mn(u)),
              (S = S == null ? 0 : Us(tn(S), 0, u.length)),
              (f = Oi(f)),
              u.slice(S, S + f.length) == f
            )
          }
          function F6(u, f, S) {
            var $ = ee.templateSettings
            S && ri(u, f, S) && (f = n), (u = Mn(u)), (f = Qf({}, f, $, JC))
            var K = Qf({}, f.imports, $.imports, JC),
              se = _r(K),
              be = Lm(K, se),
              Me,
              Ie,
              ut = 0,
              dt = f.interpolate || Tt,
              ht = "__p += '",
              $t = Rm(
                (f.escape || Tt).source +
                  '|' +
                  dt.source +
                  '|' +
                  (dt === Tr ? fe : Tt).source +
                  '|' +
                  (f.evaluate || Tt).source +
                  '|$',
                'g'
              ),
              Ut =
                '//# sourceURL=' +
                (Tn.call(f, 'sourceURL')
                  ? (f.sourceURL + '').replace(/\s/g, ' ')
                  : 'lodash.templateSources[' + ++ke + ']') +
                `
`
            u.replace($t, function (Xt, dn, mn, Ii, ii, Ri) {
              return (
                mn || (mn = Ii),
                (ht += u.slice(ut, Ri).replace(Bt, pO)),
                dn &&
                  ((Me = !0),
                  (ht +=
                    `' +
__e(` +
                    dn +
                    `) +
'`)),
                ii &&
                  ((Ie = !0),
                  (ht +=
                    `';
` +
                    ii +
                    `;
__p += '`)),
                mn &&
                  (ht +=
                    `' +
((__t = (` +
                    mn +
                    `)) == null ? '' : __t) +
'`),
                (ut = Ri + Xt.length),
                Xt
              )
            }),
              (ht += `';
`)
            var qt = Tn.call(f, 'variable') && f.variable
            if (!qt)
              ht =
                `with (obj) {
` +
                ht +
                `
}
`
            else if (ho.test(qt)) throw new Jt(s)
            ;(ht = (Ie ? ht.replace(gt, '') : ht)
              .replace(_e, '$1')
              .replace(bt, '$1;')),
              (ht =
                'function(' +
                (qt || 'obj') +
                `) {
` +
                (qt
                  ? ''
                  : `obj || (obj = {});
`) +
                "var __t, __p = ''" +
                (Me ? ', __e = _.escape' : '') +
                (Ie
                  ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                  : `;
`) +
                ht +
                `return __p
}`)
            var nn = Ww(function () {
              return wn(se, Ut + 'return ' + ht).apply(n, be)
            })
            if (((nn.source = ht), yg(nn))) throw nn
            return nn
          }
          function z6(u) {
            return Mn(u).toLowerCase()
          }
          function V6(u) {
            return Mn(u).toUpperCase()
          }
          function U6(u, f, S) {
            if (((u = Mn(u)), u && (S || f === n))) return QS(u)
            if (!u || !(f = Oi(f))) return u
            var $ = po(u),
              K = po(f),
              se = eC($, K),
              be = tC($, K) + 1
            return os($, se, be).join('')
          }
          function H6(u, f, S) {
            if (((u = Mn(u)), u && (S || f === n))) return u.slice(0, rC(u) + 1)
            if (!u || !(f = Oi(f))) return u
            var $ = po(u),
              K = tC($, po(f)) + 1
            return os($, 0, K).join('')
          }
          function W6(u, f, S) {
            if (((u = Mn(u)), u && (S || f === n))) return u.replace(Qr, '')
            if (!u || !(f = Oi(f))) return u
            var $ = po(u),
              K = eC($, po(f))
            return os($, K).join('')
          }
          function j6(u, f) {
            var S = k,
              $ = R
            if (Gn(f)) {
              var K = 'separator' in f ? f.separator : K
              ;(S = 'length' in f ? tn(f.length) : S),
                ($ = 'omission' in f ? Oi(f.omission) : $)
            }
            u = Mn(u)
            var se = u.length
            if (Wl(u)) {
              var be = po(u)
              se = be.length
            }
            if (S >= se) return u
            var Me = S - jl($)
            if (Me < 1) return $
            var Ie = be ? os(be, 0, Me).join('') : u.slice(0, Me)
            if (K === n) return Ie + $
            if ((be && (Me += Ie.length - Me), bg(K))) {
              if (u.slice(Me).search(K)) {
                var ut,
                  dt = Ie
                for (
                  K.global || (K = Rm(K.source, Mn(Ue.exec(K)) + 'g')),
                    K.lastIndex = 0;
                  (ut = K.exec(dt));

                )
                  var ht = ut.index
                Ie = Ie.slice(0, ht === n ? Me : ht)
              }
            } else if (u.indexOf(Oi(K), Me) != Me) {
              var $t = Ie.lastIndexOf(K)
              $t > -1 && (Ie = Ie.slice(0, $t))
            }
            return Ie + $
          }
          function G6(u) {
            return (u = Mn(u)), u && wt.test(u) ? u.replace(He, SO) : u
          }
          var K6 = Jl(function (u, f, S) {
              return u + (S ? ' ' : '') + f.toUpperCase()
            }),
            Cg = jC('toUpperCase')
          function Hw(u, f, S) {
            return (
              (u = Mn(u)),
              (f = S ? n : f),
              f === n ? (mO(u) ? xO(u) : sO(u)) : u.match(f) || []
            )
          }
          var Ww = on(function (u, f) {
              try {
                return Ai(u, n, f)
              } catch (S) {
                return yg(S) ? S : new Jt(S)
              }
            }),
            q6 = ga(function (u, f) {
              return (
                ji(f, function (S) {
                  ;(S = Wo(S)), va(u, S, mg(u[S], u))
                }),
                u
              )
            })
          function X6(u) {
            var f = u == null ? 0 : u.length,
              S = Kt()
            return (
              (u = f
                ? Hn(u, function ($) {
                    if (typeof $[1] != 'function') throw new Gi(a)
                    return [S($[0]), $[1]]
                  })
                : []),
              on(function ($) {
                for (var K = -1; ++K < f; ) {
                  var se = u[K]
                  if (Ai(se[0], this, $)) return Ai(se[1], this, $)
                }
              })
            )
          }
          function Y6(u) {
            return SL(qi(u, h))
          }
          function wg(u) {
            return function () {
              return u
            }
          }
          function Z6(u, f) {
            return u == null || u !== u ? f : u
          }
          var J6 = KC(),
            Q6 = KC(!0)
          function yi(u) {
            return u
          }
          function xg(u) {
            return wC(typeof u == 'function' ? u : qi(u, h))
          }
          function e8(u) {
            return MC(qi(u, h))
          }
          function t8(u, f) {
            return EC(u, qi(f, h))
          }
          var n8 = on(function (u, f) {
              return function (S) {
                return Ic(S, u, f)
              }
            }),
            r8 = on(function (u, f) {
              return function (S) {
                return Ic(u, S, f)
              }
            })
          function Mg(u, f, S) {
            var $ = _r(f),
              K = If(f, $)
            S == null &&
              !(Gn(f) && (K.length || !$.length)) &&
              ((S = f), (f = u), (u = this), (K = If(f, _r(f))))
            var se = !(Gn(S) && 'chain' in S) || !!S.chain,
              be = ba(u)
            return (
              ji(K, function (Me) {
                var Ie = f[Me]
                ;(u[Me] = Ie),
                  be &&
                    (u.prototype[Me] = function () {
                      var ut = this.__chain__
                      if (se || ut) {
                        var dt = u(this.__wrapped__),
                          ht = (dt.__actions__ = vi(this.__actions__))
                        return (
                          ht.push({ func: Ie, args: arguments, thisArg: u }),
                          (dt.__chain__ = ut),
                          dt
                        )
                      }
                      return Ie.apply(u, Qa([this.value()], arguments))
                    })
              }),
              u
            )
          }
          function i8() {
            return jn._ === this && (jn._ = AO), this
          }
          function Eg() {}
          function o8(u) {
            return (
              (u = tn(u)),
              on(function (f) {
                return PC(f, u)
              })
            )
          }
          var a8 = rg(Hn),
            s8 = rg(qS),
            l8 = rg(Tm)
          function jw(u) {
            return cg(u) ? km(Wo(u)) : BL(u)
          }
          function u8(u) {
            return function (f) {
              return u == null ? n : Hs(u, f)
            }
          }
          var c8 = XC(),
            d8 = XC(!0)
          function Pg() {
            return []
          }
          function Tg() {
            return !1
          }
          function f8() {
            return {}
          }
          function h8() {
            return ''
          }
          function p8() {
            return !0
          }
          function v8(u, f) {
            if (((u = tn(u)), u < 1 || u > W)) return []
            var S = le,
              $ = Hr(u, le)
            ;(f = Kt(f)), (u -= le)
            for (var K = Om($, f); ++S < u; ) f(S)
            return K
          }
          function m8(u) {
            return Qt(u) ? Hn(u, Wo) : Li(u) ? [u] : vi(dw(Mn(u)))
          }
          function g8(u) {
            var f = ++TO
            return Mn(u) + f
          }
          var y8 = zf(function (u, f) {
              return u + f
            }, 0),
            b8 = ig('ceil'),
            _8 = zf(function (u, f) {
              return u / f
            }, 1),
            S8 = ig('floor')
          function C8(u) {
            return u && u.length ? Lf(u, yi, Hm) : n
          }
          function w8(u, f) {
            return u && u.length ? Lf(u, Kt(f, 2), Hm) : n
          }
          function x8(u) {
            return ZS(u, yi)
          }
          function M8(u, f) {
            return ZS(u, Kt(f, 2))
          }
          function E8(u) {
            return u && u.length ? Lf(u, yi, Km) : n
          }
          function P8(u, f) {
            return u && u.length ? Lf(u, Kt(f, 2), Km) : n
          }
          var T8 = zf(function (u, f) {
              return u * f
            }, 1),
            k8 = ig('round'),
            A8 = zf(function (u, f) {
              return u - f
            }, 0)
          function $8(u) {
            return u && u.length ? $m(u, yi) : 0
          }
          function O8(u, f) {
            return u && u.length ? $m(u, Kt(f, 2)) : 0
          }
          return (
            (ee.after = eR),
            (ee.ary = Cw),
            (ee.assign = VR),
            (ee.assignIn = Dw),
            (ee.assignInWith = Qf),
            (ee.assignWith = UR),
            (ee.at = HR),
            (ee.before = ww),
            (ee.bind = mg),
            (ee.bindAll = q6),
            (ee.bindKey = xw),
            (ee.castArray = fR),
            (ee.chain = bw),
            (ee.chunk = S5),
            (ee.compact = C5),
            (ee.concat = w5),
            (ee.cond = X6),
            (ee.conforms = Y6),
            (ee.constant = wg),
            (ee.countBy = $I),
            (ee.create = WR),
            (ee.curry = Mw),
            (ee.curryRight = Ew),
            (ee.debounce = Pw),
            (ee.defaults = jR),
            (ee.defaultsDeep = GR),
            (ee.defer = tR),
            (ee.delay = nR),
            (ee.difference = x5),
            (ee.differenceBy = M5),
            (ee.differenceWith = E5),
            (ee.drop = P5),
            (ee.dropRight = T5),
            (ee.dropRightWhile = k5),
            (ee.dropWhile = A5),
            (ee.fill = $5),
            (ee.filter = LI),
            (ee.flatMap = DI),
            (ee.flatMapDeep = NI),
            (ee.flatMapDepth = BI),
            (ee.flatten = vw),
            (ee.flattenDeep = O5),
            (ee.flattenDepth = L5),
            (ee.flip = rR),
            (ee.flow = J6),
            (ee.flowRight = Q6),
            (ee.fromPairs = I5),
            (ee.functions = QR),
            (ee.functionsIn = e6),
            (ee.groupBy = FI),
            (ee.initial = D5),
            (ee.intersection = N5),
            (ee.intersectionBy = B5),
            (ee.intersectionWith = F5),
            (ee.invert = n6),
            (ee.invertBy = r6),
            (ee.invokeMap = VI),
            (ee.iteratee = xg),
            (ee.keyBy = UI),
            (ee.keys = _r),
            (ee.keysIn = gi),
            (ee.map = Kf),
            (ee.mapKeys = o6),
            (ee.mapValues = a6),
            (ee.matches = e8),
            (ee.matchesProperty = t8),
            (ee.memoize = Xf),
            (ee.merge = s6),
            (ee.mergeWith = Nw),
            (ee.method = n8),
            (ee.methodOf = r8),
            (ee.mixin = Mg),
            (ee.negate = Yf),
            (ee.nthArg = o8),
            (ee.omit = l6),
            (ee.omitBy = u6),
            (ee.once = iR),
            (ee.orderBy = HI),
            (ee.over = a8),
            (ee.overArgs = oR),
            (ee.overEvery = s8),
            (ee.overSome = l8),
            (ee.partial = gg),
            (ee.partialRight = Tw),
            (ee.partition = WI),
            (ee.pick = c6),
            (ee.pickBy = Bw),
            (ee.property = jw),
            (ee.propertyOf = u8),
            (ee.pull = H5),
            (ee.pullAll = gw),
            (ee.pullAllBy = W5),
            (ee.pullAllWith = j5),
            (ee.pullAt = G5),
            (ee.range = c8),
            (ee.rangeRight = d8),
            (ee.rearg = aR),
            (ee.reject = KI),
            (ee.remove = K5),
            (ee.rest = sR),
            (ee.reverse = pg),
            (ee.sampleSize = XI),
            (ee.set = f6),
            (ee.setWith = h6),
            (ee.shuffle = YI),
            (ee.slice = q5),
            (ee.sortBy = QI),
            (ee.sortedUniq = tI),
            (ee.sortedUniqBy = nI),
            (ee.split = D6),
            (ee.spread = lR),
            (ee.tail = rI),
            (ee.take = iI),
            (ee.takeRight = oI),
            (ee.takeRightWhile = aI),
            (ee.takeWhile = sI),
            (ee.tap = CI),
            (ee.throttle = uR),
            (ee.thru = Gf),
            (ee.toArray = Lw),
            (ee.toPairs = Fw),
            (ee.toPairsIn = zw),
            (ee.toPath = m8),
            (ee.toPlainObject = Rw),
            (ee.transform = p6),
            (ee.unary = cR),
            (ee.union = lI),
            (ee.unionBy = uI),
            (ee.unionWith = cI),
            (ee.uniq = dI),
            (ee.uniqBy = fI),
            (ee.uniqWith = hI),
            (ee.unset = v6),
            (ee.unzip = vg),
            (ee.unzipWith = yw),
            (ee.update = m6),
            (ee.updateWith = g6),
            (ee.values = tu),
            (ee.valuesIn = y6),
            (ee.without = pI),
            (ee.words = Hw),
            (ee.wrap = dR),
            (ee.xor = vI),
            (ee.xorBy = mI),
            (ee.xorWith = gI),
            (ee.zip = yI),
            (ee.zipObject = bI),
            (ee.zipObjectDeep = _I),
            (ee.zipWith = SI),
            (ee.entries = Fw),
            (ee.entriesIn = zw),
            (ee.extend = Dw),
            (ee.extendWith = Qf),
            Mg(ee, ee),
            (ee.add = y8),
            (ee.attempt = Ww),
            (ee.camelCase = C6),
            (ee.capitalize = Vw),
            (ee.ceil = b8),
            (ee.clamp = b6),
            (ee.clone = hR),
            (ee.cloneDeep = vR),
            (ee.cloneDeepWith = mR),
            (ee.cloneWith = pR),
            (ee.conformsTo = gR),
            (ee.deburr = Uw),
            (ee.defaultTo = Z6),
            (ee.divide = _8),
            (ee.endsWith = w6),
            (ee.eq = mo),
            (ee.escape = x6),
            (ee.escapeRegExp = M6),
            (ee.every = OI),
            (ee.find = II),
            (ee.findIndex = hw),
            (ee.findKey = KR),
            (ee.findLast = RI),
            (ee.findLastIndex = pw),
            (ee.findLastKey = qR),
            (ee.floor = S8),
            (ee.forEach = _w),
            (ee.forEachRight = Sw),
            (ee.forIn = XR),
            (ee.forInRight = YR),
            (ee.forOwn = ZR),
            (ee.forOwnRight = JR),
            (ee.get = _g),
            (ee.gt = yR),
            (ee.gte = bR),
            (ee.has = t6),
            (ee.hasIn = Sg),
            (ee.head = mw),
            (ee.identity = yi),
            (ee.includes = zI),
            (ee.indexOf = R5),
            (ee.inRange = _6),
            (ee.invoke = i6),
            (ee.isArguments = Gs),
            (ee.isArray = Qt),
            (ee.isArrayBuffer = _R),
            (ee.isArrayLike = mi),
            (ee.isArrayLikeObject = er),
            (ee.isBoolean = SR),
            (ee.isBuffer = as),
            (ee.isDate = CR),
            (ee.isElement = wR),
            (ee.isEmpty = xR),
            (ee.isEqual = MR),
            (ee.isEqualWith = ER),
            (ee.isError = yg),
            (ee.isFinite = PR),
            (ee.isFunction = ba),
            (ee.isInteger = kw),
            (ee.isLength = Zf),
            (ee.isMap = Aw),
            (ee.isMatch = TR),
            (ee.isMatchWith = kR),
            (ee.isNaN = AR),
            (ee.isNative = $R),
            (ee.isNil = LR),
            (ee.isNull = OR),
            (ee.isNumber = $w),
            (ee.isObject = Gn),
            (ee.isObjectLike = Zn),
            (ee.isPlainObject = zc),
            (ee.isRegExp = bg),
            (ee.isSafeInteger = IR),
            (ee.isSet = Ow),
            (ee.isString = Jf),
            (ee.isSymbol = Li),
            (ee.isTypedArray = eu),
            (ee.isUndefined = RR),
            (ee.isWeakMap = DR),
            (ee.isWeakSet = NR),
            (ee.join = z5),
            (ee.kebabCase = E6),
            (ee.last = Yi),
            (ee.lastIndexOf = V5),
            (ee.lowerCase = P6),
            (ee.lowerFirst = T6),
            (ee.lt = BR),
            (ee.lte = FR),
            (ee.max = C8),
            (ee.maxBy = w8),
            (ee.mean = x8),
            (ee.meanBy = M8),
            (ee.min = E8),
            (ee.minBy = P8),
            (ee.stubArray = Pg),
            (ee.stubFalse = Tg),
            (ee.stubObject = f8),
            (ee.stubString = h8),
            (ee.stubTrue = p8),
            (ee.multiply = T8),
            (ee.nth = U5),
            (ee.noConflict = i8),
            (ee.noop = Eg),
            (ee.now = qf),
            (ee.pad = k6),
            (ee.padEnd = A6),
            (ee.padStart = $6),
            (ee.parseInt = O6),
            (ee.random = S6),
            (ee.reduce = jI),
            (ee.reduceRight = GI),
            (ee.repeat = L6),
            (ee.replace = I6),
            (ee.result = d6),
            (ee.round = k8),
            (ee.runInContext = Oe),
            (ee.sample = qI),
            (ee.size = ZI),
            (ee.snakeCase = R6),
            (ee.some = JI),
            (ee.sortedIndex = X5),
            (ee.sortedIndexBy = Y5),
            (ee.sortedIndexOf = Z5),
            (ee.sortedLastIndex = J5),
            (ee.sortedLastIndexBy = Q5),
            (ee.sortedLastIndexOf = eI),
            (ee.startCase = N6),
            (ee.startsWith = B6),
            (ee.subtract = A8),
            (ee.sum = $8),
            (ee.sumBy = O8),
            (ee.template = F6),
            (ee.times = v8),
            (ee.toFinite = _a),
            (ee.toInteger = tn),
            (ee.toLength = Iw),
            (ee.toLower = z6),
            (ee.toNumber = Zi),
            (ee.toSafeInteger = zR),
            (ee.toString = Mn),
            (ee.toUpper = V6),
            (ee.trim = U6),
            (ee.trimEnd = H6),
            (ee.trimStart = W6),
            (ee.truncate = j6),
            (ee.unescape = G6),
            (ee.uniqueId = g8),
            (ee.upperCase = K6),
            (ee.upperFirst = Cg),
            (ee.each = _w),
            (ee.eachRight = Sw),
            (ee.first = mw),
            Mg(
              ee,
              (function () {
                var u = {}
                return (
                  Uo(ee, function (f, S) {
                    Tn.call(ee.prototype, S) || (u[S] = f)
                  }),
                  u
                )
              })(),
              { chain: !1 }
            ),
            (ee.VERSION = r),
            ji(
              [
                'bind',
                'bindKey',
                'curry',
                'curryRight',
                'partial',
                'partialRight',
              ],
              function (u) {
                ee[u].placeholder = ee
              }
            ),
            ji(['drop', 'take'], function (u, f) {
              ;(fn.prototype[u] = function (S) {
                S = S === n ? 1 : dr(tn(S), 0)
                var $ = this.__filtered__ && !f ? new fn(this) : this.clone()
                return (
                  $.__filtered__
                    ? ($.__takeCount__ = Hr(S, $.__takeCount__))
                    : $.__views__.push({
                        size: Hr(S, le),
                        type: u + ($.__dir__ < 0 ? 'Right' : ''),
                      }),
                  $
                )
              }),
                (fn.prototype[u + 'Right'] = function (S) {
                  return this.reverse()[u](S).reverse()
                })
            }),
            ji(['filter', 'map', 'takeWhile'], function (u, f) {
              var S = f + 1,
                $ = S == I || S == V
              fn.prototype[u] = function (K) {
                var se = this.clone()
                return (
                  se.__iteratees__.push({ iteratee: Kt(K, 3), type: S }),
                  (se.__filtered__ = se.__filtered__ || $),
                  se
                )
              }
            }),
            ji(['head', 'last'], function (u, f) {
              var S = 'take' + (f ? 'Right' : '')
              fn.prototype[u] = function () {
                return this[S](1).value()[0]
              }
            }),
            ji(['initial', 'tail'], function (u, f) {
              var S = 'drop' + (f ? '' : 'Right')
              fn.prototype[u] = function () {
                return this.__filtered__ ? new fn(this) : this[S](1)
              }
            }),
            (fn.prototype.compact = function () {
              return this.filter(yi)
            }),
            (fn.prototype.find = function (u) {
              return this.filter(u).head()
            }),
            (fn.prototype.findLast = function (u) {
              return this.reverse().find(u)
            }),
            (fn.prototype.invokeMap = on(function (u, f) {
              return typeof u == 'function'
                ? new fn(this)
                : this.map(function (S) {
                    return Ic(S, u, f)
                  })
            })),
            (fn.prototype.reject = function (u) {
              return this.filter(Yf(Kt(u)))
            }),
            (fn.prototype.slice = function (u, f) {
              u = tn(u)
              var S = this
              return S.__filtered__ && (u > 0 || f < 0)
                ? new fn(S)
                : (u < 0 ? (S = S.takeRight(-u)) : u && (S = S.drop(u)),
                  f !== n &&
                    ((f = tn(f)),
                    (S = f < 0 ? S.dropRight(-f) : S.take(f - u))),
                  S)
            }),
            (fn.prototype.takeRightWhile = function (u) {
              return this.reverse().takeWhile(u).reverse()
            }),
            (fn.prototype.toArray = function () {
              return this.take(le)
            }),
            Uo(fn.prototype, function (u, f) {
              var S = /^(?:filter|find|map|reject)|While$/.test(f),
                $ = /^(?:head|last)$/.test(f),
                K = ee[$ ? 'take' + (f == 'last' ? 'Right' : '') : f],
                se = $ || /^find/.test(f)
              K &&
                (ee.prototype[f] = function () {
                  var be = this.__wrapped__,
                    Me = $ ? [1] : arguments,
                    Ie = be instanceof fn,
                    ut = Me[0],
                    dt = Ie || Qt(be),
                    ht = function (dn) {
                      var mn = K.apply(ee, Qa([dn], Me))
                      return $ && $t ? mn[0] : mn
                    }
                  dt &&
                    S &&
                    typeof ut == 'function' &&
                    ut.length != 1 &&
                    (Ie = dt = !1)
                  var $t = this.__chain__,
                    Ut = !!this.__actions__.length,
                    qt = se && !$t,
                    nn = Ie && !Ut
                  if (!se && dt) {
                    be = nn ? be : new fn(this)
                    var Xt = u.apply(be, Me)
                    return (
                      Xt.__actions__.push({ func: Gf, args: [ht], thisArg: n }),
                      new Ki(Xt, $t)
                    )
                  }
                  return qt && nn
                    ? u.apply(this, Me)
                    : ((Xt = this.thru(ht)),
                      qt ? ($ ? Xt.value()[0] : Xt.value()) : Xt)
                })
            }),
            ji(
              ['pop', 'push', 'shift', 'sort', 'splice', 'unshift'],
              function (u) {
                var f = yf[u],
                  S = /^(?:push|sort|unshift)$/.test(u) ? 'tap' : 'thru',
                  $ = /^(?:pop|shift)$/.test(u)
                ee.prototype[u] = function () {
                  var K = arguments
                  if ($ && !this.__chain__) {
                    var se = this.value()
                    return f.apply(Qt(se) ? se : [], K)
                  }
                  return this[S](function (be) {
                    return f.apply(Qt(be) ? be : [], K)
                  })
                }
              }
            ),
            Uo(fn.prototype, function (u, f) {
              var S = ee[f]
              if (S) {
                var $ = S.name + ''
                Tn.call(Xl, $) || (Xl[$] = []), Xl[$].push({ name: f, func: S })
              }
            }),
            (Xl[Ff(n, y).name] = [{ name: 'wrapper', func: n }]),
            (fn.prototype.clone = GO),
            (fn.prototype.reverse = KO),
            (fn.prototype.value = qO),
            (ee.prototype.at = wI),
            (ee.prototype.chain = xI),
            (ee.prototype.commit = MI),
            (ee.prototype.next = EI),
            (ee.prototype.plant = TI),
            (ee.prototype.reverse = kI),
            (ee.prototype.toJSON =
              ee.prototype.valueOf =
              ee.prototype.value =
                AI),
            (ee.prototype.first = ee.prototype.head),
            Pc && (ee.prototype[Pc] = PI),
            ee
          )
        },
        Gl = MO()
      Sn ? (((Sn.exports = Gl)._ = Gl), (Mc._ = Gl)) : (jn._ = Gl)
    }).call(Bi)
  })(wv, wv.exports)
  var $r = wv.exports
  function R$(e, t) {
    return function () {
      return e.apply(t, arguments)
    }
  }
  const { toString: Vhe } = Object.prototype,
    { getPrototypeOf: FS } = Object,
    vm = ((e) => (t) => {
      const n = Vhe.call(t)
      return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
    })(Object.create(null)),
    ca = (e) => ((e = e.toLowerCase()), (t) => vm(t) === e),
    mm = (e) => (t) => typeof t === e,
    { isArray: fc } = Array,
    Hd = mm('undefined')
  function Uhe(e) {
    return (
      e !== null &&
      !Hd(e) &&
      e.constructor !== null &&
      !Hd(e.constructor) &&
      lo(e.constructor.isBuffer) &&
      e.constructor.isBuffer(e)
    )
  }
  const D$ = ca('ArrayBuffer')
  function Hhe(e) {
    let t
    return (
      typeof ArrayBuffer < 'u' && ArrayBuffer.isView
        ? (t = ArrayBuffer.isView(e))
        : (t = e && e.buffer && D$(e.buffer)),
      t
    )
  }
  const Whe = mm('string'),
    lo = mm('function'),
    N$ = mm('number'),
    gm = (e) => e !== null && typeof e == 'object',
    jhe = (e) => e === !0 || e === !1,
    Gp = (e) => {
      if (vm(e) !== 'object') return !1
      const t = FS(e)
      return (
        (t === null ||
          t === Object.prototype ||
          Object.getPrototypeOf(t) === null) &&
        !(Symbol.toStringTag in e) &&
        !(Symbol.iterator in e)
      )
    },
    Ghe = ca('Date'),
    Khe = ca('File'),
    qhe = ca('Blob'),
    Xhe = ca('FileList'),
    Yhe = (e) => gm(e) && lo(e.pipe),
    Zhe = (e) => {
      let t
      return (
        e &&
        ((typeof FormData == 'function' && e instanceof FormData) ||
          (lo(e.append) &&
            ((t = vm(e)) === 'formdata' ||
              (t === 'object' &&
                lo(e.toString) &&
                e.toString() === '[object FormData]'))))
      )
    },
    Jhe = ca('URLSearchParams'),
    Qhe = (e) =>
      e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
  function af(e, t, { allOwnKeys: n = !1 } = {}) {
    if (e === null || typeof e > 'u') return
    let r, i
    if ((typeof e != 'object' && (e = [e]), fc(e)))
      for (r = 0, i = e.length; r < i; r++) t.call(null, e[r], r, e)
    else {
      const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
        a = o.length
      let s
      for (r = 0; r < a; r++) (s = o[r]), t.call(null, e[s], s, e)
    }
  }
  function B$(e, t) {
    t = t.toLowerCase()
    const n = Object.keys(e)
    let r = n.length,
      i
    for (; r-- > 0; ) if (((i = n[r]), t === i.toLowerCase())) return i
    return null
  }
  const F$ = (() =>
      typeof globalThis < 'u'
        ? globalThis
        : typeof self < 'u'
        ? self
        : typeof window < 'u'
        ? window
        : global)(),
    z$ = (e) => !Hd(e) && e !== F$
  function n_() {
    const { caseless: e } = (z$(this) && this) || {},
      t = {},
      n = (r, i) => {
        const o = (e && B$(t, i)) || i
        Gp(t[o]) && Gp(r)
          ? (t[o] = n_(t[o], r))
          : Gp(r)
          ? (t[o] = n_({}, r))
          : fc(r)
          ? (t[o] = r.slice())
          : (t[o] = r)
      }
    for (let r = 0, i = arguments.length; r < i; r++)
      arguments[r] && af(arguments[r], n)
    return t
  }
  const epe = (e, t, n, { allOwnKeys: r } = {}) => (
      af(
        t,
        (i, o) => {
          n && lo(i) ? (e[o] = R$(i, n)) : (e[o] = i)
        },
        { allOwnKeys: r }
      ),
      e
    ),
    tpe = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e),
    npe = (e, t, n, r) => {
      ;(e.prototype = Object.create(t.prototype, r)),
        (e.prototype.constructor = e),
        Object.defineProperty(e, 'super', { value: t.prototype }),
        n && Object.assign(e.prototype, n)
    },
    rpe = (e, t, n, r) => {
      let i, o, a
      const s = {}
      if (((t = t || {}), e == null)) return t
      do {
        for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
          (a = i[o]),
            (!r || r(a, e, t)) && !s[a] && ((t[a] = e[a]), (s[a] = !0))
        e = n !== !1 && FS(e)
      } while (e && (!n || n(e, t)) && e !== Object.prototype)
      return t
    },
    ipe = (e, t, n) => {
      ;(e = String(e)),
        (n === void 0 || n > e.length) && (n = e.length),
        (n -= t.length)
      const r = e.indexOf(t, n)
      return r !== -1 && r === n
    },
    ope = (e) => {
      if (!e) return null
      if (fc(e)) return e
      let t = e.length
      if (!N$(t)) return null
      const n = new Array(t)
      for (; t-- > 0; ) n[t] = e[t]
      return n
    },
    ape = (
      (e) => (t) =>
        e && t instanceof e
    )(typeof Uint8Array < 'u' && FS(Uint8Array)),
    spe = (e, t) => {
      const r = (e && e[Symbol.iterator]).call(e)
      let i
      for (; (i = r.next()) && !i.done; ) {
        const o = i.value
        t.call(e, o[0], o[1])
      }
    },
    lpe = (e, t) => {
      let n
      const r = []
      for (; (n = e.exec(t)) !== null; ) r.push(n)
      return r
    },
    upe = ca('HTMLFormElement'),
    cpe = (e) =>
      e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) {
        return r.toUpperCase() + i
      }),
    YP = (
      ({ hasOwnProperty: e }) =>
      (t, n) =>
        e.call(t, n)
    )(Object.prototype),
    dpe = ca('RegExp'),
    V$ = (e, t) => {
      const n = Object.getOwnPropertyDescriptors(e),
        r = {}
      af(n, (i, o) => {
        t(i, o, e) !== !1 && (r[o] = i)
      }),
        Object.defineProperties(e, r)
    },
    fpe = (e) => {
      V$(e, (t, n) => {
        if (lo(e) && ['arguments', 'caller', 'callee'].indexOf(n) !== -1)
          return !1
        const r = e[n]
        if (lo(r)) {
          if (((t.enumerable = !1), 'writable' in t)) {
            t.writable = !1
            return
          }
          t.set ||
            (t.set = () => {
              throw Error("Can not rewrite read-only method '" + n + "'")
            })
        }
      })
    },
    hpe = (e, t) => {
      const n = {},
        r = (i) => {
          i.forEach((o) => {
            n[o] = !0
          })
        }
      return fc(e) ? r(e) : r(String(e).split(t)), n
    },
    ppe = () => {},
    vpe = (e, t) => ((e = +e), Number.isFinite(e) ? e : t),
    Y1 = 'abcdefghijklmnopqrstuvwxyz',
    ZP = '0123456789',
    U$ = { DIGIT: ZP, ALPHA: Y1, ALPHA_DIGIT: Y1 + Y1.toUpperCase() + ZP },
    mpe = (e = 16, t = U$.ALPHA_DIGIT) => {
      let n = ''
      const { length: r } = t
      for (; e--; ) n += t[(Math.random() * r) | 0]
      return n
    }
  function gpe(e) {
    return !!(
      e &&
      lo(e.append) &&
      e[Symbol.toStringTag] === 'FormData' &&
      e[Symbol.iterator]
    )
  }
  const ype = (e) => {
      const t = new Array(10),
        n = (r, i) => {
          if (gm(r)) {
            if (t.indexOf(r) >= 0) return
            if (!('toJSON' in r)) {
              t[i] = r
              const o = fc(r) ? [] : {}
              return (
                af(r, (a, s) => {
                  const l = n(a, i + 1)
                  !Hd(l) && (o[s] = l)
                }),
                (t[i] = void 0),
                o
              )
            }
          }
          return r
        }
      return n(e, 0)
    },
    bpe = ca('AsyncFunction'),
    _pe = (e) => e && (gm(e) || lo(e)) && lo(e.then) && lo(e.catch),
    st = {
      isArray: fc,
      isArrayBuffer: D$,
      isBuffer: Uhe,
      isFormData: Zhe,
      isArrayBufferView: Hhe,
      isString: Whe,
      isNumber: N$,
      isBoolean: jhe,
      isObject: gm,
      isPlainObject: Gp,
      isUndefined: Hd,
      isDate: Ghe,
      isFile: Khe,
      isBlob: qhe,
      isRegExp: dpe,
      isFunction: lo,
      isStream: Yhe,
      isURLSearchParams: Jhe,
      isTypedArray: ape,
      isFileList: Xhe,
      forEach: af,
      merge: n_,
      extend: epe,
      trim: Qhe,
      stripBOM: tpe,
      inherits: npe,
      toFlatObject: rpe,
      kindOf: vm,
      kindOfTest: ca,
      endsWith: ipe,
      toArray: ope,
      forEachEntry: spe,
      matchAll: lpe,
      isHTMLForm: upe,
      hasOwnProperty: YP,
      hasOwnProp: YP,
      reduceDescriptors: V$,
      freezeMethods: fpe,
      toObjectSet: hpe,
      toCamelCase: cpe,
      noop: ppe,
      toFiniteNumber: vpe,
      findKey: B$,
      global: F$,
      isContextDefined: z$,
      ALPHABET: U$,
      generateString: mpe,
      isSpecCompliantForm: gpe,
      toJSONObject: ype,
      isAsyncFn: bpe,
      isThenable: _pe,
    }
  function bn(e, t, n, r, i) {
    Error.call(this),
      Error.captureStackTrace
        ? Error.captureStackTrace(this, this.constructor)
        : (this.stack = new Error().stack),
      (this.message = e),
      (this.name = 'AxiosError'),
      t && (this.code = t),
      n && (this.config = n),
      r && (this.request = r),
      i && (this.response = i)
  }
  st.inherits(bn, Error, {
    toJSON: function () {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: st.toJSONObject(this.config),
        code: this.code,
        status:
          this.response && this.response.status ? this.response.status : null,
      }
    },
  })
  const H$ = bn.prototype,
    W$ = {}
  ;[
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL',
  ].forEach((e) => {
    W$[e] = { value: e }
  })
  Object.defineProperties(bn, W$)
  Object.defineProperty(H$, 'isAxiosError', { value: !0 })
  bn.from = (e, t, n, r, i, o) => {
    const a = Object.create(H$)
    return (
      st.toFlatObject(
        e,
        a,
        function (l) {
          return l !== Error.prototype
        },
        (s) => s !== 'isAxiosError'
      ),
      bn.call(a, e.message, t, n, r, i),
      (a.cause = e),
      (a.name = e.name),
      o && Object.assign(a, o),
      a
    )
  }
  const Spe = null
  function r_(e) {
    return st.isPlainObject(e) || st.isArray(e)
  }
  function j$(e) {
    return st.endsWith(e, '[]') ? e.slice(0, -2) : e
  }
  function JP(e, t, n) {
    return e
      ? e
          .concat(t)
          .map(function (i, o) {
            return (i = j$(i)), !n && o ? '[' + i + ']' : i
          })
          .join(n ? '.' : '')
      : t
  }
  function Cpe(e) {
    return st.isArray(e) && !e.some(r_)
  }
  const wpe = st.toFlatObject(st, {}, null, function (t) {
    return /^is[A-Z]/.test(t)
  })
  function ym(e, t, n) {
    if (!st.isObject(e)) throw new TypeError('target must be an object')
    ;(t = t || new FormData()),
      (n = st.toFlatObject(
        n,
        { metaTokens: !0, dots: !1, indexes: !1 },
        !1,
        function (_, b) {
          return !st.isUndefined(b[_])
        }
      ))
    const r = n.metaTokens,
      i = n.visitor || d,
      o = n.dots,
      a = n.indexes,
      l = (n.Blob || (typeof Blob < 'u' && Blob)) && st.isSpecCompliantForm(t)
    if (!st.isFunction(i)) throw new TypeError('visitor must be a function')
    function c(g) {
      if (g === null) return ''
      if (st.isDate(g)) return g.toISOString()
      if (!l && st.isBlob(g))
        throw new bn('Blob is not supported. Use a Buffer instead.')
      return st.isArrayBuffer(g) || st.isTypedArray(g)
        ? l && typeof Blob == 'function'
          ? new Blob([g])
          : Buffer.from(g)
        : g
    }
    function d(g, _, b) {
      let y = g
      if (g && !b && typeof g == 'object') {
        if (st.endsWith(_, '{}'))
          (_ = r ? _ : _.slice(0, -2)), (g = JSON.stringify(g))
        else if (
          (st.isArray(g) && Cpe(g)) ||
          ((st.isFileList(g) || st.endsWith(_, '[]')) && (y = st.toArray(g)))
        )
          return (
            (_ = j$(_)),
            y.forEach(function (x, w) {
              !(st.isUndefined(x) || x === null) &&
                t.append(
                  a === !0 ? JP([_], w, o) : a === null ? _ : _ + '[]',
                  c(x)
                )
            }),
            !1
          )
      }
      return r_(g) ? !0 : (t.append(JP(b, _, o), c(g)), !1)
    }
    const h = [],
      p = Object.assign(wpe, {
        defaultVisitor: d,
        convertValue: c,
        isVisitable: r_,
      })
    function v(g, _) {
      if (!st.isUndefined(g)) {
        if (h.indexOf(g) !== -1)
          throw Error('Circular reference detected in ' + _.join('.'))
        h.push(g),
          st.forEach(g, function (y, M) {
            ;(!(st.isUndefined(y) || y === null) &&
              i.call(t, y, st.isString(M) ? M.trim() : M, _, p)) === !0 &&
              v(y, _ ? _.concat(M) : [M])
          }),
          h.pop()
      }
    }
    if (!st.isObject(e)) throw new TypeError('data must be an object')
    return v(e), t
  }
  function QP(e) {
    const t = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\0',
    }
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) {
      return t[r]
    })
  }
  function zS(e, t) {
    ;(this._pairs = []), e && ym(e, this, t)
  }
  const G$ = zS.prototype
  G$.append = function (t, n) {
    this._pairs.push([t, n])
  }
  G$.toString = function (t) {
    const n = t
      ? function (r) {
          return t.call(this, r, QP)
        }
      : QP
    return this._pairs
      .map(function (i) {
        return n(i[0]) + '=' + n(i[1])
      }, '')
      .join('&')
  }
  function xpe(e) {
    return encodeURIComponent(e)
      .replace(/%3A/gi, ':')
      .replace(/%24/g, '$')
      .replace(/%2C/gi, ',')
      .replace(/%20/g, '+')
      .replace(/%5B/gi, '[')
      .replace(/%5D/gi, ']')
  }
  function K$(e, t, n) {
    if (!t) return e
    const r = (n && n.encode) || xpe,
      i = n && n.serialize
    let o
    if (
      (i
        ? (o = i(t, n))
        : (o = st.isURLSearchParams(t)
            ? t.toString()
            : new zS(t, n).toString(r)),
      o)
    ) {
      const a = e.indexOf('#')
      a !== -1 && (e = e.slice(0, a)),
        (e += (e.indexOf('?') === -1 ? '?' : '&') + o)
    }
    return e
  }
  class Mpe {
    constructor() {
      this.handlers = []
    }
    use(t, n, r) {
      return (
        this.handlers.push({
          fulfilled: t,
          rejected: n,
          synchronous: r ? r.synchronous : !1,
          runWhen: r ? r.runWhen : null,
        }),
        this.handlers.length - 1
      )
    }
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null)
    }
    clear() {
      this.handlers && (this.handlers = [])
    }
    forEach(t) {
      st.forEach(this.handlers, function (r) {
        r !== null && t(r)
      })
    }
  }
  const eT = Mpe,
    q$ = {
      silentJSONParsing: !0,
      forcedJSONParsing: !0,
      clarifyTimeoutError: !1,
    },
    Epe = typeof URLSearchParams < 'u' ? URLSearchParams : zS,
    Ppe = typeof FormData < 'u' ? FormData : null,
    Tpe = typeof Blob < 'u' ? Blob : null,
    kpe = (() => {
      let e
      return typeof navigator < 'u' &&
        ((e = navigator.product) === 'ReactNative' ||
          e === 'NativeScript' ||
          e === 'NS')
        ? !1
        : typeof window < 'u' && typeof document < 'u'
    })(),
    Ape = (() =>
      typeof WorkerGlobalScope < 'u' &&
      self instanceof WorkerGlobalScope &&
      typeof self.importScripts == 'function')(),
    Qo = {
      isBrowser: !0,
      classes: { URLSearchParams: Epe, FormData: Ppe, Blob: Tpe },
      isStandardBrowserEnv: kpe,
      isStandardBrowserWebWorkerEnv: Ape,
      protocols: ['http', 'https', 'file', 'blob', 'url', 'data'],
    }
  function $pe(e, t) {
    return ym(
      e,
      new Qo.classes.URLSearchParams(),
      Object.assign(
        {
          visitor: function (n, r, i, o) {
            return Qo.isNode && st.isBuffer(n)
              ? (this.append(r, n.toString('base64')), !1)
              : o.defaultVisitor.apply(this, arguments)
          },
        },
        t
      )
    )
  }
  function Ope(e) {
    return st
      .matchAll(/\w+|\[(\w*)]/g, e)
      .map((t) => (t[0] === '[]' ? '' : t[1] || t[0]))
  }
  function Lpe(e) {
    const t = {},
      n = Object.keys(e)
    let r
    const i = n.length
    let o
    for (r = 0; r < i; r++) (o = n[r]), (t[o] = e[o])
    return t
  }
  function X$(e) {
    function t(n, r, i, o) {
      let a = n[o++]
      const s = Number.isFinite(+a),
        l = o >= n.length
      return (
        (a = !a && st.isArray(i) ? i.length : a),
        l
          ? (st.hasOwnProp(i, a) ? (i[a] = [i[a], r]) : (i[a] = r), !s)
          : ((!i[a] || !st.isObject(i[a])) && (i[a] = []),
            t(n, r, i[a], o) && st.isArray(i[a]) && (i[a] = Lpe(i[a])),
            !s)
      )
    }
    if (st.isFormData(e) && st.isFunction(e.entries)) {
      const n = {}
      return (
        st.forEachEntry(e, (r, i) => {
          t(Ope(r), i, n, 0)
        }),
        n
      )
    }
    return null
  }
  const Ipe = { 'Content-Type': void 0 }
  function Rpe(e, t, n) {
    if (st.isString(e))
      try {
        return (t || JSON.parse)(e), st.trim(e)
      } catch (r) {
        if (r.name !== 'SyntaxError') throw r
      }
    return (n || JSON.stringify)(e)
  }
  const bm = {
    transitional: q$,
    adapter: ['xhr', 'http'],
    transformRequest: [
      function (t, n) {
        const r = n.getContentType() || '',
          i = r.indexOf('application/json') > -1,
          o = st.isObject(t)
        if ((o && st.isHTMLForm(t) && (t = new FormData(t)), st.isFormData(t)))
          return i && i ? JSON.stringify(X$(t)) : t
        if (
          st.isArrayBuffer(t) ||
          st.isBuffer(t) ||
          st.isStream(t) ||
          st.isFile(t) ||
          st.isBlob(t)
        )
          return t
        if (st.isArrayBufferView(t)) return t.buffer
        if (st.isURLSearchParams(t))
          return (
            n.setContentType(
              'application/x-www-form-urlencoded;charset=utf-8',
              !1
            ),
            t.toString()
          )
        let s
        if (o) {
          if (r.indexOf('application/x-www-form-urlencoded') > -1)
            return $pe(t, this.formSerializer).toString()
          if ((s = st.isFileList(t)) || r.indexOf('multipart/form-data') > -1) {
            const l = this.env && this.env.FormData
            return ym(
              s ? { 'files[]': t } : t,
              l && new l(),
              this.formSerializer
            )
          }
        }
        return o || i ? (n.setContentType('application/json', !1), Rpe(t)) : t
      },
    ],
    transformResponse: [
      function (t) {
        const n = this.transitional || bm.transitional,
          r = n && n.forcedJSONParsing,
          i = this.responseType === 'json'
        if (t && st.isString(t) && ((r && !this.responseType) || i)) {
          const a = !(n && n.silentJSONParsing) && i
          try {
            return JSON.parse(t)
          } catch (s) {
            if (a)
              throw s.name === 'SyntaxError'
                ? bn.from(s, bn.ERR_BAD_RESPONSE, this, null, this.response)
                : s
          }
        }
        return t
      },
    ],
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: Qo.classes.FormData, Blob: Qo.classes.Blob },
    validateStatus: function (t) {
      return t >= 200 && t < 300
    },
    headers: { common: { Accept: 'application/json, text/plain, */*' } },
  }
  st.forEach(['delete', 'get', 'head'], function (t) {
    bm.headers[t] = {}
  })
  st.forEach(['post', 'put', 'patch'], function (t) {
    bm.headers[t] = st.merge(Ipe)
  })
  const VS = bm,
    Dpe = st.toObjectSet([
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ]),
    Npe = (e) => {
      const t = {}
      let n, r, i
      return (
        e &&
          e
            .split(
              `
`
            )
            .forEach(function (a) {
              ;(i = a.indexOf(':')),
                (n = a.substring(0, i).trim().toLowerCase()),
                (r = a.substring(i + 1).trim()),
                !(!n || (t[n] && Dpe[n])) &&
                  (n === 'set-cookie'
                    ? t[n]
                      ? t[n].push(r)
                      : (t[n] = [r])
                    : (t[n] = t[n] ? t[n] + ', ' + r : r))
            }),
        t
      )
    },
    tT = Symbol('internals')
  function Xc(e) {
    return e && String(e).trim().toLowerCase()
  }
  function Kp(e) {
    return e === !1 || e == null ? e : st.isArray(e) ? e.map(Kp) : String(e)
  }
  function Bpe(e) {
    const t = Object.create(null),
      n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
    let r
    for (; (r = n.exec(e)); ) t[r[1]] = r[2]
    return t
  }
  const Fpe = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())
  function Z1(e, t, n, r, i) {
    if (st.isFunction(r)) return r.call(this, t, n)
    if ((i && (t = n), !!st.isString(t))) {
      if (st.isString(r)) return t.indexOf(r) !== -1
      if (st.isRegExp(r)) return r.test(t)
    }
  }
  function zpe(e) {
    return e
      .trim()
      .toLowerCase()
      .replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r)
  }
  function Vpe(e, t) {
    const n = st.toCamelCase(' ' + t)
    ;['get', 'set', 'has'].forEach((r) => {
      Object.defineProperty(e, r + n, {
        value: function (i, o, a) {
          return this[r].call(this, t, i, o, a)
        },
        configurable: !0,
      })
    })
  }
  class _m {
    constructor(t) {
      t && this.set(t)
    }
    set(t, n, r) {
      const i = this
      function o(s, l, c) {
        const d = Xc(l)
        if (!d) throw new Error('header name must be a non-empty string')
        const h = st.findKey(i, d)
        ;(!h || i[h] === void 0 || c === !0 || (c === void 0 && i[h] !== !1)) &&
          (i[h || l] = Kp(s))
      }
      const a = (s, l) => st.forEach(s, (c, d) => o(c, d, l))
      return (
        st.isPlainObject(t) || t instanceof this.constructor
          ? a(t, n)
          : st.isString(t) && (t = t.trim()) && !Fpe(t)
          ? a(Npe(t), n)
          : t != null && o(n, t, r),
        this
      )
    }
    get(t, n) {
      if (((t = Xc(t)), t)) {
        const r = st.findKey(this, t)
        if (r) {
          const i = this[r]
          if (!n) return i
          if (n === !0) return Bpe(i)
          if (st.isFunction(n)) return n.call(this, i, r)
          if (st.isRegExp(n)) return n.exec(i)
          throw new TypeError('parser must be boolean|regexp|function')
        }
      }
    }
    has(t, n) {
      if (((t = Xc(t)), t)) {
        const r = st.findKey(this, t)
        return !!(r && this[r] !== void 0 && (!n || Z1(this, this[r], r, n)))
      }
      return !1
    }
    delete(t, n) {
      const r = this
      let i = !1
      function o(a) {
        if (((a = Xc(a)), a)) {
          const s = st.findKey(r, a)
          s && (!n || Z1(r, r[s], s, n)) && (delete r[s], (i = !0))
        }
      }
      return st.isArray(t) ? t.forEach(o) : o(t), i
    }
    clear(t) {
      const n = Object.keys(this)
      let r = n.length,
        i = !1
      for (; r--; ) {
        const o = n[r]
        ;(!t || Z1(this, this[o], o, t, !0)) && (delete this[o], (i = !0))
      }
      return i
    }
    normalize(t) {
      const n = this,
        r = {}
      return (
        st.forEach(this, (i, o) => {
          const a = st.findKey(r, o)
          if (a) {
            ;(n[a] = Kp(i)), delete n[o]
            return
          }
          const s = t ? zpe(o) : String(o).trim()
          s !== o && delete n[o], (n[s] = Kp(i)), (r[s] = !0)
        }),
        this
      )
    }
    concat(...t) {
      return this.constructor.concat(this, ...t)
    }
    toJSON(t) {
      const n = Object.create(null)
      return (
        st.forEach(this, (r, i) => {
          r != null &&
            r !== !1 &&
            (n[i] = t && st.isArray(r) ? r.join(', ') : r)
        }),
        n
      )
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
      return Object.entries(this.toJSON()).map(([t, n]) => t + ': ' + n).join(`
`)
    }
    get [Symbol.toStringTag]() {
      return 'AxiosHeaders'
    }
    static from(t) {
      return t instanceof this ? t : new this(t)
    }
    static concat(t, ...n) {
      const r = new this(t)
      return n.forEach((i) => r.set(i)), r
    }
    static accessor(t) {
      const r = (this[tT] = this[tT] = { accessors: {} }).accessors,
        i = this.prototype
      function o(a) {
        const s = Xc(a)
        r[s] || (Vpe(i, a), (r[s] = !0))
      }
      return st.isArray(t) ? t.forEach(o) : o(t), this
    }
  }
  _m.accessor([
    'Content-Type',
    'Content-Length',
    'Accept',
    'Accept-Encoding',
    'User-Agent',
    'Authorization',
  ])
  st.freezeMethods(_m.prototype)
  st.freezeMethods(_m)
  const za = _m
  function J1(e, t) {
    const n = this || VS,
      r = t || n,
      i = za.from(r.headers)
    let o = r.data
    return (
      st.forEach(e, function (s) {
        o = s.call(n, o, i.normalize(), t ? t.status : void 0)
      }),
      i.normalize(),
      o
    )
  }
  function Y$(e) {
    return !!(e && e.__CANCEL__)
  }
  function sf(e, t, n) {
    bn.call(this, e ?? 'canceled', bn.ERR_CANCELED, t, n),
      (this.name = 'CanceledError')
  }
  st.inherits(sf, bn, { __CANCEL__: !0 })
  function Upe(e, t, n) {
    const r = n.config.validateStatus
    !n.status || !r || r(n.status)
      ? e(n)
      : t(
          new bn(
            'Request failed with status code ' + n.status,
            [bn.ERR_BAD_REQUEST, bn.ERR_BAD_RESPONSE][
              Math.floor(n.status / 100) - 4
            ],
            n.config,
            n.request,
            n
          )
        )
  }
  const Hpe = Qo.isStandardBrowserEnv
    ? (function () {
        return {
          write: function (n, r, i, o, a, s) {
            const l = []
            l.push(n + '=' + encodeURIComponent(r)),
              st.isNumber(i) && l.push('expires=' + new Date(i).toGMTString()),
              st.isString(o) && l.push('path=' + o),
              st.isString(a) && l.push('domain=' + a),
              s === !0 && l.push('secure'),
              (document.cookie = l.join('; '))
          },
          read: function (n) {
            const r = document.cookie.match(
              new RegExp('(^|;\\s*)(' + n + ')=([^;]*)')
            )
            return r ? decodeURIComponent(r[3]) : null
          },
          remove: function (n) {
            this.write(n, '', Date.now() - 864e5)
          },
        }
      })()
    : (function () {
        return {
          write: function () {},
          read: function () {
            return null
          },
          remove: function () {},
        }
      })()
  function Wpe(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
  }
  function jpe(e, t) {
    return t ? e.replace(/\/+$/, '') + '/' + t.replace(/^\/+/, '') : e
  }
  function Z$(e, t) {
    return e && !Wpe(t) ? jpe(e, t) : t
  }
  const Gpe = Qo.isStandardBrowserEnv
    ? (function () {
        const t = /(msie|trident)/i.test(navigator.userAgent),
          n = document.createElement('a')
        let r
        function i(o) {
          let a = o
          return (
            t && (n.setAttribute('href', a), (a = n.href)),
            n.setAttribute('href', a),
            {
              href: n.href,
              protocol: n.protocol ? n.protocol.replace(/:$/, '') : '',
              host: n.host,
              search: n.search ? n.search.replace(/^\?/, '') : '',
              hash: n.hash ? n.hash.replace(/^#/, '') : '',
              hostname: n.hostname,
              port: n.port,
              pathname:
                n.pathname.charAt(0) === '/' ? n.pathname : '/' + n.pathname,
            }
          )
        }
        return (
          (r = i(window.location.href)),
          function (a) {
            const s = st.isString(a) ? i(a) : a
            return s.protocol === r.protocol && s.host === r.host
          }
        )
      })()
    : (function () {
        return function () {
          return !0
        }
      })()
  function Kpe(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e)
    return (t && t[1]) || ''
  }
  function qpe(e, t) {
    e = e || 10
    const n = new Array(e),
      r = new Array(e)
    let i = 0,
      o = 0,
      a
    return (
      (t = t !== void 0 ? t : 1e3),
      function (l) {
        const c = Date.now(),
          d = r[o]
        a || (a = c), (n[i] = l), (r[i] = c)
        let h = o,
          p = 0
        for (; h !== i; ) (p += n[h++]), (h = h % e)
        if (((i = (i + 1) % e), i === o && (o = (o + 1) % e), c - a < t)) return
        const v = d && c - d
        return v ? Math.round((p * 1e3) / v) : void 0
      }
    )
  }
  function nT(e, t) {
    let n = 0
    const r = qpe(50, 250)
    return (i) => {
      const o = i.loaded,
        a = i.lengthComputable ? i.total : void 0,
        s = o - n,
        l = r(s),
        c = o <= a
      n = o
      const d = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: s,
        rate: l || void 0,
        estimated: l && a && c ? (a - o) / l : void 0,
        event: i,
      }
      ;(d[t ? 'download' : 'upload'] = !0), e(d)
    }
  }
  const Xpe = typeof XMLHttpRequest < 'u',
    Ype =
      Xpe &&
      function (e) {
        return new Promise(function (n, r) {
          let i = e.data
          const o = za.from(e.headers).normalize(),
            a = e.responseType
          let s
          function l() {
            e.cancelToken && e.cancelToken.unsubscribe(s),
              e.signal && e.signal.removeEventListener('abort', s)
          }
          st.isFormData(i) &&
            (Qo.isStandardBrowserEnv || Qo.isStandardBrowserWebWorkerEnv
              ? o.setContentType(!1)
              : o.setContentType('multipart/form-data;', !1))
          let c = new XMLHttpRequest()
          if (e.auth) {
            const v = e.auth.username || '',
              g = e.auth.password
                ? unescape(encodeURIComponent(e.auth.password))
                : ''
            o.set('Authorization', 'Basic ' + btoa(v + ':' + g))
          }
          const d = Z$(e.baseURL, e.url)
          c.open(
            e.method.toUpperCase(),
            K$(d, e.params, e.paramsSerializer),
            !0
          ),
            (c.timeout = e.timeout)
          function h() {
            if (!c) return
            const v = za.from(
                'getAllResponseHeaders' in c && c.getAllResponseHeaders()
              ),
              _ = {
                data:
                  !a || a === 'text' || a === 'json'
                    ? c.responseText
                    : c.response,
                status: c.status,
                statusText: c.statusText,
                headers: v,
                config: e,
                request: c,
              }
            Upe(
              function (y) {
                n(y), l()
              },
              function (y) {
                r(y), l()
              },
              _
            ),
              (c = null)
          }
          if (
            ('onloadend' in c
              ? (c.onloadend = h)
              : (c.onreadystatechange = function () {
                  !c ||
                    c.readyState !== 4 ||
                    (c.status === 0 &&
                      !(
                        c.responseURL && c.responseURL.indexOf('file:') === 0
                      )) ||
                    setTimeout(h)
                }),
            (c.onabort = function () {
              c &&
                (r(new bn('Request aborted', bn.ECONNABORTED, e, c)),
                (c = null))
            }),
            (c.onerror = function () {
              r(new bn('Network Error', bn.ERR_NETWORK, e, c)), (c = null)
            }),
            (c.ontimeout = function () {
              let g = e.timeout
                ? 'timeout of ' + e.timeout + 'ms exceeded'
                : 'timeout exceeded'
              const _ = e.transitional || q$
              e.timeoutErrorMessage && (g = e.timeoutErrorMessage),
                r(
                  new bn(
                    g,
                    _.clarifyTimeoutError ? bn.ETIMEDOUT : bn.ECONNABORTED,
                    e,
                    c
                  )
                ),
                (c = null)
            }),
            Qo.isStandardBrowserEnv)
          ) {
            const v =
              (e.withCredentials || Gpe(d)) &&
              e.xsrfCookieName &&
              Hpe.read(e.xsrfCookieName)
            v && o.set(e.xsrfHeaderName, v)
          }
          i === void 0 && o.setContentType(null),
            'setRequestHeader' in c &&
              st.forEach(o.toJSON(), function (g, _) {
                c.setRequestHeader(_, g)
              }),
            st.isUndefined(e.withCredentials) ||
              (c.withCredentials = !!e.withCredentials),
            a && a !== 'json' && (c.responseType = e.responseType),
            typeof e.onDownloadProgress == 'function' &&
              c.addEventListener('progress', nT(e.onDownloadProgress, !0)),
            typeof e.onUploadProgress == 'function' &&
              c.upload &&
              c.upload.addEventListener('progress', nT(e.onUploadProgress)),
            (e.cancelToken || e.signal) &&
              ((s = (v) => {
                c &&
                  (r(!v || v.type ? new sf(null, e, c) : v),
                  c.abort(),
                  (c = null))
              }),
              e.cancelToken && e.cancelToken.subscribe(s),
              e.signal &&
                (e.signal.aborted
                  ? s()
                  : e.signal.addEventListener('abort', s)))
          const p = Kpe(d)
          if (p && Qo.protocols.indexOf(p) === -1) {
            r(new bn('Unsupported protocol ' + p + ':', bn.ERR_BAD_REQUEST, e))
            return
          }
          c.send(i || null)
        })
      },
    qp = { http: Spe, xhr: Ype }
  st.forEach(qp, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, 'name', { value: t })
      } catch {}
      Object.defineProperty(e, 'adapterName', { value: t })
    }
  })
  const Zpe = {
    getAdapter: (e) => {
      e = st.isArray(e) ? e : [e]
      const { length: t } = e
      let n, r
      for (
        let i = 0;
        i < t && ((n = e[i]), !(r = st.isString(n) ? qp[n.toLowerCase()] : n));
        i++
      );
      if (!r)
        throw r === !1
          ? new bn(
              `Adapter ${n} is not supported by the environment`,
              'ERR_NOT_SUPPORT'
            )
          : new Error(
              st.hasOwnProp(qp, n)
                ? `Adapter '${n}' is not available in the build`
                : `Unknown adapter '${n}'`
            )
      if (!st.isFunction(r)) throw new TypeError('adapter is not a function')
      return r
    },
    adapters: qp,
  }
  function Q1(e) {
    if (
      (e.cancelToken && e.cancelToken.throwIfRequested(),
      e.signal && e.signal.aborted)
    )
      throw new sf(null, e)
  }
  function rT(e) {
    return (
      Q1(e),
      (e.headers = za.from(e.headers)),
      (e.data = J1.call(e, e.transformRequest)),
      ['post', 'put', 'patch'].indexOf(e.method) !== -1 &&
        e.headers.setContentType('application/x-www-form-urlencoded', !1),
      Zpe.getAdapter(e.adapter || VS.adapter)(e).then(
        function (r) {
          return (
            Q1(e),
            (r.data = J1.call(e, e.transformResponse, r)),
            (r.headers = za.from(r.headers)),
            r
          )
        },
        function (r) {
          return (
            Y$(r) ||
              (Q1(e),
              r &&
                r.response &&
                ((r.response.data = J1.call(
                  e,
                  e.transformResponse,
                  r.response
                )),
                (r.response.headers = za.from(r.response.headers)))),
            Promise.reject(r)
          )
        }
      )
    )
  }
  const iT = (e) => (e instanceof za ? e.toJSON() : e)
  function ec(e, t) {
    t = t || {}
    const n = {}
    function r(c, d, h) {
      return st.isPlainObject(c) && st.isPlainObject(d)
        ? st.merge.call({ caseless: h }, c, d)
        : st.isPlainObject(d)
        ? st.merge({}, d)
        : st.isArray(d)
        ? d.slice()
        : d
    }
    function i(c, d, h) {
      if (st.isUndefined(d)) {
        if (!st.isUndefined(c)) return r(void 0, c, h)
      } else return r(c, d, h)
    }
    function o(c, d) {
      if (!st.isUndefined(d)) return r(void 0, d)
    }
    function a(c, d) {
      if (st.isUndefined(d)) {
        if (!st.isUndefined(c)) return r(void 0, c)
      } else return r(void 0, d)
    }
    function s(c, d, h) {
      if (h in t) return r(c, d)
      if (h in e) return r(void 0, c)
    }
    const l = {
      url: o,
      method: o,
      data: o,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      beforeRedirect: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: s,
      headers: (c, d) => i(iT(c), iT(d), !0),
    }
    return (
      st.forEach(Object.keys(Object.assign({}, e, t)), function (d) {
        const h = l[d] || i,
          p = h(e[d], t[d], d)
        ;(st.isUndefined(p) && h !== s) || (n[d] = p)
      }),
      n
    )
  }
  const J$ = '1.4.0',
    US = {}
  ;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(
    (e, t) => {
      US[e] = function (r) {
        return typeof r === e || 'a' + (t < 1 ? 'n ' : ' ') + e
      }
    }
  )
  const oT = {}
  US.transitional = function (t, n, r) {
    function i(o, a) {
      return (
        '[Axios v' +
        J$ +
        "] Transitional option '" +
        o +
        "'" +
        a +
        (r ? '. ' + r : '')
      )
    }
    return (o, a, s) => {
      if (t === !1)
        throw new bn(
          i(a, ' has been removed' + (n ? ' in ' + n : '')),
          bn.ERR_DEPRECATED
        )
      return (
        n &&
          !oT[a] &&
          ((oT[a] = !0),
          console.warn(
            i(
              a,
              ' has been deprecated since v' +
                n +
                ' and will be removed in the near future'
            )
          )),
        t ? t(o, a, s) : !0
      )
    }
  }
  function Jpe(e, t, n) {
    if (typeof e != 'object')
      throw new bn('options must be an object', bn.ERR_BAD_OPTION_VALUE)
    const r = Object.keys(e)
    let i = r.length
    for (; i-- > 0; ) {
      const o = r[i],
        a = t[o]
      if (a) {
        const s = e[o],
          l = s === void 0 || a(s, o, e)
        if (l !== !0)
          throw new bn('option ' + o + ' must be ' + l, bn.ERR_BAD_OPTION_VALUE)
        continue
      }
      if (n !== !0) throw new bn('Unknown option ' + o, bn.ERR_BAD_OPTION)
    }
  }
  const i_ = { assertOptions: Jpe, validators: US },
    ps = i_.validators
  class xv {
    constructor(t) {
      ;(this.defaults = t),
        (this.interceptors = { request: new eT(), response: new eT() })
    }
    request(t, n) {
      typeof t == 'string' ? ((n = n || {}), (n.url = t)) : (n = t || {}),
        (n = ec(this.defaults, n))
      const { transitional: r, paramsSerializer: i, headers: o } = n
      r !== void 0 &&
        i_.assertOptions(
          r,
          {
            silentJSONParsing: ps.transitional(ps.boolean),
            forcedJSONParsing: ps.transitional(ps.boolean),
            clarifyTimeoutError: ps.transitional(ps.boolean),
          },
          !1
        ),
        i != null &&
          (st.isFunction(i)
            ? (n.paramsSerializer = { serialize: i })
            : i_.assertOptions(
                i,
                { encode: ps.function, serialize: ps.function },
                !0
              )),
        (n.method = (n.method || this.defaults.method || 'get').toLowerCase())
      let a
      ;(a = o && st.merge(o.common, o[n.method])),
        a &&
          st.forEach(
            ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
            (g) => {
              delete o[g]
            }
          ),
        (n.headers = za.concat(a, o))
      const s = []
      let l = !0
      this.interceptors.request.forEach(function (_) {
        ;(typeof _.runWhen == 'function' && _.runWhen(n) === !1) ||
          ((l = l && _.synchronous), s.unshift(_.fulfilled, _.rejected))
      })
      const c = []
      this.interceptors.response.forEach(function (_) {
        c.push(_.fulfilled, _.rejected)
      })
      let d,
        h = 0,
        p
      if (!l) {
        const g = [rT.bind(this), void 0]
        for (
          g.unshift.apply(g, s),
            g.push.apply(g, c),
            p = g.length,
            d = Promise.resolve(n);
          h < p;

        )
          d = d.then(g[h++], g[h++])
        return d
      }
      p = s.length
      let v = n
      for (h = 0; h < p; ) {
        const g = s[h++],
          _ = s[h++]
        try {
          v = g(v)
        } catch (b) {
          _.call(this, b)
          break
        }
      }
      try {
        d = rT.call(this, v)
      } catch (g) {
        return Promise.reject(g)
      }
      for (h = 0, p = c.length; h < p; ) d = d.then(c[h++], c[h++])
      return d
    }
    getUri(t) {
      t = ec(this.defaults, t)
      const n = Z$(t.baseURL, t.url)
      return K$(n, t.params, t.paramsSerializer)
    }
  }
  st.forEach(['delete', 'get', 'head', 'options'], function (t) {
    xv.prototype[t] = function (n, r) {
      return this.request(
        ec(r || {}, { method: t, url: n, data: (r || {}).data })
      )
    }
  })
  st.forEach(['post', 'put', 'patch'], function (t) {
    function n(r) {
      return function (o, a, s) {
        return this.request(
          ec(s || {}, {
            method: t,
            headers: r ? { 'Content-Type': 'multipart/form-data' } : {},
            url: o,
            data: a,
          })
        )
      }
    }
    ;(xv.prototype[t] = n()), (xv.prototype[t + 'Form'] = n(!0))
  })
  const Xp = xv
  class HS {
    constructor(t) {
      if (typeof t != 'function')
        throw new TypeError('executor must be a function.')
      let n
      this.promise = new Promise(function (o) {
        n = o
      })
      const r = this
      this.promise.then((i) => {
        if (!r._listeners) return
        let o = r._listeners.length
        for (; o-- > 0; ) r._listeners[o](i)
        r._listeners = null
      }),
        (this.promise.then = (i) => {
          let o
          const a = new Promise((s) => {
            r.subscribe(s), (o = s)
          }).then(i)
          return (
            (a.cancel = function () {
              r.unsubscribe(o)
            }),
            a
          )
        }),
        t(function (o, a, s) {
          r.reason || ((r.reason = new sf(o, a, s)), n(r.reason))
        })
    }
    throwIfRequested() {
      if (this.reason) throw this.reason
    }
    subscribe(t) {
      if (this.reason) {
        t(this.reason)
        return
      }
      this._listeners ? this._listeners.push(t) : (this._listeners = [t])
    }
    unsubscribe(t) {
      if (!this._listeners) return
      const n = this._listeners.indexOf(t)
      n !== -1 && this._listeners.splice(n, 1)
    }
    static source() {
      let t
      return {
        token: new HS(function (i) {
          t = i
        }),
        cancel: t,
      }
    }
  }
  const Qpe = HS
  function eve(e) {
    return function (n) {
      return e.apply(null, n)
    }
  }
  function tve(e) {
    return st.isObject(e) && e.isAxiosError === !0
  }
  const o_ = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  }
  Object.entries(o_).forEach(([e, t]) => {
    o_[t] = e
  })
  const nve = o_
  function Q$(e) {
    const t = new Xp(e),
      n = R$(Xp.prototype.request, t)
    return (
      st.extend(n, Xp.prototype, t, { allOwnKeys: !0 }),
      st.extend(n, t, null, { allOwnKeys: !0 }),
      (n.create = function (i) {
        return Q$(ec(e, i))
      }),
      n
    )
  }
  const gr = Q$(VS)
  gr.Axios = Xp
  gr.CanceledError = sf
  gr.CancelToken = Qpe
  gr.isCancel = Y$
  gr.VERSION = J$
  gr.toFormData = ym
  gr.AxiosError = bn
  gr.Cancel = gr.CanceledError
  gr.all = function (t) {
    return Promise.all(t)
  }
  gr.spread = eve
  gr.isAxiosError = tve
  gr.mergeConfig = ec
  gr.AxiosHeaders = za
  gr.formToJSON = (e) => X$(st.isHTMLForm(e) ? new FormData(e) : e)
  gr.HttpStatusCode = nve
  gr.default = gr
  const rve = gr
  function ive(e, t, n) {
    n === void 0 && (n = {})
    var r = { type: 'Feature' }
    return (
      (n.id === 0 || n.id) && (r.id = n.id),
      n.bbox && (r.bbox = n.bbox),
      (r.properties = t || {}),
      (r.geometry = e),
      r
    )
  }
  function ove(e, t, n) {
    if ((n === void 0 && (n = {}), !e))
      throw new Error('coordinates is required')
    if (!Array.isArray(e)) throw new Error('coordinates must be an Array')
    if (e.length < 2)
      throw new Error('coordinates must be at least 2 numbers long')
    if (!aT(e[0]) || !aT(e[1]))
      throw new Error('coordinates must contain numbers')
    var r = { type: 'Point', coordinates: e }
    return ive(r, t, n)
  }
  function aT(e) {
    return !isNaN(e) && e !== null && !Array.isArray(e)
  }
  function WS(e, t, n) {
    if (e !== null)
      for (
        var r,
          i,
          o,
          a,
          s,
          l,
          c,
          d = 0,
          h = 0,
          p,
          v = e.type,
          g = v === 'FeatureCollection',
          _ = v === 'Feature',
          b = g ? e.features.length : 1,
          y = 0;
        y < b;
        y++
      ) {
        ;(c = g ? e.features[y].geometry : _ ? e.geometry : e),
          (p = c ? c.type === 'GeometryCollection' : !1),
          (s = p ? c.geometries.length : 1)
        for (var M = 0; M < s; M++) {
          var x = 0,
            w = 0
          if (((a = p ? c.geometries[M] : c), a !== null)) {
            l = a.coordinates
            var E = a.type
            switch (
              ((d = n && (E === 'Polygon' || E === 'MultiPolygon') ? 1 : 0), E)
            ) {
              case null:
                break
              case 'Point':
                if (t(l, h, y, x, w) === !1) return !1
                h++, x++
                break
              case 'LineString':
              case 'MultiPoint':
                for (r = 0; r < l.length; r++) {
                  if (t(l[r], h, y, x, w) === !1) return !1
                  h++, E === 'MultiPoint' && x++
                }
                E === 'LineString' && x++
                break
              case 'Polygon':
              case 'MultiLineString':
                for (r = 0; r < l.length; r++) {
                  for (i = 0; i < l[r].length - d; i++) {
                    if (t(l[r][i], h, y, x, w) === !1) return !1
                    h++
                  }
                  E === 'MultiLineString' && x++, E === 'Polygon' && w++
                }
                E === 'Polygon' && x++
                break
              case 'MultiPolygon':
                for (r = 0; r < l.length; r++) {
                  for (w = 0, i = 0; i < l[r].length; i++) {
                    for (o = 0; o < l[r][i].length - d; o++) {
                      if (t(l[r][i][o], h, y, x, w) === !1) return !1
                      h++
                    }
                    w++
                  }
                  x++
                }
                break
              case 'GeometryCollection':
                for (r = 0; r < a.geometries.length; r++)
                  if (WS(a.geometries[r], t, n) === !1) return !1
                break
              default:
                throw new Error('Unknown Geometry Type')
            }
          }
        }
      }
  }
  function Mv(e) {
    var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
    return (
      WS(e, function (n) {
        t[0] > n[0] && (t[0] = n[0]),
          t[1] > n[1] && (t[1] = n[1]),
          t[2] < n[0] && (t[2] = n[0]),
          t[3] < n[1] && (t[3] = n[1])
      }),
      t
    )
  }
  Mv.default = Mv
  function ave(e, t) {
    t === void 0 && (t = {})
    var n = 0,
      r = 0,
      i = 0
    return (
      WS(
        e,
        function (o) {
          ;(n += o[0]), (r += o[1]), i++
        },
        !0
      ),
      ove([n / i, r / i], t.properties)
    )
  }
  const sT = new Is(),
    Vh = new Pe()
  class eO extends Bhe {
    constructor() {
      super(),
        (this.isLineSegmentsGeometry = !0),
        (this.type = 'LineSegmentsGeometry')
      const t = [
          -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
          -1, 0,
        ],
        n = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
        r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]
      this.setIndex(r),
        this.setAttribute('position', new so(t, 3)),
        this.setAttribute('uv', new so(n, 2))
    }
    applyMatrix4(t) {
      const n = this.attributes.instanceStart,
        r = this.attributes.instanceEnd
      return (
        n !== void 0 &&
          (n.applyMatrix4(t), r.applyMatrix4(t), (n.needsUpdate = !0)),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
      )
    }
    setPositions(t) {
      let n
      t instanceof Float32Array
        ? (n = t)
        : Array.isArray(t) && (n = new Float32Array(t))
      const r = new e_(n, 6, 1)
      return (
        this.setAttribute('instanceStart', new Cs(r, 3, 0)),
        this.setAttribute('instanceEnd', new Cs(r, 3, 3)),
        this.computeBoundingBox(),
        this.computeBoundingSphere(),
        this
      )
    }
    setColors(t) {
      let n
      t instanceof Float32Array
        ? (n = t)
        : Array.isArray(t) && (n = new Float32Array(t))
      const r = new e_(n, 6, 1)
      return (
        this.setAttribute('instanceColorStart', new Cs(r, 3, 0)),
        this.setAttribute('instanceColorEnd', new Cs(r, 3, 3)),
        this
      )
    }
    fromWireframeGeometry(t) {
      return this.setPositions(t.attributes.position.array), this
    }
    fromEdgesGeometry(t) {
      return this.setPositions(t.attributes.position.array), this
    }
    fromMesh(t) {
      return this.fromWireframeGeometry(new khe(t.geometry)), this
    }
    fromLineSegments(t) {
      const n = t.geometry
      return this.setPositions(n.attributes.position.array), this
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Is())
      const t = this.attributes.instanceStart,
        n = this.attributes.instanceEnd
      t !== void 0 &&
        n !== void 0 &&
        (this.boundingBox.setFromBufferAttribute(t),
        sT.setFromBufferAttribute(n),
        this.boundingBox.union(sT))
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new rf()),
        this.boundingBox === null && this.computeBoundingBox()
      const t = this.attributes.instanceStart,
        n = this.attributes.instanceEnd
      if (t !== void 0 && n !== void 0) {
        const r = this.boundingSphere.center
        this.boundingBox.getCenter(r)
        let i = 0
        for (let o = 0, a = t.count; o < a; o++)
          Vh.fromBufferAttribute(t, o),
            (i = Math.max(i, r.distanceToSquared(Vh))),
            Vh.fromBufferAttribute(n, o),
            (i = Math.max(i, r.distanceToSquared(Vh)))
        ;(this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',
              this
            )
      }
    }
    toJSON() {}
    applyMatrix(t) {
      return (
        console.warn(
          'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().'
        ),
        this.applyMatrix4(t)
      )
    }
  }
  Pt.line = {
    worldUnits: { value: 1 },
    linewidth: { value: 1 },
    resolution: { value: new Ct(1, 1) },
    dashOffset: { value: 0 },
    dashScale: { value: 1 },
    dashSize: { value: 1 },
    gapSize: { value: 1 },
  }
  Si.line = {
    uniforms: OS.merge([Pt.common, Pt.fog, Pt.line]),
    vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
    fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`,
  }
  class Ev extends Os {
    constructor(t) {
      super({
        type: 'LineMaterial',
        uniforms: OS.clone(Si.line.uniforms),
        vertexShader: Si.line.vertexShader,
        fragmentShader: Si.line.fragmentShader,
        clipping: !0,
      }),
        (this.isLineMaterial = !0),
        Object.defineProperties(this, {
          color: {
            enumerable: !0,
            get: function () {
              return this.uniforms.diffuse.value
            },
            set: function (n) {
              this.uniforms.diffuse.value = n
            },
          },
          worldUnits: {
            enumerable: !0,
            get: function () {
              return 'WORLD_UNITS' in this.defines
            },
            set: function (n) {
              n === !0
                ? (this.defines.WORLD_UNITS = '')
                : delete this.defines.WORLD_UNITS
            },
          },
          linewidth: {
            enumerable: !0,
            get: function () {
              return this.uniforms.linewidth.value
            },
            set: function (n) {
              this.uniforms.linewidth.value = n
            },
          },
          dashed: {
            enumerable: !0,
            get: function () {
              return 'USE_DASH' in this.defines
            },
            set(n) {
              !!n != 'USE_DASH' in this.defines && (this.needsUpdate = !0),
                n === !0
                  ? (this.defines.USE_DASH = '')
                  : delete this.defines.USE_DASH
            },
          },
          dashScale: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashScale.value
            },
            set: function (n) {
              this.uniforms.dashScale.value = n
            },
          },
          dashSize: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashSize.value
            },
            set: function (n) {
              this.uniforms.dashSize.value = n
            },
          },
          dashOffset: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashOffset.value
            },
            set: function (n) {
              this.uniforms.dashOffset.value = n
            },
          },
          gapSize: {
            enumerable: !0,
            get: function () {
              return this.uniforms.gapSize.value
            },
            set: function (n) {
              this.uniforms.gapSize.value = n
            },
          },
          opacity: {
            enumerable: !0,
            get: function () {
              return this.uniforms.opacity.value
            },
            set: function (n) {
              this.uniforms.opacity.value = n
            },
          },
          resolution: {
            enumerable: !0,
            get: function () {
              return this.uniforms.resolution.value
            },
            set: function (n) {
              this.uniforms.resolution.value.copy(n)
            },
          },
          alphaToCoverage: {
            enumerable: !0,
            get: function () {
              return 'USE_ALPHA_TO_COVERAGE' in this.defines
            },
            set: function (n) {
              !!n != 'USE_ALPHA_TO_COVERAGE' in this.defines &&
                (this.needsUpdate = !0),
                n === !0
                  ? ((this.defines.USE_ALPHA_TO_COVERAGE = ''),
                    (this.extensions.derivatives = !0))
                  : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                    (this.extensions.derivatives = !1))
            },
          },
        }),
        this.setValues(t)
    }
  }
  const lT = new Pe(),
    uT = new Pe(),
    Or = new Jn(),
    Lr = new Jn(),
    Go = new Jn(),
    eb = new Pe(),
    tb = new qn(),
    Ir = new zhe(),
    cT = new Pe(),
    Uh = new Is(),
    Hh = new rf(),
    Ko = new Jn()
  let Zo, wl
  function dT(e, t, n) {
    return (
      Ko.set(0, 0, -t, 1).applyMatrix4(e.projectionMatrix),
      Ko.multiplyScalar(1 / Ko.w),
      (Ko.x = wl / n.width),
      (Ko.y = wl / n.height),
      Ko.applyMatrix4(e.projectionMatrixInverse),
      Ko.multiplyScalar(1 / Ko.w),
      Math.abs(Math.max(Ko.x, Ko.y))
    )
  }
  function sve(e, t) {
    const n = e.matrixWorld,
      r = e.geometry,
      i = r.attributes.instanceStart,
      o = r.attributes.instanceEnd,
      a = Math.min(r.instanceCount, i.count)
    for (let s = 0, l = a; s < l; s++) {
      Ir.start.fromBufferAttribute(i, s),
        Ir.end.fromBufferAttribute(o, s),
        Ir.applyMatrix4(n)
      const c = new Pe(),
        d = new Pe()
      Zo.distanceSqToSegment(Ir.start, Ir.end, d, c),
        d.distanceTo(c) < wl * 0.5 &&
          t.push({
            point: d,
            pointOnLine: c,
            distance: Zo.origin.distanceTo(d),
            object: e,
            face: null,
            faceIndex: s,
            uv: null,
            uv1: null,
          })
    }
  }
  function lve(e, t, n) {
    const r = t.projectionMatrix,
      o = e.material.resolution,
      a = e.matrixWorld,
      s = e.geometry,
      l = s.attributes.instanceStart,
      c = s.attributes.instanceEnd,
      d = Math.min(s.instanceCount, l.count),
      h = -t.near
    Zo.at(1, Go),
      (Go.w = 1),
      Go.applyMatrix4(t.matrixWorldInverse),
      Go.applyMatrix4(r),
      Go.multiplyScalar(1 / Go.w),
      (Go.x *= o.x / 2),
      (Go.y *= o.y / 2),
      (Go.z = 0),
      eb.copy(Go),
      tb.multiplyMatrices(t.matrixWorldInverse, a)
    for (let p = 0, v = d; p < v; p++) {
      if (
        (Or.fromBufferAttribute(l, p),
        Lr.fromBufferAttribute(c, p),
        (Or.w = 1),
        (Lr.w = 1),
        Or.applyMatrix4(tb),
        Lr.applyMatrix4(tb),
        Or.z > h && Lr.z > h)
      )
        continue
      if (Or.z > h) {
        const x = Or.z - Lr.z,
          w = (Or.z - h) / x
        Or.lerp(Lr, w)
      } else if (Lr.z > h) {
        const x = Lr.z - Or.z,
          w = (Lr.z - h) / x
        Lr.lerp(Or, w)
      }
      Or.applyMatrix4(r),
        Lr.applyMatrix4(r),
        Or.multiplyScalar(1 / Or.w),
        Lr.multiplyScalar(1 / Lr.w),
        (Or.x *= o.x / 2),
        (Or.y *= o.y / 2),
        (Lr.x *= o.x / 2),
        (Lr.y *= o.y / 2),
        Ir.start.copy(Or),
        (Ir.start.z = 0),
        Ir.end.copy(Lr),
        (Ir.end.z = 0)
      const _ = Ir.closestPointToPointParameter(eb, !0)
      Ir.at(_, cT)
      const b = a$.lerp(Or.z, Lr.z, _),
        y = b >= -1 && b <= 1,
        M = eb.distanceTo(cT) < wl * 0.5
      if (y && M) {
        Ir.start.fromBufferAttribute(l, p),
          Ir.end.fromBufferAttribute(c, p),
          Ir.start.applyMatrix4(a),
          Ir.end.applyMatrix4(a)
        const x = new Pe(),
          w = new Pe()
        Zo.distanceSqToSegment(Ir.start, Ir.end, w, x),
          n.push({
            point: w,
            pointOnLine: x,
            distance: Zo.origin.distanceTo(w),
            object: e,
            face: null,
            faceIndex: p,
            uv: null,
            uv1: null,
          })
      }
    }
  }
  class uve extends Ci {
    constructor(t = new eO(), n = new Ev({ color: Math.random() * 16777215 })) {
      super(t, n), (this.isLineSegments2 = !0), (this.type = 'LineSegments2')
    }
    computeLineDistances() {
      const t = this.geometry,
        n = t.attributes.instanceStart,
        r = t.attributes.instanceEnd,
        i = new Float32Array(2 * n.count)
      for (let a = 0, s = 0, l = n.count; a < l; a++, s += 2)
        lT.fromBufferAttribute(n, a),
          uT.fromBufferAttribute(r, a),
          (i[s] = s === 0 ? 0 : i[s - 1]),
          (i[s + 1] = i[s] + lT.distanceTo(uT))
      const o = new e_(i, 2, 1)
      return (
        t.setAttribute('instanceDistanceStart', new Cs(o, 1, 0)),
        t.setAttribute('instanceDistanceEnd', new Cs(o, 1, 1)),
        this
      )
    }
    raycast(t, n) {
      const r = this.material.worldUnits,
        i = t.camera
      i === null &&
        !r &&
        console.error(
          'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
        )
      const o = (t.params.Line2 !== void 0 && t.params.Line2.threshold) || 0
      Zo = t.ray
      const a = this.matrixWorld,
        s = this.geometry,
        l = this.material
      ;(wl = l.linewidth + o),
        s.boundingSphere === null && s.computeBoundingSphere(),
        Hh.copy(s.boundingSphere).applyMatrix4(a)
      let c
      if (r) c = wl * 0.5
      else {
        const h = Math.max(i.near, Hh.distanceToPoint(Zo.origin))
        c = dT(i, h, l.resolution)
      }
      if (((Hh.radius += c), Zo.intersectsSphere(Hh) === !1)) return
      s.boundingBox === null && s.computeBoundingBox(),
        Uh.copy(s.boundingBox).applyMatrix4(a)
      let d
      if (r) d = wl * 0.5
      else {
        const h = Math.max(i.near, Uh.distanceToPoint(Zo.origin))
        d = dT(i, h, l.resolution)
      }
      Uh.expandByScalar(d),
        Zo.intersectsBox(Uh) !== !1 && (r ? sve(this, n) : lve(this, i, n))
    }
  }
  class a_ extends eO {
    constructor() {
      super(), (this.isLineGeometry = !0), (this.type = 'LineGeometry')
    }
    setPositions(t) {
      const n = t.length - 3,
        r = new Float32Array(2 * n)
      for (let i = 0; i < n; i += 3)
        (r[2 * i] = t[i]),
          (r[2 * i + 1] = t[i + 1]),
          (r[2 * i + 2] = t[i + 2]),
          (r[2 * i + 3] = t[i + 3]),
          (r[2 * i + 4] = t[i + 4]),
          (r[2 * i + 5] = t[i + 5])
      return super.setPositions(r), this
    }
    setColors(t) {
      const n = t.length - 3,
        r = new Float32Array(2 * n)
      for (let i = 0; i < n; i += 3)
        (r[2 * i] = t[i]),
          (r[2 * i + 1] = t[i + 1]),
          (r[2 * i + 2] = t[i + 2]),
          (r[2 * i + 3] = t[i + 3]),
          (r[2 * i + 4] = t[i + 4]),
          (r[2 * i + 5] = t[i + 5])
      return super.setColors(r), this
    }
    fromLine(t) {
      const n = t.geometry
      return this.setPositions(n.attributes.position.array), this
    }
  }
  class fT extends uve {
    constructor(t = new a_(), n = new Ev({ color: Math.random() * 16777215 })) {
      super(t, n), (this.isLine2 = !0), (this.type = 'Line2')
    }
  }
  var Uu = Object.freeze({
      Linear: Object.freeze({
        None: function (e) {
          return e
        },
        In: function (e) {
          return this.None(e)
        },
        Out: function (e) {
          return this.None(e)
        },
        InOut: function (e) {
          return this.None(e)
        },
      }),
      Quadratic: Object.freeze({
        In: function (e) {
          return e * e
        },
        Out: function (e) {
          return e * (2 - e)
        },
        InOut: function (e) {
          return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1)
        },
      }),
      Cubic: Object.freeze({
        In: function (e) {
          return e * e * e
        },
        Out: function (e) {
          return --e * e * e + 1
        },
        InOut: function (e) {
          return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2)
        },
      }),
      Quartic: Object.freeze({
        In: function (e) {
          return e * e * e * e
        },
        Out: function (e) {
          return 1 - --e * e * e * e
        },
        InOut: function (e) {
          return (e *= 2) < 1
            ? 0.5 * e * e * e * e
            : -0.5 * ((e -= 2) * e * e * e - 2)
        },
      }),
      Quintic: Object.freeze({
        In: function (e) {
          return e * e * e * e * e
        },
        Out: function (e) {
          return --e * e * e * e * e + 1
        },
        InOut: function (e) {
          return (e *= 2) < 1
            ? 0.5 * e * e * e * e * e
            : 0.5 * ((e -= 2) * e * e * e * e + 2)
        },
      }),
      Sinusoidal: Object.freeze({
        In: function (e) {
          return 1 - Math.sin(((1 - e) * Math.PI) / 2)
        },
        Out: function (e) {
          return Math.sin((e * Math.PI) / 2)
        },
        InOut: function (e) {
          return 0.5 * (1 - Math.sin(Math.PI * (0.5 - e)))
        },
      }),
      Exponential: Object.freeze({
        In: function (e) {
          return e === 0 ? 0 : Math.pow(1024, e - 1)
        },
        Out: function (e) {
          return e === 1 ? 1 : 1 - Math.pow(2, -10 * e)
        },
        InOut: function (e) {
          return e === 0
            ? 0
            : e === 1
            ? 1
            : (e *= 2) < 1
            ? 0.5 * Math.pow(1024, e - 1)
            : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2)
        },
      }),
      Circular: Object.freeze({
        In: function (e) {
          return 1 - Math.sqrt(1 - e * e)
        },
        Out: function (e) {
          return Math.sqrt(1 - --e * e)
        },
        InOut: function (e) {
          return (e *= 2) < 1
            ? -0.5 * (Math.sqrt(1 - e * e) - 1)
            : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        },
      }),
      Elastic: Object.freeze({
        In: function (e) {
          return e === 0
            ? 0
            : e === 1
            ? 1
            : -Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI)
        },
        Out: function (e) {
          return e === 0
            ? 0
            : e === 1
            ? 1
            : Math.pow(2, -10 * e) * Math.sin((e - 0.1) * 5 * Math.PI) + 1
        },
        InOut: function (e) {
          return e === 0
            ? 0
            : e === 1
            ? 1
            : ((e *= 2),
              e < 1
                ? -0.5 *
                  Math.pow(2, 10 * (e - 1)) *
                  Math.sin((e - 1.1) * 5 * Math.PI)
                : 0.5 *
                    Math.pow(2, -10 * (e - 1)) *
                    Math.sin((e - 1.1) * 5 * Math.PI) +
                  1)
        },
      }),
      Back: Object.freeze({
        In: function (e) {
          var t = 1.70158
          return e === 1 ? 1 : e * e * ((t + 1) * e - t)
        },
        Out: function (e) {
          var t = 1.70158
          return e === 0 ? 0 : --e * e * ((t + 1) * e + t) + 1
        },
        InOut: function (e) {
          var t = 2.5949095
          return (e *= 2) < 1
            ? 0.5 * (e * e * ((t + 1) * e - t))
            : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
        },
      }),
      Bounce: Object.freeze({
        In: function (e) {
          return 1 - Uu.Bounce.Out(1 - e)
        },
        Out: function (e) {
          return e < 1 / 2.75
            ? 7.5625 * e * e
            : e < 2 / 2.75
            ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
            : e < 2.5 / 2.75
            ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
            : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375
        },
        InOut: function (e) {
          return e < 0.5
            ? Uu.Bounce.In(e * 2) * 0.5
            : Uu.Bounce.Out(e * 2 - 1) * 0.5 + 0.5
        },
      }),
      generatePow: function (e) {
        return (
          e === void 0 && (e = 4),
          (e = e < Number.EPSILON ? Number.EPSILON : e),
          (e = e > 1e4 ? 1e4 : e),
          {
            In: function (t) {
              return Math.pow(t, e)
            },
            Out: function (t) {
              return 1 - Math.pow(1 - t, e)
            },
            InOut: function (t) {
              return t < 0.5
                ? Math.pow(t * 2, e) / 2
                : (1 - Math.pow(2 - t * 2, e)) / 2 + 0.5
            },
          }
        )
      },
    }),
    ku = function () {
      return performance.now()
    },
    tO = (function () {
      function e() {
        ;(this._tweens = {}), (this._tweensAddedDuringUpdate = {})
      }
      return (
        (e.prototype.getAll = function () {
          var t = this
          return Object.keys(this._tweens).map(function (n) {
            return t._tweens[n]
          })
        }),
        (e.prototype.removeAll = function () {
          this._tweens = {}
        }),
        (e.prototype.add = function (t) {
          ;(this._tweens[t.getId()] = t),
            (this._tweensAddedDuringUpdate[t.getId()] = t)
        }),
        (e.prototype.remove = function (t) {
          delete this._tweens[t.getId()],
            delete this._tweensAddedDuringUpdate[t.getId()]
        }),
        (e.prototype.update = function (t, n) {
          t === void 0 && (t = ku()), n === void 0 && (n = !1)
          var r = Object.keys(this._tweens)
          if (r.length === 0) return !1
          for (; r.length > 0; ) {
            this._tweensAddedDuringUpdate = {}
            for (var i = 0; i < r.length; i++) {
              var o = this._tweens[r[i]],
                a = !n
              o && o.update(t, a) === !1 && !n && delete this._tweens[r[i]]
            }
            r = Object.keys(this._tweensAddedDuringUpdate)
          }
          return !0
        }),
        e
      )
    })(),
    dl = {
      Linear: function (e, t) {
        var n = e.length - 1,
          r = n * t,
          i = Math.floor(r),
          o = dl.Utils.Linear
        return t < 0
          ? o(e[0], e[1], r)
          : t > 1
          ? o(e[n], e[n - 1], n - r)
          : o(e[i], e[i + 1 > n ? n : i + 1], r - i)
      },
      Bezier: function (e, t) {
        for (
          var n = 0,
            r = e.length - 1,
            i = Math.pow,
            o = dl.Utils.Bernstein,
            a = 0;
          a <= r;
          a++
        )
          n += i(1 - t, r - a) * i(t, a) * e[a] * o(r, a)
        return n
      },
      CatmullRom: function (e, t) {
        var n = e.length - 1,
          r = n * t,
          i = Math.floor(r),
          o = dl.Utils.CatmullRom
        return e[0] === e[n]
          ? (t < 0 && (i = Math.floor((r = n * (1 + t)))),
            o(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i))
          : t < 0
          ? e[0] - (o(e[0], e[0], e[1], e[1], -r) - e[0])
          : t > 1
          ? e[n] - (o(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n])
          : o(
              e[i ? i - 1 : 0],
              e[i],
              e[n < i + 1 ? n : i + 1],
              e[n < i + 2 ? n : i + 2],
              r - i
            )
      },
      Utils: {
        Linear: function (e, t, n) {
          return (t - e) * n + e
        },
        Bernstein: function (e, t) {
          var n = dl.Utils.Factorial
          return n(e) / n(t) / n(e - t)
        },
        Factorial: (function () {
          var e = [1]
          return function (t) {
            var n = 1
            if (e[t]) return e[t]
            for (var r = t; r > 1; r--) n *= r
            return (e[t] = n), n
          }
        })(),
        CatmullRom: function (e, t, n, r, i) {
          var o = (n - e) * 0.5,
            a = (r - t) * 0.5,
            s = i * i,
            l = i * s
          return (
            (2 * t - 2 * n + o + a) * l +
            (-3 * t + 3 * n - 2 * o - a) * s +
            o * i +
            t
          )
        },
      },
    },
    jS = (function () {
      function e() {}
      return (
        (e.nextId = function () {
          return e._nextId++
        }),
        (e._nextId = 0),
        e
      )
    })(),
    s_ = new tO(),
    cve = (function () {
      function e(t, n) {
        n === void 0 && (n = s_),
          (this._object = t),
          (this._group = n),
          (this._isPaused = !1),
          (this._pauseStart = 0),
          (this._valuesStart = {}),
          (this._valuesEnd = {}),
          (this._valuesStartRepeat = {}),
          (this._duration = 1e3),
          (this._isDynamic = !1),
          (this._initialRepeat = 0),
          (this._repeat = 0),
          (this._yoyo = !1),
          (this._isPlaying = !1),
          (this._reversed = !1),
          (this._delayTime = 0),
          (this._startTime = 0),
          (this._easingFunction = Uu.Linear.None),
          (this._interpolationFunction = dl.Linear),
          (this._chainedTweens = []),
          (this._onStartCallbackFired = !1),
          (this._onEveryStartCallbackFired = !1),
          (this._id = jS.nextId()),
          (this._isChainStopped = !1),
          (this._propertiesAreSetUp = !1),
          (this._goToEnd = !1)
      }
      return (
        (e.prototype.getId = function () {
          return this._id
        }),
        (e.prototype.isPlaying = function () {
          return this._isPlaying
        }),
        (e.prototype.isPaused = function () {
          return this._isPaused
        }),
        (e.prototype.to = function (t, n) {
          if ((n === void 0 && (n = 1e3), this._isPlaying))
            throw new Error(
              'Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.'
            )
          return (
            (this._valuesEnd = t),
            (this._propertiesAreSetUp = !1),
            (this._duration = n),
            this
          )
        }),
        (e.prototype.duration = function (t) {
          return t === void 0 && (t = 1e3), (this._duration = t), this
        }),
        (e.prototype.dynamic = function (t) {
          return t === void 0 && (t = !1), (this._isDynamic = t), this
        }),
        (e.prototype.start = function (t, n) {
          if (
            (t === void 0 && (t = ku()),
            n === void 0 && (n = !1),
            this._isPlaying)
          )
            return this
          if (
            (this._group && this._group.add(this),
            (this._repeat = this._initialRepeat),
            this._reversed)
          ) {
            this._reversed = !1
            for (var r in this._valuesStartRepeat)
              this._swapEndStartRepeatValues(r),
                (this._valuesStart[r] = this._valuesStartRepeat[r])
          }
          if (
            ((this._isPlaying = !0),
            (this._isPaused = !1),
            (this._onStartCallbackFired = !1),
            (this._onEveryStartCallbackFired = !1),
            (this._isChainStopped = !1),
            (this._startTime = t),
            (this._startTime += this._delayTime),
            !this._propertiesAreSetUp || n)
          ) {
            if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
              var i = {}
              for (var o in this._valuesEnd) i[o] = this._valuesEnd[o]
              this._valuesEnd = i
            }
            this._setupProperties(
              this._object,
              this._valuesStart,
              this._valuesEnd,
              this._valuesStartRepeat,
              n
            )
          }
          return this
        }),
        (e.prototype.startFromCurrentValues = function (t) {
          return this.start(t, !0)
        }),
        (e.prototype._setupProperties = function (t, n, r, i, o) {
          for (var a in r) {
            var s = t[a],
              l = Array.isArray(s),
              c = l ? 'array' : typeof s,
              d = !l && Array.isArray(r[a])
            if (!(c === 'undefined' || c === 'function')) {
              if (d) {
                var h = r[a]
                if (h.length === 0) continue
                for (var p = [s], v = 0, g = h.length; v < g; v += 1) {
                  var _ = this._handleRelativeValue(s, h[v])
                  if (isNaN(_)) {
                    ;(d = !1),
                      console.warn(
                        'Found invalid interpolation list. Skipping.'
                      )
                    break
                  }
                  p.push(_)
                }
                d && (r[a] = p)
              }
              if ((c === 'object' || l) && s && !d) {
                n[a] = l ? [] : {}
                var b = s
                for (var y in b) n[a][y] = b[y]
                i[a] = l ? [] : {}
                var h = r[a]
                if (!this._isDynamic) {
                  var M = {}
                  for (var y in h) M[y] = h[y]
                  r[a] = h = M
                }
                this._setupProperties(b, n[a], h, i[a], o)
              } else
                (typeof n[a] > 'u' || o) && (n[a] = s),
                  l || (n[a] *= 1),
                  d ? (i[a] = r[a].slice().reverse()) : (i[a] = n[a] || 0)
            }
          }
        }),
        (e.prototype.stop = function () {
          return (
            this._isChainStopped ||
              ((this._isChainStopped = !0), this.stopChainedTweens()),
            this._isPlaying
              ? (this._group && this._group.remove(this),
                (this._isPlaying = !1),
                (this._isPaused = !1),
                this._onStopCallback && this._onStopCallback(this._object),
                this)
              : this
          )
        }),
        (e.prototype.end = function () {
          return (this._goToEnd = !0), this.update(1 / 0), this
        }),
        (e.prototype.pause = function (t) {
          return (
            t === void 0 && (t = ku()),
            this._isPaused || !this._isPlaying
              ? this
              : ((this._isPaused = !0),
                (this._pauseStart = t),
                this._group && this._group.remove(this),
                this)
          )
        }),
        (e.prototype.resume = function (t) {
          return (
            t === void 0 && (t = ku()),
            !this._isPaused || !this._isPlaying
              ? this
              : ((this._isPaused = !1),
                (this._startTime += t - this._pauseStart),
                (this._pauseStart = 0),
                this._group && this._group.add(this),
                this)
          )
        }),
        (e.prototype.stopChainedTweens = function () {
          for (var t = 0, n = this._chainedTweens.length; t < n; t++)
            this._chainedTweens[t].stop()
          return this
        }),
        (e.prototype.group = function (t) {
          return t === void 0 && (t = s_), (this._group = t), this
        }),
        (e.prototype.delay = function (t) {
          return t === void 0 && (t = 0), (this._delayTime = t), this
        }),
        (e.prototype.repeat = function (t) {
          return (
            t === void 0 && (t = 0),
            (this._initialRepeat = t),
            (this._repeat = t),
            this
          )
        }),
        (e.prototype.repeatDelay = function (t) {
          return (this._repeatDelayTime = t), this
        }),
        (e.prototype.yoyo = function (t) {
          return t === void 0 && (t = !1), (this._yoyo = t), this
        }),
        (e.prototype.easing = function (t) {
          return (
            t === void 0 && (t = Uu.Linear.None),
            (this._easingFunction = t),
            this
          )
        }),
        (e.prototype.interpolation = function (t) {
          return (
            t === void 0 && (t = dl.Linear),
            (this._interpolationFunction = t),
            this
          )
        }),
        (e.prototype.chain = function () {
          for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n]
          return (this._chainedTweens = t), this
        }),
        (e.prototype.onStart = function (t) {
          return (this._onStartCallback = t), this
        }),
        (e.prototype.onEveryStart = function (t) {
          return (this._onEveryStartCallback = t), this
        }),
        (e.prototype.onUpdate = function (t) {
          return (this._onUpdateCallback = t), this
        }),
        (e.prototype.onRepeat = function (t) {
          return (this._onRepeatCallback = t), this
        }),
        (e.prototype.onComplete = function (t) {
          return (this._onCompleteCallback = t), this
        }),
        (e.prototype.onStop = function (t) {
          return (this._onStopCallback = t), this
        }),
        (e.prototype.update = function (t, n) {
          if (
            (t === void 0 && (t = ku()),
            n === void 0 && (n = !0),
            this._isPaused)
          )
            return !0
          var r,
            i,
            o = this._startTime + this._duration
          if (!this._goToEnd && !this._isPlaying) {
            if (t > o) return !1
            n && this.start(t, !0)
          }
          if (((this._goToEnd = !1), t < this._startTime)) return !0
          this._onStartCallbackFired === !1 &&
            (this._onStartCallback && this._onStartCallback(this._object),
            (this._onStartCallbackFired = !0)),
            this._onEveryStartCallbackFired === !1 &&
              (this._onEveryStartCallback &&
                this._onEveryStartCallback(this._object),
              (this._onEveryStartCallbackFired = !0)),
            (i = (t - this._startTime) / this._duration),
            (i = this._duration === 0 || i > 1 ? 1 : i)
          var a = this._easingFunction(i)
          if (
            (this._updateProperties(
              this._object,
              this._valuesStart,
              this._valuesEnd,
              a
            ),
            this._onUpdateCallback && this._onUpdateCallback(this._object, i),
            i === 1)
          )
            if (this._repeat > 0) {
              isFinite(this._repeat) && this._repeat--
              for (r in this._valuesStartRepeat)
                !this._yoyo &&
                  typeof this._valuesEnd[r] == 'string' &&
                  (this._valuesStartRepeat[r] =
                    this._valuesStartRepeat[r] +
                    parseFloat(this._valuesEnd[r])),
                  this._yoyo && this._swapEndStartRepeatValues(r),
                  (this._valuesStart[r] = this._valuesStartRepeat[r])
              return (
                this._yoyo && (this._reversed = !this._reversed),
                this._repeatDelayTime !== void 0
                  ? (this._startTime = t + this._repeatDelayTime)
                  : (this._startTime = t + this._delayTime),
                this._onRepeatCallback && this._onRepeatCallback(this._object),
                (this._onEveryStartCallbackFired = !1),
                !0
              )
            } else {
              this._onCompleteCallback && this._onCompleteCallback(this._object)
              for (var s = 0, l = this._chainedTweens.length; s < l; s++)
                this._chainedTweens[s].start(
                  this._startTime + this._duration,
                  !1
                )
              return (this._isPlaying = !1), !1
            }
          return !0
        }),
        (e.prototype._updateProperties = function (t, n, r, i) {
          for (var o in r)
            if (n[o] !== void 0) {
              var a = n[o] || 0,
                s = r[o],
                l = Array.isArray(t[o]),
                c = Array.isArray(s),
                d = !l && c
              d
                ? (t[o] = this._interpolationFunction(s, i))
                : typeof s == 'object' && s
                ? this._updateProperties(t[o], a, s, i)
                : ((s = this._handleRelativeValue(a, s)),
                  typeof s == 'number' && (t[o] = a + (s - a) * i))
            }
        }),
        (e.prototype._handleRelativeValue = function (t, n) {
          return typeof n != 'string'
            ? n
            : n.charAt(0) === '+' || n.charAt(0) === '-'
            ? t + parseFloat(n)
            : parseFloat(n)
        }),
        (e.prototype._swapEndStartRepeatValues = function (t) {
          var n = this._valuesStartRepeat[t],
            r = this._valuesEnd[t]
          typeof r == 'string'
            ? (this._valuesStartRepeat[t] =
                this._valuesStartRepeat[t] + parseFloat(r))
            : (this._valuesStartRepeat[t] = this._valuesEnd[t]),
            (this._valuesEnd[t] = n)
        }),
        e
      )
    })(),
    dve = '20.0.3',
    fve = jS.nextId,
    sa = s_,
    hve = sa.getAll.bind(sa),
    pve = sa.removeAll.bind(sa),
    vve = sa.add.bind(sa),
    mve = sa.remove.bind(sa),
    gve = sa.update.bind(sa),
    Wd = {
      Easing: Uu,
      Group: tO,
      Interpolation: dl,
      now: ku,
      Sequence: jS,
      nextId: fve,
      Tween: cve,
      VERSION: dve,
      getAll: hve,
      removeAll: pve,
      add: vve,
      remove: mve,
      update: gve,
    }
  const hT = { type: 'change' },
    nb = { type: 'start' },
    pT = { type: 'end' }
  class yve extends Rl {
    constructor(t, n) {
      super(),
        (this.object = t),
        (this.domElement = n),
        (this.domElement.style.touchAction = 'none'),
        (this.enabled = !0),
        (this.target = new Pe()),
        (this.minDistance = 0),
        (this.maxDistance = 1 / 0),
        (this.minZoom = 0),
        (this.maxZoom = 1 / 0),
        (this.minPolarAngle = 0),
        (this.maxPolarAngle = Math.PI),
        (this.minAzimuthAngle = -1 / 0),
        (this.maxAzimuthAngle = 1 / 0),
        (this.enableDamping = !1),
        (this.dampingFactor = 0.05),
        (this.enableZoom = !0),
        (this.zoomSpeed = 1),
        (this.enableRotate = !0),
        (this.rotateSpeed = 1),
        (this.enablePan = !0),
        (this.panSpeed = 1),
        (this.screenSpacePanning = !0),
        (this.keyPanSpeed = 7),
        (this.autoRotate = !1),
        (this.autoRotateSpeed = 2),
        (this.keys = {
          LEFT: 'ArrowLeft',
          UP: 'ArrowUp',
          RIGHT: 'ArrowRight',
          BOTTOM: 'ArrowDown',
        }),
        (this.mouseButtons = {
          LEFT: iu.ROTATE,
          MIDDLE: iu.DOLLY,
          RIGHT: iu.PAN,
        }),
        (this.touches = { ONE: ou.ROTATE, TWO: ou.DOLLY_PAN }),
        (this.target0 = this.target.clone()),
        (this.position0 = this.object.position.clone()),
        (this.zoom0 = this.object.zoom),
        (this._domElementKeyEvents = null),
        (this.getPolarAngle = function () {
          return s.phi
        }),
        (this.getAzimuthalAngle = function () {
          return s.theta
        }),
        (this.getDistance = function () {
          return this.object.position.distanceTo(this.target)
        }),
        (this.listenToKeyEvents = function (ne) {
          ne.addEventListener('keydown', $e), (this._domElementKeyEvents = ne)
        }),
        (this.stopListenToKeyEvents = function () {
          this._domElementKeyEvents.removeEventListener('keydown', $e),
            (this._domElementKeyEvents = null)
        }),
        (this.saveState = function () {
          r.target0.copy(r.target),
            r.position0.copy(r.object.position),
            (r.zoom0 = r.object.zoom)
        }),
        (this.reset = function () {
          r.target.copy(r.target0),
            r.object.position.copy(r.position0),
            (r.object.zoom = r.zoom0),
            r.object.updateProjectionMatrix(),
            r.dispatchEvent(hT),
            r.update(),
            (o = i.NONE)
        }),
        (this.update = (function () {
          const ne = new Pe(),
            Le = new Pl().setFromUnitVectors(t.up, new Pe(0, 1, 0)),
            et = Le.clone().invert(),
            Ne = new Pe(),
            Et = new Pl(),
            kt = new Pe(),
            je = 2 * Math.PI
          return function () {
            const Ye = r.object.position
            ne.copy(Ye).sub(r.target),
              ne.applyQuaternion(Le),
              s.setFromVector3(ne),
              r.autoRotate && o === i.NONE && T(A()),
              r.enableDamping
                ? ((s.theta += l.theta * r.dampingFactor),
                  (s.phi += l.phi * r.dampingFactor))
                : ((s.theta += l.theta), (s.phi += l.phi))
            let lt = r.minAzimuthAngle,
              gt = r.maxAzimuthAngle
            return (
              isFinite(lt) &&
                isFinite(gt) &&
                (lt < -Math.PI ? (lt += je) : lt > Math.PI && (lt -= je),
                gt < -Math.PI ? (gt += je) : gt > Math.PI && (gt -= je),
                lt <= gt
                  ? (s.theta = Math.max(lt, Math.min(gt, s.theta)))
                  : (s.theta =
                      s.theta > (lt + gt) / 2
                        ? Math.max(lt, s.theta)
                        : Math.min(gt, s.theta))),
              (s.phi = Math.max(
                r.minPolarAngle,
                Math.min(r.maxPolarAngle, s.phi)
              )),
              s.makeSafe(),
              (s.radius *= c),
              (s.radius = Math.max(
                r.minDistance,
                Math.min(r.maxDistance, s.radius)
              )),
              r.enableDamping === !0
                ? r.target.addScaledVector(d, r.dampingFactor)
                : r.target.add(d),
              ne.setFromSpherical(s),
              ne.applyQuaternion(et),
              Ye.copy(r.target).add(ne),
              r.object.lookAt(r.target),
              r.enableDamping === !0
                ? ((l.theta *= 1 - r.dampingFactor),
                  (l.phi *= 1 - r.dampingFactor),
                  d.multiplyScalar(1 - r.dampingFactor))
                : (l.set(0, 0, 0), d.set(0, 0, 0)),
              (c = 1),
              h ||
              Ne.distanceToSquared(r.object.position) > a ||
              8 * (1 - Et.dot(r.object.quaternion)) > a ||
              kt.distanceToSquared(r.target) > 0
                ? (r.dispatchEvent(hT),
                  Ne.copy(r.object.position),
                  Et.copy(r.object.quaternion),
                  kt.copy(r.target),
                  (h = !1),
                  !0)
                : !1
            )
          }
        })()),
        (this.dispose = function () {
          r.domElement.removeEventListener('contextmenu', Q),
            r.domElement.removeEventListener('pointerdown', z),
            r.domElement.removeEventListener('pointercancel', ae),
            r.domElement.removeEventListener('wheel', we),
            r.domElement.removeEventListener('pointermove', ie),
            r.domElement.removeEventListener('pointerup', ae),
            r._domElementKeyEvents !== null &&
              (r._domElementKeyEvents.removeEventListener('keydown', $e),
              (r._domElementKeyEvents = null))
        })
      const r = this,
        i = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6,
        }
      let o = i.NONE
      const a = 1e-6,
        s = new qP(),
        l = new qP()
      let c = 1
      const d = new Pe()
      let h = !1
      const p = new Ct(),
        v = new Ct(),
        g = new Ct(),
        _ = new Ct(),
        b = new Ct(),
        y = new Ct(),
        M = new Ct(),
        x = new Ct(),
        w = new Ct(),
        E = [],
        P = {}
      function A() {
        return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed
      }
      function F() {
        return Math.pow(0.95, r.zoomSpeed)
      }
      function T(ne) {
        l.theta -= ne
      }
      function k(ne) {
        l.phi -= ne
      }
      const R = (function () {
          const ne = new Pe()
          return function (et, Ne) {
            ne.setFromMatrixColumn(Ne, 0), ne.multiplyScalar(-et), d.add(ne)
          }
        })(),
        j = (function () {
          const ne = new Pe()
          return function (et, Ne) {
            r.screenSpacePanning === !0
              ? ne.setFromMatrixColumn(Ne, 1)
              : (ne.setFromMatrixColumn(Ne, 0),
                ne.crossVectors(r.object.up, ne)),
              ne.multiplyScalar(et),
              d.add(ne)
          }
        })(),
        N = (function () {
          const ne = new Pe()
          return function (et, Ne) {
            const Et = r.domElement
            if (r.object.isPerspectiveCamera) {
              const kt = r.object.position
              ne.copy(kt).sub(r.target)
              let je = ne.length()
              ;(je *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
                R((2 * et * je) / Et.clientHeight, r.object.matrix),
                j((2 * Ne * je) / Et.clientHeight, r.object.matrix)
            } else
              r.object.isOrthographicCamera
                ? (R(
                    (et * (r.object.right - r.object.left)) /
                      r.object.zoom /
                      Et.clientWidth,
                    r.object.matrix
                  ),
                  j(
                    (Ne * (r.object.top - r.object.bottom)) /
                      r.object.zoom /
                      Et.clientHeight,
                    r.object.matrix
                  ))
                : (console.warn(
                    'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
                  ),
                  (r.enablePan = !1))
          }
        })()
      function I(ne) {
        r.object.isPerspectiveCamera
          ? (c /= ne)
          : r.object.isOrthographicCamera
          ? ((r.object.zoom = Math.max(
              r.minZoom,
              Math.min(r.maxZoom, r.object.zoom * ne)
            )),
            r.object.updateProjectionMatrix(),
            (h = !0))
          : (console.warn(
              'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
            ),
            (r.enableZoom = !1))
      }
      function B(ne) {
        r.object.isPerspectiveCamera
          ? (c *= ne)
          : r.object.isOrthographicCamera
          ? ((r.object.zoom = Math.max(
              r.minZoom,
              Math.min(r.maxZoom, r.object.zoom / ne)
            )),
            r.object.updateProjectionMatrix(),
            (h = !0))
          : (console.warn(
              'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
            ),
            (r.enableZoom = !1))
      }
      function V(ne) {
        p.set(ne.clientX, ne.clientY)
      }
      function L(ne) {
        M.set(ne.clientX, ne.clientY)
      }
      function W(ne) {
        _.set(ne.clientX, ne.clientY)
      }
      function Y(ne) {
        v.set(ne.clientX, ne.clientY),
          g.subVectors(v, p).multiplyScalar(r.rotateSpeed)
        const Le = r.domElement
        T((2 * Math.PI * g.x) / Le.clientHeight),
          k((2 * Math.PI * g.y) / Le.clientHeight),
          p.copy(v),
          r.update()
      }
      function U(ne) {
        x.set(ne.clientX, ne.clientY),
          w.subVectors(x, M),
          w.y > 0 ? I(F()) : w.y < 0 && B(F()),
          M.copy(x),
          r.update()
      }
      function le(ne) {
        b.set(ne.clientX, ne.clientY),
          y.subVectors(b, _).multiplyScalar(r.panSpeed),
          N(y.x, y.y),
          _.copy(b),
          r.update()
      }
      function q(ne) {
        ne.deltaY < 0 ? B(F()) : ne.deltaY > 0 && I(F()), r.update()
      }
      function oe(ne) {
        let Le = !1
        switch (ne.code) {
          case r.keys.UP:
            ne.ctrlKey || ne.metaKey || ne.shiftKey
              ? k((2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
              : N(0, r.keyPanSpeed),
              (Le = !0)
            break
          case r.keys.BOTTOM:
            ne.ctrlKey || ne.metaKey || ne.shiftKey
              ? k((-2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
              : N(0, -r.keyPanSpeed),
              (Le = !0)
            break
          case r.keys.LEFT:
            ne.ctrlKey || ne.metaKey || ne.shiftKey
              ? T((2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
              : N(r.keyPanSpeed, 0),
              (Le = !0)
            break
          case r.keys.RIGHT:
            ne.ctrlKey || ne.metaKey || ne.shiftKey
              ? T((-2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
              : N(-r.keyPanSpeed, 0),
              (Le = !0)
            break
        }
        Le && (ne.preventDefault(), r.update())
      }
      function te() {
        if (E.length === 1) p.set(E[0].pageX, E[0].pageY)
        else {
          const ne = 0.5 * (E[0].pageX + E[1].pageX),
            Le = 0.5 * (E[0].pageY + E[1].pageY)
          p.set(ne, Le)
        }
      }
      function ue() {
        if (E.length === 1) _.set(E[0].pageX, E[0].pageY)
        else {
          const ne = 0.5 * (E[0].pageX + E[1].pageX),
            Le = 0.5 * (E[0].pageY + E[1].pageY)
          _.set(ne, Le)
        }
      }
      function me() {
        const ne = E[0].pageX - E[1].pageX,
          Le = E[0].pageY - E[1].pageY,
          et = Math.sqrt(ne * ne + Le * Le)
        M.set(0, et)
      }
      function Re() {
        r.enableZoom && me(), r.enablePan && ue()
      }
      function qe() {
        r.enableZoom && me(), r.enableRotate && te()
      }
      function Ve(ne) {
        if (E.length == 1) v.set(ne.pageX, ne.pageY)
        else {
          const et = xe(ne),
            Ne = 0.5 * (ne.pageX + et.x),
            Et = 0.5 * (ne.pageY + et.y)
          v.set(Ne, Et)
        }
        g.subVectors(v, p).multiplyScalar(r.rotateSpeed)
        const Le = r.domElement
        T((2 * Math.PI * g.x) / Le.clientHeight),
          k((2 * Math.PI * g.y) / Le.clientHeight),
          p.copy(v)
      }
      function nt(ne) {
        if (E.length === 1) b.set(ne.pageX, ne.pageY)
        else {
          const Le = xe(ne),
            et = 0.5 * (ne.pageX + Le.x),
            Ne = 0.5 * (ne.pageY + Le.y)
          b.set(et, Ne)
        }
        y.subVectors(b, _).multiplyScalar(r.panSpeed), N(y.x, y.y), _.copy(b)
      }
      function We(ne) {
        const Le = xe(ne),
          et = ne.pageX - Le.x,
          Ne = ne.pageY - Le.y,
          Et = Math.sqrt(et * et + Ne * Ne)
        x.set(0, Et),
          w.set(0, Math.pow(x.y / M.y, r.zoomSpeed)),
          I(w.y),
          M.copy(x)
      }
      function D(ne) {
        r.enableZoom && We(ne), r.enablePan && nt(ne)
      }
      function G(ne) {
        r.enableZoom && We(ne), r.enableRotate && Ve(ne)
      }
      function z(ne) {
        r.enabled !== !1 &&
          (E.length === 0 &&
            (r.domElement.setPointerCapture(ne.pointerId),
            r.domElement.addEventListener('pointermove', ie),
            r.domElement.addEventListener('pointerup', ae)),
          X(ne),
          ne.pointerType === 'touch' ? Ae(ne) : re(ne))
      }
      function ie(ne) {
        r.enabled !== !1 && (ne.pointerType === 'touch' ? ft(ne) : pe(ne))
      }
      function ae(ne) {
        he(ne),
          E.length === 0 &&
            (r.domElement.releasePointerCapture(ne.pointerId),
            r.domElement.removeEventListener('pointermove', ie),
            r.domElement.removeEventListener('pointerup', ae)),
          r.dispatchEvent(pT),
          (o = i.NONE)
      }
      function re(ne) {
        let Le
        switch (ne.button) {
          case 0:
            Le = r.mouseButtons.LEFT
            break
          case 1:
            Le = r.mouseButtons.MIDDLE
            break
          case 2:
            Le = r.mouseButtons.RIGHT
            break
          default:
            Le = -1
        }
        switch (Le) {
          case iu.DOLLY:
            if (r.enableZoom === !1) return
            L(ne), (o = i.DOLLY)
            break
          case iu.ROTATE:
            if (ne.ctrlKey || ne.metaKey || ne.shiftKey) {
              if (r.enablePan === !1) return
              W(ne), (o = i.PAN)
            } else {
              if (r.enableRotate === !1) return
              V(ne), (o = i.ROTATE)
            }
            break
          case iu.PAN:
            if (ne.ctrlKey || ne.metaKey || ne.shiftKey) {
              if (r.enableRotate === !1) return
              V(ne), (o = i.ROTATE)
            } else {
              if (r.enablePan === !1) return
              W(ne), (o = i.PAN)
            }
            break
          default:
            o = i.NONE
        }
        o !== i.NONE && r.dispatchEvent(nb)
      }
      function pe(ne) {
        switch (o) {
          case i.ROTATE:
            if (r.enableRotate === !1) return
            Y(ne)
            break
          case i.DOLLY:
            if (r.enableZoom === !1) return
            U(ne)
            break
          case i.PAN:
            if (r.enablePan === !1) return
            le(ne)
            break
        }
      }
      function we(ne) {
        r.enabled === !1 ||
          r.enableZoom === !1 ||
          o !== i.NONE ||
          (ne.preventDefault(), r.dispatchEvent(nb), q(ne), r.dispatchEvent(pT))
      }
      function $e(ne) {
        r.enabled === !1 || r.enablePan === !1 || oe(ne)
      }
      function Ae(ne) {
        switch ((de(ne), E.length)) {
          case 1:
            switch (r.touches.ONE) {
              case ou.ROTATE:
                if (r.enableRotate === !1) return
                te(), (o = i.TOUCH_ROTATE)
                break
              case ou.PAN:
                if (r.enablePan === !1) return
                ue(), (o = i.TOUCH_PAN)
                break
              default:
                o = i.NONE
            }
            break
          case 2:
            switch (r.touches.TWO) {
              case ou.DOLLY_PAN:
                if (r.enableZoom === !1 && r.enablePan === !1) return
                Re(), (o = i.TOUCH_DOLLY_PAN)
                break
              case ou.DOLLY_ROTATE:
                if (r.enableZoom === !1 && r.enableRotate === !1) return
                qe(), (o = i.TOUCH_DOLLY_ROTATE)
                break
              default:
                o = i.NONE
            }
            break
          default:
            o = i.NONE
        }
        o !== i.NONE && r.dispatchEvent(nb)
      }
      function ft(ne) {
        switch ((de(ne), o)) {
          case i.TOUCH_ROTATE:
            if (r.enableRotate === !1) return
            Ve(ne), r.update()
            break
          case i.TOUCH_PAN:
            if (r.enablePan === !1) return
            nt(ne), r.update()
            break
          case i.TOUCH_DOLLY_PAN:
            if (r.enableZoom === !1 && r.enablePan === !1) return
            D(ne), r.update()
            break
          case i.TOUCH_DOLLY_ROTATE:
            if (r.enableZoom === !1 && r.enableRotate === !1) return
            G(ne), r.update()
            break
          default:
            o = i.NONE
        }
      }
      function Q(ne) {
        r.enabled !== !1 && ne.preventDefault()
      }
      function X(ne) {
        E.push(ne)
      }
      function he(ne) {
        delete P[ne.pointerId]
        for (let Le = 0; Le < E.length; Le++)
          if (E[Le].pointerId == ne.pointerId) {
            E.splice(Le, 1)
            return
          }
      }
      function de(ne) {
        let Le = P[ne.pointerId]
        Le === void 0 && ((Le = new Ct()), (P[ne.pointerId] = Le)),
          Le.set(ne.pageX, ne.pageY)
      }
      function xe(ne) {
        const Le = ne.pointerId === E[0].pointerId ? E[1] : E[0]
        return P[Le.pointerId]
      }
      r.domElement.addEventListener('contextmenu', Q),
        r.domElement.addEventListener('pointerdown', z),
        r.domElement.addEventListener('pointercancel', ae),
        r.domElement.addEventListener('wheel', we, { passive: !1 }),
        this.update()
    }
  }
  class bve extends Br {
    constructor(t = document.createElement('div')) {
      super(),
        (this.isCSS2DObject = !0),
        (this.element = t),
        (this.element.style.position = 'absolute'),
        (this.element.style.userSelect = 'none'),
        this.element.setAttribute('draggable', !1),
        (this.center = new Ct(0.5, 0.5)),
        this.addEventListener('removed', function () {
          this.traverse(function (n) {
            n.element instanceof Element &&
              n.element.parentNode !== null &&
              n.element.parentNode.removeChild(n.element)
          })
        })
    }
    copy(t, n) {
      return (
        super.copy(t, n),
        (this.element = t.element.cloneNode(!0)),
        (this.center = t.center),
        this
      )
    }
  }
  const Cu = new Pe(),
    vT = new qn(),
    mT = new qn(),
    gT = new Pe(),
    yT = new Pe()
  class _ve {
    constructor(t = {}) {
      const n = this
      let r, i, o, a
      const s = { objects: new WeakMap() },
        l = t.element !== void 0 ? t.element : document.createElement('div')
      ;(l.style.overflow = 'hidden'),
        (this.domElement = l),
        (this.getSize = function () {
          return { width: r, height: i }
        }),
        (this.render = function (v, g) {
          v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(),
            g.parent === null &&
              g.matrixWorldAutoUpdate === !0 &&
              g.updateMatrixWorld(),
            vT.copy(g.matrixWorldInverse),
            mT.multiplyMatrices(g.projectionMatrix, vT),
            c(v, v, g),
            p(v)
        }),
        (this.setSize = function (v, g) {
          ;(r = v),
            (i = g),
            (o = r / 2),
            (a = i / 2),
            (l.style.width = v + 'px'),
            (l.style.height = g + 'px')
        })
      function c(v, g, _) {
        if (v.isCSS2DObject) {
          Cu.setFromMatrixPosition(v.matrixWorld), Cu.applyMatrix4(mT)
          const b =
            v.visible === !0 &&
            Cu.z >= -1 &&
            Cu.z <= 1 &&
            v.layers.test(_.layers) === !0
          if (((v.element.style.display = b === !0 ? '' : 'none'), b === !0)) {
            v.onBeforeRender(n, g, _)
            const M = v.element
            ;(M.style.transform =
              'translate(' +
              -100 * v.center.x +
              '%,' +
              -100 * v.center.y +
              '%)translate(' +
              (Cu.x * o + o) +
              'px,' +
              (-Cu.y * a + a) +
              'px)'),
              M.parentNode !== l && l.appendChild(M),
              v.onAfterRender(n, g, _)
          }
          const y = { distanceToCameraSquared: d(_, v) }
          s.objects.set(v, y)
        }
        for (let b = 0, y = v.children.length; b < y; b++)
          c(v.children[b], g, _)
      }
      function d(v, g) {
        return (
          gT.setFromMatrixPosition(v.matrixWorld),
          yT.setFromMatrixPosition(g.matrixWorld),
          gT.distanceToSquared(yT)
        )
      }
      function h(v) {
        const g = []
        return (
          v.traverse(function (_) {
            _.isCSS2DObject && g.push(_)
          }),
          g
        )
      }
      function p(v) {
        const g = h(v).sort(function (b, y) {
            if (b.renderOrder !== y.renderOrder)
              return y.renderOrder - b.renderOrder
            const M = s.objects.get(b).distanceToCameraSquared,
              x = s.objects.get(y).distanceToCameraSquared
            return M - x
          }),
          _ = g.length
        for (let b = 0, y = g.length; b < y; b++)
          g[b].element.style.zIndex = _ - b
      }
    }
  }
  function Sve() {
    const e = J(),
      t = xo(),
      n = xo(),
      r = xo(),
      i = xo(),
      o = xo(),
      a = xo([]),
      s = xo([]),
      l = () => {
        var p
        Wd.update(),
          (p = r.value) == null || p.update(),
          a.value.forEach((v) => v()),
          s.value.forEach((v) => v()),
          i.value.render(n.value, t.value),
          o.value.render(n.value, t.value),
          requestAnimationFrame(l)
      },
      c = () => {
        const p = new GP(8058111, 1)
        p.position.set(106.59893798828125, 26.918846130371094, 30)
        const v = new GP(8058111, 1)
        v.position.set(106.59893798828125, 26.918846130371094, 30)
        const g = new Nhe(8058111, 1)
        n.value.add(p), n.value.add(v), n.value.add(g)
      },
      d = (p) => {
        const v = ce({
            render() {
              return _i(p.component, p.props)
            },
          }),
          g = m(v)
        Ua(g, document.createElement('div'))
        const _ = new bve(g.el)
        return _.position.set(...p.position), _
      },
      h = () => {
        const { clientWidth: p, clientHeight: v } = e.value
        ;(t.value = new to(65, p / v, 0.001, 9e7)),
          t.value.up.set(0, 0, 1),
          t.value.position.set(0, 0, 0),
          (n.value = new Xfe()),
          (i.value = new x$()),
          i.value.setPixelRatio(window.devicePixelRatio),
          i.value.setSize(p, v),
          (i.value.outputEncoding = Fa),
          (o.value = new _ve()),
          o.value.setSize(p, v),
          (o.value.domElement.style.position = 'absolute'),
          (o.value.domElement.style.top = '0px'),
          e.value.appendChild(o.value.domElement),
          e.value.appendChild(i.value.domElement),
          (r.value = new yve(t.value, o.value.domElement)),
          (r.value.enableDamping = !0),
          (r.value.dampingFactor = 0.05),
          l(),
          c()
      }
    return (
      Wt(() => {
        h()
      }),
      {
        container: e,
        camera: t,
        scene: n,
        renderer: i,
        labelRenderer: o,
        control: r,
        renderMixins: a,
        boostrap: h,
        createCSSObject: d,
      }
    )
  }
  const Cve = { class: 'region-label' },
    wve = ce({
      __name: 'RegionLabel',
      props: { name: {} },
      setup(e) {
        return (t, n) => (O(), Z('div', Cve, mt(t.name), 1))
      },
    }),
    Sm = (e, t) => {
      const n = e.__vccOpts || e
      for (const [r, i] of t) n[r] = i
      return n
    },
    xve = Sm(wve, [['__scopeId', 'data-v-b1d1c0e0']])
  function Mve() {
    const {
        container: e,
        camera: t,
        scene: n,
        labelRenderer: r,
        control: i,
        renderMixins: o,
        createCSSObject: a,
      } = Sve(),
      s = J(),
      l = xo(new La()),
      c = xo(new La()),
      d = xo(new La()),
      h = xo(new La()),
      p = new Ct(-10, -10),
      v = new Fhe()
    let g = null
    const _ = (T) => {
        const [k, R, j, N] = Mv(T),
          I = (k + j) / 2,
          B = (R + N) / 2,
          V = () => {
            var Y
            const W = Math.max(j - k, N - R)
            ;(Y = i.value) == null || Y.target.set(I, B, 0),
              (i.value.maxDistance = 100),
              (i.value.maxDistance = W * 1.2),
              (i.value.minDistance = W * 0.5),
              (i.value.maxPolarAngle = Math.PI / 2)
          },
          L = () => {
            var le
            const W = I,
              Y = R - (N - R) / 2,
              U = (N - Y) * Math.tan(s.value.pitch * (Math.PI / 180))
            ;(le = t.value) == null || le.position.set(0, 0, 0),
              new Wd.Tween(t.value.position)
                .to({ x: W, y: Y, z: U }, 2e3)
                .easing(Wd.Easing.Quadratic.InOut)
                .start()
          }
        V(), L()
      },
      b = () => {
        const k = new HP().load('./texture/texture_map.jpg')
        ;(k.wrapS = Rd),
          (k.wrapT = Rd),
          (k.flipY = !1),
          (k.rotation = a$.degToRad(45)),
          k.repeat.set(0.128, 0.128),
          (k.encoding = Fa)
        const R = new Ahe({
            map: k,
            color: 11857642,
            combine: nf,
            transparent: !0,
            opacity: 1,
          }),
          j = new $he({ color: 1191972, transparent: !0, opacity: 0.95 })
        return () => [R.clone(), j.clone()]
      },
      y = (T) => {
        const k = b(),
          R = (j) => {
            const N = new k$()
            $r.forEach(j, (L, W) => {
              $r.size(L) === 2 && N[W === 0 ? 'moveTo' : 'lineTo'](...L)
            })
            const I = {
                depth: 0.2,
                bevelEnabled: !1,
                bevelSegments: 1,
                bevelThickness: 0.1,
              },
              B = new BS(N, I),
              V = new Ci(B, k())
            l.value.add(V)
          }
        $r.forEach(T.features, (j) => {
          const { type: N, coordinates: I } = j.geometry
          N === 'Polygon'
            ? $r.forEach(I, R)
            : $r.forEach(I, (B) => $r.forEach(B, R))
        }),
          n.value.add(l.value)
      },
      M = (T) => {
        $r.forEach(T.features, (k) => {
          const { properties: R } = k
          let j
          R.centroid ? (j = R.centroid) : (j = ave(T).geometry.coordinates)
          const N = {
              component: xve,
              position: [j[0], j[1], s.value.depth + 0.2],
              props: { name: R.name },
            },
            I = a(N)
          h.value.add(I)
        }),
          n.value.add(h.value)
      },
      x = (T) => {
        const k = (R) => {
          const j = []
          $r.forEach(R, (B) => {
            j.push(B[0], B[1], s.value.depth + 0.05)
          })
          const N = new Ev({ color: 16777215, linewidth: 0.001 }),
            I = new a_()
          I.setPositions(j), c.value.add(new fT(I, N))
        }
        $r.forEach(T.features, (R) => {
          const { type: j, coordinates: N } = R.geometry
          j === 'Polygon'
            ? $r.forEach(N, k)
            : j === 'MultiPolygon' && $r.forEach(N, (I) => $r.forEach(I, k))
        }),
          n.value.add(c.value)
      },
      w = (T) => {
        const k = (R) => {
          const j = []
          $r.forEach(R, (V) => {
            j.push(V[0], V[1], 0)
          })
          const N = new Ev({ color: 3586492, linewidth: 0.002 }),
            I = new a_()
          I.setPositions(j)
          const B = new fT(I, N)
          c.value.add(B)
        }
        $r.forEach(T.features, (R) => {
          const { type: j, coordinates: N } = R.geometry
          j === 'Polygon'
            ? $r.forEach(N, k)
            : j === 'MultiPolygon' && $r.forEach(N, (I) => $r.forEach(I, k))
        }),
          n.value.add(c.value)
      },
      E = (T) => {
        const [k, R, j, N] = Mv(T),
          I = j - k,
          B = N - R,
          V = Math.max(I, B),
          L = new HP(),
          W = [(k + j) / 2, (R + N) / 2],
          Y = () => {
            const oe = new cl(V, V),
              te = new Eu({
                map: L.load('./texture/texture_circle_out.png'),
                transparent: !0,
                opacity: 1,
                depthTest: !0,
              }),
              ue = new Ci(oe, te)
            ue.position.set(...W, 0)
            const me = 1.1
            ue.scale.set(me, me, me),
              o.value.push(() => {
                ue.rotation.z += 5e-4
              }),
              d.value.add(ue)
          },
          U = () => {
            const oe = new cl(V, V),
              te = new Eu({
                map: L.load('./texture/texture_circle_inner.png'),
                transparent: !0,
                opacity: 1,
                depthTest: !0,
              }),
              ue = new Ci(oe, te),
              me = 0.9
            ue.scale.set(me, me, me),
              ue.position.set(...W, -0.02),
              o.value.push(() => {
                ue.rotation.z -= 0.001
              }),
              d.value.add(ue)
          },
          le = () => {
            const oe = new cl(V * 4, V * 4),
              te = new Eu({
                map: L.load('./texture/texture_plane.png'),
                transparent: !0,
                opacity: 1,
                depthTest: !0,
              }),
              ue = new Ci(oe, te)
            ue.position.set(...W, -0.2), d.value.add(ue)
          },
          q = () => {
            const oe = new cl(V, V),
              te = new Eu({
                map: L.load('./texture/texture_plane_dot.png'),
                transparent: !0,
                opacity: 1,
                depthTest: !0,
              }),
              ue = new Ci(oe, te)
            ue.position.set(...W, -0.1), d.value.add(ue)
          }
        Y(), U(), le(), q(), n.value.add(d.value)
      },
      P = () => {
        ;(p.x = -10), (p.y = -10), (g = null)
        const T = (k) => {
          const R = r.value.domElement.getBoundingClientRect()
          ;(p.x = ((k.clientX - R.left) / R.width) * 2 - 1),
            (p.y = -((k.clientY - R.top) / R.height) * 2 + 1)
        }
        r.value.domElement.removeEventListener('mousemove', T),
          r.value.domElement.addEventListener('mousemove', T),
          o.value.push(() => {
            var R, j, N, I, B, V, L, W
            v.setFromCamera(p, t.value)
            const k = v.intersectObjects(l.value.children, !0)
            k.length > 0
              ? g !== k[0].object &&
                (g &&
                  g != null &&
                  g.material &&
                  ((j =
                    (R = g == null ? void 0 : g.material[0]) == null
                      ? void 0
                      : R.emissive) == null ||
                    j.setHex(g.currentHex)),
                (g = k[0].object),
                (g.currentHex =
                  (I =
                    (N = g == null ? void 0 : g.material[0]) == null
                      ? void 0
                      : N.emissive) == null
                    ? void 0
                    : I.getHex()),
                (V =
                  (B = g == null ? void 0 : g.material[0]) == null
                    ? void 0
                    : B.emissive) == null || V.setHex(16711680))
              : (g &&
                  ((W =
                    (L = g == null ? void 0 : g.material[0]) == null
                      ? void 0
                      : L.emissive) == null ||
                    W.setHex(g.currentHex)),
                (g = null))
          })
      },
      A = () => {
        const T = (k) => {
          k.value.clear(), n.value.remove(k.value), (k.value = new La())
        }
        T(l), T(h), T(c), T(d), (o.value = [])
      }
    return {
      container: e,
      bootstrap: async (T) => {
        A(), (s.value = { depth: 0.2, pitch: 45, ...T })
        const { data: k } = await rve.get(T.geojson)
        _(k), y(k), x(k), w(k), M(k), E(k), P()
      },
    }
  }
  const Eve = ce({
      __name: 'index',
      props: { adcode: {} },
      setup(e) {
        const t = e,
          { container: n, bootstrap: r } = Mve()
        return (
          Wt(() => {
            pr(() => {
              r({ geojson: `https://geojson.cn/api/data/${t.adcode}.json` })
            })
          }),
          (i, o) => (
            O(),
            Z(
              'div',
              { ref_key: 'container', ref: n, class: 'base-map' },
              null,
              512
            )
          )
        )
      },
    }),
    Pve = Sm(Eve, [['__scopeId', 'data-v-82274468']]),
    Tve = [
      { value: 11e4, label: '' },
      { value: 12e4, label: '' },
      { value: 13e4, label: '' },
      { value: 14e4, label: '' },
      { value: 15e4, label: '' },
      { value: 21e4, label: '' },
      { value: 22e4, label: '' },
      { value: 23e4, label: '' },
      { value: 31e4, label: '' },
      { value: 32e4, label: '' },
      { value: 33e4, label: '' },
      { value: 34e4, label: '' },
      { value: 35e4, label: '' },
      { value: 36e4, label: '' },
      { value: 37e4, label: '' },
      { value: 41e4, label: '' },
      { value: 42e4, label: '' },
      { value: 43e4, label: '' },
      { value: 44e4, label: '' },
      { value: 45e4, label: '' },
      { value: 46e4, label: '' },
      { value: 5e5, label: '' },
      { value: 51e4, label: '' },
      { value: 52e4, label: '' },
      { value: 53e4, label: '' },
      { value: 54e4, label: '' },
      { value: 61e4, label: '' },
      { value: 62e4, label: '' },
      { value: 63e4, label: '' },
      { value: 64e4, label: '' },
      { value: 65e4, label: '' },
      { value: 71e4, label: '', disabled: !0 },
      { value: 81e4, label: '', disabled: !0 },
      { value: 82e4, label: '', disabled: !0 },
    ],
    kve = { class: 'base-selector' },
    Ave = ce({
      __name: 'index',
      props: { modelValue: {} },
      emits: ['update:modelValue'],
      setup(e, { emit: t }) {
        const n = e,
          r = C({
            get: () => n.modelValue,
            set: (i) => t('update:modelValue', i),
          })
        return (i, o) => {
          const a = ge('a-select')
          return (
            O(),
            Z('div', kve, [
              m(
                a,
                {
                  modelValue: r.value,
                  'onUpdate:modelValue': o[0] || (o[0] = (s) => (r.value = s)),
                  options: zT(Tve),
                  style: { width: '320px' },
                },
                null,
                8,
                ['modelValue', 'options']
              ),
            ])
          )
        }
      },
    }),
    $ve = Sm(Ave, [['__scopeId', 'data-v-8cd3dade']]),
    Ove = { class: 'container' },
    Lve = ce({
      __name: 'App',
      setup(e) {
        const t = J(34e4)
        return (n, r) => (
          O(),
          Z('div', Ove, [
            m(
              $ve,
              {
                modelValue: t.value,
                'onUpdate:modelValue': r[0] || (r[0] = (i) => (t.value = i)),
              },
              null,
              8,
              ['modelValue']
            ),
            m(Pve, { adcode: t.value }, null, 8, ['adcode']),
          ])
        )
      },
    }),
    Ive = Sm(Lve, [['__scopeId', 'data-v-9ee79bd4']]),
    Rve = () => {
      const e = $_(Ive)
      e.use(Rae), e.mount('#app')
    }
  Rve()
})
export default Dve()
